=== DUMP GENERATED ===
Source: /Users/abondarenko/Library/Mobile Documents/com~apple~CloudDocs/XCode/CardSampleGame

=== FILE STRUCTURE (Relevant Files) ===
ViewModels/
    ContentManagerVM.swift
en.lproj/
App/
    CardGameApp.swift
    ContentView.swift
.claude/
Models/
    GameSave.swift
Docs/
    Design/
    Archive/
    Specs/
    QA/
    Audit/
        Feedback/
    Technical/
Utilities/
    AccessibilityIdentifiers.swift
    AssetRegistry.swift
    DesignSystem.swift
    Localization.swift
    SafeImage.swift
Packages/
    CharacterPacks/
        CoreHeroes/
            Package.swift
            Sources/
                CoreHeroesContent/
                    CoreHeroesContent.swift
                    Resources/
                        CoreHeroes/
                            Cards/
                            Characters/
                            Localization/
            .swiftpm/
                xcode/
                    xcuserdata/
                        abondarenko.xcuserdatad/
                            xcschemes/
    TwilightEngine/
        Package.swift
        Tests/
            TwilightEngineTests/
                CombatEngineFirstTests.swift
                DataSeparationTests.swift
                EnemyDefinitionTests.swift
                GameplayFlowTests.swift
                Phase3ContractTests.swift
                RegressionPlaythroughTests.swift
                TimeSystemTests.swift
                Helpers/
                    TestContentLoader.swift
        Sources/
            TwilightEngine/
                Core/
                    EconomyManager.swift
                    EngineProtocols.swift
                    EngineSave.swift
                    GameLoop.swift
                    PressureEngine.swift
                    RequirementsEvaluator.swift
                    TimeEngine.swift
                    TwilightGameAction.swift
                    TwilightGameEngine.swift
                Combat/
                    CombatCalculator.swift
                Config/
                    DegradationRules.swift
                    TwilightMarchesConfig.swift
                Heroes/
                    AbilityRegistry.swift
                    HeroAbility.swift
                    HeroDefinition.swift
                    HeroRegistry.swift
                Cards/
                    CardDefinition.swift
                    CardFactory.swift
                    CardRegistry.swift
                Runtime/
                    EngineTypes.swift
                    EventRuntimeState.swift
                    GameRuntimeState.swift
                    PlayerRuntimeState.swift
                    QuestRuntimeState.swift
                    WorldRuntimeState.swift
                ContentPacks/
                    BalanceConfiguration.swift
                    BinaryPack.swift
                    ConditionValidator.swift
                    ContentManager.swift
                    ContentRegistry.swift
                    ExpressionParser.swift
                    PackCompiler.swift
                    PackLoader.swift
                    PackManifest.swift
                    PackTypes.swift
                    PackValidator.swift
                Models/
                    Card.swift
                    CardType.swift
                    ExplorationModels.swift
                Utilities/
                    WorldRNG.swift
                Quest/
                    QuestTriggerEngine.swift
                Events/
                    EventPipeline.swift
                    MiniGameDispatcher.swift
                Modules/
                    CombatModule.swift
                Data/
                    Providers/
                        CodeContentProvider.swift
                        ContentProvider.swift
                        JSONContentProvider.swift
                    Definitions/
                        AnchorDefinition.swift
                        EnemyDefinition.swift
                        EventDefinition.swift
                        GameDefinition.swift
                        LocalizedString.swift
                        MiniGameChallengeDefinition.swift
                        QuestDefinition.swift
                        RegionDefinition.swift
                Migration/
                    EventDefinitionAdapter.swift
                    QuestDefinitionAdapter.swift
                Story/
                    StoryDirector.swift
                Localization/
                    L10nStub.swift
                    LocalizableText.swift
                    LocalizationManager.swift
                    LocalizationValidator.swift
                    StringKey.swift
            PackCompilerTool/
                main.swift
        .swiftpm/
            xcode/
                package.xcworkspace/
                    xcuserdata/
                        abondarenko.xcuserdatad/
                xcuserdata/
                    abondarenko.xcuserdatad/
                        xcschemes/
                xcshareddata/
                    xcschemes/
            configuration/
    StoryPacks/
        Season1/
            TwilightMarchesActI/
                Package.swift
                Sources/
                    TwilightMarchesActIContent/
                        TwilightMarchesActIContent.swift
                        Resources/
                            TwilightMarchesActI/
                                Cards/
                                Balance/
                                Campaign/
                                Localization/
                                Enemies/
                .swiftpm/
                    xcode/
                        xcuserdata/
                            abondarenko.xcuserdatad/
                                xcschemes/
.github/
    workflows/
ru.lproj/
Views/
    CardView.swift
    CombatView.swift
    ContentManagerView.swift
    EventView.swift
    HeroSelectionView.swift
    PlayerHandView.swift
    RulesView.swift
    StatisticsView.swift
    WorldMapView.swift
    Components/
        HeroPanel.swift

=== FILE CONTENTS ===

// ==========================================
// FILE: ViewModels/ContentManagerVM.swift
// ==========================================

import Foundation
import SwiftUI
import TwilightEngine

/// ViewModel for Content Manager UI
@MainActor
public final class ContentManagerVM: ObservableObject {
    // MARK: - Published State

    @Published public private(set) var packs: [ManagedPack] = []
    @Published public private(set) var isScanning = false
    @Published public var lastError: String?
    @Published public var selectedPackId: String?

    /// Bundled pack URLs (injected from app)
    private var bundledPackURLs: [URL] = []

    // MARK: - Computed Properties

    public var bundledPacks: [ManagedPack] {
        packs.filter { if case .bundled = $0.source { return true } else { return false } }
    }

    public var externalPacks: [ManagedPack] {
        packs.filter { if case .external = $0.source { return true } else { return false } }
    }

    public var loadedPacks: [ManagedPack] {
        packs.filter { $0.state == .loaded }
    }

    public var loadedCount: Int {
        loadedPacks.count
    }

    public var errorCount: Int {
        packs.filter { $0.hasErrors }.count
    }

    public var warningCount: Int {
        packs.filter { $0.hasWarnings }.count
    }

    public var selectedPack: ManagedPack? {
        guard let id = selectedPackId else { return nil }
        return packs.first { $0.id == id }
    }

    public var externalPacksPath: String {
        ContentManager.shared.externalPacksDirectory().path
    }

    // MARK: - Initialization

    public init() {}

    /// Set bundled pack URLs (call from app)
    public func setBundledPackURLs(_ urls: [URL]) {
        self.bundledPackURLs = urls
    }

    // MARK: - Actions

    /// Refresh pack list
    public func refresh() async {
        isScanning = true
        lastError = nil

        // Discover packs
        let discovered = await Task.detached { [bundledPackURLs] in
            ContentManager.shared.discoverPacks(bundledURLs: bundledPackURLs)
        }.value

        packs = discovered.sorted { $0.id < $1.id }
        isScanning = false
    }

    /// Select a pack for detail view
    public func selectPack(_ packId: String) {
        selectedPackId = packId
    }

    /// Clear selection
    public func clearSelection() {
        selectedPackId = nil
    }

    /// Validate a specific pack
    public func validatePack(_ packId: String) async {
        guard let index = packs.firstIndex(where: { $0.id == packId }) else { return }

        // Update UI to show validating
        packs[index].state = .validating

        // Perform validation
        let summary = await ContentManager.shared.validatePack(packId)

        // Update UI with result
        if let newIndex = packs.firstIndex(where: { $0.id == packId }) {
            packs[newIndex].state = .validated(summary)
            packs[newIndex].lastValidation = summary
        }
    }

    /// Load a pack (after validation)
    public func loadPack(_ packId: String) async {
        guard let index = packs.firstIndex(where: { $0.id == packId }) else { return }

        packs[index].state = .loading
        lastError = nil

        do {
            _ = try await ContentManager.shared.loadPack(packId)
            if let newIndex = packs.firstIndex(where: { $0.id == packId }) {
                packs[newIndex].state = .loaded
                packs[newIndex].loadedAt = Date()
            }
        } catch {
            if let newIndex = packs.firstIndex(where: { $0.id == packId }) {
                packs[newIndex].state = .failed(error.localizedDescription)
            }
            lastError = error.localizedDescription
        }
    }

    /// Reload a pack (hot-reload)
    public func reloadPack(_ packId: String) async {
        guard let index = packs.firstIndex(where: { $0.id == packId }) else { return }

        packs[index].state = .validating
        lastError = nil

        let result = await ContentManager.shared.safeReloadPack(packId)

        switch result {
        case .success:
            if let newIndex = packs.firstIndex(where: { $0.id == packId }) {
                packs[newIndex].state = .loaded
                packs[newIndex].loadedAt = Date()
            }

        case .failure(let error):
            if let newIndex = packs.firstIndex(where: { $0.id == packId }) {
                switch error {
                case .validationFailed(let summary):
                    packs[newIndex].state = .validated(summary)
                    packs[newIndex].lastValidation = summary
                default:
                    packs[newIndex].state = .failed(error.localizedDescription)
                }
            }
            lastError = error.localizedDescription
        }
    }

    /// Reload all external packs
    public func reloadAllExternal() async {
        for pack in externalPacks where pack.canReload {
            await reloadPack(pack.id)
        }
    }

    /// Validate all discovered (not loaded) packs
    public func validateAll() async {
        for pack in packs where pack.state == .discovered {
            await validatePack(pack.id)
        }
    }

    // MARK: - File Operations

    #if os(iOS)
    /// Open external packs folder in Files app
    public func openExternalPacksFolder() {
        let url = ContentManager.shared.externalPacksDirectory()
        // Use shareddocuments URL scheme to open in Files app
        if let filesURL = URL(string: "shareddocuments://\(url.path)") {
            UIApplication.shared.open(filesURL)
        }
    }
    #endif

    /// Copy path to clipboard
    public func copyPathToClipboard() {
        #if os(iOS)
        UIPasteboard.general.string = externalPacksPath
        #elseif os(macOS)
        NSPasteboard.general.clearContents()
        NSPasteboard.general.setString(externalPacksPath, forType: .string)
        #endif
    }
}

// MARK: - Pack Display Helpers

extension ManagedPack {
    /// Formatted file size
    public var formattedFileSize: String {
        let formatter = ByteCountFormatter()
        formatter.countStyle = .file
        return formatter.string(fromByteCount: fileSize)
    }

    /// Formatted modification date
    public var formattedModifiedAt: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        return formatter.string(from: modifiedAt)
    }

    /// Formatted load date
    public var formattedLoadedAt: String? {
        guard let loadedAt = loadedAt else { return nil }
        let formatter = DateFormatter()
        formatter.dateStyle = .none
        formatter.timeStyle = .short
        return formatter.string(from: loadedAt)
    }

    /// Content summary string
    public var contentSummary: String {
        guard let manifest = manifest else { return "Unknown content" }

        var parts: [String] = []

        // Get counts from ContentRegistry if loaded
        if case .loaded = state {
            let registry = ContentRegistry.shared
            if let pack = registry.loadedPacks[id] {
                if !pack.heroes.isEmpty { parts.append("\(pack.heroes.count) heroes") }
                if !pack.cards.isEmpty { parts.append("\(pack.cards.count) cards") }
                if !pack.regions.isEmpty { parts.append("\(pack.regions.count) regions") }
                if !pack.events.isEmpty { parts.append("\(pack.events.count) events") }
                if !pack.quests.isEmpty { parts.append("\(pack.quests.count) quests") }
                if !pack.enemies.isEmpty { parts.append("\(pack.enemies.count) enemies") }
            }
        }

        if parts.isEmpty {
            return manifest.packType.rawValue.capitalized
        }

        return parts.joined(separator: ", ")
    }

    /// Display name
    public var displayName: String {
        manifest?.displayName.localized ?? id
    }

    /// Version string
    public var versionString: String {
        manifest?.version.description ?? "?"
    }

    /// Pack type display
    public var packTypeDisplay: String {
        manifest?.packType.rawValue.capitalized ?? "Unknown"
    }
}


// ==========================================
// FILE: App/CardGameApp.swift
// ==========================================

import SwiftUI
import TwilightEngine
import CoreHeroesContent
import TwilightMarchesActIContent

@main
struct CardGameApp: App {
    @StateObject private var contentLoader = ContentLoader()

    var body: some Scene {
        WindowGroup {
            if contentLoader.isLoaded {
                ContentView()
            } else {
                LoadingView(loader: contentLoader)
            }
        }
    }
}

// MARK: - Content Loader (Binary Pack Loading)

/// Represents a content item being loaded
struct LoadingItem: Identifiable {
    let id = UUID()
    let name: String
    let icon: String
    var count: Int?
    var status: LoadingItemStatus

    enum LoadingItemStatus {
        case pending
        case loading
        case loaded
        case failed
    }
}

/// Loads binary .pack files
/// Simple, fast loading - no caching needed (binary format is already optimized)
@MainActor
class ContentLoader: ObservableObject {
    @Published var isLoaded = false
    @Published var loadingProgress: Double = 0
    @Published var loadingMessage = L10n.loadingDefault.localized
    @Published var loadingItems: [LoadingItem] = []
    @Published var loadingSummary: String = ""

    init() {
        Task {
            await loadContentPacks()
        }
    }

    private func loadContentPacks() async {
        loadingMessage = L10n.loadingSearchPacks.localized
        loadingProgress = 0.1

        let packURLs = findPackURLs()

        guard !packURLs.isEmpty else {
            loadingMessage = L10n.loadingContentNotFound.localized
            #if DEBUG
            print("âš ï¸ No .pack files found")
            #endif
            finishLoading()
            return
        }

        // Load .pack files
        loadingMessage = L10n.loadingContent.localized
        loadingProgress = 0.3
        initializeLoadingItems()

        await loadBinaryPacks(urls: packURLs)

        finishLoading()
    }

    private func loadBinaryPacks(urls: [URL]) async {
        let registry = ContentRegistry.shared

        let result = await Task.detached(priority: .userInitiated) { () -> Result<[LoadedPack], Error> in
            do {
                let packs = try registry.loadPacks(from: urls)
                return .success(packs)
            } catch {
                return .failure(error)
            }
        }.value

        switch result {
        case .success(let packs):
            loadingProgress = 0.8

            let inventory = registry.totalInventory

            updateLoadingItem(name: L10n.loadingItemRegions.localized, status: .loaded, count: inventory.regionCount)
            updateLoadingItem(name: L10n.loadingItemEvents.localized, status: .loaded, count: inventory.eventCount)
            updateLoadingItem(name: L10n.loadingItemQuests.localized, status: .loaded, count: inventory.questCount)
            updateLoadingItem(name: L10n.loadingItemAnchors.localized, status: .loaded, count: inventory.anchorCount)
            updateLoadingItem(name: L10n.loadingItemHeroes.localized, status: .loaded, count: inventory.heroCount)
            updateLoadingItem(name: L10n.loadingItemCards.localized, status: .loaded, count: inventory.cardCount)
            updateLoadingItem(name: L10n.loadingItemEnemies.localized, status: .loaded, count: inventory.enemyCount)
            updateLoadingItem(name: L10n.loadingItemLocalization.localized, status: .loaded, count: inventory.supportedLocales.count)

            loadingProgress = 0.9
            loadingMessage = L10n.loadingContentLoaded.localized

            let totalItems = inventory.regionCount + inventory.eventCount + inventory.questCount +
                             inventory.heroCount + inventory.cardCount + inventory.enemyCount
            loadingSummary = String(format: L10n.loadingSummary.localized, totalItems)

            #if DEBUG
            print("ContentLoader: Loaded \(packs.count) packs:")
            for pack in packs {
                print("  - \(pack.manifest.packId) (\(pack.manifest.packType.rawValue))")
            }
            #endif

        case .failure(let error):
            loadingMessage = L10n.loadingError.localized
            for i in loadingItems.indices {
                loadingItems[i].status = .failed
            }
            #if DEBUG
            print("ContentLoader: Failed to load packs: \(error)")
            #endif
        }
    }

    // MARK: - Helpers

    private func findPackURLs() -> [URL] {
        var urls: [URL] = []

        // Load character pack (CoreHeroes)
        if let heroesURL = CoreHeroesContent.packURL {
            urls.append(heroesURL)
            #if DEBUG
            print("ðŸ” CoreHeroes pack: \(heroesURL)")
            #endif
        }

        // Load story pack (TwilightMarchesActI)
        if let storyURL = TwilightMarchesActIContent.packURL {
            urls.append(storyURL)
            #if DEBUG
            print("ðŸ” TwilightMarchesActI pack: \(storyURL)")
            #endif
        }

        #if DEBUG
        print("ðŸ” Found \(urls.count) content packs")
        #endif

        return urls
    }

    private func initializeLoadingItems() {
        loadingItems = [
            LoadingItem(name: L10n.loadingItemRegions.localized, icon: "map", status: .pending),
            LoadingItem(name: L10n.loadingItemEvents.localized, icon: "sparkles", status: .pending),
            LoadingItem(name: L10n.loadingItemQuests.localized, icon: "scroll", status: .pending),
            LoadingItem(name: L10n.loadingItemAnchors.localized, icon: "mappin.and.ellipse", status: .pending),
            LoadingItem(name: L10n.loadingItemHeroes.localized, icon: "person.fill", status: .pending),
            LoadingItem(name: L10n.loadingItemCards.localized, icon: "rectangle.portrait.on.rectangle.portrait", status: .pending),
            LoadingItem(name: L10n.loadingItemEnemies.localized, icon: "flame", status: .pending),
            LoadingItem(name: L10n.loadingItemLocalization.localized, icon: "globe", status: .pending)
        ]
    }

    private func updateLoadingItem(name: String, status: LoadingItem.LoadingItemStatus, count: Int? = nil) {
        if let index = loadingItems.firstIndex(where: { $0.name == name }) {
            loadingItems[index].status = status
            if let count = count {
                loadingItems[index].count = count
            }
        }
    }

    private func finishLoading() {
        loadingProgress = 1.0
        loadingMessage = L10n.loadingReady.localized

        Task {
            try? await Task.sleep(nanoseconds: 300_000_000)
            isLoaded = true
        }
    }
}

// MARK: - Loading View

struct LoadingView: View {
    @ObservedObject var loader: ContentLoader

    var body: some View {
        VStack(spacing: 20) {
            Text(L10n.appTitle.localized)
                .font(.largeTitle)
                .fontWeight(.bold)

            ProgressView(value: loader.loadingProgress)
                .progressViewStyle(.linear)
                .frame(width: 280)

            Text(loader.loadingMessage)
                .font(.subheadline)
                .foregroundColor(.secondary)

            // Show loading items
            if !loader.loadingItems.isEmpty {
                VStack(alignment: .leading, spacing: 8) {
                    ForEach(loader.loadingItems) { item in
                        LoadingItemRow(item: item)
                    }
                }
                .padding()
                .background(Color(.systemGray6))
                .cornerRadius(12)
            }

            // Show summary when loaded
            if !loader.loadingSummary.isEmpty {
                Text(loader.loadingSummary)
                    .font(.caption)
                    .foregroundColor(.green)
            }
        }
        .padding()
    }
}

// MARK: - Loading Item Row

struct LoadingItemRow: View {
    let item: LoadingItem

    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: item.icon)
                .foregroundColor(iconColor)
                .frame(width: 20)

            Text(item.name)
                .font(.caption)
                .foregroundColor(.primary)

            Spacer()

            if let count = item.count {
                Text("\(count)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .monospacedDigit()
            }

            statusIcon
        }
    }

    private var iconColor: Color {
        switch item.status {
        case .pending: return .gray
        case .loading: return .blue
        case .loaded: return .green
        case .failed: return .red
        }
    }

    @ViewBuilder
    private var statusIcon: some View {
        switch item.status {
        case .pending:
            Image(systemName: "circle")
                .foregroundColor(.gray)
                .font(.caption2)
        case .loading:
            ProgressView()
                .scaleEffect(0.7)
        case .loaded:
            Image(systemName: "checkmark.circle.fill")
                .foregroundColor(.green)
                .font(.caption)
        case .failed:
            Image(systemName: "xmark.circle.fill")
                .foregroundColor(.red)
                .font(.caption)
        }
    }
}


// ==========================================
// FILE: App/ContentView.swift
// ==========================================

import SwiftUI
import TwilightEngine
import CoreHeroesContent
import TwilightMarchesActIContent

struct ContentView: View {
    @State private var showingWorldMap = false
    @State private var showingRules = false
    @State private var showingSaveSlots = false
    @State private var showingLoadSlots = false  // New: for "Continue" flow
    @State private var showingStatistics = false
    @State private var showingContentManager = false
    @State private var selectedHeroId: String?
    @State private var selectedSaveSlot: Int?

    // MARK: - Engine-First Architecture
    // Engine is the single source of truth (no legacy GameState)
    @StateObject private var engine = TwilightGameEngine()
    @StateObject private var saveManager = SaveManager.shared

    // Heroes loaded from Content Pack (data-driven)
    private var availableHeroes: [HeroDefinition] {
        HeroRegistry.shared.availableHeroes()
    }

    // Check if there are any saves
    var hasSaves: Bool {
        saveManager.hasSaves
    }

    // Get the most recent save slot (for single-save auto-load)
    var mostRecentSaveSlot: Int? {
        guard let mostRecent = saveManager.allSaves.first else {
            return nil
        }
        // Find the slot for this save
        for (slot, save) in saveManager.saveSlots {
            if save.savedAt == mostRecent.savedAt {
                return slot
            }
        }
        return nil
    }

    var body: some View {
        NavigationView {
            if showingWorldMap {
                // MARK: - Engine-First: Pass engine directly to WorldMapView
                WorldMapView(
                    engine: engine,
                    onExit: {
                        // Save game on exit
                        if let slot = selectedSaveSlot {
                            saveManager.saveGame(to: slot, engine: engine)
                        }
                        showingWorldMap = false
                        showingSaveSlots = false
                        showingLoadSlots = false
                    }
                )
            } else if showingSaveSlots {
                saveSlotSelectionView
            } else if showingLoadSlots {
                loadSlotSelectionView
            } else {
                characterSelectionView
            }
        }
    }

    var characterSelectionView: some View {
        GeometryReader { geometry in
            ZStack(alignment: .bottom) {
                // Scrollable content
                ScrollView {
                    VStack(spacing: 20) {
                        // Header with rules and statistics buttons
                        HStack(spacing: 8) {
                            VStack(alignment: .leading, spacing: 2) {
                                Text(L10n.tmGameTitle.localized)
                                    .font(.title2)
                                    .fontWeight(.bold)
                                    .minimumScaleFactor(0.6)
                                    .lineLimit(2)
                                Text(L10n.tmGameSubtitle.localized)
                                    .font(.caption2)
                                    .foregroundColor(.secondary)
                                    .lineLimit(1)
                                    .minimumScaleFactor(0.8)
                            }
                            .frame(maxWidth: .infinity, alignment: .leading)

                            #if DEBUG
                            Button(action: { showingContentManager = true }) {
                                Image(systemName: "shippingbox.fill")
                                    .font(.title3)
                                    .padding(8)
                                    .background(Color.purple.opacity(0.2))
                                    .foregroundColor(.purple)
                                    .cornerRadius(8)
                            }
                            #endif

                            Button(action: { showingStatistics = true }) {
                                Image(systemName: "chart.bar.fill")
                                    .font(.title3)
                                    .padding(8)
                                    .background(Color.orange.opacity(0.2))
                                    .foregroundColor(.orange)
                                    .cornerRadius(8)
                            }
                            Button(action: { showingRules = true }) {
                                Image(systemName: "book.fill")
                                    .font(.title3)
                                    .padding(8)
                                    .background(Color.blue.opacity(0.2))
                                    .foregroundColor(.blue)
                                    .cornerRadius(8)
                            }
                        }
                        .padding(.horizontal)
                        .padding(.top, 8)

                        Text(L10n.characterSelectTitle.localized)
                            .font(.title2)
                            .foregroundColor(.secondary)

                        // Hero cards scroll (data-driven from HeroRegistry)
                        ScrollView(.horizontal, showsIndicators: false) {
                            HStack(spacing: 20) {
                                ForEach(availableHeroes, id: \.id) { hero in
                                    HeroSelectionCard(
                                        hero: hero,
                                        isSelected: selectedHeroId == hero.id,
                                        onTap: {
                                            selectedHeroId = hero.id
                                        }
                                    )
                                    .frame(width: min(geometry.size.width * 0.65, 240), height: 280)
                                }
                            }
                            .padding(.horizontal)
                            .padding(.vertical, 12)
                        }
                        .frame(height: 320)

                        // Hero stats (data-driven from HeroRegistry)
                        if let heroId = selectedHeroId,
                           let hero = HeroRegistry.shared.hero(id: heroId) {
                            VStack(alignment: .leading, spacing: 16) {
                                Text(L10n.characterStats.localized)
                                    .font(.headline)

                                Text(hero.description.localized)
                                    .font(.body)
                                    .foregroundColor(.secondary)
                                    .fixedSize(horizontal: false, vertical: true)

                                HStack(spacing: 24) {
                                    StatDisplay(icon: "heart.fill", label: L10n.statHealth.localized, value: hero.baseStats.health, color: .red)
                                    StatDisplay(icon: "bolt.fill", label: L10n.statPower.localized, value: hero.baseStats.strength, color: .orange)
                                    StatDisplay(icon: "shield.fill", label: L10n.statDefense.localized, value: hero.baseStats.constitution, color: .blue)
                                }

                                // Hero special ability
                                Divider()
                                Text(L10n.characterAbilities.localized)
                                    .font(.headline)

                                VStack(alignment: .leading, spacing: 4) {
                                    HStack {
                                        Text(hero.specialAbility.icon)
                                        Text(hero.specialAbility.name.localized)
                                            .font(.subheadline)
                                            .fontWeight(.bold)
                                            .foregroundColor(.orange)
                                    }
                                    Text(hero.specialAbility.description.localized)
                                        .font(.caption)
                                        .foregroundColor(.secondary)
                                        .fixedSize(horizontal: false, vertical: true)
                                }
                                .padding(.vertical, 4)
                            }
                            .padding()
                            .background(Color(UIColor.secondarySystemBackground))
                            .cornerRadius(12)
                            .padding(.horizontal)
                        }

                        // Extra space for button
                        Color.clear.frame(height: 90)
                    }
                    .padding(.bottom, 20)
                }

                // Fixed buttons at bottom with shadow
                VStack(spacing: 0) {
                    Rectangle()
                        .fill(
                            LinearGradient(
                                gradient: Gradient(colors: [Color.clear, Color(UIColor.systemBackground)]),
                                startPoint: .top,
                                endPoint: .bottom
                            )
                        )
                        .frame(height: 30)

                    VStack(spacing: 12) {
                        // Continue button (only if saves exist)
                        if hasSaves {
                            Button(action: { handleContinueGame() }) {
                                HStack {
                                    Image(systemName: "play.fill")
                                    Text(L10n.uiContinue.localized)
                                }
                                .font(.title3)
                                .fontWeight(.bold)
                                .foregroundColor(.white)
                                .frame(maxWidth: .infinity)
                                .padding()
                                .background(Color.green)
                                .cornerRadius(12)
                            }
                        }

                        // New game button - requires hero selection
                        Button(action: { showingSaveSlots = true }) {
                            HStack {
                                Image(systemName: hasSaves ? "plus.circle.fill" : "play.fill")
                                Text(selectedHeroId == nil
                                    ? L10n.buttonSelectHeroFirst.localized
                                    : L10n.buttonStartAdventure.localized)
                            }
                            .font(.title3)
                            .fontWeight(.bold)
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .padding()
                            .background(selectedHeroId == nil ? Color.gray : Color.blue)
                            .cornerRadius(12)
                        }
                        .disabled(selectedHeroId == nil)
                    }
                    .padding(.horizontal)
                    .padding(.bottom, 12)
                    .background(Color(UIColor.systemBackground))
                }
            }
        }
        .navigationBarHidden(true)
        .sheet(isPresented: $showingRules) {
            RulesView()
        }
        .sheet(isPresented: $showingStatistics) {
            StatisticsView()
        }
        #if DEBUG
        .sheet(isPresented: $showingContentManager) {
            ContentManagerView(bundledPackURLs: getBundledPackURLs())
        }
        #endif
    }

    var saveSlotSelectionView: some View {
        VStack(spacing: 20) {
            // Header
            HStack {
                Button(action: { showingSaveSlots = false }) {
                    HStack(spacing: 4) {
                        Image(systemName: "chevron.left")
                        Text(L10n.uiBack.localized)
                    }
                    .foregroundColor(.blue)
                }
                Spacer()
                VStack(alignment: .trailing, spacing: 4) {
                    Text(L10n.uiSlotSelection.localized)
                        .font(.title2)
                        .fontWeight(.bold)
                    if let heroId = selectedHeroId,
                       let hero = HeroRegistry.shared.hero(id: heroId) {
                        Text(hero.name.localized)
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                    }
                }
            }
            .padding()

            // Save slots
            ScrollView {
                VStack(spacing: 16) {
                    ForEach(1...3, id: \.self) { slotNumber in
                        SaveSlotCard(
                            slotNumber: slotNumber,
                            saveData: saveManager.getSave(from: slotNumber),
                            onNewGame: { startGame(in: slotNumber) },
                            onLoadGame: { loadGame(from: slotNumber) },
                            onDelete: { saveManager.deleteSave(from: slotNumber) }
                        )
                    }
                }
                .padding()
            }
        }
        .navigationBarHidden(true)
    }

    func startGame(in slot: Int) {
        guard let heroId = selectedHeroId,
              let hero = HeroRegistry.shared.hero(id: heroId) else {
            return
        }

        // Get starting deck from hero's card IDs
        let startingDeckDefs = hero.startingDeckCardIDs.compactMap { ContentRegistry.shared.getCard(id: $0) }
        let startingDeck = startingDeckDefs.map { $0.toCard() }

        // Initialize new game in engine
        engine.initializeNewGame(
            playerName: hero.name.localized,
            heroId: heroId,
            startingDeck: startingDeck
        )

        // Save to selected slot
        selectedSaveSlot = slot
        saveManager.saveGame(to: slot, engine: engine)

        showingWorldMap = true
        showingSaveSlots = false
    }

    func loadGame(from slot: Int) {
        if saveManager.loadGame(from: slot, engine: engine) {
            selectedHeroId = engine.heroId
            selectedSaveSlot = slot
            showingWorldMap = true
            showingSaveSlots = false
            showingLoadSlots = false
        }
    }

    // MARK: - Continue Game

    func handleContinueGame() {
        let count = saveManager.saveCount

        if count == 0 {
            // No saves - shouldn't happen as button is hidden
            return
        } else if count == 1 {
            // Only one save - load it directly
            if let slot = mostRecentSaveSlot {
                loadGame(from: slot)
            }
        } else {
            // Multiple saves - show selection screen
            showingLoadSlots = true
        }
    }

    // MARK: - Load Slot Selection View

    var loadSlotSelectionView: some View {
        VStack(spacing: 20) {
            // Header
            HStack {
                Button(action: { showingLoadSlots = false }) {
                    HStack(spacing: 4) {
                        Image(systemName: "chevron.left")
                        Text(L10n.uiBack.localized)
                    }
                    .foregroundColor(.blue)
                }
                Spacer()
                Text(L10n.uiContinueGame.localized)
                    .font(.title2)
                    .fontWeight(.bold)
            }
            .padding()

            // Load slots - show all saves
            ScrollView {
                VStack(spacing: 16) {
                    ForEach(Array(saveManager.saveSlots.keys.sorted()), id: \.self) { slot in
                        if let save = saveManager.getSave(from: slot) {
                            LoadSlotCard(
                                slot: slot,
                                saveData: save,
                                onLoad: { loadGame(from: slot) }
                            )
                        }
                    }

                    // Empty state
                    if !saveManager.hasSaves {
                        VStack(spacing: 12) {
                            Image(systemName: "tray")
                                .font(.largeTitle)
                                .foregroundColor(.secondary)
                            Text(L10n.uiNoSaves.localized)
                                .foregroundColor(.secondary)
                        }
                        .padding(.top, 40)
                    }
                }
                .padding()
            }
        }
        .navigationBarHidden(true)
    }
}

struct StatDisplay: View {
    let icon: String
    let label: String
    let value: Int
    let color: Color

    var body: some View {
        VStack(spacing: 4) {
            Image(systemName: icon)
                .font(.title2)
                .foregroundColor(color)
            Text("\(value)")
                .font(.title3)
                .fontWeight(.bold)
            Text(label)
                .font(.caption)
                .foregroundColor(.secondary)
        }
    }
}

// MARK: - Save Slot Card

struct SaveSlotCard: View {
    let slotNumber: Int
    let saveData: EngineSave?
    let onNewGame: () -> Void
    let onLoadGame: () -> Void
    let onDelete: () -> Void

    @State private var showingDeleteAlert = false
    @State private var showingOverwriteAlert = false

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text(L10n.uiSlotNumber.localized(with: slotNumber))
                    .font(.headline)
                Spacer()
                if saveData != nil {
                    Button(action: { showingDeleteAlert = true }) {
                        Image(systemName: "trash")
                            .foregroundColor(.red)
                    }
                }
            }

            if let save = saveData {
                // Existing save
                VStack(alignment: .leading, spacing: 8) {
                    Text(save.playerName)
                        .font(.title3)
                        .fontWeight(.bold)

                    HStack(spacing: 16) {
                        Label("\(save.playerHealth)/\(save.playerMaxHealth)", systemImage: "heart.fill")
                            .foregroundColor(.red)
                        Label("\(save.playerFaith)", systemImage: "sparkles")
                            .foregroundColor(.yellow)
                        Label("\(save.playerBalance)", systemImage: "scale.3d")
                            .foregroundColor(.purple)
                    }
                    .font(.subheadline)

                    Text(L10n.dayNumber.localized(with: save.currentDay))
                        .font(.caption)
                        .foregroundColor(.secondary)

                    Text(formatDate(save.savedAt))
                        .font(.caption2)
                        .foregroundColor(.secondary)

                    Divider()

                    HStack(spacing: 12) {
                        Button(action: onLoadGame) {
                            Text(L10n.uiLoad.localized)
                                .font(.subheadline)
                                .fontWeight(.semibold)
                                .foregroundColor(.white)
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, 10)
                                .background(Color.blue)
                                .cornerRadius(8)
                        }

                        Button(action: { showingOverwriteAlert = true }) {
                            Text(L10n.uiNewGame.localized)
                                .font(.subheadline)
                                .fontWeight(.semibold)
                                .foregroundColor(.blue)
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, 10)
                                .background(Color.blue.opacity(0.1))
                                .cornerRadius(8)
                        }
                    }
                }
            } else {
                // Empty slot
                VStack(spacing: 12) {
                    Image(systemName: "square.dashed")
                        .font(.largeTitle)
                        .foregroundColor(.secondary)

                    Text(L10n.uiEmptySlot.localized)
                        .font(.subheadline)
                        .foregroundColor(.secondary)

                    Button(action: onNewGame) {
                        Text(L10n.uiStartNewGame.localized)
                            .font(.subheadline)
                            .fontWeight(.semibold)
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 10)
                            .background(Color.green)
                            .cornerRadius(8)
                    }
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 20)
            }
        }
        .padding()
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(12)
        .alert(L10n.uiDeleteSave.localized, isPresented: $showingDeleteAlert) {
            Button(L10n.uiCancel.localized, role: .cancel) { }
            Button(L10n.uiDelete.localized, role: .destructive) {
                onDelete()
            }
        } message: {
            Text(L10n.uiDeleteConfirm.localized)
        }
        .alert(L10n.uiOverwriteSave.localized, isPresented: $showingOverwriteAlert) {
            Button(L10n.uiCancel.localized, role: .cancel) { }
            Button(L10n.uiOverwrite.localized, role: .destructive) {
                onDelete()
                onNewGame()
            }
        } message: {
            Text(L10n.uiOverwriteConfirm.localized)
        }
    }

    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        return formatter.string(from: date)
    }
}

// MARK: - Load Slot Card (for Continue flow)

struct LoadSlotCard: View {
    let slot: Int
    let saveData: EngineSave
    let onLoad: () -> Void

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text(L10n.uiSlotNumber.localized(with: slot))
                    .font(.headline)
                Spacer()
                Image(systemName: "chevron.right")
                    .foregroundColor(.blue)
            }

            VStack(alignment: .leading, spacing: 8) {
                Text(saveData.playerName)
                    .font(.title3)
                    .fontWeight(.bold)

                HStack(spacing: 16) {
                    Label("\(saveData.playerHealth)/\(saveData.playerMaxHealth)", systemImage: "heart.fill")
                        .foregroundColor(.red)
                    Label("\(saveData.playerFaith)", systemImage: "sparkles")
                        .foregroundColor(.yellow)
                    Label("\(saveData.playerBalance)", systemImage: "scale.3d")
                        .foregroundColor(.purple)
                }
                .font(.subheadline)

                Text(L10n.dayNumber.localized(with: saveData.currentDay))
                    .font(.caption)
                    .foregroundColor(.secondary)

                Text(formatDate(saveData.savedAt))
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(12)
        .onTapGesture {
            onLoad()
        }
    }

    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        return formatter.string(from: date)
    }
}

// MARK: - Hero Selection Card (data-driven)

struct HeroSelectionCard: View {
    let hero: HeroDefinition
    let isSelected: Bool
    let onTap: () -> Void

    var body: some View {
        VStack(spacing: 8) {
            // Hero icon/name header
            VStack(spacing: 4) {
                Image(systemName: hero.icon)
                    .font(.system(size: 40))

                Text(hero.name.localized)
                    .font(.headline)
                    .fontWeight(.bold)
                    .lineLimit(1)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 16)
            .background(Color.purple.opacity(0.8))
            .foregroundColor(.white)

            // Stats
            Text(L10n.cardTypeCharacter.localized)
                .font(.caption)
                .foregroundColor(.secondary)

            HStack(spacing: 12) {
                StatMini(icon: "heart.fill", value: hero.baseStats.health, color: .red)
                StatMini(icon: "bolt.fill", value: hero.baseStats.strength, color: .orange)
                StatMini(icon: "shield.fill", value: hero.baseStats.constitution, color: .blue)
            }
            .padding(.bottom, 8)
        }
        .background(Color(UIColor.systemBackground))
        .cornerRadius(16)
        .overlay(
            RoundedRectangle(cornerRadius: 16)
                .stroke(isSelected ? Color.blue : Color.gray.opacity(0.3), lineWidth: isSelected ? 3 : 1)
        )
        .shadow(radius: isSelected ? 8 : 2)
        .scaleEffect(isSelected ? 1.02 : 1.0)
        .animation(.easeInOut(duration: 0.2), value: isSelected)
        .onTapGesture {
            onTap()
        }
    }
}

struct StatMini: View {
    let icon: String
    let value: Int
    let color: Color

    var body: some View {
        HStack(spacing: 2) {
            Image(systemName: icon)
                .font(.caption2)
                .foregroundColor(color)
            Text("\(value)")
                .font(.caption)
                .fontWeight(.bold)
        }
    }
}

// MARK: - Content Manager Helpers

#if DEBUG
/// Get bundled pack URLs for Content Manager
private func getBundledPackURLs() -> [URL] {
    var urls: [URL] = []
    if let heroesURL = CoreHeroesContent.packURL {
        urls.append(heroesURL)
    }
    if let storyURL = TwilightMarchesActIContent.packURL {
        urls.append(storyURL)
    }
    return urls
}
#endif

#Preview {
    ContentView()
}


// ==========================================
// FILE: Models/GameSave.swift
// ==========================================

import Foundation
import TwilightEngine

// MARK: - Save Manager (Engine-First Architecture)
// Uses only EngineSave format - no legacy format needed

// MARK: - Save Load Result

/// Detailed result of a save load operation
struct SaveLoadResult {
    /// Whether the load succeeded
    let success: Bool
    /// Compatibility check result (if save was found)
    let compatibility: SaveCompatibilityResult?
    /// Error if load failed
    let error: SaveLoadError?

    /// Warnings from compatibility check (for UI display)
    var warnings: [String] {
        switch compatibility {
        case .compatible(let warnings):
            return warnings
        default:
            return []
        }
    }

    /// Whether this was a partial load with warnings
    var hasWarnings: Bool {
        return success && !warnings.isEmpty
    }
}

/// Errors that can occur during save load
enum SaveLoadError: Error, Equatable {
    case saveNotFound(slot: Int)
    case incompatibleSave(details: [String])
    case decodingFailed(reason: String)

    var localizedDescription: String {
        switch self {
        case .saveNotFound(let slot):
            return L10n.errorSaveNotFound.localized(with: slot)
        case .incompatibleSave(let details):
            return L10n.errorIncompatibleSave.localized + ": " + details.joined(separator: "; ")
        case .decodingFailed(let reason):
            return L10n.errorSaveDecodingFailed.localized(with: reason)
        }
    }
}

class SaveManager: ObservableObject {
    static let shared = SaveManager()

    private let savesKey = "twilight_marches_engine_saves"
    @Published var saveSlots: [Int: EngineSave] = [:]

    init() {
        loadSaves()
    }

    // MARK: - Public API

    /// Save game from engine to slot
    func saveGame(to slot: Int, engine: TwilightGameEngine) {
        let save = engine.createEngineSave()
        saveSlots[slot] = save
        persistSaves()
    }

    /// Load game from slot into engine
    func loadGame(from slot: Int, engine: TwilightGameEngine) -> Bool {
        let result = loadGameWithResult(from: slot, engine: engine)
        return result.success
    }

    /// Load game from slot with detailed result (for UI error display)
    func loadGameWithResult(from slot: Int, engine: TwilightGameEngine) -> SaveLoadResult {
        guard let save = saveSlots[slot] else {
            return SaveLoadResult(
                success: false,
                compatibility: nil,
                error: .saveNotFound(slot: slot)
            )
        }

        // Check compatibility before loading
        let compatibility = save.validateCompatibility(with: ContentRegistry.shared)

        if !compatibility.isLoadable {
            return SaveLoadResult(
                success: false,
                compatibility: compatibility,
                error: .incompatibleSave(details: compatibility.errorMessages)
            )
        }

        // Load the save
        engine.restoreFromEngineSave(save)

        return SaveLoadResult(
            success: true,
            compatibility: compatibility,
            error: nil
        )
    }

    /// Check compatibility of a save without loading it
    func checkCompatibility(slot: Int) -> SaveCompatibilityResult? {
        guard let save = saveSlots[slot] else { return nil }
        return save.validateCompatibility(with: ContentRegistry.shared)
    }

    /// Get save from slot (for display purposes)
    func getSave(from slot: Int) -> EngineSave? {
        return saveSlots[slot]
    }

    /// Delete save from slot
    func deleteSave(from slot: Int) {
        saveSlots.removeValue(forKey: slot)
        persistSaves()

        // Also clean up any old legacy saves (one-time migration cleanup)
        UserDefaults.standard.removeObject(forKey: "twilight_marches_saves")
    }

    /// Check if slot has a save
    func hasSave(in slot: Int) -> Bool {
        return saveSlots[slot] != nil
    }

    /// Get all saves sorted by date (most recent first)
    var allSaves: [EngineSave] {
        return saveSlots.values.sorted { $0.savedAt > $1.savedAt }
    }

    /// Total number of saves
    var saveCount: Int {
        return saveSlots.count
    }

    /// Check if any saves exist
    var hasSaves: Bool {
        return !saveSlots.isEmpty
    }

    // MARK: - Persistence

    private func persistSaves() {
        if let encoded = try? JSONEncoder().encode(saveSlots) {
            UserDefaults.standard.set(encoded, forKey: savesKey)
        }
    }

    private func loadSaves() {
        if let data = UserDefaults.standard.data(forKey: savesKey),
           let decoded = try? JSONDecoder().decode([Int: EngineSave].self, from: data) {
            saveSlots = decoded
        }
    }
}


// ==========================================
// FILE: Utilities/AccessibilityIdentifiers.swift
// ==========================================

import Foundation

/// Ð¦ÐµÐ½Ñ‚Ñ€Ð°Ð»Ð¸Ð·Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ accessibility identifiers Ð´Ð»Ñ UI Ñ‚ÐµÑÑ‚Ð¾Ð²
/// Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ ÑÑ‚Ð¸ ÐºÐ¾Ð½ÑÑ‚Ð°Ð½Ñ‚Ñ‹ Ð²Ð¼ÐµÑÑ‚Ð¾ ÑÑ‚Ñ€Ð¾ÐºÐ¾Ð²Ñ‹Ñ… Ð»Ð¸Ñ‚ÐµÑ€Ð°Ð»Ð¾Ð²
enum AccessibilityIdentifiers {

    // MARK: - WorldMapView

    enum WorldMap {
        static let view = "worldMapView"
        static let playerInfoBar = "playerInfoBar"
        static let worldInfoBar = "worldInfoBar"
        static let regionsList = "regionsList"

        static func regionCard(_ regionId: UUID) -> String {
            "regionCard_\(regionId.uuidString)"
        }

        static func regionCard(name: String) -> String {
            "regionCard_\(name)"
        }
    }

    // MARK: - RegionDetailView

    enum RegionDetail {
        static let view = "regionDetailView"
        static let anchorInfo = "anchorInfo"
        static let stateIndicator = "stateIndicator"

        // Actions
        static let actionTravel = "action_travel"
        static let actionRest = "action_rest"
        static let actionTrade = "action_trade"
        static let actionExplore = "action_explore"
        static let actionStrengthenAnchor = "action_strengthenAnchor"
    }

    // MARK: - EventView

    enum Event {
        static let view = "eventView"
        static let title = "eventTitle"
        static let description = "eventDescription"
        static let consequencesPreview = "consequencesPreview"
        static let closeButton = "closeEvent"

        static func choice(_ choiceId: UUID) -> String {
            "choice_\(choiceId.uuidString)"
        }

        static func choice(index: Int) -> String {
            "choice_\(index)"
        }
    }

    // MARK: - CombatView

    enum Combat {
        static let view = "combatView"
        static let monsterCard = "monsterCard"
        static let playerStats = "playerStats"
        static let actionBar = "actionBar"
        static let combatLog = "combatLog"
        static let playerHand = "playerHand"

        // Actions
        static let attackButton = "attackButton"
        static let endTurnButton = "endTurnButton"
        static let fleeButton = "fleeButton"

        static func handCard(_ cardId: UUID) -> String {
            "handCard_\(cardId.uuidString)"
        }
    }

    // MARK: - GameBoardView

    enum GameBoard {
        static let view = "gameBoardView"
        static let topBar = "topBar"
        static let encounterArea = "encounterArea"
        static let marketView = "marketView"
        static let deckInfo = "deckInfo"
        static let phaseProgress = "phaseProgress"

        static let pauseButton = "pauseButton"
        static let nextPhaseButton = "nextPhaseButton"
        static let rollDiceButton = "rollDiceButton"
    }

    // MARK: - MainMenu / ContentView

    enum MainMenu {
        static let view = "mainMenuView"
        static let continueButton = "continueButton"
        static let newGameButton = "newGameButton"
        static let loadGameButton = "loadGameButton"
        static let settingsButton = "settingsButton"
    }
}


// ==========================================
// FILE: Utilities/AssetRegistry.swift
// ==========================================

import SwiftUI

// MARK: - Asset Registry
// Reference: AUDIT_ENGINE_FIRST_v1_1.md, Epic 0.1
// Single point of access for all images with fallback support

/// AssetRegistry provides centralized access to all image assets with automatic fallback.
/// This ensures UI never shows broken/missing images.
///
/// Usage:
/// ```swift
/// AssetRegistry.image(for: .region("forest"))
/// AssetRegistry.image(for: .hero("warrior"))
/// AssetRegistry.image(for: .card("fireball"))
/// ```
public enum AssetRegistry {

    // MARK: - Asset Types

    /// Types of assets with their fallback SF Symbol
    public enum AssetType {
        case region(String)
        case hero(String)
        case card(String)
        case custom(name: String, fallback: String)

        /// The asset name to look up
        var assetName: String {
            switch self {
            case .region(let id): return "region_\(id)"
            case .hero(let id): return "hero_\(id)"
            case .card(let id): return "card_\(id)"
            case .custom(let name, _): return name
            }
        }

        /// Fallback asset name if primary not found
        var fallbackAssetName: String {
            switch self {
            case .region: return "unknown_region"
            case .hero: return "unknown_hero"
            case .card: return "unknown_card"
            case .custom(_, let fallback): return fallback
            }
        }

        /// SF Symbol fallback if no asset found at all
        var sfSymbolFallback: String {
            switch self {
            case .region: return "mappin.circle"
            case .hero: return "person.circle"
            case .card: return "rectangle.portrait"
            case .custom: return "questionmark.circle"
            }
        }
    }

    // MARK: - Public API

    /// Get image for asset type with automatic fallback chain:
    /// 1. Try exact asset name (e.g., "region_forest")
    /// 2. Try fallback asset (e.g., "unknown_region")
    /// 3. Use SF Symbol as last resort
    public static func image(for type: AssetType) -> Image {
        // Try primary asset
        if hasAsset(named: type.assetName) {
            return Image(type.assetName)
        }

        // Try fallback asset
        if hasAsset(named: type.fallbackAssetName) {
            return Image(type.fallbackAssetName)
        }

        // Last resort: SF Symbol
        #if DEBUG
        print("âš ï¸ AssetRegistry: Missing asset '\(type.assetName)', using SF Symbol fallback")
        #endif
        return Image(systemName: type.sfSymbolFallback)
    }

    /// Get SF Symbol image (no fallback needed - SF Symbols always exist)
    public static func systemImage(_ name: String) -> Image {
        Image(systemName: name)
    }

    /// Get region icon - convenience method
    public static func regionIcon(_ regionId: String) -> Image {
        image(for: .region(regionId))
    }

    /// Get hero portrait - convenience method
    public static func heroPortrait(_ heroId: String) -> Image {
        image(for: .hero(heroId))
    }

    /// Get card art - convenience method
    public static func cardArt(_ cardId: String) -> Image {
        image(for: .card(cardId))
    }

    // MARK: - Asset Checking

    /// Check if an asset exists in the asset catalog
    public static func hasAsset(named name: String) -> Bool {
        #if os(iOS) || os(tvOS) || os(watchOS) || os(visionOS)
        return UIImage(named: name) != nil
        #elseif os(macOS)
        return NSImage(named: name) != nil
        #else
        return false
        #endif
    }

    /// Get list of all placeholder assets that should exist
    public static var requiredPlaceholders: [String] {
        ["unknown_region", "unknown_hero", "unknown_card"]
    }

    /// Validate that all required placeholder assets exist
    /// Returns list of missing placeholders
    public static func validatePlaceholders() -> [String] {
        requiredPlaceholders.filter { !hasAsset(named: $0) }
    }
}

// MARK: - SwiftUI View Extension

public extension View {
    /// Apply asset image as overlay with fallback support
    func assetOverlay(_ type: AssetRegistry.AssetType, alignment: Alignment = .center) -> some View {
        self.overlay(alignment: alignment) {
            AssetRegistry.image(for: type)
                .resizable()
                .aspectRatio(contentMode: .fit)
        }
    }
}


// ==========================================
// FILE: Utilities/DesignSystem.swift
// ==========================================

import SwiftUI
import UIKit

// MARK: - Design System
// Reference: AUDIT_ENGINE_FIRST_v1_1.md, Epic 9.1
// Centralized design tokens for consistent UI across the app

// MARK: - Spacing

/// Spacing constants for padding and margins
public enum Spacing {
    /// 2pt - Minimal spacing
    public static let xxxs: CGFloat = 2
    /// 4pt - Extra extra small
    public static let xxs: CGFloat = 4
    /// 6pt - Extra small
    public static let xs: CGFloat = 6
    /// 8pt - Small
    public static let sm: CGFloat = 8
    /// 10pt - Small-medium
    public static let smd: CGFloat = 10
    /// 12pt - Medium
    public static let md: CGFloat = 12
    /// 16pt - Large
    public static let lg: CGFloat = 16
    /// 20pt - Extra large
    public static let xl: CGFloat = 20
    /// 24pt - Extra extra large
    public static let xxl: CGFloat = 24
    /// 32pt - Extra extra extra large
    public static let xxxl: CGFloat = 32
}

// MARK: - Sizes

/// Size constants for frames and components
public enum Sizes {
    // MARK: - Icons
    /// 16pt - Tiny icon
    public static let iconTiny: CGFloat = 16
    /// 20pt - Small icon
    public static let iconSmall: CGFloat = 20
    /// 24pt - Medium icon
    public static let iconMedium: CGFloat = 24
    /// 32pt - Large icon
    public static let iconLarge: CGFloat = 32
    /// 40pt - Extra large icon
    public static let iconXL: CGFloat = 40
    /// 50pt - Hero icon
    public static let iconHero: CGFloat = 50
    /// 60pt - Region card icon
    public static let iconRegion: CGFloat = 60

    // MARK: - Components
    /// 4pt - Progress bar thin
    public static let progressThin: CGFloat = 4
    /// 6pt - Progress bar medium
    public static let progressMedium: CGFloat = 6
    /// 8pt - Progress bar thick
    public static let progressThick: CGFloat = 8

    /// 44pt - Minimum touch target (Apple HIG)
    public static let touchTarget: CGFloat = 44

    /// 120pt - Minimum button width
    public static let buttonMinWidth: CGFloat = 120

    /// 80pt - Card width small
    public static let cardWidthSmall: CGFloat = 80
    /// 100pt - Card width medium
    public static let cardWidthMedium: CGFloat = 100
    /// 120pt - Card width large
    public static let cardWidthLarge: CGFloat = 120

    /// 100pt - Card height small
    public static let cardHeightSmall: CGFloat = 100
    /// 140pt - Card height medium
    public static let cardHeightMedium: CGFloat = 140
    /// 180pt - Card height large
    public static let cardHeightLarge: CGFloat = 180
}

// MARK: - Corner Radius

/// Corner radius constants
public enum CornerRadius {
    /// 4pt - Small
    public static let sm: CGFloat = 4
    /// 8pt - Medium
    public static let md: CGFloat = 8
    /// 12pt - Large
    public static let lg: CGFloat = 12
    /// 16pt - Extra large
    public static let xl: CGFloat = 16
    /// 20pt - Extra extra large
    public static let xxl: CGFloat = 20
    /// Full circle
    public static let full: CGFloat = .infinity
}

// MARK: - App Colors

/// Semantic color palette for the app
public enum AppColors {
    // MARK: - Primary Actions
    /// Primary action color (buttons, links)
    public static let primary = Color.blue
    /// Secondary action color
    public static let secondary = Color.gray

    // MARK: - Game States
    /// Success/positive state
    public static let success = Color.green
    /// Warning state
    public static let warning = Color.orange
    /// Danger/negative state
    public static let danger = Color.red
    /// Info state
    public static let info = Color.blue

    // MARK: - Twilight Marches Theme
    /// Light alignment
    public static let light = Color.yellow
    /// Dark alignment
    public static let dark = Color.purple
    /// Neutral alignment
    public static let neutral = Color.gray

    // MARK: - Resources
    /// Health color
    public static let health = Color.red
    /// Faith color
    public static let faith = Color.yellow
    /// Power/Attack color
    public static let power = Color.orange
    /// Defense/Shield color
    public static let defense = Color.blue

    // MARK: - UI Elements
    /// Card background
    public static let cardBackground = Color(UIColor.secondarySystemBackground)
    /// Overlay background
    public static let overlay = Color.black.opacity(0.5)
    /// Highlight color
    public static let highlight = Color.blue
    /// Muted text
    public static let muted = Color.secondary

    // MARK: - Rarity Colors
    /// Common rarity
    public static let rarityCommon = Color.gray
    /// Uncommon rarity
    public static let rarityUncommon = Color.green
    /// Rare rarity
    public static let rarityRare = Color.blue
    /// Epic rarity
    public static let rarityEpic = Color.purple
    /// Legendary rarity
    public static let rarityLegendary = Color.orange

    // MARK: - Region States
    /// Visited region
    public static let regionVisited = Color.green.opacity(0.3)
    /// Available region
    public static let regionAvailable = Color.blue.opacity(0.3)
    /// Locked region
    public static let regionLocked = Color.gray.opacity(0.3)
    /// Current region
    public static let regionCurrent = Color.blue
}

// MARK: - Typography

/// Font styles for the app
public enum AppTypography {
    /// Large title
    public static let largeTitle = Font.largeTitle
    /// Title 1
    public static let title1 = Font.title
    /// Title 2
    public static let title2 = Font.title2
    /// Title 3
    public static let title3 = Font.title3
    /// Headline
    public static let headline = Font.headline
    /// Body
    public static let body = Font.body
    /// Callout
    public static let callout = Font.callout
    /// Subheadline
    public static let subheadline = Font.subheadline
    /// Footnote
    public static let footnote = Font.footnote
    /// Caption
    public static let caption = Font.caption
    /// Caption 2
    public static let caption2 = Font.caption2
}

// MARK: - Shadows

/// Shadow styles
public enum AppShadows {
    /// Small shadow
    public static let sm = Shadow(color: .black.opacity(0.1), radius: 2, x: 0, y: 1)
    /// Medium shadow
    public static let md = Shadow(color: .black.opacity(0.15), radius: 4, x: 0, y: 2)
    /// Large shadow
    public static let lg = Shadow(color: .black.opacity(0.2), radius: 8, x: 0, y: 4)
}

/// Shadow configuration
public struct Shadow {
    public let color: Color
    public let radius: CGFloat
    public let x: CGFloat
    public let y: CGFloat
}

// MARK: - View Extensions

public extension View {
    /// Apply standard card styling
    func cardStyle() -> some View {
        self
            .background(AppColors.cardBackground)
            .cornerRadius(CornerRadius.md)
    }

    /// Apply standard button padding
    func buttonPadding() -> some View {
        self
            .padding(.horizontal, Spacing.lg)
            .padding(.vertical, Spacing.smd)
    }

    /// Apply standard section padding
    func sectionPadding() -> some View {
        self
            .padding(Spacing.lg)
    }

    /// Apply shadow style
    func shadow(_ shadow: Shadow) -> some View {
        self.shadow(color: shadow.color, radius: shadow.radius, x: shadow.x, y: shadow.y)
    }

    /// Apply primary button style
    func primaryButtonStyle() -> some View {
        self
            .foregroundColor(.white)
            .buttonPadding()
            .background(AppColors.primary)
            .cornerRadius(CornerRadius.md)
    }

    /// Apply secondary button style
    func secondaryButtonStyle() -> some View {
        self
            .foregroundColor(AppColors.primary)
            .buttonPadding()
            .background(AppColors.cardBackground)
            .cornerRadius(CornerRadius.md)
    }
}

// MARK: - Animation Durations

/// Standard animation durations
public enum AnimationDuration {
    /// 0.15s - Fast
    public static let fast: Double = 0.15
    /// 0.25s - Normal
    public static let normal: Double = 0.25
    /// 0.35s - Slow
    public static let slow: Double = 0.35
    /// 0.5s - Very slow
    public static let verySlow: Double = 0.5
}

// MARK: - Opacity Values

/// Standard opacity values
public enum Opacity {
    /// 0.0 - Invisible
    public static let invisible: Double = 0.0
    /// 0.2 - Very faint
    public static let faint: Double = 0.2
    /// 0.3 - Light
    public static let light: Double = 0.3
    /// 0.5 - Medium
    public static let medium: Double = 0.5
    /// 0.6 - Medium-high
    public static let mediumHigh: Double = 0.6
    /// 0.8 - High
    public static let high: Double = 0.8
    /// 0.95 - Almost opaque
    public static let almostOpaque: Double = 0.95
    /// 1.0 - Fully opaque
    public static let opaque: Double = 1.0
}


// ==========================================
// FILE: Utilities/Localization.swift
// ==========================================

import Foundation

// MARK: - Localization Helper
extension String {
    var localized: String {
        return NSLocalizedString(self, comment: "")
    }

    func localized(with arguments: CVarArg...) -> String {
        return String(format: self.localized, arguments: arguments)
    }
}

// MARK: - Localization Keys
enum L10n {
    // Main Screen
    static let gameTitle = "game.title"
    static let characterSelectTitle = "character.select.title"
    static let characterStats = "character.stats"
    static let characterAbilities = "character.abilities"
    static let buttonStartAdventure = "button.start.adventure"
    static let buttonSelectHeroFirst = "button.select.hero.first"

    // Game Board
    static let turnLabel = "turn.label"
    static let buttonNextPhase = "button.next.phase"
    static let buttonExplore = "button.explore"
    static let buttonRollDice = "button.roll.dice"
    static let diceResult = "dice.result"
    static let diceRollTitle = "dice.roll.title"
    static let diceRollMessage = "dice.roll.message"
    static let buttonOk = "button.ok"

    // Game Phases
    static let phaseSetup = "phase.setup"
    static let phaseExploration = "phase.exploration"
    static let phaseEncounter = "phase.encounter"
    static let phasePlayerTurn = "phase.player.turn"
    static let phaseEnemyTurn = "phase.enemy.turn"
    static let phaseEndTurn = "phase.end.turn"
    static let phaseGameOver = "phase.game.over"

    // Encounter
    static let encounterActive = "encounter.active"

    // Deck
    static let deckEncounters = "deck.encounters"
    static let deckLocations = "deck.locations"
    static let deckCards = "deck.cards"

    // Player Hand
    static let playerHandTitle = "player.hand.title"
    static let playerDiscardPile = "player.discard.pile"
    static let playerDeckRemaining = "player.deck.remaining"

    // Card Types
    static let cardTypeCharacter = "card.type.character"
    static let cardTypeWeapon = "card.type.weapon"
    static let cardTypeSpell = "card.type.spell"
    static let cardTypeArmor = "card.type.armor"
    static let cardTypeItem = "card.type.item"
    static let cardTypeBlessing = "card.type.blessing"
    static let cardTypeMonster = "card.type.monster"
    static let cardTypeLocation = "card.type.location"
    static let cardTypeAlly = "card.type.ally"

    // Stats
    static let statHealth = "stat.health"
    static let statPower = "stat.power"
    static let statDefense = "stat.defense"
    static let statStrength = "stat.strength"
    static let statDexterity = "stat.dexterity"
    static let statConstitution = "stat.constitution"
    static let statIntelligence = "stat.intelligence"
    static let statWisdom = "stat.wisdom"
    static let statCharisma = "stat.charisma"

    // Rarity
    static let rarityCommon = "rarity.common"
    static let rarityUncommon = "rarity.uncommon"
    static let rarityRare = "rarity.rare"
    static let rarityEpic = "rarity.epic"
    static let rarityLegendary = "rarity.legendary"

    // Damage Types
    static let damagePhysical = "damage.physical"
    static let damageFire = "damage.fire"
    static let damageCold = "damage.cold"
    static let damageLightning = "damage.lightning"
    static let damagePoison = "damage.poison"
    static let damageAcid = "damage.acid"
    static let damageHoly = "damage.holy"
    static let damageShadow = "damage.shadow"

    // Actions
    static let actionPlay = "action.play"
    static let actionDiscard = "action.discard"
    static let actionExamine = "action.examine"

    // Rules
    static let rulesTitle = "rules.title"
    static let rulesButton = "rules.button"

    // Rules Sections
    static let rulesObjectiveTitle = "rules.objective.title"
    static let rulesObjectiveContent = "rules.objective.content"

    static let rulesPhasesTitle = "rules.phases.title"
    static let rulesPhasesContent = "rules.phases.content"

    static let rulesPhaseExploration = "rules.phase.exploration"
    static let rulesPhaseEncounter = "rules.phase.encounter"
    static let rulesPhasePlayerTurn = "rules.phase.player.turn"
    static let rulesPhaseEnemyTurn = "rules.phase.enemy.turn"
    static let rulesPhaseEndTurn = "rules.phase.endturn"

    static let rulesCardsTitle = "rules.cards.title"
    static let rulesCardsContent = "rules.cards.content"

    static let rulesResourcesTitle = "rules.resources.title"
    static let rulesResourcesContent = "rules.resources.content"

    static let rulesActionsTitle = "rules.actions.title"
    static let rulesActionsContent = "rules.actions.content"

    static let rulesDiceTitle = "rules.dice.title"
    static let rulesDiceContent = "rules.dice.content"

    static let rulesVictoryTitle = "rules.victory.title"
    static let rulesVictoryContent = "rules.victory.content"

    static let rulesTipsTitle = "rules.tips.title"
    static let rulesTipsContent = "rules.tips.content"

    // MARK: - Twilight Marches
    static let tmGameTitle = "tm.game.title"
    static let tmGameSubtitle = "tm.game.subtitle"

    // Realms
    static let tmRealmYav = "tm.realm.yav"
    static let tmRealmNav = "tm.realm.nav"
    static let tmRealmPrav = "tm.realm.prav"

    // Balance
    static let tmBalanceLight = "tm.balance.light"
    static let tmBalanceNeutral = "tm.balance.neutral"
    static let tmBalanceDark = "tm.balance.dark"

    // Resources
    static let tmResourceFaith = "tm.resource.faith"
    static let tmResourceBalance = "tm.resource.balance"

    // Card Types
    static let tmCardTypeCurse = "tm.card.type.curse"
    static let tmCardTypeSpirit = "tm.card.type.spirit"
    static let tmCardTypeArtifact = "tm.card.type.artifact"
    static let tmCardTypeRitual = "tm.card.type.ritual"

    // Curse Types
    static let tmCurseBlindness = "tm.curse.type.blindness"
    static let tmCurseMuteness = "tm.curse.type.muteness"
    static let tmCurseWeakness = "tm.curse.type.weakness"
    static let tmCurseForgetfulness = "tm.curse.type.forgetfulness"
    static let tmCurseSickness = "tm.curse.type.sickness"
    static let tmCurseMadness = "tm.curse.type.madness"
    static let tmCurseTransformation = "tm.curse.type.transformation"

    // UI Elements
    static let uiMenuButton = "ui.menu.button"
    static let uiPauseMenu = "ui.pause.menu"
    static let uiResume = "ui.resume"
    static let uiSaveGame = "ui.save.game"
    static let uiRules = "ui.rules"
    static let uiExit = "ui.exit"
    static let uiRoll = "ui.roll"
    static let uiResult = "ui.result"
    static let uiEncounters = "ui.encounters"
    static let uiYourDeck = "ui.your.deck"
    static let uiDiscard = "ui.discard"
    static let uiActiveEncounter = "ui.active.encounter"
    static let uiExplore = "ui.explore"
    static let uiDeckInfo = "ui.deck.info"
    static let uiHandTitle = "ui.hand.title"
    static let uiGameSaved = "ui.game.saved"
    static let uiProgressSaved = "ui.progress.saved"

    // Victory/Defeat
    static let uiVictoryTitle = "ui.victory.title"
    static let uiDefeatTitle = "ui.defeat.title"
    static let uiEncountersDefeated = "ui.encounters.defeated"
    static let uiTurnsTaken = "ui.turns.taken"
    static let uiTurnsSurvived = "ui.turns.survived"
    static let uiReturnMenu = "ui.return.menu"

    // Tooltips
    static let tooltipHealth = "tooltip.health"
    static let tooltipFaith = "tooltip.faith"
    static let tooltipBalance = "tooltip.balance"
    static let tooltipNextPhase = "tooltip.next.phase"

    // MARK: - Region UI (Audit v1.1 Issue #2)

    // Region States
    static let regionStateStable = "region.state.stable"
    static let regionStateBorderland = "region.state.borderland"
    static let regionStateBreach = "region.state.breach"

    // Region Info
    static let regionReputation = "region.reputation"
    static let regionCurrentLocation = "region.current.location"

    // Actions
    static let actionTravel = "action.travel"
    static let actionRest = "action.rest"
    static let actionTrade = "action.trade"
    static let actionStrengthenAnchor = "action.strengthen.anchor"
    static let actionExploreRegion = "action.explore.region"

    // MARK: - Combat UI (Engine-First Migration)

    // Combat phases
    static let combatTitle = "combat.title"
    static let combatTurnNumber = "combat.turn.number"
    static let combatActionsRemaining = "combat.actions.remaining"
    static let combatPlayerTurn = "combat.phase.player.turn"
    static let combatEnemyTurn = "combat.phase.enemy.turn"
    static let combatEndTurn = "combat.phase.end.turn"
    static let combatOver = "combat.phase.over"

    // Combat actions
    static let combatAttackButton = "combat.action.attack"
    static let combatEndTurnButton = "combat.action.end.turn"
    static let combatFleeButton = "combat.action.flee"
    static let combatPlayCard = "combat.action.play.card"

    // Combat stats
    static let combatHP = "combat.stat.hp"
    static let combatAttack = "combat.stat.attack"
    static let combatDefense = "combat.stat.defense"
    static let combatStrength = "combat.stat.strength"

    // Combat messages
    static let combatVictory = "combat.message.victory"
    static let combatDefeat = "combat.message.defeat"
    static let combatFled = "combat.message.fled"
    static let combatHit = "combat.message.hit"
    static let combatMiss = "combat.message.miss"
    static let combatDamage = "combat.message.damage"

    // Combat log
    static let combatLogTitle = "combat.log.title"
    static let combatLogBattleStart = "combat.log.battle.start"
    static let combatLogActionsPerTurn = "combat.log.actions.per.turn"
    static let combatLogEnemyAttacks = "combat.log.enemy.attacks"
    static let combatLogSpiritAttacks = "combat.log.spirit.attacks"
    static let combatLogMeditation = "combat.log.meditation"
    static let combatLogTurnSeparator = "combat.log.turn.separator"

    // Combat card effects
    static let combatEffectHeal = "combat.effect.heal"
    static let combatEffectDamage = "combat.effect.damage"
    static let combatEffectDrawCards = "combat.effect.draw.cards"
    static let combatEffectGainFaith = "combat.effect.gain.faith"
    static let combatEffectSpendFaith = "combat.effect.spend.faith"
    static let combatEffectRemoveCurse = "combat.effect.remove.curse"
    static let combatEffectBonusDice = "combat.effect.bonus.dice"
    static let combatEffectShiftBalance = "combat.effect.shift.balance"
    static let combatEffectSummonSpirit = "combat.effect.summon.spirit"
    static let combatEffectSacrifice = "combat.effect.sacrifice"

    // Combat attack breakdown
    static let combatAttackRoll = "combat.attack.roll"
    static let combatDamageCalc = "combat.damage.calc"
    static let combatBaseDamage = "combat.damage.base"

    // Hand UI
    static let combatYourHand = "combat.your.hand"
    static let combatTapToPlay = "combat.tap.to.play"
    static let combatNotEnoughFaith = "combat.not.enough.faith"

    // MARK: - UI Strings (Audit Issue #1 - Hardcoded Strings)

    // ContentView / Save Slots
    static let uiContinue = "ui.continue"
    static let uiBack = "ui.back"
    static let uiSlotSelection = "ui.slot.selection"
    static let uiContinueGame = "ui.continue.game"
    static let uiSlotNumber = "ui.slot.number"
    static let uiTurnNumber = "ui.turn.number"
    static let uiVictories = "ui.victories"
    static let uiLoad = "ui.load"
    static let uiNewGame = "ui.new.game"
    static let uiEmptySlot = "ui.empty.slot"
    static let uiStartNewGame = "ui.start.new.game"
    static let uiDeleteConfirm = "ui.delete.confirm"
    static let uiOverwriteConfirm = "ui.overwrite.confirm"
    static let uiDeleteSave = "ui.delete.save"
    static let uiOverwriteSave = "ui.overwrite.save"
    static let uiCancel = "ui.cancel"
    static let uiDelete = "ui.delete"
    static let uiOverwrite = "ui.overwrite"

    // EventView
    static let eventChooseAction = "event.choose.action"
    static let eventRequiresFaith = "event.requires.faith"
    static let eventYouHaveFaith = "event.you.have.faith"
    static let eventRequiresHealth = "event.requires.health"
    static let eventYouHaveHealth = "event.you.have.health"
    static let eventRequiresPath = "event.requires.path"
    static let eventYourPath = "event.your.path"
    static let eventFaithChange = "event.faith.change"
    static let eventHealthChange = "event.health.change"
    static let eventBalanceToLight = "event.balance.to.light"
    static let eventBalanceToDark = "event.balance.to.dark"
    static let eventReputationChange = "event.reputation.change"
    static let eventReceiveCard = "event.receive.card"
    static let eventReceiveCurse = "event.receive.curse"
    static let eventChoiceMade = "event.choice.made"
    static let eventCombatVictoryMessage = "event.combat.victory.message"
    static let eventCombatDefeatMessage = "event.combat.defeat.message"
    static let eventCombatFledMessage = "event.combat.fled.message"

    // UI Common
    static let uiClose = "ui.close"

    // Balance (genitive form)
    static let tmBalanceLightGenitive = "tm.balance.light.genitive"
    static let tmBalanceNeutralGenitive = "tm.balance.neutral.genitive"
    static let tmBalanceDarkGenitive = "tm.balance.dark.genitive"

    // StatisticsView
    static let statsTitle = "stats.title"
    static let statsGameName = "stats.game.name"
    static let statsGeneral = "stats.general"
    static let statsLeaderboard = "stats.leaderboard"
    static let statsHistory = "stats.history"
    static let statsNoSaves = "stats.no.saves"
    static let statsStartHint = "stats.start.hint"
    static let statsDone = "stats.done"
    static let statsResources = "stats.resources"
    static let statsProgress = "stats.progress"
    static let statsGamesCount = "stats.games.count"
    static let statsBestResult = "stats.best.result"
    static let statsLongestSurvival = "stats.longest.survival"
    static let statsTurnsCount = "stats.turns.count"
    static let statsVictoriesLabel = "stats.victories.label"
    static let statsTurnsLabel = "stats.turns.label"

    // CombatView additional
    static let combatVs = "combat.vs"
    static let combatAttackRollTitle = "combat.attack.roll"
    static let combatDamageCalcTitle = "combat.damage.calc.title"
    static let combatBaseValue = "combat.base.value"
    static let combatTotalDamage = "combat.total.damage"

    // Combat UI labels (Audit v2.1 Item 5)
    static let combatShield = "combat.shield"
    static let combatDefend = "combat.defend"
    static let combatFallen = "combat.fallen"
    static let combatStatsTurns = "combat.stats.turns"
    static let combatStatsDamageDealt = "combat.stats.damage.dealt"
    static let combatStatsDamageTaken = "combat.stats.damage.taken"
    static let combatStatsCardsPlayed = "combat.stats.cards.played"
    static let combatAttackVsDefense = "combat.attack.vs.defense"

    // MARK: - WorldMapView (Full localization - Audit v2.1)

    // Loading & Alerts
    static let worldLoading = "world.loading"
    static let worldEvent = "world.event"
    static let buttonUnderstood = "button.understood"
    static let dayNumber = "day.number"
    static let worldLabel = "world.label"
    static let daysInJourney = "days.in.journey"
    static let buttonConfirm = "button.confirm"
    static let nothingFound = "nothing.found"
    static let noEventsInRegion = "no.events.in.region"
    static let cardsReceived = "cards.received"
    static let addedToDeck = "added.to.deck"
    static let buttonGreat = "button.great"
    static let youAreHere = "you.are.here"

    // Region descriptions
    static let regionDescStable = "region.desc.stable"
    static let regionDescBorderland = "region.desc.borderland"
    static let regionDescBreach = "region.desc.breach"

    // Combat modifiers
    static let combatModifiers = "combat.modifiers"
    static let enemyStrength = "enemy.strength"
    static let enemyDefense = "enemy.defense"
    static let enemyHealth = "enemy.health"

    // Anchor
    static let anchorOfYav = "anchor.of.yav"
    static let anchorIntegrity = "anchor.integrity"
    static let anchorInfluence = "anchor.influence"

    // Balance names
    static let balanceLight = "balance.light"
    static let balanceNeutral = "balance.neutral"
    static let balanceDark = "balance.dark"

    // Actions
    static let availableActions = "available.actions"
    static let dayWord1 = "day.word.1"
    static let dayWord234 = "day.word.234"
    static let actionTravelTo = "action.travel.to"
    static let actionRegionFar = "action.region.far"
    static let actionMoveToRegionHint = "action.move.to.region.hint"
    static let actionRegionNotDirectlyAccessible = "action.region.not.directly.accessible"
    static let actionRestWithHealth = "action.rest.with.health"
    static let actionStrengthenAnchorCost = "action.strengthen.anchor.cost"

    // Quest
    static let activeQuestsInRegion = "active.quests.in.region"
    static let questProgress = "quest.progress"

    // Journal
    static let journalEmpty = "journal.empty"
    static let journalTitle = "journal.title"

    // Confirmations
    static let confirmationTitle = "confirmation.title"
    static let confirmTravelTo = "confirm.travel.to"
    static let confirmRest = "confirm.rest"
    static let confirmTrade = "confirm.trade"
    static let confirmStrengthenAnchor = "confirm.strengthen.anchor"
    static let confirmExplore = "confirm.explore"
    static let locationUnknown = "location.unknown"

    // Log entries
    static let logEventRest = "log.event.rest"
    static let logChoiceRest = "log.choice.rest"
    static let logOutcomeHealthRestored = "log.outcome.health.restored"
    static let logEventStrengthenAnchor = "log.event.strengthen.anchor"
    static let logChoiceFaithSpent = "log.choice.faith.spent"
    static let logOutcomeAnchorStrengthened = "log.outcome.anchor.strengthened"

    // Warnings
    static let warningTitle = "warning.title"
    static let warningHighDanger = "warning.high.danger"
    static let actionImpossible = "action.impossible"
    static let goThroughFirst = "go.through.first"

    // MARK: - HeroSelectionView / HeroPanel

    static let heroClassDefault = "hero.class.default"
    static let heroSelectTitle = "hero.select.title"
    static let heroSelectSubtitle = "hero.select.subtitle"
    static let heroStartGame = "hero.start.game"
    static let heroSelectClass = "hero.select.class"
    static let heroPath = "hero.path"
    static let pathLight = "path.light"
    static let pathDark = "path.dark"
    static let pathBalance = "path.balance"

    // MARK: - GameBoardView

    static let enemyDefeated = "enemy.defeated"
    static let returningToEvent = "returning.to.event"
    static let rollResult = "roll.result"
    static let enemyAttacksYou = "enemy.attacks.you"
    static let marketplace = "marketplace"
    static let noCardsForPurchase = "no.cards.for.purchase"
    static let victoryMessage = "victory.message"
    static let defeatMessage = "defeat.message"
    static let buttonBuy = "button.buy"

    // MARK: - CardView

    static let cardStatHealth = "card.stat.health"
    static let cardStatStrength = "card.stat.strength"
    static let cardStatDefense = "card.stat.defense"

    // MARK: - PlayerHandView

    static let noCardsInHand = "no.cards.in.hand"

    // MARK: - GameBoardView (Full localization - Audit v2.1)

    // Combat alerts
    static let combatAlertSuccess = "combat.alert.success"
    static let combatAlertFail = "combat.alert.fail"
    static let combatRollResultSuccess = "combat.roll.result.success"
    static let combatRollResultFail = "combat.roll.result.fail"
    static let combatEnemyAttackTitle = "combat.enemy.attack.title"
    static let combatEnemyAttackMessage = "combat.enemy.attack.message"

    // Pause menu
    static let worldMap = "world.map"

    // Stats display
    static let statsEncountersDefeated = "stats.encounters.defeated"
    static let statsTurnsMade = "stats.turns.made"
    static let statsTurnsSurvived = "stats.turns.survived"

    // Card types for market
    static let cardTypeResource = "card.type.resource"
    static let cardTypeAttack = "card.type.attack"
    static let cardTypeDefense = "card.type.defense"
    static let cardTypeSpecial = "card.type.special"

    // Phase progress bar labels
    static let phaseProgressExploration = "phase.progress.exploration"
    static let phaseProgressEncounter = "phase.progress.encounter"
    static let phaseProgressPlayerTurn = "phase.progress.player.turn"
    static let phaseProgressEnemyTurn = "phase.progress.enemy.turn"
    static let phaseProgressEndTurn = "phase.progress.end.turn"

    // MARK: - Models/ExplorationModels - Combat Modifiers
    static let combatModifierBorderland = "combat.modifier.borderland"
    static let combatModifierBreach = "combat.modifier.breach"

    // MARK: - Models/ExplorationModels - RegionType
    static let regionTypeForest = "region.type.forest"
    static let regionTypeSwamp = "region.type.swamp"
    static let regionTypeMountain = "region.type.mountain"
    static let regionTypeSettlement = "region.type.settlement"
    static let regionTypeWater = "region.type.water"
    static let regionTypeWasteland = "region.type.wasteland"
    static let regionTypeSacred = "region.type.sacred"

    // MARK: - Models/ExplorationModels - AnchorType
    static let anchorTypeShrine = "anchor.type.shrine"
    static let anchorTypeBarrow = "anchor.type.barrow"
    static let anchorTypeSacredTree = "anchor.type.sacred.tree"
    static let anchorTypeStoneIdol = "anchor.type.stone.idol"
    static let anchorTypeSpring = "anchor.type.spring"
    static let anchorTypeChapel = "anchor.type.chapel"
    static let anchorTypeTemple = "anchor.type.temple"
    static let anchorTypeCross = "anchor.type.cross"

    // MARK: - Models/ExplorationModels - EventType
    static let eventTypeCombat = "event.type.combat"
    static let eventTypeRitual = "event.type.ritual"
    static let eventTypeNarrative = "event.type.narrative"
    static let eventTypeExploration = "event.type.exploration"
    static let eventTypeWorldShift = "event.type.world.shift"

    // MARK: - Models/Player - Balance path
    static let balancePathDark = "balance.path.dark"
    static let balancePathNeutral = "balance.path.neutral"
    static let balancePathLight = "balance.path.light"
    static let balancePathUnknown = "balance.path.unknown"

    // MARK: - CardGameApp - Loading messages
    static let loadingDefault = "loading.default"
    static let loadingSearchPacks = "loading.search.packs"
    static let loadingContent = "loading.content"
    static let loadingContentNotFound = "loading.content.not.found"
    static let loadingReady = "loading.ready"
    static let loadingContentLoaded = "loading.content.loaded"
    static let loadingError = "loading.error"
    static let appTitle = "app.title"

    // MARK: - Content Cache messages
    static let loadingValidatingCache = "loading.validating.cache"
    static let loadingFromCache = "loading.from.cache"
    static let loadingSavingCache = "loading.saving.cache"
    static let loadingFromCacheIndicator = "loading.from.cache.indicator"
    static let loadingSummary = "loading.summary"

    // MARK: - Loading Items
    static let loadingItemRegions = "loading.item.regions"
    static let loadingItemEvents = "loading.item.events"
    static let loadingItemQuests = "loading.item.quests"
    static let loadingItemAnchors = "loading.item.anchors"
    static let loadingItemHeroes = "loading.item.heroes"
    static let loadingItemCards = "loading.item.cards"
    static let loadingItemEnemies = "loading.item.enemies"
    static let loadingItemLocalization = "loading.item.localization"

    // MARK: - ViewModels/GameViewModel
    static let defaultPlayerName = "default.player.name"
    static let regionUnknown = "region.unknown"
    static let journalEntryRest = "journal.entry.rest"
    static let journalEntryRestChoice = "journal.entry.rest.choice"
    static let journalEntryRestOutcome = "journal.entry.rest.outcome"
    static let journalEntryAnchor = "journal.entry.anchor"
    static let journalEntryAnchorChoice = "journal.entry.anchor.choice"
    static let journalEntryAnchorOutcome = "journal.entry.anchor.outcome"
    static let choiceMade = "choice.made"

    // MARK: - WorldMapView - Additional Actions (unique keys)
    static let actionTravelFar = "action.travel.far"
    static let actionExplore = "action.explore"
    static let confirmTravel = "confirm.travel"

    // MARK: - WorldMapView - Journal entries
    static let journalEntryTravel = "journal.entry.travel"
    static let journalEntryTravelChoice = "journal.entry.travel.choice"
    static let journalEntryTravelOutcome = "journal.entry.travel.outcome"
    static let journalEntryExplore = "journal.entry.explore"
    static let journalEntryExploreChoice = "journal.entry.explore.choice"
    static let journalEntryExploreNothing = "journal.entry.explore.nothing"

    // MARK: - WorldMapView - Error messages
    static let errorUnknown = "error.unknown"
    static let errorRegionFar = "error.region.far"
    static let errorRegionInaccessible = "error.region.inaccessible"
    static let errorHealthLow = "error.health.low"
    static let errorInsufficientResource = "error.insufficient.resource"
    static let errorInCombat = "error.in.combat"
    static let errorFinishEvent = "error.finish.event"
    static let errorActionFailed = "error.action.failed"

    // MARK: - GameViewModel Journal entries (used in GameViewModel.swift)
    static let journalRestTitle = "journal.rest.title"
    static let journalRestChoice = "journal.rest.choice"
    static let journalRestOutcome = "journal.rest.outcome"
    static let journalAnchorTitle = "journal.anchor.title"
    static let journalAnchorChoice = "journal.anchor.choice"
    static let journalAnchorOutcome = "journal.anchor.outcome"
    static let journalChoiceMade = "journal.choice.made"

    // MARK: - WorldMapView - Action buttons (localized titles)
    static let actionRestHeal = "action.rest.heal"
    static let actionTradeName = "action.trade.name"
    static let actionExploreName = "action.explore.name"
    static let actionAnchorCost = "action.anchor.cost"

    // MARK: - CurseType display names
    static let curseWeakness = "curse.weakness"
    static let curseFear = "curse.fear"
    static let curseExhaustion = "curse.exhaustion"
    static let curseGreed = "curse.greed"
    static let curseShadowOfNav = "curse.shadow.of.nav"
    static let curseBloodCurse = "curse.blood.curse"
    static let curseSealOfNav = "curse.seal.of.nav"

    // MARK: - DayEvent notifications
    static let dayEventTensionTitle = "dayevent.tension.title"
    static let dayEventTensionDescription = "dayevent.tension.description"
    static let dayEventRegionDegradedTitle = "dayevent.region.degraded.title"
    static let dayEventRegionDegradedDescription = "dayevent.region.degraded.description"
    static let dayEventWorldImprovingTitle = "dayevent.world.improving.title"
    static let dayEventWorldImprovingDescription = "dayevent.world.improving.description"

    // MARK: - World log messages
    static let logTensionIncreased = "log.tension.increased"
    static let logAnchorResists = "log.anchor.resists"
    static let logRegionDegraded = "log.region.degraded"
    static let logWorldChange = "log.world.change"
    static let logWorld = "log.world"

    // MARK: - Travel log messages
    static let logTravelTitle = "log.travel.title"
    static let logTravelChoice = "log.travel.choice"
    static let logTravelOutcomeDay = "log.travel.outcome.day"
    static let logTravelOutcomeDays = "log.travel.outcome.days"

    // MARK: - Combat UI strings
    static let combatTurnsStats = "combat.turns.stats"
    static let combatActionCost = "combat.action.cost"
    static let combatMonsterDefeated = "combat.monster.defeated"
    static let combatContinue = "combat.continue"
    static let combatReturn = "combat.return"
    static let combatHitResult = "combat.hit.result"
    static let combatMissResult = "combat.miss.result"
    static let combatDiceRoll = "combat.dice.roll"
    static let combatDefenseValue = "combat.defense.value"
    static let combatDamageValue = "combat.damage.value"

    // MARK: - Combat log messages
    static let combatLogBattleStartEnemy = "combat.log.battle.start.enemy"
    static let combatLogActionsInfo = "combat.log.actions.info"
    static let combatLogHit = "combat.log.hit"
    static let combatLogMissed = "combat.log.miss"
    static let combatLogCover = "combat.log.cover"
    static let combatLogStrengthBonus = "combat.log.strength.bonus"
    static let combatLogInsufficientFaith = "combat.log.insufficient.faith"
    static let combatLogFaithSpent = "combat.log.faith.spent"
    static let combatLogShieldCard = "combat.log.shield.card"
    static let combatLogAttackBonus = "combat.log.attack.bonus"
    static let combatLogSpellCast = "combat.log.spell.cast"
    static let combatLogCardPlayed = "combat.log.card.played"
    static let combatLogHealEffect = "combat.log.heal.effect"
    static let combatLogDamageEffect = "combat.log.damage.effect"
    static let combatLogDrawCards = "combat.log.draw.cards"
    static let combatLogFaithGained = "combat.log.faith.gained"
    static let combatLogCurseRemoved = "combat.log.curse.removed"
    static let combatLogBonusDice = "combat.log.bonus.dice"
    static let combatLogReroll = "combat.log.reroll"
    static let combatLogBalanceShift = "combat.log.balance.shift"
    static let combatLogCurseDamage = "combat.log.curse.damage"
    static let combatLogSpiritSummoned = "combat.log.spirit.summoned"
    static let combatLogSpiritAttack = "combat.log.spirit.attack"

    // MARK: - Realm names
    static let realmYav = "realm.yav"
    static let realmNav = "realm.nav"
    static let realmPrav = "realm.prav"

    // MARK: - Hero Classes
    static let heroClassWarrior = "hero.class.warrior"
    static let heroClassMage = "hero.class.mage"
    static let heroClassRanger = "hero.class.ranger"
    static let heroClassPriest = "hero.class.priest"
    static let heroClassShadow = "hero.class.shadow"

    static let heroClassWarriorDesc = "hero.class.warrior.desc"
    static let heroClassMageDesc = "hero.class.mage.desc"
    static let heroClassRangerDesc = "hero.class.ranger.desc"
    static let heroClassPriestDesc = "hero.class.priest.desc"
    static let heroClassShadowDesc = "hero.class.shadow.desc"

    static let heroAbilityWarrior = "hero.ability.warrior"
    static let heroAbilityMage = "hero.ability.mage"
    static let heroAbilityRanger = "hero.ability.ranger"
    static let heroAbilityPriest = "hero.ability.priest"
    static let heroAbilityShadow = "hero.ability.shadow"

    // MARK: - Curse Definitions
    static let curseWeaknessName = "curse.weakness.name"
    static let curseWeaknessDescription = "curse.weakness.description"
    static let curseFearName = "curse.fear.name"
    static let curseFearDescription = "curse.fear.description"
    static let curseExhaustionName = "curse.exhaustion.name"
    static let curseExhaustionDescription = "curse.exhaustion.description"
    static let curseGreedName = "curse.greed.name"
    static let curseGreedDescription = "curse.greed.description"
    static let curseShadowOfNavName = "curse.shadow.of.nav.name"
    static let curseShadowOfNavDescription = "curse.shadow.of.nav.description"
    static let curseBloodCurseName = "curse.blood.curse.name"
    static let curseBloodCurseDescription = "curse.blood.curse.description"
    static let curseSealOfNavName = "curse.seal.of.nav.name"
    static let curseSealOfNavDescription = "curse.seal.of.nav.description"

    // MARK: - Hero Ability Definitions
    static let abilityWarriorRageName = "ability.warrior.rage.name"
    static let abilityWarriorRageDesc = "ability.warrior.rage.desc"
    static let abilityMageMeditationName = "ability.mage.meditation.name"
    static let abilityMageMeditationDesc = "ability.mage.meditation.desc"
    static let abilityRangerTrackingName = "ability.ranger.tracking.name"
    static let abilityRangerTrackingDesc = "ability.ranger.tracking.desc"
    static let abilityPriestBlessingName = "ability.priest.blessing.name"
    static let abilityPriestBlessingDesc = "ability.priest.blessing.desc"
    static let abilityShadowAmbushName = "ability.shadow.ambush.name"
    static let abilityShadowAmbushDesc = "ability.shadow.ambush.desc"

    // MARK: - Action Errors
    static let errorInvalidAction = "error.invalid.action"
    static let errorRegionNotAccessible = "error.region.not.accessible"
    static let errorRegionNotNeighbor = "error.region.not.neighbor"
    static let errorActionNotAvailable = "error.action.not.available"
    static let errorInsufficientResources = "error.insufficient.resources"
    static let errorHealthTooLow = "error.health.too.low"
    static let errorGameNotInProgress = "error.game.not.in.progress"
    static let errorCombatInProgress = "error.combat.in.progress"
    static let errorEventInProgress = "error.event.in.progress"
    static let errorNoActiveEvent = "error.no.active.event"
    static let errorNoActiveCombat = "error.no.active.combat"
    static let errorEventNotFound = "error.event.not.found"
    static let errorInvalidChoiceIndex = "error.invalid.choice.index"
    static let errorChoiceRequirementsNotMet = "error.choice.requirements.not.met"
    static let errorCardNotInHand = "error.card.not.in.hand"
    static let errorNotEnoughActions = "error.not.enough.actions"
    static let errorInvalidTarget = "error.invalid.target"

    // MARK: - Save format labels
    static let uiEngineFormat = "ui.engine.format"
    static let uiNoSaves = "ui.no.saves"

    // MARK: - Save Compatibility Errors (Epic 7)
    static let errorSaveNotFound = "error.save.not.found"
    static let errorIncompatibleSave = "error.incompatible.save"
    static let errorSaveDecodingFailed = "error.save.decoding.failed"

    // MARK: - CombatCalculator log messages
    static let calcHit = "calc.hit"
    static let calcMiss = "calc.miss"
    static let calcAttackVsDefense = "calc.attack.vs.defense"
    static let calcStrength = "calc.strength"
    static let calcBonusDice = "calc.bonus.dice"
    static let calcBonusDamage = "calc.bonus.damage"
    static let calcDamage = "calc.damage"
    static let calcBaseDamage = "calc.base.damage"
    static let calcHeroAbilityDice = "calc.hero.ability.dice"
    static let calcHeroAbility = "calc.hero.ability"
    static let calcCurseWeakness = "calc.curse.weakness"
    static let calcCurseShadowOfNav = "calc.curse.shadow.of.nav"
}


// ==========================================
// FILE: Utilities/SafeImage.swift
// ==========================================

import SwiftUI

// MARK: - Safe Image Loading
// Audit 2.0 Requirement: Fallback System for missing icons
// If icon not found in Assets â†’ show default placeholder

/// Safe image view that handles missing assets gracefully
struct SafeImage: View {
    let name: String
    let fallbackSystemName: String

    init(_ name: String, fallback: String = "questionmark.circle") {
        self.name = name
        self.fallbackSystemName = fallback
    }

    var body: some View {
        if let uiImage = UIImage(named: name) {
            Image(uiImage: uiImage)
                .resizable()
                .scaledToFit()
        } else {
            // Fallback: show SF Symbol placeholder
            Image(systemName: fallbackSystemName)
                .foregroundColor(.secondary)
        }
    }
}

/// Safe async image loading with fallback
struct SafeAsyncImage: View {
    let name: String
    let fallbackSystemName: String

    init(_ name: String, fallback: String = "questionmark.circle") {
        self.name = name
        self.fallbackSystemName = fallback
    }

    var body: some View {
        if UIImage(named: name) != nil {
            Image(name)
                .resizable()
                .scaledToFit()
        } else {
            Image(systemName: fallbackSystemName)
                .foregroundColor(.secondary)
        }
    }
}

// MARK: - Image Validation Utility

/// Utility to validate asset availability at runtime
enum AssetValidator {

    /// Check if asset exists in bundle
    static func assetExists(_ name: String, in bundle: Bundle = .main) -> Bool {
        return UIImage(named: name, in: bundle, compatibleWith: nil) != nil
    }

    /// Validate all icons referenced in content pack
    static func validatePackIcons(icons: [String], in bundle: Bundle = .main) -> [String] {
        return icons.filter { !assetExists($0, in: bundle) }
    }

    /// Get safe icon name with fallback
    static func safeIconName(_ name: String?, fallback: String = "questionmark.circle") -> String {
        guard let name = name, !name.isEmpty else {
            return fallback
        }

        // If it looks like an SF Symbol (contains period), assume it exists
        if name.contains(".") {
            return name
        }

        // For custom assets, check if they exist
        if assetExists(name) {
            return name
        } else {
            return fallback
        }
    }
}

// MARK: - View Extension for Safe Images

extension View {
    /// Apply safe icon with fallback
    func safeIcon(_ name: String?, fallback: String = "questionmark.circle") -> some View {
        let safeName = AssetValidator.safeIconName(name, fallback: fallback)
        return AnyView(
            Group {
                if safeName.contains(".") {
                    // SF Symbol
                    Image(systemName: safeName)
                } else {
                    // Custom asset
                    SafeImage(safeName, fallback: fallback)
                }
            }
        )
    }
}

// MARK: - Preview

#if DEBUG
struct SafeImage_Previews: PreviewProvider {
    static var previews: some View {
        VStack(spacing: 20) {
            // Existing asset (should show image)
            SafeImage("AppIcon", fallback: "star.fill")
                .frame(width: 50, height: 50)

            // Missing asset (should show fallback)
            SafeImage("nonexistent_icon", fallback: "exclamationmark.triangle")
                .frame(width: 50, height: 50)

            // SF Symbol style
            Image(systemName: AssetValidator.safeIconName("valid.symbol", fallback: "questionmark"))
                .font(.largeTitle)
        }
        .padding()
    }
}
#endif


// ==========================================
// FILE: Packages/CharacterPacks/CoreHeroes/Package.swift
// ==========================================

// swift-tools-version: 5.9
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: "CoreHeroes",
    defaultLocalization: "en",
    platforms: [
        .iOS(.v16),
        .macOS(.v13)
    ],
    products: [
        .library(
            name: "CoreHeroesContent",
            targets: ["CoreHeroesContent"]
        ),
    ],
    targets: [
        .target(
            name: "CoreHeroesContent",
            resources: [
                // Compiled binary pack (fast loading, compressed) - used at runtime
                .copy("Resources/CoreHeroes.pack"),
                // JSON source directory - for PackLoader tests and content authoring
                .copy("Resources/CoreHeroes")
            ]
        ),
    ]
)


// ==========================================
// FILE: Packages/CharacterPacks/CoreHeroes/Sources/CoreHeroesContent/CoreHeroesContent.swift
// ==========================================

import Foundation

/// CoreHeroes content pack
/// Provides base heroes and their class-specific cards
public enum CoreHeroesContent {
    /// URL to the CoreHeroes.pack binary file
    public static var packURL: URL? {
        Bundle.module.url(forResource: "CoreHeroes", withExtension: "pack")
    }

    /// Pack identifier
    public static let packId = "core-heroes"
}


// ==========================================
// FILE: Packages/TwilightEngine/Package.swift
// ==========================================

// swift-tools-version: 5.9
import PackageDescription

let package = Package(
    name: "TwilightEngine",
    platforms: [
        .iOS(.v16),
        .macOS(.v13)
    ],
    products: [
        .library(
            name: "TwilightEngine",
            targets: ["TwilightEngine"]
        ),
        .executable(
            name: "pack-compiler",
            targets: ["PackCompilerTool"]
        ),
    ],
    targets: [
        .target(
            name: "TwilightEngine",
            dependencies: [],
            path: "Sources/TwilightEngine"
        ),
        .executableTarget(
            name: "PackCompilerTool",
            dependencies: ["TwilightEngine"],
            path: "Sources/PackCompilerTool"
        ),
        .testTarget(
            name: "TwilightEngineTests",
            dependencies: ["TwilightEngine"],
            path: "Tests/TwilightEngineTests"
        ),
    ]
)


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/CombatEngineFirstTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Tests for Engine-First combat system
/// Verifies that combat works without legacy Player/WorldState adapters
final class CombatEngineFirstTests: XCTestCase {

    var engine: TwilightGameEngine!

    // Load content once for all tests in this class
    override class func setUp() {
        super.setUp()
        TestContentLoader.loadContentPacksIfNeeded()
    }

    override func setUp() {
        super.setUp()
        engine = TwilightGameEngine()

        // Initialize game with starting deck
        let startingDeck = [
            Card(name: "Strike", type: .attack, description: "Basic attack", power: 3),
            Card(name: "Strike", type: .attack, description: "Basic attack", power: 3),
            Card(name: "Defend", type: .defense, description: "Basic defense", defense: 2),
            Card(name: "Defend", type: .defense, description: "Basic defense", defense: 2),
            Card(name: "Heal", type: .spell, description: "Heal 2 HP")
        ]
        engine.initializeNewGame(playerName: "Test Hero", heroId: nil, startingDeck: startingDeck)
    }

    override func tearDown() {
        engine = nil
        super.tearDown()
    }

    // MARK: - Combat Setup Tests

    func testSetupCombatEnemy() {
        // Given
        let enemy = Card(name: "Wild Beast", type: .monster, description: "A wild beast", power: 3, defense: 2, health: 10)

        // When
        engine.setupCombatEnemy(enemy)

        // Then
        XCTAssertTrue(engine.isInCombat, "Should be in combat after setup")
        XCTAssertEqual(engine.combatEnemyHealth, 10, "Enemy health should be set")
        XCTAssertNotNil(engine.combatState, "Combat state should be available")
        XCTAssertEqual(engine.combatState?.enemy.name, "Wild Beast")
    }

    func testCombatInitializeDrawsCards() {
        // Given
        let enemy = Card(name: "Enemy", type: .monster, description: "Test", health: 10)
        engine.setupCombatEnemy(enemy)

        // When
        engine.performAction(.combatInitialize)

        // Then
        XCTAssertEqual(engine.playerHand.count, 5, "Should draw 5 cards")
    }

    // MARK: - Damage Tests

    func testDamageEnemyReducesHealth() {
        // Given
        let enemy = Card(name: "Enemy", type: .monster, description: "Test", health: 10)
        engine.setupCombatEnemy(enemy)
        let initialHealth = engine.combatEnemyHealth

        // When
        engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: 3)))

        // Then
        XCTAssertEqual(engine.combatEnemyHealth, initialHealth - 3, "Enemy health should decrease by damage amount")
    }

    func testDamageEnemyCannotGoBelowZero() {
        // Given
        let enemy = Card(name: "Enemy", type: .monster, description: "Test", health: 5)
        engine.setupCombatEnemy(enemy)

        // When
        engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: 100)))

        // Then
        XCTAssertEqual(engine.combatEnemyHealth, 0, "Enemy health should not go below 0")
    }

    func testDamageEnemyRequiresCombatEnemy() {
        // Given - no enemy set up
        XCTAssertFalse(engine.isInCombat)

        // When
        engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: 5)))

        // Then - should not crash, just no effect
        XCTAssertEqual(engine.combatEnemyHealth, 0)
    }

    // MARK: - Card Effects Tests

    func testHealEffectRestoresHealth() {
        // Given
        engine.performAction(.combatApplyEffect(effect: .takeDamage(amount: 5)))
        let healthAfterDamage = engine.playerHealth

        // When
        engine.performAction(.combatApplyEffect(effect: .heal(amount: 3)))

        // Then
        XCTAssertEqual(engine.playerHealth, healthAfterDamage + 3, "Health should increase by heal amount")
    }

    func testHealEffectCannotExceedMax() {
        // Given - at full health
        let maxHealth = engine.playerMaxHealth

        // When
        engine.performAction(.combatApplyEffect(effect: .heal(amount: 100)))

        // Then
        XCTAssertEqual(engine.playerHealth, maxHealth, "Health should not exceed max")
    }

    func testDrawCardsEffect() {
        // Given
        let enemy = Card(name: "Enemy", type: .monster, description: "Test", health: 10)
        engine.setupCombatEnemy(enemy)
        engine.performAction(.combatInitialize)
        XCTAssertEqual(engine.playerHand.count, 5, "Should start with 5 cards")

        // When - play a card first to make room
        if !engine.playerHand.isEmpty {
            engine.performAction(.playCard(cardId: engine.playerHand[0].id, targetId: nil))
        }
        let handSizeAfterPlay = engine.playerHand.count
        engine.performAction(.combatApplyEffect(effect: .drawCards(count: 1)))

        // Then - hand size should increase by 1 (if deck has cards)
        XCTAssertGreaterThanOrEqual(engine.playerHand.count, handSizeAfterPlay)
    }

    func testGainFaithEffect() {
        // Given
        let initialFaith = engine.playerFaith

        // When
        engine.performAction(.combatApplyEffect(effect: .gainFaith(amount: 2)))

        // Then
        XCTAssertEqual(engine.playerFaith, min(initialFaith + 2, engine.playerMaxFaith))
    }

    func testSpendFaithEffect() {
        // Given
        let initialFaith = engine.playerFaith

        // When
        engine.performAction(.combatApplyEffect(effect: .spendFaith(amount: 1)))

        // Then
        XCTAssertEqual(engine.playerFaith, max(0, initialFaith - 1))
    }

    func testTakeDamageEffect() {
        // Given
        let initialHealth = engine.playerHealth

        // When
        engine.performAction(.combatApplyEffect(effect: .takeDamage(amount: 3)))

        // Then
        XCTAssertEqual(engine.playerHealth, initialHealth - 3)
    }

    func testAddBonusDiceEffect() {
        // Given
        let enemy = Card(name: "Enemy", type: .monster, description: "Test", health: 10)
        engine.setupCombatEnemy(enemy)

        // When
        engine.performAction(.combatApplyEffect(effect: .addBonusDice(count: 2)))

        // Then
        XCTAssertEqual(engine.combatState?.bonusDice, 2)
    }

    func testAddBonusDamageEffect() {
        // Given
        let enemy = Card(name: "Enemy", type: .monster, description: "Test", health: 10)
        engine.setupCombatEnemy(enemy)

        // When
        engine.performAction(.combatApplyEffect(effect: .addBonusDamage(amount: 5)))

        // Then
        XCTAssertEqual(engine.combatState?.bonusDamage, 5)
    }

    // MARK: - Combat Lifecycle Tests

    func testCombatFinishClearsEnemy() {
        // Given
        let enemy = Card(name: "Enemy", type: .monster, description: "Test", health: 10)
        engine.setupCombatEnemy(enemy)
        XCTAssertTrue(engine.isInCombat)

        // When
        engine.performAction(.combatFinish(victory: true))

        // Then
        XCTAssertFalse(engine.isInCombat, "Should not be in combat after finish")
        XCTAssertNil(engine.combatState, "Combat state should be nil")
    }

    func testCombatFleeClearsEnemy() {
        // Given
        let enemy = Card(name: "Enemy", type: .monster, description: "Test", health: 10)
        engine.setupCombatEnemy(enemy)

        // When
        engine.performAction(.combatFlee)

        // Then
        XCTAssertFalse(engine.isInCombat)
    }

    // MARK: - Multiple Combats Tests

    func testSecondCombatRestoresDeck() {
        // Given - first combat
        let enemy1 = Card(name: "Enemy 1", type: .monster, description: "Test", health: 5)
        engine.setupCombatEnemy(enemy1)
        engine.performAction(.combatInitialize)

        let initialHandCount = engine.playerHand.count
        XCTAssertEqual(initialHandCount, 5, "Should start with 5 cards in hand")

        // Play some attack cards (they reliably go to discard)
        let attackCards = engine.playerHand.filter { $0.type == .attack }
        for card in attackCards {
            engine.performAction(.playCard(cardId: card.id, targetId: nil))
        }
        XCTAssertLessThan(engine.playerHand.count, initialHandCount, "Some cards should be played")

        // End first combat
        engine.performAction(.combatFinish(victory: true))

        // When - start second combat
        let enemy2 = Card(name: "Enemy 2", type: .monster, description: "Test", health: 5)
        engine.setupCombatEnemy(enemy2)
        engine.performAction(.combatInitialize)

        // Then - should have full hand again (deck restored from discard)
        XCTAssertEqual(engine.playerHand.count, 5, "Should draw full hand in second combat")
    }

    func testCardsReturnFromDiscardOnNewCombat() {
        // Given - setup and use cards in first combat
        let enemy = Card(name: "Enemy", type: .monster, description: "Test", health: 100)
        engine.setupCombatEnemy(enemy)
        engine.performAction(.combatInitialize)

        let totalCards = engine.playerHand.count + engine.playerDeck.count

        // Play some cards (with safety limit to prevent infinite loop)
        var cardsPlayed = 0
        let maxCardsToPlay = 10
        while !engine.playerHand.isEmpty && cardsPlayed < maxCardsToPlay {
            engine.performAction(.playCard(cardId: engine.playerHand[0].id, targetId: nil))
            cardsPlayed += 1
        }

        // End combat
        engine.performAction(.combatFinish(victory: false))

        // When - new combat
        engine.setupCombatEnemy(enemy)
        engine.performAction(.combatInitialize)

        // Then - all cards should be available again
        let newTotalCards = engine.playerHand.count + engine.playerDeck.count + engine.playerDiscard.count
        XCTAssertEqual(newTotalCards, totalCards, "All cards should be restored")
    }

    // MARK: - Balance Shift Tests

    func testShiftBalanceTowardsLight() {
        // Given
        let initialBalance = engine.playerBalance

        // When
        engine.performAction(.combatApplyEffect(effect: .shiftBalance(towards: "light", amount: 10)))

        // Then
        XCTAssertEqual(engine.playerBalance, min(100, initialBalance + 10))
    }

    func testShiftBalanceTowardsDark() {
        // Given
        let initialBalance = engine.playerBalance

        // When
        engine.performAction(.combatApplyEffect(effect: .shiftBalance(towards: "dark", amount: 10)))

        // Then
        XCTAssertEqual(engine.playerBalance, max(0, initialBalance - 10))
    }

    // MARK: - Gate Test: Combat Determinism

    /// Gate test: Combat with same seed produces identical results
    /// Requirement: "Ð±Ð¾Ð¹ Ñ Ð¾Ð´Ð¸Ð½Ð°ÐºÐ¾Ð²Ñ‹Ð¼ seed Ð´Ð°Ñ‘Ñ‚ Ð¾Ð´Ð¸Ð½Ð°ÐºÐ¾Ð²Ñ‹Ð¹ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚"
    func testCombatDeterminismWithSeed() {
        let testSeed: UInt64 = 54321

        // First combat simulation
        WorldRNG.shared.setSeed(testSeed)
        let results1 = simulateCombatSequence()

        // Second combat simulation with same seed
        WorldRNG.shared.setSeed(testSeed)
        let results2 = simulateCombatSequence()

        // Results must be identical
        XCTAssertEqual(results1.finalEnemyHealth, results2.finalEnemyHealth,
                       "Enemy health must be identical with same seed")
        XCTAssertEqual(results1.finalPlayerHealth, results2.finalPlayerHealth,
                       "Player health must be identical with same seed")
        XCTAssertEqual(results1.cardsDrawn, results2.cardsDrawn,
                       "Cards drawn must be identical with same seed")
        XCTAssertEqual(results1.damageDealt, results2.damageDealt,
                       "Damage dealt must be identical with same seed")
    }

    /// Helper: Simulate a combat sequence and return results
    private func simulateCombatSequence() -> CombatSimulationResult {
        let engine = TwilightGameEngine()

        // Initialize with known deck
        let startingDeck = [
            Card(name: "Strike", type: .attack, description: "Basic attack", power: 3),
            Card(name: "Strike", type: .attack, description: "Basic attack", power: 3),
            Card(name: "Defend", type: .defense, description: "Basic defense", defense: 2),
            Card(name: "Heal", type: .spell, description: "Heal 2 HP"),
            Card(name: "Power", type: .attack, description: "Strong attack", power: 5)
        ]
        engine.initializeNewGame(playerName: "Test", heroId: nil, startingDeck: startingDeck)

        // Setup combat
        let enemy = Card(name: "Test Enemy", type: .monster, description: "Test", power: 4, health: 20)
        engine.setupCombatEnemy(enemy)
        engine.performAction(.combatInitialize)

        // Record initial state
        let cardsDrawn = engine.playerHand.map { $0.name }
        var totalDamage = 0

        // Simulate combat turns
        for _ in 0..<3 {
            // Play attack cards
            for card in engine.playerHand where card.type == .attack {
                engine.performAction(.playCard(cardId: card.id, targetId: nil))
                totalDamage += card.power ?? 0
            }

            // Apply damage to enemy
            engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: 5)))

            // End turn
            engine.performAction(.combatEndTurnPhase)
        }

        return CombatSimulationResult(
            finalEnemyHealth: engine.combatEnemyHealth,
            finalPlayerHealth: engine.playerHealth,
            cardsDrawn: cardsDrawn,
            damageDealt: totalDamage
        )
    }
}

/// Result of combat simulation for determinism testing
private struct CombatSimulationResult {
    let finalEnemyHealth: Int
    let finalPlayerHealth: Int
    let cardsDrawn: [String]
    let damageDealt: Int
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/DataSeparationTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Data Separation Contract Tests
/// Verify Definition/Runtime separation is maintained.
/// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4
final class DataSeparationTests: XCTestCase {

    // MARK: - INV-D01: Definitions Are Immutable

    /// Definition structs should have no runtime/mutable state
    /// Reference: ENGINE_ARCHITECTURE.md, Section 4.1
    func testDefinitionsAreImmutable() {
        // Given: A region definition
        let regionDef = MockRegionDefinition(
            id: "test_region",
            title: LocalizedString(en: "Test Region", ru: "Ð¢ÐµÑÑ‚Ð¾Ð²Ñ‹Ð¹ Ñ€ÐµÐ³Ð¸Ð¾Ð½"),
            neighborIds: ["north", "south"],
            anchorId: "anchor_001",
            eventPoolIds: ["pool_common", "pool_special"],
            initialState: "stable"
        )

        // Then: All properties should be let (immutable)
        // This test verifies by construction - Definition uses let for all fields
        XCTAssertEqual(regionDef.id, "test_region")
        XCTAssertEqual(regionDef.neighborIds.count, 2)

        // Note: In Swift, the compiler enforces immutability via let.
        // This test documents the contract.
    }

    func testDefinitionHasNoRuntimeFields() {
        // Given: Event definition
        let eventDef = MockEventDefinition(
            id: "event_001",
            title: LocalizedString(en: "Test Event", ru: "Ð¢ÐµÑÑ‚Ð¾Ð²Ð¾Ðµ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ðµ"),
            body: LocalizedString(en: "Test body", ru: "Ð¢ÐµÑÑ‚Ð¾Ð²Ð¾Ðµ Ñ‚ÐµÐ»Ð¾"),
            choiceIds: ["choice_a", "choice_b"],
            isOneTime: true,
            pressureRange: 0...100,
            regionIds: ["forest", "village"]
        )

        // Then: No runtime fields (visitCount, isCompleted, etc.)
        // Definition only has static data
        XCTAssertEqual(eventDef.id, "event_001")
        XCTAssertTrue(eventDef.isOneTime)

        // Runtime state like "isCompleted" lives in EventRuntimeState, not here
    }

    // MARK: - INV-D02: Runtime References Valid Definitions

    /// RuntimeState should reference Definition by valid id
    func testRuntimeReferencesValidDefinitions() {
        // Given: Content provider with definitions
        let provider = MockContentProvider()

        // And: Runtime state referencing definitions
        let runtime = MockWorldRuntimeState(
            currentRegionId: "forest",
            regionsState: [
                "forest": MockRegionRuntimeState(definitionId: "forest", currentState: "stable", visitCount: 0),
                "village": MockRegionRuntimeState(definitionId: "village", currentState: "stable", visitCount: 2)
            ],
            pressure: 20,
            currentTime: 5
        )

        // When: Validate references
        var brokenReferences: [String] = []
        for (regionId, regionState) in runtime.regionsState {
            if provider.getRegionDefinition(id: regionState.definitionId) == nil {
                brokenReferences.append(regionId)
            }
        }

        // Then: All references valid
        XCTAssertTrue(brokenReferences.isEmpty, "Broken references: \(brokenReferences)")
    }

    func testRuntimeWithInvalidReferenceDetected() {
        // Given: Runtime with invalid reference
        let provider = MockContentProvider()
        let runtime = MockWorldRuntimeState(
            currentRegionId: "nonexistent_region",
            regionsState: [
                "invalid": MockRegionRuntimeState(definitionId: "does_not_exist", currentState: "stable", visitCount: 0)
            ],
            pressure: 20,
            currentTime: 5
        )

        // When: Validate
        var brokenReferences: [String] = []
        for (regionId, regionState) in runtime.regionsState {
            if provider.getRegionDefinition(id: regionState.definitionId) == nil {
                brokenReferences.append(regionId)
            }
        }

        // Then: Invalid reference detected
        XCTAssertFalse(brokenReferences.isEmpty, "Should detect broken reference")
        XCTAssertTrue(brokenReferences.contains("invalid"))
    }

    // MARK: - INV-D03: ContentProvider Validation

    /// ContentProvider should catch broken links
    func testContentProviderValidationCatchesBrokenLinks() {
        // Given: Provider with broken content
        let provider = MockContentProviderWithBrokenLinks()

        // When: Validate
        let errors = provider.validate()

        // Then: Errors detected
        XCTAssertFalse(errors.isEmpty, "Should detect validation errors")
        XCTAssertTrue(errors.contains { $0.type == .brokenNeighborLink })
    }

    func testContentProviderValidationPassesForValidContent() {
        // Given: Provider with valid content
        let provider = MockContentProvider()

        // When: Validate
        let errors = provider.validate()

        // Then: No errors
        XCTAssertTrue(errors.isEmpty, "Valid content should pass validation")
    }

    // MARK: - INV-D04: ID Uniqueness

    func testDefinitionIdsAreUnique() {
        // Given: Content provider
        let provider = MockContentProvider()

        // When: Get all definitions
        let regionDefs = provider.getAllRegionDefinitions()
        let eventDefs = provider.getAllEventDefinitions()

        // Then: IDs unique within each type
        let regionIds = regionDefs.map { $0.id }
        let eventIds = eventDefs.map { $0.id }

        XCTAssertEqual(regionIds.count, Set(regionIds).count, "Region IDs should be unique")
        XCTAssertEqual(eventIds.count, Set(eventIds).count, "Event IDs should be unique")
    }

    // MARK: - INV-D05: Localized Strings Present

    func testDefinitionsHaveLocalizedStrings() {
        // Given: Definitions with LocalizedString
        let regionDef = MockRegionDefinition(
            id: "test",
            title: LocalizedString(en: "Test Region", ru: "Ð¢ÐµÑÑ‚Ð¾Ð²Ñ‹Ð¹ Ñ€ÐµÐ³Ð¸Ð¾Ð½"),
            neighborIds: [],
            anchorId: nil,
            eventPoolIds: [],
            initialState: "stable"
        )

        // Then: Both English and Russian localizations are present
        XCTAssertFalse(regionDef.title.en.isEmpty, "Should have English localization")
        XCTAssertFalse(regionDef.title.ru.isEmpty, "Should have Russian localization")
        XCTAssertNotEqual(regionDef.title.en, regionDef.title.ru, "Localizations should be different")
    }

    // NOTE: ContentRegistry JSON loading tests are in ContentRegistryTests.
    // Removed duplicate stubs that were just throwing XCTSkip.
}

// MARK: - Mock Types

struct MockRegionDefinition {
    let id: String
    let title: LocalizedString
    let neighborIds: [String]
    let anchorId: String?
    let eventPoolIds: [String]
    let initialState: String
}

struct MockEventDefinition {
    let id: String
    let title: LocalizedString
    let body: LocalizedString
    let choiceIds: [String]
    let isOneTime: Bool
    let pressureRange: ClosedRange<Int>
    let regionIds: [String]
}

struct MockRegionRuntimeState {
    let definitionId: String
    var currentState: String
    var visitCount: Int
}

struct MockWorldRuntimeState {
    var currentRegionId: String
    var regionsState: [String: MockRegionRuntimeState]
    var pressure: Int
    var currentTime: Int
}

struct ContentValidationError: Equatable {
    enum ErrorType: Equatable {
        case brokenNeighborLink
        case brokenEventReference
        case duplicateId
        case invalidPressureRange
    }

    let type: ErrorType
    let message: String

    static func == (lhs: ContentValidationError, rhs: ContentValidationError) -> Bool {
        return lhs.type == rhs.type && lhs.message == rhs.message
    }
}

// MARK: - Mock Content Provider

class MockContentProvider {
    private let regions: [MockRegionDefinition] = [
        MockRegionDefinition(
            id: "forest",
            title: LocalizedString(en: "Forest", ru: "Ð›ÐµÑ"),
            neighborIds: ["village"],
            anchorId: "anchor_forest",
            eventPoolIds: ["pool_forest"],
            initialState: "stable"
        ),
        MockRegionDefinition(
            id: "village",
            title: LocalizedString(en: "Village", ru: "Ð”ÐµÑ€ÐµÐ²Ð½Ñ"),
            neighborIds: ["forest", "mountains"],
            anchorId: nil,
            eventPoolIds: ["pool_village"],
            initialState: "stable"
        ),
        MockRegionDefinition(
            id: "mountains",
            title: LocalizedString(en: "Mountains", ru: "Ð“Ð¾Ñ€Ñ‹"),
            neighborIds: ["village"],
            anchorId: "anchor_mountains",
            eventPoolIds: ["pool_mountains"],
            initialState: "borderland"
        )
    ]

    private let events: [MockEventDefinition] = [
        MockEventDefinition(
            id: "event_001",
            title: LocalizedString(en: "Event 001", ru: "Ð¡Ð¾Ð±Ñ‹Ñ‚Ð¸Ðµ 001"),
            body: LocalizedString(en: "Event body", ru: "Ð¢ÐµÐ»Ð¾ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ñ"),
            choiceIds: ["choice_a", "choice_b"],
            isOneTime: false,
            pressureRange: 0...50,
            regionIds: ["forest"]
        ),
        MockEventDefinition(
            id: "event_002",
            title: LocalizedString(en: "Event 002", ru: "Ð¡Ð¾Ð±Ñ‹Ñ‚Ð¸Ðµ 002"),
            body: LocalizedString(en: "Event body 2", ru: "Ð¢ÐµÐ»Ð¾ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ñ 2"),
            choiceIds: ["choice_c"],
            isOneTime: true,
            pressureRange: 30...100,
            regionIds: ["village", "mountains"]
        )
    ]

    func getAllRegionDefinitions() -> [MockRegionDefinition] {
        return regions
    }

    func getRegionDefinition(id: String) -> MockRegionDefinition? {
        return regions.first { $0.id == id }
    }

    func getAllEventDefinitions() -> [MockEventDefinition] {
        return events
    }

    func validate() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []

        // Check neighbor links
        let regionIds = Set(regions.map { $0.id })
        for region in regions {
            for neighborId in region.neighborIds {
                if !regionIds.contains(neighborId) {
                    errors.append(ContentValidationError(
                        type: .brokenNeighborLink,
                        message: "Region \(region.id) references non-existent neighbor \(neighborId)"
                    ))
                }
            }
        }

        return errors
    }
}

class MockContentProviderWithBrokenLinks: MockContentProvider {
    private let brokenRegions: [MockRegionDefinition] = [
        MockRegionDefinition(
            id: "island",
            title: LocalizedString(en: "Island", ru: "ÐžÑÑ‚Ñ€Ð¾Ð²"),
            neighborIds: ["nonexistent_region"], // Broken link!
            anchorId: nil,
            eventPoolIds: [],
            initialState: "stable"
        )
    ]

    override func getAllRegionDefinitions() -> [MockRegionDefinition] {
        return brokenRegions
    }

    override func validate() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []
        let regions = getAllRegionDefinitions()
        let regionIds = Set(regions.map { $0.id })

        for region in regions {
            for neighborId in region.neighborIds {
                if !regionIds.contains(neighborId) {
                    errors.append(ContentValidationError(
                        type: .brokenNeighborLink,
                        message: "Region \(region.id) references non-existent neighbor \(neighborId)"
                    ))
                }
            }
        }

        return errors
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/EnemyDefinitionTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Tests for EnemyDefinition JSON decoding
/// Verifies that enemies load correctly from JSON content packs
final class EnemyDefinitionTests: XCTestCase {

    // MARK: - Helper

    /// Creates a decoder configured the same way as PackLoader
    private func makeDecoder() -> JSONDecoder {
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        return decoder
    }

    // MARK: - Basic Decoding Tests

    func testDecodeBasicEnemy() throws {
        // Given: JSON with basic enemy data
        let json = """
        {
            "id": "test_enemy",
            "name": {"en": "Test Enemy", "ru": "Ð¢ÐµÑÑ‚Ð¾Ð²Ñ‹Ð¹ Ð’Ñ€Ð°Ð³"},
            "description": {"en": "A test enemy.", "ru": "Ð¢ÐµÑÑ‚Ð¾Ð²Ñ‹Ð¹ Ð²Ñ€Ð°Ð³."},
            "health": 10,
            "power": 3,
            "defense": 1,
            "difficulty": 2,
            "enemy_type": "beast",
            "rarity": "common",
            "abilities": [],
            "loot_card_ids": [],
            "faith_reward": 5,
            "balance_delta": 0
        }
        """.data(using: .utf8)!

        // When: Decoding
        let enemy = try makeDecoder().decode(EnemyDefinition.self, from: json)

        // Then: Fields should match
        XCTAssertEqual(enemy.id, "test_enemy")
        // Check that both locales are available
        XCTAssertEqual(enemy.name.en, "Test Enemy")
        XCTAssertEqual(enemy.name.ru, "Ð¢ÐµÑÑ‚Ð¾Ð²Ñ‹Ð¹ Ð’Ñ€Ð°Ð³")
        XCTAssertEqual(enemy.health, 10)
        XCTAssertEqual(enemy.power, 3)
        XCTAssertEqual(enemy.defense, 1)
        XCTAssertEqual(enemy.difficulty, 2)
        XCTAssertEqual(enemy.enemyType, .beast)
        XCTAssertEqual(enemy.rarity, .common)
        XCTAssertEqual(enemy.faithReward, 5)
        XCTAssertEqual(enemy.balanceDelta, 0)
    }

    func testDecodeEnemyWithSnakeCaseFields() throws {
        // Given: JSON with snake_case fields
        let json = """
        {
            "id": "snake_case_test",
            "name": {"en": "Snake Case", "ru": "Ð—Ð¼ÐµÐ¹ÐºÐ°"},
            "description": {"en": "Test", "ru": "Ð¢ÐµÑÑ‚"},
            "health": 8,
            "power": 2,
            "defense": 1,
            "difficulty": 1,
            "enemy_type": "spirit",
            "rarity": "uncommon",
            "abilities": [],
            "loot_card_ids": ["card1", "card2"],
            "faith_reward": 3,
            "balance_delta": -5
        }
        """.data(using: .utf8)!

        // When: Decoding
        let enemy = try makeDecoder().decode(EnemyDefinition.self, from: json)

        // Then: Snake case fields should be mapped correctly
        XCTAssertEqual(enemy.enemyType, .spirit)
        XCTAssertEqual(enemy.lootCardIds, ["card1", "card2"])
        XCTAssertEqual(enemy.faithReward, 3)
        XCTAssertEqual(enemy.balanceDelta, -5)
    }

    // MARK: - Enemy Type Tests

    func testAllEnemyTypesDecodable() throws {
        let types = ["beast", "spirit", "undead", "demon", "human", "boss"]
        let expectedTypes: [EnemyType] = [.beast, .spirit, .undead, .demon, .human, .boss]

        for (jsonType, expectedType) in zip(types, expectedTypes) {
            let json = """
            {
                "id": "type_test",
                "name": {"en": "Test", "ru": "Ð¢ÐµÑÑ‚"},
                "description": {"en": "Test", "ru": "Ð¢ÐµÑÑ‚"},
                "health": 5,
                "power": 1,
                "defense": 0,
                "difficulty": 1,
                "enemy_type": "\(jsonType)",
                "rarity": "common",
                "abilities": [],
                "loot_card_ids": [],
                "faith_reward": 1,
                "balance_delta": 0
            }
            """.data(using: .utf8)!

            let enemy = try makeDecoder().decode(EnemyDefinition.self, from: json)
            XCTAssertEqual(enemy.enemyType, expectedType, "Failed for type: \(jsonType)")
        }
    }

    // MARK: - Enemy Ability Tests

    func testDecodeEnemyWithBonusDamageAbility() throws {
        // Given: JSON with bonus_damage ability
        let json = """
        {
            "id": "ability_test",
            "name": {"en": "Rager", "ru": "Ð‘ÐµÑ€ÑÐµÑ€Ðº"},
            "description": {"en": "Test", "ru": "Ð¢ÐµÑÑ‚"},
            "health": 10,
            "power": 4,
            "defense": 1,
            "difficulty": 2,
            "enemy_type": "beast",
            "rarity": "uncommon",
            "abilities": [
                {
                    "id": "rage",
                    "name": {"en": "Rage", "ru": "Ð¯Ñ€Ð¾ÑÑ‚ÑŒ"},
                    "description": {"en": "Extra damage", "ru": "Ð”Ð¾Ð¿. ÑƒÑ€Ð¾Ð½"},
                    "effect": {"bonus_damage": 3}
                }
            ],
            "loot_card_ids": [],
            "faith_reward": 4,
            "balance_delta": 0
        }
        """.data(using: .utf8)!

        // When: Decoding
        let enemy = try makeDecoder().decode(EnemyDefinition.self, from: json)

        // Then: Ability should be decoded correctly
        XCTAssertEqual(enemy.abilities.count, 1)
        XCTAssertEqual(enemy.abilities[0].id, "rage")

        if case .bonusDamage(let damage) = enemy.abilities[0].effect {
            XCTAssertEqual(damage, 3)
        } else {
            XCTFail("Expected bonusDamage effect")
        }
    }

    func testDecodeEnemyWithRegenerationAbility() throws {
        // Given: JSON with regeneration ability
        let json = """
        {
            "id": "regen_test",
            "name": {"en": "Troll", "ru": "Ð¢Ñ€Ð¾Ð»Ð»ÑŒ"},
            "description": {"en": "Test", "ru": "Ð¢ÐµÑÑ‚"},
            "health": 15,
            "power": 3,
            "defense": 2,
            "difficulty": 3,
            "enemy_type": "beast",
            "rarity": "rare",
            "abilities": [
                {
                    "id": "regen",
                    "name": {"en": "Regeneration", "ru": "Ð ÐµÐ³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ"},
                    "description": {"en": "Heals each turn", "ru": "Ð›ÐµÑ‡Ð¸Ñ‚ÑÑ ÐºÐ°Ð¶Ð´Ñ‹Ð¹ Ñ…Ð¾Ð´"},
                    "effect": {"regeneration": 2}
                }
            ],
            "loot_card_ids": [],
            "faith_reward": 6,
            "balance_delta": 0
        }
        """.data(using: .utf8)!

        // When: Decoding
        let enemy = try makeDecoder().decode(EnemyDefinition.self, from: json)

        // Then: Regeneration ability should be decoded
        XCTAssertEqual(enemy.abilities.count, 1)
        if case .regeneration(let amount) = enemy.abilities[0].effect {
            XCTAssertEqual(amount, 2)
        } else {
            XCTFail("Expected regeneration effect")
        }
    }

    func testDecodeEnemyWithArmorAbility() throws {
        // Given: JSON with armor ability
        let json = """
        {
            "id": "armor_test",
            "name": {"en": "Guardian", "ru": "Ð¡Ñ‚Ñ€Ð°Ð¶"},
            "description": {"en": "Test", "ru": "Ð¢ÐµÑÑ‚"},
            "health": 12,
            "power": 2,
            "defense": 4,
            "difficulty": 2,
            "enemy_type": "spirit",
            "rarity": "uncommon",
            "abilities": [
                {
                    "id": "stone_skin",
                    "name": {"en": "Stone Skin", "ru": "ÐšÐ°Ð¼ÐµÐ½Ð½Ð°Ñ ÐšÐ¾Ð¶Ð°"},
                    "description": {"en": "Reduces damage", "ru": "Ð£Ð¼ÐµÐ½ÑŒÑˆÐ°ÐµÑ‚ ÑƒÑ€Ð¾Ð½"},
                    "effect": {"armor": 2}
                }
            ],
            "loot_card_ids": [],
            "faith_reward": 5,
            "balance_delta": 5
        }
        """.data(using: .utf8)!

        // When: Decoding
        let enemy = try makeDecoder().decode(EnemyDefinition.self, from: json)

        // Then: Armor ability should be decoded
        if case .armor(let amount) = enemy.abilities[0].effect {
            XCTAssertEqual(amount, 2)
        } else {
            XCTFail("Expected armor effect")
        }
    }

    func testDecodeEnemyWithApplyCurseAbility() throws {
        // Given: JSON with apply_curse ability
        let json = """
        {
            "id": "curse_test",
            "name": {"en": "Witch", "ru": "Ð’ÐµÐ´ÑŒÐ¼Ð°"},
            "description": {"en": "Test", "ru": "Ð¢ÐµÑÑ‚"},
            "health": 8,
            "power": 5,
            "defense": 1,
            "difficulty": 3,
            "enemy_type": "demon",
            "rarity": "rare",
            "abilities": [
                {
                    "id": "curse",
                    "name": {"en": "Curse Touch", "ru": "ÐŸÑ€Ð¾ÐºÐ»ÑÑ‚Ð¸Ðµ"},
                    "description": {"en": "Curses on hit", "ru": "ÐŸÑ€Ð¾ÐºÐ»Ð¸Ð½Ð°ÐµÑ‚ Ð¿Ñ€Ð¸ ÑƒÐ´Ð°Ñ€Ðµ"},
                    "effect": {"apply_curse": "weakness"}
                }
            ],
            "loot_card_ids": [],
            "faith_reward": 7,
            "balance_delta": -10
        }
        """.data(using: .utf8)!

        // When: Decoding
        let enemy = try makeDecoder().decode(EnemyDefinition.self, from: json)

        // Then: Apply curse ability should be decoded
        if case .applyCurse(let curseId) = enemy.abilities[0].effect {
            XCTAssertEqual(curseId, "weakness")
        } else {
            XCTFail("Expected applyCurse effect")
        }
    }

    // MARK: - Card Conversion Tests

    func testEnemyToCardConversion() throws {
        // Given: Enemy definition
        let json = """
        {
            "id": "card_test",
            "name": {"en": "Wild Beast", "ru": "Ð”Ð¸ÐºÐ¸Ð¹ Ð—Ð²ÐµÑ€ÑŒ"},
            "description": {"en": "A wild beast.", "ru": "Ð”Ð¸ÐºÐ¸Ð¹ Ð·Ð²ÐµÑ€ÑŒ."},
            "health": 8,
            "power": 3,
            "defense": 1,
            "difficulty": 1,
            "enemy_type": "beast",
            "rarity": "common",
            "abilities": [],
            "loot_card_ids": [],
            "faith_reward": 2,
            "balance_delta": 0
        }
        """.data(using: .utf8)!

        let enemy = try makeDecoder().decode(EnemyDefinition.self, from: json)

        // When: Converting to card
        let card = enemy.toCard()

        // Then: Card should have correct values
        // Card name depends on system locale - just verify it's one of the localized values
        XCTAssertTrue(card.name == "Wild Beast" || card.name == "Ð”Ð¸ÐºÐ¸Ð¹ Ð—Ð²ÐµÑ€ÑŒ")
        XCTAssertEqual(card.type, .monster)
        XCTAssertEqual(card.health, 8)
        XCTAssertEqual(card.power, 3)
        XCTAssertEqual(card.defense, 1)
        XCTAssertEqual(card.rarity, .common)
    }

    // MARK: - Multiple Abilities Test

    func testDecodeEnemyWithMultipleAbilities() throws {
        // Given: Boss enemy with multiple abilities
        let json = """
        {
            "id": "boss_test",
            "name": {"en": "Leshy Guardian", "ru": "Ð›ÐµÑˆÐ¸Ð¹-Ð¥Ñ€Ð°Ð½Ð¸Ñ‚ÐµÐ»ÑŒ"},
            "description": {"en": "Ancient guardian.", "ru": "Ð”Ñ€ÐµÐ²Ð½Ð¸Ð¹ ÑÑ‚Ñ€Ð°Ð¶."},
            "health": 25,
            "power": 7,
            "defense": 4,
            "difficulty": 5,
            "enemy_type": "boss",
            "rarity": "legendary",
            "abilities": [
                {
                    "id": "nature_wrath",
                    "name": {"en": "Nature's Wrath", "ru": "Ð“Ð½ÐµÐ² ÐŸÑ€Ð¸Ñ€Ð¾Ð´Ñ‹"},
                    "description": {"en": "Regenerates health", "ru": "Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÑ‚ Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÐµ"},
                    "effect": {"regeneration": 3}
                },
                {
                    "id": "ancient_armor",
                    "name": {"en": "Ancient Armor", "ru": "Ð”Ñ€ÐµÐ²Ð½ÑÑ Ð‘Ñ€Ð¾Ð½Ñ"},
                    "description": {"en": "Thick bark", "ru": "Ð¢Ð¾Ð»ÑÑ‚Ð°Ñ ÐºÐ¾Ñ€Ð°"},
                    "effect": {"armor": 2}
                }
            ],
            "loot_card_ids": ["guardian_seal", "ancient_power"],
            "faith_reward": 20,
            "balance_delta": 20
        }
        """.data(using: .utf8)!

        // When: Decoding
        let enemy = try makeDecoder().decode(EnemyDefinition.self, from: json)

        // Then: Should have two abilities
        XCTAssertEqual(enemy.abilities.count, 2)
        XCTAssertEqual(enemy.enemyType, .boss)
        XCTAssertEqual(enemy.rarity, .legendary)
        XCTAssertEqual(enemy.lootCardIds.count, 2)
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/GameplayFlowTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Tests for gameplay flow - regions, travel, events, choices
/// These tests verify the critical user paths work correctly
final class GameplayFlowTests: XCTestCase {

    var engine: TwilightGameEngine!

    override func setUp() {
        super.setUp()
        TestContentLoader.loadContentPacksIfNeeded()
        engine = TwilightGameEngine()
        engine.initializeNewGame(playerName: "Test", heroId: nil)
    }

    override func tearDown() {
        engine = nil
        super.tearDown()
    }

    /// Helper to fail test if regions not loaded
    private func requireRegionsLoaded() -> Bool {
        if engine.regionsArray.isEmpty {
            XCTFail("Skipping: ContentPack not loaded (no regions)")
            return false
        }
        return true
    }

    // MARK: - Region Tests

    func testRegionsArrayNotEmpty() {
        guard requireRegionsLoaded() else { return }
        // Given: Engine initialized
        // When: Accessing regions
        let regions = engine.regionsArray

        // Then: Should have regions
        XCTAssertFalse(regions.isEmpty, "Engine should have at least one region")
    }

    func testCurrentRegionExists() {
        guard requireRegionsLoaded() else { return }
        // Given: Engine initialized
        // When: Checking current region
        let currentRegionId = engine.currentRegionId

        // Then: Should have current region
        XCTAssertNotNil(currentRegionId, "Engine should have current region ID")

        // And current region should be in regionsArray
        let currentRegion = engine.regionsArray.first { $0.id == currentRegionId }
        XCTAssertNotNil(currentRegion, "Current region should exist in regionsArray")
    }

    func testRegionHasRequiredProperties() {
        guard requireRegionsLoaded() else { return }
        // Given: Engine with regions
        guard let region = engine.regionsArray.first else {
            XCTFail("No regions available"); return
        }

        // Then: Region should have required properties
        XCTAssertFalse(region.name.isEmpty, "Region should have name")
        // ID is UUID, always valid
        XCTAssertNotNil(region.id, "Region should have ID")
    }

    // MARK: - Travel Tests

    func testTravelToNeighborRegion() {
        guard requireRegionsLoaded() else { return }
        // Given: Current region with neighbors
        guard let currentRegion = engine.currentRegion else {
            XCTFail("No current region"); return
        }

        guard let neighborId = currentRegion.neighborIds.first else {
            XCTFail("Current region has no neighbors to travel to"); return
        }

        let initialRegionId = engine.currentRegionId

        // When: Traveling to neighbor
        let result = engine.performAction(.travel(toRegionId: neighborId))

        // Then: Travel should succeed
        XCTAssertTrue(result.success, "Travel to neighbor should succeed")

        // And current region should change
        XCTAssertNotEqual(engine.currentRegionId, initialRegionId, "Current region should change after travel")
        XCTAssertEqual(engine.currentRegionId, neighborId, "Current region should be destination")
    }

    func testTravelAdvancesTime() {
        // Given: Current day
        let initialDay = engine.currentDay

        guard let currentRegion = engine.currentRegion,
              let neighborId = currentRegion.neighborIds.first else {
            XCTFail("Cannot test travel time - no neighbors"); return
        }

        // When: Traveling
        let _ = engine.performAction(.travel(toRegionId: neighborId))

        // Then: Day should advance
        XCTAssertGreaterThan(engine.currentDay, initialDay, "Travel should advance time")
    }

    func testCannotTravelToNonNeighbor() {
        guard requireRegionsLoaded() else { return }
        // Given: A region that is not a neighbor
        guard let currentRegion = engine.currentRegion else {
            XCTFail("No current region"); return
        }

        // Find a non-neighbor region
        let nonNeighborRegion = engine.regionsArray.first { region in
            region.id != currentRegion.id && !currentRegion.neighborIds.contains(region.id)
        }

        guard let targetRegion = nonNeighborRegion else {
            XCTFail("All regions are neighbors - cannot test non-neighbor travel"); return
        }

        // When: Trying to travel to non-neighbor
        let _ = engine.performAction(.travel(toRegionId: targetRegion.id))

        // Then: Should fail or be blocked (depending on implementation)
        // Note: Some implementations may allow travel to any region
        // This test documents expected behavior
        if !currentRegion.neighborIds.contains(targetRegion.id) {
            // Either fails or implementation allows any travel
            XCTAssertTrue(true, "Non-neighbor travel behavior documented")
        }
    }

    // MARK: - Event Tests

    func testExploreTriggersEvent() {
        guard requireRegionsLoaded() else { return }
        // Given: Engine in a region
        guard engine.currentRegion != nil else {
            XCTFail("No current region"); return
        }

        // When: Exploring
        let result = engine.performAction(.explore)

        // Then: Should succeed (may or may not trigger event)
        XCTAssertTrue(result.success, "Explore action should succeed")

        // Note: Event may or may not be triggered depending on availability
        // This test verifies the action completes without error
    }

    func testEventHasChoices() {
        // Given: A combat event
        let testEvent = GameEvent(
            eventType: .combat,
            title: "Test Combat",
            description: "Test description",
            choices: [
                EventChoice(
                    id: "fight",
                    text: "Fight",
                    consequences: EventConsequences(message: "Fought")
                ),
                EventChoice(
                    id: "flee",
                    text: "Flee",
                    consequences: EventConsequences(healthChange: -1, message: "Fled")
                )
            ]
        )

        // Then: Event should have choices
        XCTAssertGreaterThan(testEvent.choices.count, 0, "Event should have at least one choice")
        XCTAssertEqual(testEvent.choices.count, 2, "Test event should have 2 choices")
    }

    // MARK: - Choice Requirement Tests

    func testChoiceWithNoRequirementsIsAvailable() {
        // Given: A choice with no requirements
        let choice = EventChoice(
            id: "simple_choice",
            text: "Simple choice",
            requirements: nil,
            consequences: EventConsequences(message: "Done")
        )

        // Then: Should be available (requirements are nil)
        XCTAssertNil(choice.requirements, "Choice should have no requirements")
    }

    func testChoiceWithFaithRequirement() {
        // Given: A choice requiring faith
        let choice = EventChoice(
            id: "holy_action",
            text: "Holy action",
            requirements: EventRequirements(minimumFaith: 5),
            consequences: EventConsequences(message: "Blessed")
        )

        // When: Player has enough faith
        let hasFaith = engine.playerFaith >= 5

        // Then: Requirement check depends on faith
        XCTAssertNotNil(choice.requirements?.minimumFaith, "Choice should have faith requirement")
        XCTAssertEqual(choice.requirements?.minimumFaith, 5, "Faith requirement should be 5")

        // Document current state
        print("Player faith: \(engine.playerFaith), Required: 5, Can meet: \(hasFaith)")
    }

    func testChoiceWithHealthRequirement() {
        // Given: A choice requiring health
        let choice = EventChoice(
            id: "dangerous_action",
            text: "Dangerous action",
            requirements: EventRequirements(minimumHealth: 3),
            consequences: EventConsequences(message: "Survived")
        )

        // When: Player has enough health
        let hasHealth = engine.playerHealth >= 3

        // Then: Requirement check depends on health
        XCTAssertNotNil(choice.requirements?.minimumHealth, "Choice should have health requirement")
        XCTAssertEqual(choice.requirements?.minimumHealth, 3, "Health requirement should be 3")
        XCTAssertTrue(hasHealth, "Player should have at least 3 health")
    }

    // MARK: - Choice Application Tests

    func testChoiceConsequencesStructure() {
        // Given: Consequences with various changes
        let consequences = EventConsequences(
            faithChange: -2,
            healthChange: -1,
            message: "Test consequence"
        )

        // Then: Verify consequences structure
        XCTAssertNotNil(consequences.faithChange, "Consequences should have faith change")
        XCTAssertEqual(consequences.faithChange, -2, "Faith change should be -2")
        XCTAssertNotNil(consequences.healthChange, "Consequences should have health change")
        XCTAssertEqual(consequences.healthChange, -1, "Health change should be -1")
        XCTAssertEqual(consequences.message, "Test consequence", "Message should match")
    }

    // MARK: - Combat Event Tests

    func testCombatEventHasMonsterCard() {
        // Given: A combat event definition with challenge
        let challenge = MiniGameChallengeDefinition(
            id: "test_challenge",
            challengeKind: .combat,
            difficulty: 1,
            enemyId: "wild_beast"
        )

        let eventDef = EventDefinition(
            id: "test_combat",
            title: .inline(LocalizedString(en: "Test Combat", ru: "Ð¢ÐµÑÑ‚ Ð‘Ð¾Ð¹")),
            body: .inline(LocalizedString(en: "A beast attacks!", ru: "Ð—Ð²ÐµÑ€ÑŒ Ð°Ñ‚Ð°ÐºÑƒÐµÑ‚!")),
            eventKind: .miniGame(.combat),
            availability: .always,
            poolIds: ["pool_common"],
            weight: 10,
            isOneTime: false,
            choices: [],
            miniGameChallenge: challenge
        )

        // When: Converting to GameEvent using extension method
        let gameEvent = eventDef.toGameEvent()

        // Then: Should be combat event type
        XCTAssertEqual(gameEvent.eventType, .combat, "Event type should be combat")
        // Note: monsterCard may be nil if enemy is not in registry, but eventType should be correct
    }

    func testNarrativeEventType() {
        // Given: A narrative event definition
        let eventDef = EventDefinition(
            id: "test_narrative",
            title: .inline(LocalizedString(en: "Test Narrative", ru: "Ð¢ÐµÑÑ‚ ÐÐ°Ñ€Ñ€Ð°Ñ‚Ð¸Ð²")),
            body: .inline(LocalizedString(en: "Something happens", ru: "Ð§Ñ‚Ð¾-Ñ‚Ð¾ Ð¿Ñ€Ð¾Ð¸ÑÑ…Ð¾Ð´Ð¸Ñ‚")),
            eventKind: .inline,
            availability: .always,
            poolIds: ["pool_common"],
            weight: 10,
            isOneTime: false,
            choices: [],
            miniGameChallenge: nil
        )

        // When: Converting to GameEvent using extension method
        let gameEvent = eventDef.toGameEvent()

        // Then: Should NOT have monster card and should be narrative type
        XCTAssertNil(gameEvent.monsterCard, "Non-combat event should not have monster card")
        XCTAssertEqual(gameEvent.eventType, .narrative, "Event type should be narrative")
    }

    // MARK: - Event Definition Parsing Tests

    func testEventKindDecodingInline() throws {
        // Given: JSON with inline event kind
        let json = """
        "inline"
        """.data(using: .utf8)!

        // When: Decoding
        let decoder = JSONDecoder()
        let eventKind = try decoder.decode(EventKind.self, from: json)

        // Then: Should be inline
        XCTAssertEqual(eventKind, .inline, "Should decode 'inline' string to EventKind.inline")
    }

    func testEventKindDecodingMiniGame() throws {
        // Given: JSON with mini_game event kind
        let json = """
        {"mini_game": "combat"}
        """.data(using: .utf8)!

        // When: Decoding
        let decoder = JSONDecoder()
        let eventKind = try decoder.decode(EventKind.self, from: json)

        // Then: Should be miniGame combat
        XCTAssertEqual(eventKind, .miniGame(.combat), "Should decode mini_game object to EventKind.miniGame(.combat)")
    }

    func testMiniGameChallengeDecoding() throws {
        // Given: JSON with simplified mini_game_challenge format
        let json = """
        {
            "enemy_id": "wild_beast",
            "difficulty": 2
        }
        """.data(using: .utf8)!

        // When: Decoding (using same decoder config as PackLoader)
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let challenge = try decoder.decode(MiniGameChallengeDefinition.self, from: json)

        // Then: Should have correct values
        XCTAssertEqual(challenge.enemyId, "wild_beast", "Enemy ID should be decoded")
        XCTAssertEqual(challenge.difficulty, 2, "Difficulty should be decoded")
        XCTAssertEqual(challenge.id, "challenge_wild_beast", "ID should be generated from enemy ID")
    }

    // MARK: - State Persistence Tests

    func testRegionStateAfterTravel() {
        // Given: Initial state
        guard let initialRegion = engine.currentRegion,
              let neighborId = initialRegion.neighborIds.first else {
            XCTFail("Cannot test - no neighbors"); return
        }

        // When: Traveling
        let _ = engine.performAction(.travel(toRegionId: neighborId))

        // Then: New region should be current
        XCTAssertEqual(engine.currentRegionId, neighborId, "Current region ID should update")

        // And previous region should still exist in array
        let previousRegion = engine.regionsArray.first { $0.id == initialRegion.id }
        XCTAssertNotNil(previousRegion, "Previous region should still exist")
    }

    // MARK: - Explore Flow Tests

    func testExploreActionSuccess() {
        guard requireRegionsLoaded() else { return }
        // Given: Engine in a region
        guard engine.currentRegion != nil else {
            XCTFail("No current region"); return
        }

        // When: Exploring
        let result = engine.performAction(.explore)

        // Then: Action should succeed
        XCTAssertTrue(result.success, "Explore action should always succeed")
    }

    func testExploreReturnsEventOrNil() {
        guard requireRegionsLoaded() else { return }
        // Given: Engine in a region
        guard engine.currentRegion != nil else {
            XCTFail("No current region"); return
        }

        // When: Exploring
        let result = engine.performAction(.explore)

        // Then: Either an event is triggered or nil (no events available)
        // Both outcomes are valid
        if let eventId = result.currentEvent {
            // Event was triggered - verify it's a valid UUID
            XCTAssertNotNil(eventId, "Triggered event should have valid ID")
            // Engine should have currentEvent set
            XCTAssertEqual(engine.currentEventId, eventId, "Engine currentEventId should match result")
        } else {
            // No event available - this is expected when region is fully explored
            XCTAssertTrue(result.success, "Explore should succeed even without events")
            XCTAssertNil(engine.currentEventId, "Engine currentEventId should be nil when no event")
        }
    }

    func testExploreDoesNotAdvanceTimeWhenNoEvent() {
        guard requireRegionsLoaded() else { return }
        // Given: Engine with current day
        let initialDay = engine.currentDay

        // When: Exploring
        let result = engine.performAction(.explore)

        // Then: If no event triggered, time should not advance
        if result.currentEvent == nil {
            XCTAssertEqual(engine.currentDay, initialDay, "Day should not advance when no event found")
        }
        // Note: If event was triggered, time advancement depends on event handling
    }

    // MARK: - Combat Mechanics v2.0 Tests (Cards as Modifiers)
    // NOTE: CombatView.CombatStats/CombatOutcome tests moved to app tests (UI types)

    func testCardTypeAttackAddsBonus() {
        // Given: An attack card
        let attackCard = Card(
            name: "Test Sword",
            type: .attack,
            description: "A test weapon",
            power: 5
        )

        // Then: Attack cards should have power property
        XCTAssertEqual(attackCard.type, .attack, "Card should be attack type")
        XCTAssertEqual(attackCard.power, 5, "Attack card should have power for bonus damage")
    }

    func testCardTypeDefenseHasDefenseValue() {
        // Given: A defense card
        let defenseCard = Card(
            name: "Test Shield",
            type: .defense,
            description: "A test shield",
            defense: 4
        )

        // Then: Defense cards should have defense property
        XCTAssertEqual(defenseCard.type, .defense, "Card should be defense type")
        XCTAssertEqual(defenseCard.defense, 4, "Defense card should have defense for shield value")
    }

    func testCardCostProperty() {
        // Given: Cards with different costs
        let freeCard = Card(
            name: "Free Card",
            type: .attack,
            description: "No cost",
            cost: 0
        )
        let costlyCard = Card(
            name: "Costly Card",
            type: .spell,
            description: "Costs faith",
            cost: 3
        )

        // Then: Costs should be correct
        XCTAssertEqual(freeCard.cost, 0, "Free card should have 0 cost")
        XCTAssertEqual(costlyCard.cost, 3, "Costly card should have cost of 3")
    }

    func testCardTypeSpellHasAbilities() {
        // Given: A spell card with abilities
        let spellCard = Card(
            name: "Fireball",
            type: .spell,
            description: "Deals damage",
            cost: 2,
            abilities: [
                CardAbility(
                    name: "Fire Damage",
                    description: "Deals fire damage",
                    effect: .damage(amount: 6, type: .fire)
                )
            ]
        )

        // Then: Spell should have abilities
        XCTAssertEqual(spellCard.type, .spell, "Card should be spell type")
        XCTAssertFalse(spellCard.abilities.isEmpty, "Spell should have abilities")

        if case .damage(let amount, let type) = spellCard.abilities.first?.effect {
            XCTAssertEqual(amount, 6, "Damage amount should be 6")
            XCTAssertEqual(type, .fire, "Damage type should be fire")
        } else {
            XCTFail("First ability should be damage effect"); return
        }
    }

    func testCardTypeAffectsCombatBehavior() {
        // Given: Different card types
        let attackTypes: [CardType] = [.attack, .weapon]
        let defenseTypes: [CardType] = [.defense, .armor]
        let spellTypes: [CardType] = [.spell, .ritual]

        // Then: Types should be categorized correctly
        for type in attackTypes {
            XCTAssertTrue(type == .attack || type == .weapon, "Should be attack type")
        }
        for type in defenseTypes {
            XCTAssertTrue(type == .defense || type == .armor, "Should be defense type")
        }
        for type in spellTypes {
            XCTAssertTrue(type == .spell || type == .ritual, "Should be spell type")
        }
    }

    func testCombatResourceFaith() {
        // Given: Engine with player
        let initialFaith = engine.playerFaith

        // Then: Faith should be available for card costs
        XCTAssertGreaterThanOrEqual(initialFaith, 0, "Player should have non-negative faith")
    }

    func testCardAbilityAddDice() {
        // Given: An ability that adds dice
        let ability = CardAbility(
            name: "Blessing",
            description: "Adds bonus dice",
            effect: .addDice(count: 2)
        )

        // Then: Effect should be addDice with correct count
        if case .addDice(let count) = ability.effect {
            XCTAssertEqual(count, 2, "Should add 2 dice")
        } else {
            XCTFail("Effect should be addDice"); return
        }
    }

    func testCardAbilityHeal() {
        // Given: An ability that heals
        let ability = CardAbility(
            name: "Heal",
            description: "Heals player",
            effect: .heal(amount: 5)
        )

        // Then: Effect should be heal with correct amount
        if case .heal(let amount) = ability.effect {
            XCTAssertEqual(amount, 5, "Should heal 5 HP")
        } else {
            XCTFail("Effect should be heal"); return
        }
    }

    func testCardAbilityGainFaith() {
        // Given: An ability that grants faith
        let ability = CardAbility(
            name: "Prayer",
            description: "Grants faith",
            effect: .gainFaith(amount: 3)
        )

        // Then: Effect should be gainFaith with correct amount
        if case .gainFaith(let amount) = ability.effect {
            XCTAssertEqual(amount, 3, "Should grant 3 faith")
        } else {
            XCTFail("Effect should be gainFaith"); return
        }
    }

    // MARK: - Navigation System Tests v2.0

    func testIsNeighborReturnsTrue() {
        // Given: Current region with neighbors
        guard let currentRegion = engine.currentRegion,
              let neighborId = currentRegion.neighborIds.first else {
            XCTFail("No neighbors available"); return
        }

        // When: Checking if neighbor
        let isNeighbor = engine.isNeighbor(regionId: neighborId)

        // Then: Should return true
        XCTAssertTrue(isNeighbor, "Should return true for neighbor region")
    }

    func testIsNeighborReturnsFalseForDistant() {
        // Given: A region that is not a neighbor
        guard let currentRegion = engine.currentRegion else {
            XCTFail("No current region"); return
        }

        let distantRegion = engine.regionsArray.first { region in
            region.id != currentRegion.id && !currentRegion.neighborIds.contains(region.id)
        }

        guard let distant = distantRegion else {
            XCTFail("All regions are neighbors"); return
        }

        // When: Checking if neighbor
        let isNeighbor = engine.isNeighbor(regionId: distant.id)

        // Then: Should return false
        XCTAssertFalse(isNeighbor, "Should return false for distant region")
    }

    func testCalculateTravelCostForNeighbor() {
        // Given: Current region with neighbors
        guard let currentRegion = engine.currentRegion,
              let neighborId = currentRegion.neighborIds.first else {
            XCTFail("No neighbors available"); return
        }

        // When: Calculating travel cost
        let cost = engine.calculateTravelCost(to: neighborId)

        // Then: Should be 1 day for neighbor
        XCTAssertEqual(cost, 1, "Travel cost to neighbor should be 1 day")
    }

    func testCalculateTravelCostForDistant() {
        // Given: A distant region
        guard let currentRegion = engine.currentRegion else {
            XCTFail("No current region"); return
        }

        let distantRegion = engine.regionsArray.first { region in
            region.id != currentRegion.id && !currentRegion.neighborIds.contains(region.id)
        }

        guard let distant = distantRegion else {
            XCTFail("All regions are neighbors"); return
        }

        // When: Calculating travel cost
        let cost = engine.calculateTravelCost(to: distant.id)

        // Then: Should be 2 days for distant
        XCTAssertEqual(cost, 2, "Travel cost to distant region should be 2 days")
    }

    func testCanTravelToNeighbor() {
        // Given: Current region with neighbors
        guard let currentRegion = engine.currentRegion,
              let neighborId = currentRegion.neighborIds.first else {
            XCTFail("No neighbors available"); return
        }

        // When: Checking if can travel
        let canTravel = engine.canTravelTo(regionId: neighborId)

        // Then: Should be able to travel to neighbor
        XCTAssertTrue(canTravel, "Should be able to travel to neighbor")
    }

    func testCannotTravelToDistantRegion() {
        // Given: A distant region
        guard let currentRegion = engine.currentRegion else {
            XCTFail("No current region"); return
        }

        let distantRegion = engine.regionsArray.first { region in
            region.id != currentRegion.id && !currentRegion.neighborIds.contains(region.id)
        }

        guard let distant = distantRegion else {
            XCTFail("All regions are neighbors"); return
        }

        // When: Checking if can travel
        let canTravel = engine.canTravelTo(regionId: distant.id)

        // Then: Should not be able to travel to distant
        XCTAssertFalse(canTravel, "Should not be able to travel to distant region directly")
    }

    func testCannotTravelToCurrentRegion() {
        // Given: Current region
        guard let currentRegionId = engine.currentRegionId else {
            XCTFail("No current region"); return
        }

        // When: Checking if can travel to self
        let canTravel = engine.canTravelTo(regionId: currentRegionId)

        // Then: Should not be able to travel to self
        XCTAssertFalse(canTravel, "Should not be able to travel to current region")
    }

    func testGetRoutingHintForDistantRegion() {
        // Given: A distant region
        guard let currentRegion = engine.currentRegion else {
            XCTFail("No current region"); return
        }

        let distantRegion = engine.regionsArray.first { region in
            region.id != currentRegion.id && !currentRegion.neighborIds.contains(region.id)
        }

        guard let distant = distantRegion else {
            XCTFail("All regions are neighbors"); return
        }

        // When: Getting routing hint
        let hints = engine.getRoutingHint(to: distant.id)

        // Then: Should return array (may be empty if no path via 1 hop)
        // This test verifies the method returns without error and hints are valid region names
        for hint in hints {
            XCTAssertFalse(hint.isEmpty, "Each routing hint should be a non-empty region name")
        }
    }

    func testGetRoutingHintEmptyForNeighbor() {
        // Given: A neighbor region
        guard let currentRegion = engine.currentRegion,
              let neighborId = currentRegion.neighborIds.first else {
            XCTFail("No neighbors available"); return
        }

        // When: Getting routing hint for neighbor
        let hints = engine.getRoutingHint(to: neighborId)

        // Then: Should be empty (no hint needed)
        XCTAssertTrue(hints.isEmpty, "Routing hints should be empty for neighbor")
    }

    // MARK: - UI Stability Tests (Duplicate ID Prevention)

    func testDuplicateCardsHaveUniqueIds() {
        // Given: Two cards with the same name (like "Ð—Ð°Ñ‰Ð¸Ñ‚Ð½Ñ‹Ð¹ ÐŸÐ¾ÑÐ¾Ñ…")
        let card1 = Card(
            name: "Ð—Ð°Ñ‰Ð¸Ñ‚Ð½Ñ‹Ð¹ ÐŸÐ¾ÑÐ¾Ñ…",
            type: .attack,
            rarity: .common,
            description: "ÐŸÑ€Ð¾ÑÑ‚Ð¾Ð¹ Ð¿Ð¾ÑÐ¾Ñ…",
            power: 2
        )
        let card2 = Card(
            name: "Ð—Ð°Ñ‰Ð¸Ñ‚Ð½Ñ‹Ð¹ ÐŸÐ¾ÑÐ¾Ñ…",
            type: .attack,
            rarity: .common,
            description: "ÐŸÑ€Ð¾ÑÑ‚Ð¾Ð¹ Ð¿Ð¾ÑÐ¾Ñ…",
            power: 2
        )

        // Then: Cards should have unique IDs even with same name
        XCTAssertNotEqual(card1.id, card2.id, "Cards with same name should have unique IDs")
    }

    func testCombatLogCanHaveDuplicateEntries() {
        // Given: A combat log with duplicate entries
        var combatLog: [String] = []
        let entry = "âš”ï¸ Ð—Ð°Ñ‰Ð¸Ñ‚Ð½Ñ‹Ð¹ ÐŸÐ¾ÑÐ¾Ñ…: +2 Ðº ÑƒÑ€Ð¾Ð½Ñƒ ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐ¹ Ð°Ñ‚Ð°ÐºÐ¸"

        // When: Adding same entry multiple times
        combatLog.append(entry)
        combatLog.append(entry)
        combatLog.append(entry)

        // Then: Log should contain all entries
        XCTAssertEqual(combatLog.count, 3, "Combat log should allow duplicate entries")

        // And: Enumerated access should work (as used in ForEach)
        let enumerated = Array(combatLog.suffix(5).enumerated())
        XCTAssertEqual(enumerated.count, 3, "Enumerated log should have same count")

        // And: Each entry should have unique offset
        let offsets = enumerated.map { $0.offset }
        let uniqueOffsets = Set(offsets)
        XCTAssertEqual(offsets.count, uniqueOffsets.count, "Each entry should have unique offset for ForEach id")
    }

    // NOTE: SF Symbol tests (testValidSFSymbolsUsed, testInvalidSFSymbolReturnsNil) moved to app tests (UIImage)

    func testDeckCanContainMultipleCopiesOfSameCard() {
        // Given: A deck with multiple copies of the same card name
        let cards = [
            Card(name: "Ð—Ð°Ñ‰Ð¸Ñ‚Ð½Ñ‹Ð¹ ÐŸÐ¾ÑÐ¾Ñ…", type: .attack, rarity: .common, description: "Test", power: 2),
            Card(name: "Ð—Ð°Ñ‰Ð¸Ñ‚Ð½Ñ‹Ð¹ ÐŸÐ¾ÑÐ¾Ñ…", type: .attack, rarity: .common, description: "Test", power: 2),
            Card(name: "Ð¡Ð²ÐµÑ‚Ð»Ñ‹Ð¹ ÐžÐ±ÐµÑ€ÐµÐ³", type: .defense, rarity: .common, description: "Test", defense: 1),
            Card(name: "Ð¡Ð²ÐµÑ‚Ð»Ñ‹Ð¹ ÐžÐ±ÐµÑ€ÐµÐ³", type: .defense, rarity: .common, description: "Test", defense: 1)
        ]

        // When: Getting unique IDs
        let ids = cards.map { $0.id }
        let uniqueIds = Set(ids)

        // Then: All cards should have unique IDs
        XCTAssertEqual(ids.count, uniqueIds.count, "All cards should have unique IDs even with same names")
        XCTAssertEqual(uniqueIds.count, 4, "Should have 4 unique card IDs")
    }

    // MARK: - Content Pack Loading Tests

    func testSemanticVersionDecoding() throws {
        // Given: JSON with version string
        let json = """
        {"version": "1.2.3"}
        """
        struct VersionWrapper: Codable { let version: SemanticVersion }

        // When: Decoding
        let data = json.data(using: .utf8)!
        let decoded = try JSONDecoder().decode(VersionWrapper.self, from: data)

        // Then: Version should be parsed correctly
        XCTAssertEqual(decoded.version.major, 1)
        XCTAssertEqual(decoded.version.minor, 2)
        XCTAssertEqual(decoded.version.patch, 3)
    }

    func testSemanticVersionEncoding() throws {
        // Given: SemanticVersion
        let version = SemanticVersion(major: 2, minor: 0, patch: 1)
        struct VersionWrapper: Codable { let version: SemanticVersion }

        // When: Encoding
        let wrapper = VersionWrapper(version: version)
        let data = try JSONEncoder().encode(wrapper)
        let json = String(data: data, encoding: .utf8)!

        // Then: Should encode to string format
        XCTAssertTrue(json.contains("\"2.0.1\""), "Version should be encoded as string")
    }

    func testInvalidSemanticVersionThrowsError() {
        // Given: JSON with invalid version
        let json = """
        {"version": "invalid"}
        """
        struct VersionWrapper: Codable { let version: SemanticVersion }

        // When/Then: Decoding should throw
        let data = json.data(using: .utf8)!
        XCTAssertThrowsError(try JSONDecoder().decode(VersionWrapper.self, from: data))
    }

    func testContentRegistryExists() {
        // Given: Shared content registry
        let registry = ContentRegistry.shared

        // Then: Should exist
        XCTAssertNotNil(registry, "ContentRegistry.shared should exist")
    }

    // MARK: - Performance Tests

    func testEngineInitializationPerformance() {
        guard requireRegionsLoaded() else { return }
        // Measure time to initialize engine (Engine-First)
        measure {
            let testEngine = TwilightGameEngine()
            testEngine.initializeFromContentRegistry(ContentRegistry.shared)

            // Ensure engine is usable
            XCTAssertNotNil(testEngine.currentRegionId)
        }
    }

    func testRegionAccessPerformance() {
        guard requireRegionsLoaded() else { return }
        // Measure time to access regions multiple times
        measure {
            for _ in 0..<100 {
                let regions = engine.regionsArray
                XCTAssertFalse(regions.isEmpty)
            }
        }
    }

    func testTravelActionPerformance() {
        guard let currentRegion = engine.currentRegion,
              let neighborId = currentRegion.neighborIds.first else {
            XCTFail("No neighbors for performance test"); return
        }

        // Measure travel performance
        measure {
            // Travel to neighbor
            _ = engine.performAction(.travel(toRegionId: neighborId))

            // Travel back
            if let newRegion = engine.currentRegion,
               let returnId = newRegion.neighborIds.first {
                _ = engine.performAction(.travel(toRegionId: returnId))
            }
        }
    }

    func testCardCreationPerformance() {
        // Measure card creation performance
        measure {
            for i in 0..<100 {
                _ = Card(
                    name: "Test Card \(i)",
                    type: .attack,
                    rarity: .common,
                    description: "Test description",
                    power: 2
                )
            }
        }
    }

    func testCombatLogEnumeratedPerformance() {
        // Test that enumerated log (used in ForEach) is fast
        var log: [String] = []
        for i in 0..<1000 {
            log.append("âš”ï¸ Action \(i)")
        }

        measure {
            // This is what ForEach does
            let enumerated = Array(log.suffix(5).enumerated())
            XCTAssertEqual(enumerated.count, 5)

            // Access each element
            for (index, entry) in enumerated {
                XCTAssertNotNil(index)
                XCTAssertFalse(entry.isEmpty)
            }
        }
    }

    // Legacy sync tests removed - Engine-First architecture manages playerHand directly

    // MARK: - Engine Reset Tests

    /// Test that resetGameState clears isGameOver flag
    func testResetGameStateClearsIsGameOver() {
        // Given: Game is over (simulate by setting tension to max)
        // First check that we can trigger game over
        let initialGameOver = engine.isGameOver
        XCTAssertFalse(initialGameOver, "Game should not be over initially")

        // When: resetGameState is called
        engine.resetGameState()

        // Then: isGameOver should be false
        XCTAssertFalse(engine.isGameOver, "isGameOver should be false after reset")
    }

    /// Test that new game creates fresh world state - Engine-First version
    func testNewGameCreatesFreshWorldState() {
        guard requireRegionsLoaded() else { return }
        // Given: A fresh engine after initialization
        let freshEngine = TwilightGameEngine()
        TestContentLoader.loadContentPacksIfNeeded()
        freshEngine.initializeNewGame(playerName: "Test", heroId: nil)

        // Then: It should have initial world tension
        XCTAssertEqual(freshEngine.worldTension, 30, "Fresh engine should have initial tension")

        // And: It should have initial day count
        XCTAssertEqual(freshEngine.currentDay, 0, "Fresh engine should start at day 0")

        // And: It should have regions (when ContentPack loaded)
        XCTAssertFalse(freshEngine.publishedRegions.isEmpty, "Fresh engine should have regions")
    }

    // MARK: - Travel Validation Tests

    /// Test that travel to non-neighbor region is blocked
    func testTravelToNonNeighborIsBlocked() {
        guard let currentRegion = engine.currentRegion else {
            XCTFail("No current region"); return
        }

        // Find a non-neighbor region
        let nonNeighborRegion = engine.regionsArray.first { region in
            region.id != currentRegion.id && !currentRegion.neighborIds.contains(region.id)
        }

        guard let targetRegion = nonNeighborRegion else {
            XCTFail("No non-neighbor region available for testing"); return
        }

        // When: Try to travel to non-neighbor
        let result = engine.performAction(.travel(toRegionId: targetRegion.id))

        // Then: Action should fail
        XCTAssertFalse(result.success, "Travel to non-neighbor should fail")
        XCTAssertNotNil(result.error, "Should have an error for non-neighbor travel")
    }

    /// Test that travel to neighbor region succeeds
    func testTravelToNeighborSucceeds() {
        guard let currentRegion = engine.currentRegion,
              let neighborId = currentRegion.neighborIds.first else {
            XCTFail("No neighbor available for travel test"); return
        }

        let initialDay = engine.currentDay

        // When: Travel to neighbor
        let result = engine.performAction(.travel(toRegionId: neighborId))

        // Then: Action should succeed
        XCTAssertTrue(result.success, "Travel to neighbor should succeed")
        XCTAssertGreaterThan(engine.currentDay, initialDay, "Day should advance after travel")
        XCTAssertEqual(engine.currentRegionId, neighborId, "Current region should change")
    }

    /// Test that travel cost is calculated correctly
    func testTravelCostCalculation() {
        guard let currentRegion = engine.currentRegion,
              let neighborId = currentRegion.neighborIds.first else {
            XCTFail("No neighbor for cost test"); return
        }

        // When: Calculate travel cost to neighbor
        let neighborCost = engine.calculateTravelCost(to: neighborId)

        // Then: Cost should be 1 for neighbor
        XCTAssertEqual(neighborCost, 1, "Travel to neighbor should cost 1 day")

        // Find non-neighbor
        let nonNeighborRegion = engine.regionsArray.first { region in
            region.id != currentRegion.id && !currentRegion.neighborIds.contains(region.id)
        }

        if let nonNeighbor = nonNeighborRegion {
            // When: Calculate travel cost to non-neighbor
            let nonNeighborCost = engine.calculateTravelCost(to: nonNeighbor.id)

            // Then: Cost should be 2 for non-neighbor
            XCTAssertEqual(nonNeighborCost, 2, "Travel to non-neighbor should cost 2 days")
        }
    }
}

// MARK: - Test Helpers

extension GameplayFlowTests {

    /// Helper to create test engine (Engine-First)
    func createTestEngine() -> TwilightGameEngine {
        let testEngine = TwilightGameEngine()
        testEngine.initializeFromContentRegistry(ContentRegistry.shared)
        return testEngine
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/Phase3ContractTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Phase 3 Contract Tests: GameLoop Integration
/// Verifies that all actions go through Engine and state changes are correct
///
/// ÐÐ Ð¥Ð˜Ð¢Ð•ÐšÐ¢Ð£Ð Ð Ð¢Ð•Ð¡Ð¢Ð˜Ð ÐžÐ’ÐÐÐ˜Ð¯ (Audit v1.1 Issue #3):
/// - Ð­Ñ‚Ð¾Ñ‚ Ñ„Ð°Ð¹Ð» ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ñ‚ Ð˜ÐÐ¢Ð•Ð“Ð ÐÐ¦Ð˜ÐžÐÐÐ«Ð• Ñ‚ÐµÑÑ‚Ñ‹ Ð¸Ð³Ñ€Ð¾Ð²Ð¾Ð³Ð¾ Ð¿Ð¾Ñ‚Ð¾ÐºÐ°
/// - Ð’Ð¡Ð• Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ Ñ‚ÐµÑÑ‚Ð¸Ñ€ÑƒÑŽÑ‚ÑÑ Ñ‡ÐµÑ€ÐµÐ· TwilightGameEngine.performAction()
/// - Ð­Ñ‚Ð¾ ÐºÐ°Ð½Ð¾Ð½Ð¸Ñ‡ÐµÑÐºÐ¸Ð¹ ÑÐ¿Ð¾ÑÐ¾Ð± Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ð¸Ð³Ñ€Ð¾Ð²Ð¾Ð¹ Ð»Ð¾Ð³Ð¸ÐºÐ¸
/// - Ð”Ð»Ñ unit-Ñ‚ÐµÑÑ‚Ð¾Ð² Ð¼Ð¾Ð´ÐµÐ»ÐµÐ¹ ÑÐ¼. WorldStateTests, RegionActionsModelTests
/// - Engine Ð¾Ð±ÐµÑÐ¿ÐµÑ‡Ð¸Ð²Ð°ÐµÑ‚: Ð²Ð°Ð»Ð¸Ð´Ð°Ñ†Ð¸ÑŽ, ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð°Ñ†Ð¸ÑŽ legacy, Ð¾Ñ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ð½Ð¸Ðµ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¹
final class Phase3ContractTests: XCTestCase {

    var engine: TwilightGameEngine!

    override func setUp() {
        super.setUp()
        TestContentLoader.loadContentPacksIfNeeded()
        engine = TwilightGameEngine()
        engine.initializeNewGame(playerName: "Test", heroId: nil)
    }

    override func tearDown() {
        engine = nil
        WorldRNG.shared.setSeed(0)
        super.tearDown()
    }

    /// Helper to fail test if regions not loaded
    private func requireRegionsLoaded() -> Bool {
        if engine.publishedRegions.isEmpty {
            XCTFail("Skipping: ContentPack not loaded (regions empty)")
            return false
        }
        return true
    }

    // MARK: - INV-P3-001: All Actions Through Engine

    func testAllActionsReturnActionResult() {
        // Every action should return an ActionResult
        let actions: [TwilightGameAction] = [
            .rest,
            .explore,
            .skipTurn
        ]

        for action in actions {
            let result = engine.performAction(action)
            XCTAssertNotNil(result, "Action \(action) should return result")
        }
    }

    // MARK: - INV-P3-002: Time Advances Only Via Engine

    func testTimeAdvancesOnlyViaEngine() {
        guard requireRegionsLoaded() else { return }
        let initialDay = engine.currentDay

        // Perform action with time cost
        let result = engine.performAction(.rest)

        XCTAssertTrue(result.success, "Rest action should succeed")
        XCTAssertEqual(engine.currentDay, initialDay + 1, "Day should advance by 1")
    }

    // MARK: - INV-P3-003: State Changes Are Tracked

    func testStateChangesAreTracked() {
        guard requireRegionsLoaded() else { return }
        // Perform action that changes state
        let result = engine.performAction(.rest)

        XCTAssertTrue(result.success)
        XCTAssertFalse(result.stateChanges.isEmpty, "Rest should produce state changes")

        // Check for expected changes
        let hasHealthChange = result.stateChanges.contains { change in
            if case .healthChanged = change { return true }
            return false
        }
        XCTAssertTrue(hasHealthChange, "Rest should change health")

        let hasDayChange = result.stateChanges.contains { change in
            if case .dayAdvanced = change { return true }
            return false
        }
        XCTAssertTrue(hasDayChange, "Rest should advance day")
    }

    // MARK: - INV-P3-004: Validation Before Execution

    func testInvalidActionReturnsError() {
        // Try to travel to non-neighbor region
        let farRegionId = UUID()  // Non-existent region
        let result = engine.performAction(.travel(toRegionId: farRegionId))

        XCTAssertFalse(result.success, "Invalid travel should fail")
        XCTAssertNotNil(result.error, "Should have error")
    }

    // MARK: - INV-P3-005: Tension Escalation Through Engine

    func testTensionEscalatesOnDay3() {
        guard requireRegionsLoaded() else { return }
        // Advance to day 3
        _ = engine.performAction(.rest)  // Day 1
        _ = engine.performAction(.rest)  // Day 2

        let tensionBeforeDay3 = engine.worldTension

        _ = engine.performAction(.rest)  // Day 3 - should trigger tension

        // Tension should increase on day 3
        XCTAssertGreaterThan(engine.worldTension, tensionBeforeDay3,
            "Tension should increase on day 3")

        // Verify escalation formula: +3 + (daysPassed / 10)
        let expectedIncrease = 3 + (3 / 10)  // = 3
        XCTAssertEqual(engine.worldTension, tensionBeforeDay3 + expectedIncrease,
            "Escalation should follow formula")
    }

    // Legacy sync tests removed - Engine-First architecture

    // MARK: - INV-P3-007: Rest Heals Player

    func testRestHealsPlayer() {
        guard requireRegionsLoaded() else { return }
        // Damage player first by setting engine health directly
        engine.setPlayerHealth(5)

        let initialHealth = engine.playerHealth
        let result = engine.performAction(.rest)

        XCTAssertTrue(result.success)

        // Health should increase (capped at max)
        XCTAssertGreaterThan(engine.playerHealth, initialHealth,
            "Rest should heal player")
    }

    // MARK: - INV-P3-008: Strengthen Anchor Costs Faith

    func testStrengthenAnchorCostsFaith() {
        // Ensure player has enough faith
        engine.setPlayerFaith(20)

        // Move to region with anchor
        guard let regionWithAnchor = engine.publishedRegions.values.first(where: { $0.anchor != nil }) else {
            XCTFail("No region with anchor found"); return
        }
        engine.setCurrentRegion(regionWithAnchor.id)

        let initialFaith = engine.playerFaith
        let result = engine.performAction(.strengthenAnchor)

        if result.success {
            // Faith should decrease
            XCTAssertLessThan(engine.playerFaith, initialFaith,
                "Strengthening anchor should cost faith")
        }
    }

    // MARK: - INV-P3-009: Game Over On Tension 100

    func testGameOverOnMaxTension() {
        // Set tension near max
        engine.setWorldTension(97)

        // Advance time to trigger tension increase
        _ = engine.performAction(.rest)
        _ = engine.performAction(.rest)
        _ = engine.performAction(.rest)  // Day 3

        // If tension reached 100, game should be over
        if engine.worldTension >= 100 {
            XCTAssertTrue(engine.isGameOver, "Game should be over at tension 100")
            XCTAssertNotNil(engine.gameResult, "Should have game result")

            if case .defeat(let reason) = engine.gameResult {
                XCTAssertTrue(reason.contains("ÐÐ°Ð¿Ñ€ÑÐ¶ÐµÐ½Ð¸Ðµ") || reason.contains("tension"),
                    "Defeat reason should mention tension")
            } else {
                XCTFail("Should be defeat, not victory")
            }
        }
    }

    // MARK: - INV-P3-010: Game Over On Health 0

    func testGameOverOnHealthZero() {
        // Set health to 1
        engine.setPlayerHealth(1)

        // Apply damage through consequences (simulated)
        // For now, manually trigger check
        engine.setPlayerHealth(0)

        // Trigger end condition check
        _ = engine.performAction(.skipTurn)

        XCTAssertTrue(engine.isGameOver || engine.playerHealth <= 0,
            "Game should be over or health should be 0")
    }

    // MARK: - INV-P3-011: Actions Blocked When Game Over

    func testActionsBlockedWhenGameOver() {
        // End the game
        engine.setWorldTension(100)
        _ = engine.performAction(.skipTurn)  // Trigger end check

        // If game is over, actions should fail
        if engine.isGameOver {
            let result = engine.performAction(.rest)
            XCTAssertFalse(result.success, "Actions should fail when game is over")
            XCTAssertEqual(result.error, .gameNotInProgress)
        }
    }

    // MARK: - INV-P3-012: Event Choice Resolution

    func testEventChoiceProducesStateChanges() {
        // This test requires an active event
        // For unit testing, we can test the resolver directly

        let resolver = EventResolver()

        // Create test event with proper EventConsequences structure
        let consequences = EventConsequences(
            faithChange: 3,
            healthChange: -2,
            tensionChange: 1,
            setFlags: ["test_flag": true],
            message: "Test result"
        )

        let choice = EventChoice(
            id: "test_choice",
            text: "Test Choice",
            consequences: consequences
        )

        let event = GameEvent(
            eventType: .exploration,
            title: "Test Event",
            description: "Test description",
            choices: [choice],
            weight: 10
        )

        let context = EventResolutionContext(
            currentHealth: 10,
            currentFaith: 5,
            currentBalance: 50,
            currentTension: 30,
            currentFlags: [:]
        )

        let result = resolver.resolve(event: event, choiceIndex: 0, context: context)

        XCTAssertTrue(result.success)
        XCTAssertFalse(result.stateChanges.isEmpty, "Choice should produce changes")

        // Verify expected changes exist
        let hasHealthChange = result.stateChanges.contains { change in
            if case .healthChanged(let delta, _) = change {
                return delta == -2
            }
            return false
        }
        XCTAssertTrue(hasHealthChange, "Should have health change of -2")

        let hasFaithChange = result.stateChanges.contains { change in
            if case .faithChanged(let delta, _) = change {
                return delta == 3
            }
            return false
        }
        XCTAssertTrue(hasFaithChange, "Should have faith change of +3")
    }

    // MARK: - INV-P3-013: Deterministic With Seed

    func testEngineDeterministicWithSeed() {
        // Run same actions with same seed twice
        WorldRNG.shared.setSeed(42)

        let engine1 = TwilightGameEngine()
        engine1.initializeFromContentRegistry(ContentRegistry.shared)

        // Perform actions
        _ = engine1.performAction(.rest)
        _ = engine1.performAction(.rest)
        _ = engine1.performAction(.rest)

        let finalTension1 = engine1.worldTension
        let finalDay1 = engine1.currentDay

        // Reset and run again
        WorldRNG.shared.setSeed(42)

        let engine2 = TwilightGameEngine()
        engine2.initializeFromContentRegistry(ContentRegistry.shared)

        _ = engine2.performAction(.rest)
        _ = engine2.performAction(.rest)
        _ = engine2.performAction(.rest)

        let finalTension2 = engine2.worldTension
        let finalDay2 = engine2.currentDay

        // Results should be identical
        XCTAssertEqual(finalDay1, finalDay2, "Days should match with same seed")
        XCTAssertEqual(finalTension1, finalTension2, "Tension should match with same seed")
    }
}

// MARK: - Test Helpers

/// Helper to describe TwilightGameAction for test output (avoids extension conformance issues)
private func describeAction(_ action: TwilightGameAction) -> String {
    switch action {
    case .travel(let id): return "travel(\(id))"
    case .rest: return "rest"
    case .explore: return "explore"
    case .trade: return "trade"
    case .strengthenAnchor: return "strengthenAnchor"
    case .chooseEventOption(let e, let c): return "choose(\(e), \(c))"
    case .resolveMiniGame(let r): return "miniGame(\(r))"
    case .startCombat(let id): return "combat(\(id))"
    case .combatInitialize: return "combatInitialize"
    case .combatAttack(let dice, let dmg, let first): return "combatAttack(\(dice), \(dmg), \(first))"
    case .playCard(let c, let t): return "playCard(\(c), \(String(describing: t)))"
    case .combatApplyEffect(let effect): return "combatApplyEffect(\(effect))"
    case .endCombatTurn: return "endCombatTurn"
    case .combatEnemyAttack(let dmg): return "combatEnemyAttack(\(dmg))"
    case .combatEndTurnPhase: return "combatEndTurnPhase"
    case .combatFlee: return "combatFlee"
    case .combatFinish(let victory): return "combatFinish(\(victory))"
    case .dismissCurrentEvent: return "dismissCurrentEvent"
    case .dismissDayEvent: return "dismissDayEvent"
    case .skipTurn: return "skipTurn"
    case .custom(let id, let cost): return "custom(\(id), \(cost))"
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/RegressionPlaythroughTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Regression Playthrough Tests
/// Ensures migration does not change game behavior.
/// These tests use fixed seeds and action sequences to verify determinism.
/// Reference: Docs/MIGRATION_PLAN.md
final class RegressionPlaythroughTests: XCTestCase {

    // MARK: - Test Fixtures

    /// Snapshot of expected game state at checkpoints
    struct GameStateSnapshot: Equatable {
        let pressure: Int
        let time: Int
        let healthRange: ClosedRange<Int>   // Allow small variance
        let faithRange: ClosedRange<Int>
        let visitedRegionsCount: Int
        let flagsSet: Set<String>

        func matches(_ state: ActualGameState, tolerance: Int = 2) -> Bool {
            guard pressure == state.pressure else { return false }
            guard time == state.time else { return false }
            guard healthRange.contains(state.health) else { return false }
            guard faithRange.contains(state.faith) else { return false }
            guard visitedRegionsCount == state.visitedRegionsCount else { return false }
            guard flagsSet.isSubset(of: state.flags) else { return false }
            return true
        }
    }

    struct ActualGameState {
        let pressure: Int
        let time: Int
        let health: Int
        let faith: Int
        let visitedRegionsCount: Int
        let flags: Set<String>
    }

    // MARK: - Determinism Tests

    /// Same seed should produce same event selection
    func testFixedSeedProducesDeterministicEvents() {
        // Given: Fixed seed
        let seed: UInt64 = 42

        // When: Run selection multiple times
        var results: [String] = []
        for _ in 0..<5 {
            let eventId = selectEventWithFixedSeed(seed: seed, poolSize: 10)
            results.append(eventId)
        }

        // Then: All results identical
        let uniqueResults = Set(results)
        XCTAssertEqual(uniqueResults.count, 1, "Same seed should always select same event")
    }

    /// Different actions should produce different outcomes
    func testDifferentActionsProduceDifferentOutcomes() {
        // Given: Two playthroughs with different action sequences
        let actionsA: [TestAction] = [.rest, .rest, .travel("forest")]
        let actionsB: [TestAction] = [.travel("village"), .explore, .rest]

        // When: Simulate both
        let outcomeA = simulatePlaythrough(actions: actionsA, seed: 100)
        let outcomeB = simulatePlaythrough(actions: actionsB, seed: 100)

        // Then: Different final states
        // Note: They might coincidentally match, but likely different
        let areDifferent = outcomeA.time != outcomeB.time ||
                          outcomeA.visitedRegions != outcomeB.visitedRegions
        XCTAssertTrue(areDifferent || actionsA == actionsB,
                      "Different actions should generally produce different outcomes")
    }

    // MARK: - Save/Load Roundtrip

    /// Game state should survive save/load cycle unchanged
    func testSaveLoadRoundtripPreservesState() {
        // Given: Game state
        let originalState = TestGameState(
            pressure: 35,
            time: 12,
            health: 15,
            faith: 8,
            currentRegion: "village",
            visitedRegions: ["forest", "village", "crossroads"],
            flags: ["quest_started": true, "npc_met": true],
            completedEvents: ["event_001", "event_003"]
        )

        // When: Save and load
        let savedData = encodeState(originalState)
        let loadedState = decodeState(savedData)

        // Then: State preserved
        XCTAssertEqual(loadedState.pressure, originalState.pressure)
        XCTAssertEqual(loadedState.time, originalState.time)
        XCTAssertEqual(loadedState.health, originalState.health)
        XCTAssertEqual(loadedState.faith, originalState.faith)
        XCTAssertEqual(loadedState.currentRegion, originalState.currentRegion)
        XCTAssertEqual(loadedState.visitedRegions, originalState.visitedRegions)
        XCTAssertEqual(loadedState.flags, originalState.flags)
        XCTAssertEqual(loadedState.completedEvents, originalState.completedEvents)
    }

    // MARK: - Regression Checkpoints

    /// Standard playthrough should hit expected checkpoints
    /// This test documents expected behavior and catches regressions
    func testStandardPlaythroughReachesCheckpoints() {
        // Given: Standard action sequence (typical early game)
        let standardActions: [TestAction] = [
            .explore,           // Day 1: Explore starting area
            .travel("forest"),  // Day 2: Travel to forest
            .explore,           // Day 3: Explore forest (triggers day threshold)
            .rest,              // Day 4: Rest to recover
            .travel("village"), // Day 5: Travel to village
        ]

        // And: Expected checkpoints (for future snapshot comparison)
        _ = GameStateSnapshot(
            pressure: 0,        // Before first threshold
            time: 2,
            healthRange: 18...20,
            faithRange: 8...12,
            visitedRegionsCount: 1,
            flagsSet: []
        )

        _ = GameStateSnapshot(
            pressure: 5,        // After first threshold (day 3)
            time: 5,
            healthRange: 15...20,
            faithRange: 5...12,
            visitedRegionsCount: 3,
            flagsSet: []
        )

        // When: Run playthrough
        let outcomes = simulateWithCheckpoints(
            actions: standardActions,
            checkpointIndices: [2, 5], // After action 2 and after action 5
            seed: 12345
        )

        // Then: Checkpoints reached (within tolerance)
        // Note: This test may need adjustment as game balance changes
        // The key invariant is: same input â†’ same output
        XCTAssertEqual(outcomes.count, 2, "Should have 2 checkpoints")
    }

    // MARK: - Migration Safety Net

    /// This test captures current behavior for migration comparison
    /// Run before and after migration - results should match
    func testMigrationRegressionHarness() {
        // Given: Canonical test sequence
        let canonicalSeed: UInt64 = 98765
        let canonicalActions: [TestAction] = [
            .explore,
            .travel("forest"),
            .explore,
            .travel("village"),
            .rest,
            .strengthen,
            .travel("crossroads"),
            .explore,
            .rest,
            .travel("forest")
        ]

        // When: Run simulation
        let finalState = simulatePlaythrough(actions: canonicalActions, seed: canonicalSeed)

        // Then: Record/verify known good values
        // These values should be captured once and then verified on each run
        // If migration changes behavior, this test will fail

        // For now, we just verify the simulation completes
        XCTAssertGreaterThan(finalState.time, 0, "Time should advance")
        XCTAssertGreaterThanOrEqual(finalState.visitedRegions.count, 1, "Should have visited regions")

        // TODO: After establishing baseline, add specific assertions:
        // XCTAssertEqual(finalState.pressure, EXPECTED_PRESSURE)
        // XCTAssertEqual(finalState.time, EXPECTED_TIME)
        // XCTAssertEqual(finalState.visitedRegions, EXPECTED_REGIONS)
    }

    // MARK: - Deck State Persistence

    func testDeckStatePersistsAcrossSaveLoad() {
        // Given: Deck state with zones
        let deckState = TestDeckState(
            drawPile: ["card_1", "card_2", "card_3"],
            hand: ["card_4", "card_5"],
            discard: ["card_6"],
            exile: []
        )

        // When: Save and load
        let savedData = encodeDeckState(deckState)
        let loadedDeck = decodeDeckState(savedData)

        // Then: All zones preserved
        XCTAssertEqual(loadedDeck.drawPile, deckState.drawPile)
        XCTAssertEqual(loadedDeck.hand, deckState.hand)
        XCTAssertEqual(loadedDeck.discard, deckState.discard)
        XCTAssertEqual(loadedDeck.exile, deckState.exile)
    }

    // MARK: - Legacy vs Engine Comparison Tests

    /// Compare legacy playthrough to engine playthrough - must produce same results
    /// This is the critical migration safety net
    func testLegacyVsEngineProduceSameOutcome() {
        // Given: Same seed and actions for both
        let seed: UInt64 = 54321
        let actions: [TestAction] = [
            .explore,
            .travel("forest"),
            .rest,
            .explore,
            .travel("village"),
            .strengthen
        ]

        // When: Run both simulations
        let legacyOutcome = runLegacyPlaythrough(seed: seed, actions: actions)
        let engineOutcome = runEnginePlaythrough(seed: seed, actions: actions)

        // Then: Key metrics must match
        XCTAssertEqual(
            legacyOutcome.time,
            engineOutcome.time,
            "Time should match: legacy=\(legacyOutcome.time), engine=\(engineOutcome.time)"
        )
        XCTAssertEqual(
            legacyOutcome.pressure,
            engineOutcome.pressure,
            "Pressure should match: legacy=\(legacyOutcome.pressure), engine=\(engineOutcome.pressure)"
        )
        XCTAssertEqual(
            legacyOutcome.visitedRegions,
            engineOutcome.visitedRegions,
            "Visited regions should match"
        )
    }

    /// Run playthrough using legacy simulation (current Models/*)
    private func runLegacyPlaythrough(seed: UInt64, actions: [TestAction]) -> PlaythroughOutcome {
        // This simulates the current (legacy) game flow
        return simulatePlaythrough(actions: actions, seed: seed)
    }

    /// Run playthrough using new Engine simulation
    private func runEnginePlaythrough(seed: UInt64, actions: [TestAction]) -> PlaythroughOutcome {
        // This simulates the new Engine flow using GameRuntimeState
        var runtime = GameRuntimeState.newGame(
            startingRegionId: "starting_area",
            startingResources: ["health": 20, "faith": 10],
            startingDeck: [],
            seed: seed
        )

        var rng = SeededRNG(seed: seed)

        for action in actions {
            switch action {
            case .rest:
                runtime.world.currentTime += 1
                let currentHealth = runtime.player.getResource("health")
                runtime.player.setResource("health", value: min(20, currentHealth + 3))

            case .explore:
                runtime.world.currentTime += 1
                let eventRoll = Int.random(in: 0..<10, using: &rng)
                if eventRoll < 3 {
                    runtime.player.modifyResource("faith", by: -1)
                }

            case .travel(let destination):
                runtime.world.currentTime += 1
                runtime.world.currentRegionId = destination
                runtime.world.regionsState[destination] = RegionRuntimeState(
                    definitionId: destination,
                    currentState: .stable,
                    visitCount: 1,
                    isDiscovered: true
                )

            case .strengthen:
                runtime.world.currentTime += 1
                runtime.player.modifyResource("faith", by: -2)

            case .choose:
                break
            }

            // Check pressure threshold (same logic as legacy)
            if runtime.world.currentTime > 0 && runtime.world.currentTime % 3 == 0 {
                runtime.world.pressure += 5
            }
        }

        // Build visited regions set
        var visitedRegions = Set<String>(["starting_area"])
        for (regionId, state) in runtime.world.regionsState {
            if state.visitCount > 0 {
                visitedRegions.insert(regionId)
            }
        }

        return PlaythroughOutcome(
            time: runtime.world.currentTime,
            pressure: runtime.world.pressure,
            health: runtime.player.getResource("health"),
            faith: runtime.player.getResource("faith"),
            visitedRegions: visitedRegions,
            completedEvents: runtime.events.completedOneTimeEvents
        )
    }

    /// Test that snapshots can be compared for equality
    func testSnapshotComparison() {
        // Given: Two game states with same values
        let state1 = GameRuntimeState.newGame(
            startingRegionId: "forest",
            startingResources: ["health": 20, "faith": 10],
            startingDeck: ["c1", "c2"],
            seed: 100
        )

        let state2 = GameRuntimeState.newGame(
            startingRegionId: "forest",
            startingResources: ["health": 20, "faith": 10],
            startingDeck: ["c1", "c2"],
            seed: 100
        )

        // When: Take snapshots
        let snapshot1 = state1.snapshot()
        let snapshot2 = state2.snapshot()

        // Then: Snapshots equal
        XCTAssertEqual(snapshot1, snapshot2)
    }

    /// Test that different states produce different snapshots
    func testSnapshotDetectsDifferences() {
        // Given: Two different game states
        var state1 = GameRuntimeState.newGame(
            startingRegionId: "forest",
            startingResources: ["health": 20, "faith": 10],
            startingDeck: [],
            seed: 100
        )
        state1.world.pressure = 50

        var state2 = GameRuntimeState.newGame(
            startingRegionId: "forest",
            startingResources: ["health": 20, "faith": 10],
            startingDeck: [],
            seed: 100
        )
        state2.world.pressure = 0

        // When: Take snapshots
        let snapshot1 = state1.snapshot()
        let snapshot2 = state2.snapshot()

        // Then: Snapshots different
        XCTAssertNotEqual(snapshot1, snapshot2)
        XCTAssertNotEqual(snapshot1.pressure, snapshot2.pressure)
    }
}

// MARK: - Test Types

enum TestAction: Equatable {
    case rest
    case explore
    case travel(String)
    case strengthen
    case choose(eventId: String, choiceId: String)
}

struct TestGameState: Codable, Equatable {
    var pressure: Int
    var time: Int
    var health: Int
    var faith: Int
    var currentRegion: String
    var visitedRegions: Set<String>
    var flags: [String: Bool]
    var completedEvents: Set<String>
}

struct TestDeckState: Codable, Equatable {
    var drawPile: [String]
    var hand: [String]
    var discard: [String]
    var exile: [String]
}

struct PlaythroughOutcome {
    let time: Int
    let pressure: Int
    let health: Int
    let faith: Int
    let visitedRegions: Set<String>
    let completedEvents: Set<String>
}

// MARK: - Simulation Helpers

func selectEventWithFixedSeed(seed: UInt64, poolSize: Int) -> String {
    var rng = SeededRNG(seed: seed)
    let index = Int.random(in: 0..<poolSize, using: &rng)
    return "event_\(index)"
}

func simulatePlaythrough(actions: [TestAction], seed: UInt64) -> PlaythroughOutcome {
    var state = TestGameState(
        pressure: 0,
        time: 0,
        health: 20,
        faith: 10,
        currentRegion: "starting_area",
        visitedRegions: ["starting_area"],
        flags: [:],
        completedEvents: []
    )

    var rng = SeededRNG(seed: seed)

    for action in actions {
        switch action {
        case .rest:
            state.time += 1
            state.health = min(20, state.health + 3)

        case .explore:
            state.time += 1
            // Random event might affect resources
            let eventRoll = Int.random(in: 0..<10, using: &rng)
            if eventRoll < 3 {
                state.faith -= 1
            }

        case .travel(let destination):
            state.time += 1
            state.currentRegion = destination
            state.visitedRegions.insert(destination)

        case .strengthen:
            state.time += 1
            state.faith -= 2

        case .choose:
            // Choice resolution would go here
            break
        }

        // Check pressure threshold
        if state.time > 0 && state.time % 3 == 0 {
            state.pressure += 5
        }
    }

    return PlaythroughOutcome(
        time: state.time,
        pressure: state.pressure,
        health: state.health,
        faith: state.faith,
        visitedRegions: state.visitedRegions,
        completedEvents: state.completedEvents
    )
}

func simulateWithCheckpoints(
    actions: [TestAction],
    checkpointIndices: [Int],
    seed: UInt64
) -> [PlaythroughOutcome] {
    var results: [PlaythroughOutcome] = []
    var currentActions: [TestAction] = []

    for (index, action) in actions.enumerated() {
        currentActions.append(action)

        if checkpointIndices.contains(index + 1) {
            let outcome = simulatePlaythrough(actions: currentActions, seed: seed)
            results.append(outcome)
        }
    }

    return results
}

func encodeState(_ state: TestGameState) -> Data {
    return try! JSONEncoder().encode(state)
}

func decodeState(_ data: Data) -> TestGameState {
    return try! JSONDecoder().decode(TestGameState.self, from: data)
}

func encodeDeckState(_ state: TestDeckState) -> Data {
    return try! JSONEncoder().encode(state)
}

func decodeDeckState(_ data: Data) -> TestDeckState {
    return try! JSONDecoder().decode(TestDeckState.self, from: data)
}

struct SeededRNG: RandomNumberGenerator {
    var state: UInt64

    init(seed: UInt64) {
        self.state = seed
    }

    mutating func next() -> UInt64 {
        state = state &* 6364136223846793005 &+ 1442695040888963407
        return state
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/TimeSystemTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Time System Invariant Tests
/// Ensures the time system follows critical rules:
/// - Each day must be processed individually (no skipping)
/// - Time cannot be rolled back
/// - Escalation happens at correct intervals
final class TimeSystemTests: XCTestCase {

    var engine: TwilightGameEngine!

    override func setUp() {
        super.setUp()
        engine = TwilightGameEngine()
        // Initialize with minimal setup
        TestContentLoader.loadContentPacksIfNeeded()
        engine.initializeNewGame(playerName: "Test", heroId: nil)
    }

    override func tearDown() {
        engine = nil
        super.tearDown()
    }

    // MARK: - Day Processing Invariants

    /// INVARIANT: Each day must be processed individually, not skipped
    /// When advancing multiple days, tension should increase for EACH eligible day
    func testEachDayProcessedIndividually() {
        // Given: Engine at day 0 with initial tension
        let initialDay = engine.currentDay
        let initialTension = engine.worldTension

        // When: Advance by 9 days (should trigger 3 tension ticks at days 3, 6, 9)
        // Using performAction to simulate real gameplay
        for _ in 0..<9 {
            // Rest action costs 1 day
            _ = engine.performAction(.rest)
        }

        // Then: Should be at day 9
        XCTAssertEqual(engine.currentDay, initialDay + 9, "Should have advanced 9 days")

        // And: Tension should have increased 3 times (at days 3, 6, 9)
        // Each tick increases tension by at least 3 (base amount)
        XCTAssertGreaterThanOrEqual(
            engine.worldTension,
            initialTension + 9, // 3 ticks * 3 base minimum
            "Tension should increase at each interval"
        )
    }

    /// INVARIANT: Time cannot be rolled back
    /// currentDay should only increase, never decrease
    func testTimeCannotBeRolledBack() {
        // Given: Engine at some day
        let dayBeforeAction = engine.currentDay

        // When: Perform any action
        _ = engine.performAction(.rest)

        // Then: Day should not have decreased
        XCTAssertGreaterThanOrEqual(
            engine.currentDay,
            dayBeforeAction,
            "Time should never go backwards"
        )
    }

    /// INVARIANT: No day can be skipped when advancing time
    /// If we go from day 1 to day 10, days 2-9 must all be processed
    func testNoDaySkipping() {
        // This test verifies the implementation correctness
        // by checking that tension ticks happen at the expected intervals

        // Given: Engine at day 0
        XCTAssertEqual(engine.currentDay, 0, "Should start at day 0")

        // Record tension before starting
        let tensionAtDay0 = engine.worldTension

        // Advance to day 3 (first tension tick)
        for _ in 0..<3 {
            _ = engine.performAction(.rest)
        }
        let tensionAtDay3 = engine.worldTension
        XCTAssertGreaterThan(tensionAtDay3, tensionAtDay0, "Tension should increase at day 3")

        // Advance to day 6 (second tension tick)
        for _ in 0..<3 {
            _ = engine.performAction(.rest)
        }
        let tensionAtDay6 = engine.worldTension
        XCTAssertGreaterThan(tensionAtDay6, tensionAtDay3, "Tension should increase at day 6")

        // Advance to day 9 (third tension tick)
        for _ in 0..<3 {
            _ = engine.performAction(.rest)
        }
        let tensionAtDay9 = engine.worldTension
        XCTAssertGreaterThan(tensionAtDay9, tensionAtDay6, "Tension should increase at day 9")
    }

    // MARK: - Escalation Invariants

    /// INVARIANT: Escalation must increase with time
    /// The tension increase per tick should grow as days progress
    func testEscalationIncreasesWithTime() {
        // The formula is: base + (daysPassed / 10)
        // Day 1-9: +3
        // Day 10-19: +4
        // Day 20-29: +5

        let earlyIncrease = TwilightPressureRules.calculateTensionIncrease(daysPassed: 5)
        let midIncrease = TwilightPressureRules.calculateTensionIncrease(daysPassed: 15)
        let lateIncrease = TwilightPressureRules.calculateTensionIncrease(daysPassed: 25)

        XCTAssertEqual(earlyIncrease, 3, "Early game (day 5): base tension increase")
        XCTAssertEqual(midIncrease, 4, "Mid game (day 15): +1 escalation")
        XCTAssertEqual(lateIncrease, 5, "Late game (day 25): +2 escalation")

        XCTAssertLessThan(earlyIncrease, midIncrease, "Tension increase should grow over time")
        XCTAssertLessThan(midIncrease, lateIncrease, "Tension increase should continue growing")
    }

    /// INVARIANT: Tension tick interval is respected
    /// Tension should only increase every N days (default 3)
    func testTensionTickIntervalRespected() {
        // Record initial tension
        let initialTension = engine.worldTension

        // Day 1: No tick
        _ = engine.performAction(.rest)
        XCTAssertEqual(engine.worldTension, initialTension, "No tension increase on day 1")

        // Day 2: No tick
        _ = engine.performAction(.rest)
        XCTAssertEqual(engine.worldTension, initialTension, "No tension increase on day 2")

        // Day 3: Tick!
        _ = engine.performAction(.rest)
        XCTAssertGreaterThan(engine.worldTension, initialTension, "Tension should increase on day 3")
    }

    // MARK: - Free Action Invariants

    /// INVARIANT: Most actions cost time (no free actions except instant ones)
    func testMostActionsCostTime() {
        let dayBefore = engine.currentDay

        // Rest should cost time
        _ = engine.performAction(.rest)
        XCTAssertGreaterThan(engine.currentDay, dayBefore, "Rest should advance time")
    }

    // MARK: - State Consistency

    /// INVARIANT: Engine state remains consistent after time advancement
    func testStateConsistencyAfterTimeAdvancement() {
        // Advance several days
        for _ in 0..<10 {
            _ = engine.performAction(.rest)
        }

        // State should be consistent
        XCTAssertGreaterThanOrEqual(engine.playerHealth, 0, "Health should not be negative")
        XCTAssertGreaterThanOrEqual(engine.playerFaith, 0, "Faith should not be negative")
        XCTAssertGreaterThanOrEqual(engine.worldTension, 0, "Tension should not be negative")
        XCTAssertLessThanOrEqual(engine.worldTension, 100, "Tension should not exceed 100")
    }

    // MARK: - Regression Tests

    /// Regression test: Ensure advancing by N days doesn't skip day processing
    /// This guards against the bug: `daysPassed += N` instead of proper iteration
    func testAdvanceMultipleDaysProcessesEach() {
        // Setup: Start at day 0, tension tick every 3 days
        let initialTension = engine.worldTension

        // If we advance by 6 days, we should see exactly 2 tension ticks
        // (at day 3 and day 6)

        // Simulate advancing 6 days
        for _ in 0..<6 {
            _ = engine.performAction(.rest)
        }

        // We should be at day 6
        XCTAssertEqual(engine.currentDay, 6)

        // Tension should have increased twice
        // Minimum increase: 2 * 3 (base) = 6
        XCTAssertGreaterThanOrEqual(
            engine.worldTension - initialTension,
            6,
            "Two tension ticks should have occurred"
        )
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/Helpers/TestContentLoader.swift
// ==========================================

import Foundation
@testable import TwilightEngine

/// Helper Ð´Ð»Ñ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸ ContentPacks Ð² Ñ‚ÐµÑÑ‚Ð¾Ð²Ð¾Ð¼ Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ð¸ Ð¿Ð°ÐºÐµÑ‚Ð° TwilightEngine
/// Ð—Ð°Ð³Ñ€ÑƒÐ¶Ð°ÐµÑ‚ Ð¿Ð°ÐºÐ¸ Ð¸Ð· Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸Ð¸ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð° (CoreHeroes + TwilightMarchesActI)
enum TestContentLoader {

    /// Ð¤Ð»Ð°Ð³, Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÑŽÑ‰Ð¸Ð¹ Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ñ‹ Ð»Ð¸ Ð¿Ð°ÐºÐ¸
    private(set) static var isLoaded = false

    /// Ð—Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ ContentPacks Ð¸Ð· Ð¸ÑÑ…Ð¾Ð´Ð½Ð¾Ð¹ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸Ð¸
    /// Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ Ð²Ñ‹Ð·Ñ‹Ð²Ð°Ñ‚ÑŒ Ð¼Ð½Ð¾Ð³Ð¾ÐºÑ€Ð°Ñ‚Ð½Ð¾ - Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° Ð¿Ñ€Ð¾Ð¸Ð·Ð¾Ð¹Ð´Ñ‘Ñ‚ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¾Ð´Ð¸Ð½ Ñ€Ð°Ð·
    static func loadContentPacksIfNeeded() {
        let registry = ContentRegistry.shared

        // Always check actual registry state, not just isLoaded flag.
        // Other test classes may call resetForTesting() which clears the registry.
        guard registry.loadedPackIds.isEmpty else {
            isLoaded = true
            return
        }

        let packURLs = findContentPacksURLs()

        guard !packURLs.isEmpty else {
            print("âš ï¸ TestContentLoader: ContentPacks not found")
            return
        }

        do {
            try registry.loadPacks(from: packURLs)
            print("âœ… TestContentLoader: Loaded \(packURLs.count) packs")
            isLoaded = true
        } catch {
            print("âŒ TestContentLoader: Failed to load packs: \(error)")
        }
    }

    /// ÐÐ°Ð¹Ñ‚Ð¸ Ð¿ÑƒÑ‚Ð¸ Ðº ContentPacks
    private static func findContentPacksURLs() -> [URL] {
        // ÐŸÑƒÑ‚ÑŒ Ð¾Ñ‚ Ñ„Ð°Ð¹Ð»Ð° Ñ‚ÐµÑÑ‚Ð° Ðº ÐºÐ¾Ñ€Ð½ÑŽ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð°:
        // TwilightEngineTests/Helpers/TestContentLoader.swift
        //   â†’ TwilightEngineTests
        //   â†’ Tests
        //   â†’ TwilightEngine
        //   â†’ Packages
        //   â†’ ProjectRoot
        let testFilePath = URL(fileURLWithPath: #filePath)
        let projectRoot = testFilePath
            .deletingLastPathComponent()  // Helpers
            .deletingLastPathComponent()  // TwilightEngineTests
            .deletingLastPathComponent()  // Tests
            .deletingLastPathComponent()  // TwilightEngine
            .deletingLastPathComponent()  // Packages
            .deletingLastPathComponent()  // Project root

        var urls: [URL] = []

        // Character pack (CoreHeroes) â€” must point to .pack file, not directory
        let coreHeroesPath = projectRoot
            .appendingPathComponent("Packages")
            .appendingPathComponent("CharacterPacks")
            .appendingPathComponent("CoreHeroes")
            .appendingPathComponent("Sources")
            .appendingPathComponent("CoreHeroesContent")
            .appendingPathComponent("Resources")
            .appendingPathComponent("CoreHeroes.pack")

        if FileManager.default.fileExists(atPath: coreHeroesPath.path) {
            urls.append(coreHeroesPath)
        }

        // Story pack (TwilightMarchesActI) â€” must point to .pack file, not directory
        let storyPackPath = projectRoot
            .appendingPathComponent("Packages")
            .appendingPathComponent("StoryPacks")
            .appendingPathComponent("Season1")
            .appendingPathComponent("TwilightMarchesActI")
            .appendingPathComponent("Sources")
            .appendingPathComponent("TwilightMarchesActIContent")
            .appendingPathComponent("Resources")
            .appendingPathComponent("TwilightMarchesActI.pack")

        if FileManager.default.fileExists(atPath: storyPackPath.path) {
            urls.append(storyPackPath)
        }

        if urls.isEmpty {
            print("âŒ TestContentLoader: ContentPacks not found")
        }

        return urls
    }

    /// Ð¡Ð±Ñ€Ð¾ÑÐ¸Ñ‚ÑŒ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ (Ð´Ð»Ñ Ð¸Ð·Ð¾Ð»Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ñ… Ñ‚ÐµÑÑ‚Ð¾Ð²)
    static func reset() {
        ContentRegistry.shared.unloadAllPacks()
        CardRegistry.shared.clear()
        AbilityRegistry.shared.clear()
        isLoaded = false
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Core/EconomyManager.swift
// ==========================================

import Foundation

// MARK: - Economy Manager Implementation
// Handles all resource transactions in a consistent way.

/// Default implementation of EconomyManagerProtocol
public final class EconomyManager: EconomyManagerProtocol {
    // MARK: - Properties

    /// Track transaction history for debugging/analytics
    private var transactionHistory: [TransactionRecord] = []

    /// Maximum history size
    private let maxHistorySize: Int

    // MARK: - Initialization

    public init(maxHistorySize: Int = 100) {
        self.maxHistorySize = maxHistorySize
    }

    // MARK: - EconomyManagerProtocol

    /// Check if a transaction can be afforded
    public func canAfford(_ transaction: Transaction, resources: [String: Int]) -> Bool {
        for (resource, cost) in transaction.costs {
            let available = resources[resource] ?? 0
            if available < cost {
                return false
            }
        }
        return true
    }

    /// Process a transaction, modifying resources
    /// Returns true if successful, false if cannot afford
    public func process(_ transaction: Transaction, resources: inout [String: Int]) -> Bool {
        // First check if affordable
        guard canAfford(transaction, resources: resources) else {
            return false
        }

        // Apply costs
        for (resource, cost) in transaction.costs {
            let current = resources[resource] ?? 0
            resources[resource] = current - cost
        }

        // Apply gains
        for (resource, gain) in transaction.gains {
            let current = resources[resource] ?? 0
            resources[resource] = current + gain
        }

        // Record transaction
        recordTransaction(transaction, success: true)

        return true
    }

    // MARK: - Extended Methods

    /// Process transaction with caps (e.g., max health)
    public func processWithCaps(
        _ transaction: Transaction,
        resources: inout [String: Int],
        caps: [String: Int]
    ) -> Bool {
        guard process(transaction, resources: &resources) else {
            return false
        }

        // Apply caps
        for (resource, maxValue) in caps {
            if let current = resources[resource], current > maxValue {
                resources[resource] = maxValue
            }
        }

        return true
    }

    /// Preview transaction result without applying
    public func preview(
        _ transaction: Transaction,
        resources: [String: Int]
    ) -> [String: Int]? {
        guard canAfford(transaction, resources: resources) else {
            return nil
        }

        var result = resources

        // Apply costs
        for (resource, cost) in transaction.costs {
            let current = result[resource] ?? 0
            result[resource] = current - cost
        }

        // Apply gains
        for (resource, gain) in transaction.gains {
            let current = result[resource] ?? 0
            result[resource] = current + gain
        }

        return result
    }

    /// Calculate net change from a transaction
    public func netChange(_ transaction: Transaction) -> [String: Int] {
        var net: [String: Int] = [:]

        for (resource, cost) in transaction.costs {
            net[resource] = (net[resource] ?? 0) - cost
        }

        for (resource, gain) in transaction.gains {
            net[resource] = (net[resource] ?? 0) + gain
        }

        return net
    }

    // MARK: - History

    private func recordTransaction(_ transaction: Transaction, success: Bool) {
        let record = TransactionRecord(
            transaction: transaction,
            timestamp: Date(),
            success: success
        )

        transactionHistory.append(record)

        // Trim history if needed
        if transactionHistory.count > maxHistorySize {
            transactionHistory.removeFirst(transactionHistory.count - maxHistorySize)
        }
    }

    /// Get recent transaction history
    public func getHistory(limit: Int = 10) -> [TransactionRecord] {
        return Array(transactionHistory.suffix(limit))
    }

    /// Clear history
    public func clearHistory() {
        transactionHistory.removeAll()
    }
}

// MARK: - Transaction Record

/// Record of a processed transaction
public struct TransactionRecord {
    public let transaction: Transaction
    public let timestamp: Date
    public let success: Bool
}

// MARK: - Transaction Extensions

extension Transaction {
    /// Create a simple cost-only transaction
    public static func cost(_ resource: String, amount: Int, description: String = "") -> Transaction {
        Transaction(costs: [resource: amount], description: description)
    }

    /// Create a simple gain-only transaction
    public static func gain(_ resource: String, amount: Int, description: String = "") -> Transaction {
        Transaction(gains: [resource: amount], description: description)
    }

    /// Create a trade transaction (exchange one resource for another)
    public static func trade(
        spend resource1: String,
        amount1: Int,
        gain resource2: String,
        amount2: Int,
        description: String = ""
    ) -> Transaction {
        Transaction(
            costs: [resource1: amount1],
            gains: [resource2: amount2],
            description: description
        )
    }

    /// Combine two transactions
    public func combined(with other: Transaction) -> Transaction {
        var newCosts = self.costs
        var newGains = self.gains

        for (resource, cost) in other.costs {
            newCosts[resource] = (newCosts[resource] ?? 0) + cost
        }

        for (resource, gain) in other.gains {
            newGains[resource] = (newGains[resource] ?? 0) + gain
        }

        return Transaction(
            costs: newCosts,
            gains: newGains,
            description: "\(self.description); \(other.description)"
        )
    }
}

// MARK: - Standard Resource Types

/// Common resource identifiers (games can define their own)
public enum StandardResource: String {
    case health
    case maxHealth
    case energy
    case faith
    case gold
    case experience
    case reputation

    public var id: String { rawValue }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Core/EngineProtocols.swift
// ==========================================

import Foundation

// MARK: - Game Engine v1.0 Core Protocols
// Setting-agnostic contracts for the game engine.
// The engine is the "processor", the game content is the "cartridge".

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARK: - 1. Time System
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Delegate for time progression events
public protocol TimeSystemDelegate: AnyObject {
    /// Called when time advances by one tick
    func onTimeTick(currentTime: Int, delta: Int)

    /// Called when a time threshold is crossed (e.g., every 3 days)
    func onTimeThreshold(currentTime: Int, threshold: Int)
}

/// Contract for time-consuming actions
public protocol TimedAction {
    /// Cost in time units (0 = instant)
    var timeCost: Int { get }
}

/// Time engine protocol - manages game time progression
public protocol TimeEngineProtocol {
    var currentTime: Int { get }
    var delegate: TimeSystemDelegate? { get set }

    /// Advance time by a cost. Invariant: cost > 0 (except instant actions)
    func advance(cost: Int)

    /// Check if a threshold interval has been reached
    func checkThreshold(_ interval: Int) -> Bool
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARK: - 2. Pressure System
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Defines the rules for pressure/tension escalation
public protocol PressureRuleSet {
    var maxPressure: Int { get }
    var initialPressure: Int { get }

    /// Calculate pressure increase based on current state
    func calculateEscalation(currentPressure: Int, currentTime: Int) -> Int

    /// Check what effects trigger at current pressure level
    func checkThresholds(pressure: Int) -> [WorldEffect]

    /// Interval (in time units) for automatic pressure increase
    var escalationInterval: Int { get }

    /// Amount of pressure added per interval
    var escalationAmount: Int { get }
}

/// Effects that can be applied to the world
public enum WorldEffect: Equatable {
    case regionDegradation(probability: Double)
    case globalEvent(eventId: String)
    case phaseChange(newPhase: String)
    case anchorWeakening(amount: Int)
    case custom(id: String, parameters: [String: Any])

    public static func == (lhs: WorldEffect, rhs: WorldEffect) -> Bool {
        switch (lhs, rhs) {
        case (.regionDegradation(let p1), .regionDegradation(let p2)):
            return p1 == p2
        case (.globalEvent(let e1), .globalEvent(let e2)):
            return e1 == e2
        case (.phaseChange(let ph1), .phaseChange(let ph2)):
            return ph1 == ph2
        case (.anchorWeakening(let a1), .anchorWeakening(let a2)):
            return a1 == a2
        case (.custom(let id1, _), .custom(let id2, _)):
            return id1 == id2
        default:
            return false
        }
    }
}

/// Pressure engine protocol
public protocol PressureEngineProtocol {
    var currentPressure: Int { get }
    var rules: PressureRuleSet { get }

    /// Escalate pressure based on rules
    func escalate(at currentTime: Int)

    /// Manually adjust pressure
    func adjust(by delta: Int)

    /// Get current threshold effects
    func currentEffects() -> [WorldEffect]
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARK: - 3. Event System
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Abstract event definition protocol (setting-agnostic)
/// Concrete implementation: Engine/Data/Definitions/EventDefinition.swift
public protocol EventDefinitionProtocol {
    associatedtype ChoiceType: ChoiceDefinitionProtocol

    var id: String { get }
    var title: String { get }
    var description: String { get }
    var choices: [ChoiceType] { get }

    /// Whether this event consumes time
    var isInstant: Bool { get }

    /// Whether this event can only occur once
    var isOneTime: Bool { get }

    /// Check if event can occur given current context
    func canOccur(in context: EventContext) -> Bool
}

/// Abstract choice definition protocol
/// Concrete implementation: Engine/Data/Definitions/EventDefinition.swift (ChoiceDefinition struct)
public protocol ChoiceDefinitionProtocol {
    associatedtype RequirementsType: RequirementsDefinitionProtocol
    associatedtype ConsequencesType: ConsequencesDefinitionProtocol

    var id: String { get }
    var text: String { get }
    var requirements: RequirementsType? { get }
    var consequences: ConsequencesType { get }
}

/// Abstract requirements protocol (gating conditions)
public protocol RequirementsDefinitionProtocol {
    func canMeet(with resources: ResourceProvider) -> Bool
}

/// Abstract consequences protocol (outcomes)
public protocol ConsequencesDefinitionProtocol {
    /// Resource changes (positive or negative)
    var resourceChanges: [String: Int] { get }

    /// Flags to set
    var flagsToSet: [String: Bool] { get }

    /// Custom effects
    var customEffects: [String] { get }
}

/// Context for event evaluation
public struct EventContext {
    public let currentLocation: String
    public let locationState: String
    public let pressure: Int
    public let flags: [String: Bool]
    public let resources: [String: Int]
    public let completedEvents: Set<String>

    public init(
        currentLocation: String,
        locationState: String,
        pressure: Int,
        flags: [String: Bool],
        resources: [String: Int],
        completedEvents: Set<String>
    ) {
        self.currentLocation = currentLocation
        self.locationState = locationState
        self.pressure = pressure
        self.flags = flags
        self.resources = resources
        self.completedEvents = completedEvents
    }
}

/// Provider for checking resources
public protocol ResourceProvider {
    func getValue(for resource: String) -> Int
    func hasFlag(_ flag: String) -> Bool
}

/// Event system protocol
public protocol EventSystemProtocol {
    associatedtype Event: EventDefinitionProtocol

    /// Get available events for current context
    func getAvailableEvents(in context: EventContext) -> [Event]

    /// Mark event as completed
    func markCompleted(eventId: String)

    /// Check if event was completed
    func isCompleted(eventId: String) -> Bool
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARK: - 4. Resolution System (Conflicts)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Types of challenges/conflicts
public enum ChallengeType: String, Codable {
    case combat
    case skillCheck
    case socialEncounter
    case puzzle
    case tradeOff
    case sacrifice
}

/// Abstract challenge definition
public protocol ChallengeDefinition {
    var type: ChallengeType { get }
    var difficulty: Int { get }
    var context: Any? { get }
}

/// Result of challenge resolution
public enum ResolutionResult<Reward, Penalty> {
    case success(Reward)
    case failure(Penalty)
    case partial(reward: Reward, penalty: Penalty)
    case cancelled
}

/// Conflict resolver protocol - pluggable resolution mechanics
public protocol ConflictResolverProtocol {
    associatedtype Challenge: ChallengeDefinition
    associatedtype Actor
    associatedtype Reward
    associatedtype Penalty

    /// Resolve a challenge. Can be async for animations/UI.
    func resolve(
        challenge: Challenge,
        actor: Actor
    ) async -> ResolutionResult<Reward, Penalty>
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARK: - 5. Progression System
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Player path/alignment tracking
public protocol ProgressionPathProtocol {
    associatedtype PathType

    var currentPath: PathType { get }
    var pathValue: Int { get }

    /// Shift path by delta
    func shift(by delta: Int)

    /// Get unlocked capabilities for current path
    func unlockedCapabilities() -> [String]

    /// Get locked options for current path
    func lockedOptions() -> [String]
}

/// Progression tracker
public protocol ProgressionTrackerProtocol {
    /// Track capability unlock
    func unlock(capability: String)

    /// Track capability lock (path trade-off)
    func lock(capability: String)

    /// Check if capability is available
    func isUnlocked(_ capability: String) -> Bool
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARK: - 6. Victory/Defeat System
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// End condition types
public enum EndConditionType: String, Codable {
    case objectiveBased    // Complete specific goals
    case pressureBased     // Pressure reaches threshold
    case resourceBased     // Resource hits 0 or max
    case pathBased         // Player path determines ending
    case timeBased         // Time limit reached
}

/// End condition definition
public protocol EndConditionDefinition {
    var type: EndConditionType { get }
    var id: String { get }
    var isVictory: Bool { get }

    /// Check if condition is met
    func isMet(pressure: Int, resources: [String: Int], flags: [String: Bool], time: Int) -> Bool
}

/// Victory/Defeat checker protocol
public protocol EndGameCheckerProtocol {
    associatedtype Condition: EndConditionDefinition

    var conditions: [Condition] { get }

    /// Check all conditions, return first met (or nil)
    func checkConditions(
        pressure: Int,
        resources: [String: Int],
        flags: [String: Bool],
        time: Int
    ) -> Condition?
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARK: - 7. Economy System
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Transaction for resource changes
public struct Transaction {
    let costs: [String: Int]
    let gains: [String: Int]
    let description: String

    init(costs: [String: Int] = [:], gains: [String: Int] = [:], description: String = "") {
        self.costs = costs
        self.gains = gains
        self.description = description
    }
}

/// Economy manager protocol
public protocol EconomyManagerProtocol {
    /// Check if transaction is affordable
    func canAfford(_ transaction: Transaction, resources: [String: Int]) -> Bool

    /// Process transaction, returns new resource values
    func process(_ transaction: Transaction, resources: inout [String: Int]) -> Bool
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARK: - 8. World State System
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Location state (abstract)
public protocol LocationStateProtocol {
    var id: String { get }
    var name: String { get }
    var currentState: String { get }

    /// Can player rest here?
    var canRest: Bool { get }

    /// Can player trade here?
    var canTrade: Bool { get }

    /// Neighbor location IDs
    var neighborIds: [String] { get }
}

/// World state manager protocol
public protocol WorldStateManagerProtocol {
    associatedtype Location: LocationStateProtocol

    var locations: [Location] { get }
    var currentLocationId: String? { get }
    var flags: [String: Bool] { get }

    /// Move to location
    func moveTo(locationId: String) -> Int // Returns time cost

    /// Set flag
    func setFlag(_ flag: String, value: Bool)

    /// Get flag
    func hasFlag(_ flag: String) -> Bool

    /// Degrade location
    func degradeLocation(_ locationId: String)

    /// Improve location
    func improveLocation(_ locationId: String)
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARK: - 9. Quest System
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Quest objective
public protocol QuestObjectiveProtocol {
    var id: String { get }
    var description: String { get }
    var isCompleted: Bool { get }

    /// Check if objective is complete based on flags
    func checkCompletion(flags: [String: Bool]) -> Bool
}

/// Quest definition
public protocol QuestDefinitionProtocol {
    associatedtype Objective: QuestObjectiveProtocol

    var id: String { get }
    var title: String { get }
    var isMain: Bool { get }
    var objectives: [Objective] { get }
    var isCompleted: Bool { get }

    /// Rewards on completion
    var rewardTransaction: Transaction { get }
}

/// Quest manager protocol
public protocol QuestManagerProtocol {
    associatedtype Quest: QuestDefinitionProtocol

    var activeQuests: [Quest] { get }
    var completedQuests: [String] { get }

    /// Check quest progress based on flags
    func checkProgress(flags: [String: Bool])

    /// Complete a quest
    func completeQuest(_ questId: String) -> Transaction?
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARK: - 10. Core Engine Protocol
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Main game engine orchestrator protocol
public protocol GameEngineProtocol {
    associatedtype PlayerState
    associatedtype WorldManager: WorldStateManagerProtocol
    associatedtype EventSystem: EventSystemProtocol
    associatedtype Resolver: ConflictResolverProtocol
    associatedtype QuestManager: QuestManagerProtocol
    associatedtype EndChecker: EndGameCheckerProtocol

    // Subsystems
    var timeEngine: any TimeEngineProtocol { get }
    var pressureEngine: any PressureEngineProtocol { get }
    var worldManager: WorldManager { get }
    var eventSystem: EventSystem { get }
    var resolver: Resolver { get }
    var questManager: QuestManager { get }
    var endChecker: EndChecker { get }
    var economyManager: any EconomyManagerProtocol { get }

    // State
    var playerState: PlayerState { get }
    var isGameOver: Bool { get }
    var isVictory: Bool { get }

    // Core Loop
    func performAction(_ action: any TimedAction) async
    func worldTick()
    func checkEndConditions()
    func save()
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Core/EngineSave.swift
// ==========================================

import Foundation

// MARK: - Engine Save Structure
// Ð¡ÐµÑ€Ð¸Ð°Ð»Ð¸Ð·ÑƒÐµÐ¼Ð¾Ðµ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ Ð´Ð»Ñ save/load (Engine-First Architecture)

/// Full game state for saving
/// Engine saves/loads via this struct, not through WorldState
public struct EngineSave: Codable {
    // MARK: - Metadata
    public let version: Int
    public let savedAt: Date
    public let gameDuration: TimeInterval

    // MARK: - Pack Compatibility (Audit 2.0 Requirement)
    /// Core engine version for compatibility checking
    public let coreVersion: String
    /// Active pack set with versions (packId -> version string)
    public let activePackSet: [String: String]
    /// Save format version for migration
    public let formatVersion: Int
    /// Primary campaign pack ID (the main pack that defines the campaign)
    public let primaryCampaignPackId: String?

    // MARK: - Player State
    public let playerName: String
    public let heroId: String?  // Hero definition ID for data-driven hero system
    public let playerHealth: Int
    public let playerMaxHealth: Int
    public let playerFaith: Int
    public let playerMaxFaith: Int
    public let playerBalance: Int

    // MARK: - Deck State (String IDs for stable serialization - Epic 3)
    public let deckCardIds: [String]
    public let handCardIds: [String]
    public let discardCardIds: [String]

    // MARK: - World State
    public let currentDay: Int
    public let worldTension: Int
    public let lightDarkBalance: Int
    public let currentRegionId: String?  // Definition ID, not UUID

    // MARK: - Regions State
    public let regions: [RegionSaveState]

    // MARK: - Quest State
    public let mainQuestStage: Int
    public let activeQuestIds: [String]
    public let completedQuestIds: [String]
    public let questStages: [String: Int]

    // MARK: - Events State (String IDs for stable serialization - Epic 3)
    public let completedEventIds: [String]  // Definition IDs, not UUIDs
    public let eventLog: [EventLogEntrySave]

    // MARK: - World Flags
    public let worldFlags: [String: Bool]

    // MARK: - RNG State (Audit A2 - determinism after load)
    public let rngSeed: UInt64
    public let rngState: UInt64

    // MARK: - Current Version
    public static let currentVersion = 1
    public static let currentFormatVersion = 1
    public static let currentCoreVersion = "1.2.0"

    // MARK: - Initialization

    public init(
        version: Int = EngineSave.currentVersion,
        savedAt: Date = Date(),
        gameDuration: TimeInterval = 0,
        coreVersion: String = EngineSave.currentCoreVersion,
        activePackSet: [String: String] = [:],
        formatVersion: Int = EngineSave.currentFormatVersion,
        primaryCampaignPackId: String? = nil,
        playerName: String = "",
        heroId: String? = nil,
        playerHealth: Int = 10,
        playerMaxHealth: Int = 10,
        playerFaith: Int = 3,
        playerMaxFaith: Int = 10,
        playerBalance: Int = 50,
        deckCardIds: [String] = [],
        handCardIds: [String] = [],
        discardCardIds: [String] = [],
        currentDay: Int = 1,
        worldTension: Int = 0,
        lightDarkBalance: Int = 50,
        currentRegionId: String? = nil,
        regions: [RegionSaveState] = [],
        mainQuestStage: Int = 1,
        activeQuestIds: [String] = [],
        completedQuestIds: [String] = [],
        questStages: [String: Int] = [:],
        completedEventIds: [String] = [],
        eventLog: [EventLogEntrySave] = [],
        worldFlags: [String: Bool] = [:],
        rngSeed: UInt64,
        rngState: UInt64
    ) {
        self.version = version
        self.savedAt = savedAt
        self.gameDuration = gameDuration
        self.coreVersion = coreVersion
        self.activePackSet = activePackSet
        self.formatVersion = formatVersion
        self.primaryCampaignPackId = primaryCampaignPackId
        self.playerName = playerName
        self.heroId = heroId
        self.playerHealth = playerHealth
        self.playerMaxHealth = playerMaxHealth
        self.playerFaith = playerFaith
        self.playerMaxFaith = playerMaxFaith
        self.playerBalance = playerBalance
        self.deckCardIds = deckCardIds
        self.handCardIds = handCardIds
        self.discardCardIds = discardCardIds
        self.currentDay = currentDay
        self.worldTension = worldTension
        self.lightDarkBalance = lightDarkBalance
        self.currentRegionId = currentRegionId
        self.regions = regions
        self.mainQuestStage = mainQuestStage
        self.activeQuestIds = activeQuestIds
        self.completedQuestIds = completedQuestIds
        self.questStages = questStages
        self.completedEventIds = completedEventIds
        self.eventLog = eventLog
        self.worldFlags = worldFlags
        self.rngSeed = rngSeed
        self.rngState = rngState
    }

    // MARK: - Pack Compatibility Validation

    /// Check if save is compatible with current engine and loaded packs
    public func validateCompatibility(with registry: ContentRegistry) -> SaveCompatibilityResult {
        var warnings: [String] = []
        var errors: [String] = []

        // Check core version
        if coreVersion != EngineSave.currentCoreVersion {
            warnings.append("Save was created with core version \(coreVersion), current is \(EngineSave.currentCoreVersion)")
        }

        // Check format version - only fail if format is NEWER than supported
        if formatVersion > EngineSave.currentFormatVersion {
            errors.append("Save format version \(formatVersion) is newer than supported \(EngineSave.currentFormatVersion)")
        }

        // Check primary campaign pack - this is CRITICAL for save compatibility
        // If the primary campaign pack is missing, the save cannot be loaded properly
        if let primaryPackId = primaryCampaignPackId {
            if registry.loadedPacks[primaryPackId] == nil {
                errors.append("Primary campaign pack '\(primaryPackId)' is not loaded - this save requires it to continue")
            }
        }

        // Check pack versions - missing/mismatched packs are warnings, not errors
        // The game can still try to load with available content
        for (packId, savedVersion) in activePackSet {
            if let loadedPack = registry.loadedPacks[packId] {
                let loadedVersion = loadedPack.manifest.version.description
                if loadedVersion != savedVersion {
                    warnings.append("Pack '\(packId)' version mismatch: save has \(savedVersion), loaded is \(loadedVersion)")
                }
            } else if packId != primaryCampaignPackId {
                // Missing non-primary pack is a warning, not an error
                // The game can try to continue with whatever content is available
                warnings.append("Pack '\(packId)' (version \(savedVersion)) is not currently loaded - some content may be unavailable")
            }
        }

        if !errors.isEmpty {
            return .incompatible(errors: errors)
        } else if !warnings.isEmpty {
            return .compatible(warnings: warnings)
        } else {
            return .fullyCompatible
        }
    }
}

/// Result of save compatibility validation
public enum SaveCompatibilityResult {
    case fullyCompatible
    case compatible(warnings: [String])
    case incompatible(errors: [String])

    public var isLoadable: Bool {
        switch self {
        case .fullyCompatible, .compatible:
            return true
        case .incompatible:
            return false
        }
    }

    /// Get error messages (for incompatible saves)
    public var errorMessages: [String] {
        switch self {
        case .incompatible(let errors):
            return errors
        default:
            return []
        }
    }

    /// Get warning messages (for compatible saves)
    public var warningMessages: [String] {
        switch self {
        case .compatible(let warnings):
            return warnings
        default:
            return []
        }
    }
}

// MARK: - Region Save State

/// Region state for saving (String IDs - Epic 3)
public struct RegionSaveState: Codable {
    public let definitionId: String  // Stable definition ID
    public let name: String
    public let type: String  // RegionType.rawValue
    public let state: String  // RegionState.rawValue
    public let anchorDefinitionId: String?
    public let anchorIntegrity: Int?
    public let neighborDefinitionIds: [String]
    public let canTrade: Bool
    public let visited: Bool
    public let reputation: Int

    public init(from region: EngineRegionState) {
        // definitionId is now required (Audit A1 - no UUID fallback)
        self.definitionId = region.definitionId
        self.name = region.name
        self.type = region.type.rawValue
        self.state = region.state.rawValue
        self.anchorDefinitionId = region.anchor?.definitionId
        self.anchorIntegrity = region.anchor?.integrity
        self.neighborDefinitionIds = region.neighborDefinitionIds
        self.canTrade = region.canTrade
        self.visited = region.visited
        self.reputation = region.reputation
    }

    public func toEngineRegionState() -> EngineRegionState {
        var anchor: EngineAnchorState? = nil
        if let anchorId = anchorDefinitionId {
            anchor = EngineAnchorState(
                id: UUID(),
                definitionId: anchorId,
                name: anchorId,
                integrity: anchorIntegrity ?? 100
            )
        }

        return EngineRegionState(
            id: UUID(),
            definitionId: definitionId,
            name: name,
            type: RegionType(rawValue: type) ?? .settlement,
            state: RegionState(rawValue: state) ?? .stable,
            anchor: anchor,
            neighborIds: [],
            neighborDefinitionIds: neighborDefinitionIds,
            canTrade: canTrade,
            visited: visited,
            reputation: reputation
        )
    }
}

// MARK: - Anchor Save State (Deprecated - anchors now stored inline in RegionSaveState)

// MARK: - Event Log Entry Save

/// Event log entry for saving
public struct EventLogEntrySave: Codable {
    public let id: UUID
    public let dayNumber: Int
    public let timestamp: Date
    public let regionName: String
    public let eventTitle: String
    public let choiceMade: String
    public let outcome: String
    public let type: String  // EventLogType.rawValue

    public init(from entry: EventLogEntry) {
        self.id = entry.id
        self.dayNumber = entry.dayNumber
        self.timestamp = entry.timestamp
        self.regionName = entry.regionName
        self.eventTitle = entry.eventTitle
        self.choiceMade = entry.choiceMade
        self.outcome = entry.outcome
        self.type = entry.type.rawValue
    }

    public func toEventLogEntry() -> EventLogEntry {
        EventLogEntry(
            id: id,
            dayNumber: dayNumber,
            timestamp: timestamp,
            regionName: regionName,
            eventTitle: eventTitle,
            choiceMade: choiceMade,
            outcome: outcome,
            type: EventLogType(rawValue: type) ?? .exploration
        )
    }
}

// MARK: - TwilightGameEngine Save/Load
// NOTE: Save/Load methods moved to TwilightGameEngine.swift for proper access to internal state
// See TwilightGameEngine+Persistence.swift for implementation


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Core/GameLoop.swift
// ==========================================

import Foundation

// MARK: - Game Loop / Engine Orchestrator
// The central coordinator that runs the game engine.
// This is the "processor" - specific games are the "cartridge".

/// Engine game phase enum (distinct from legacy GamePhase in Models/GameState.swift)
public enum EngineGamePhase: String, Codable {
    case setup
    case playing
    case paused
    case ended
}

/// Game end result
public enum GameEndResult: Equatable {
    case victory(endingId: String)
    case defeat(reason: String)
    case abandoned
}

// MARK: - Abstract Game Loop

/// Base class for game loop implementation
/// Subclass this for specific game implementations
open class GameLoopBase: ObservableObject {
    // MARK: - Published State

    @Published private(set) var currentPhase: EngineGamePhase = .setup
    @Published private(set) var isGameOver: Bool = false
    @Published private(set) var endResult: GameEndResult?

    // MARK: - Core Subsystems

    public let timeEngine: TimeEngine
    public let pressureEngine: PressureEngine
    public let economyManager: EconomyManager

    // MARK: - State

    /// Player resources (generic key-value store)
    @Published var playerResources: [String: Int] = [:]

    /// World flags
    @Published var worldFlags: [String: Bool] = [:]

    /// Completed event IDs
    private(set) var completedEvents: Set<String> = []

    // MARK: - Delegates

    weak var timeDelegate: TimeSystemDelegate? {
        didSet { timeEngine.delegate = timeDelegate }
    }

    // MARK: - Initialization

    public init(
        pressureRules: PressureRuleSet,
        timeThresholdInterval: Int = 3
    ) {
        self.timeEngine = TimeEngine(thresholdInterval: timeThresholdInterval)
        self.pressureEngine = PressureEngine(rules: pressureRules)
        self.economyManager = EconomyManager()
    }

    // MARK: - Core Loop Methods

    /// Start a new game
    public func startGame() {
        currentPhase = .playing
        isGameOver = false
        endResult = nil

        // Reset subsystems
        timeEngine.reset()
        pressureEngine.reset()
        economyManager.clearHistory()
        completedEvents.removeAll()

        // Subclass should override to set initial state
        setupInitialState()
    }

    /// Override in subclass to set initial player resources, world state, etc.
    open func setupInitialState() {
        // Subclass implementation
    }

    /// Main action execution - the canonical core loop
    public func performAction(_ action: any TimedAction) async {
        guard currentPhase == .playing else { return }

        // 1. Get time cost
        let cost = action.timeCost

        // 2. Advance time (triggers worldTick via delegate)
        timeEngine.advance(cost: cost)

        // 3. Check if time threshold crossed (every N days)
        if timeEngine.checkThreshold(pressureEngine.rules.escalationInterval) {
            // 4. Escalate pressure
            pressureEngine.escalate(at: timeEngine.currentTime)

            // 5. Apply world effects
            applyWorldEffects(pressureEngine.currentEffects())
        }

        // 6. Process action-specific logic (subclass)
        await processAction(action)

        // 7. Update quests (subclass)
        updateQuests()

        // 8. Check end conditions
        checkEndConditions()

        // 9. Auto-save (if configured)
        autoSave()
    }

    /// Override in subclass to handle specific actions
    public func processAction(_ action: any TimedAction) async {
        // Subclass implementation
    }

    /// Override in subclass to update quest progress
    public func updateQuests() {
        // Subclass implementation
    }

    /// Apply world effects from pressure thresholds
    public func applyWorldEffects(_ effects: [WorldEffect]) {
        for effect in effects {
            applyWorldEffect(effect)
        }
    }

    /// Apply a single world effect - override in subclass for custom effects
    public func applyWorldEffect(_ effect: WorldEffect) {
        switch effect {
        case .regionDegradation(let probability):
            // Subclass handles region degradation
            handleRegionDegradation(probability: probability)

        case .globalEvent(let eventId):
            // Trigger a global event
            triggerGlobalEvent(eventId)

        case .phaseChange(let newPhase):
            // Handle phase change
            handlePhaseChange(newPhase)

        case .anchorWeakening(let amount):
            // Weaken anchors
            weakenAnchors(amount: amount)

        case .custom(let id, let parameters):
            // Custom effect - subclass handles
            handleCustomEffect(id: id, parameters: parameters)
        }
    }

    // MARK: - Effect Handlers (Override in Subclass)

    public func handleRegionDegradation(probability: Double) {
        // Subclass implementation
    }

    public func triggerGlobalEvent(_ eventId: String) {
        // Subclass implementation
    }

    public func handlePhaseChange(_ newPhase: String) {
        // Subclass implementation
    }

    public func weakenAnchors(amount: Int) {
        // Subclass implementation
    }

    public func handleCustomEffect(id: String, parameters: [String: Any]) {
        // Subclass implementation
    }

    // MARK: - End Conditions

    /// Check victory and defeat conditions
    public func checkEndConditions() {
        // Check pressure-based defeat
        if pressureEngine.isAtMaximum {
            endGame(result: .defeat(reason: "pressure_maximum"))
            return
        }

        // Check resource-based defeat (e.g., health = 0)
        if let health = playerResources["health"], health <= 0 {
            endGame(result: .defeat(reason: "health_zero"))
            return
        }

        // Subclass should override for victory conditions
        checkVictoryConditions()
    }

    /// Override in subclass for game-specific victory conditions
    public func checkVictoryConditions() {
        // Subclass implementation
    }

    /// End the game
    public func endGame(result: GameEndResult) {
        currentPhase = .ended
        isGameOver = true
        endResult = result
    }

    // MARK: - Resource Management

    /// Get a resource value
    public func getResource(_ key: String) -> Int {
        return playerResources[key] ?? 0
    }

    /// Set a resource value
    public func setResource(_ key: String, value: Int) {
        playerResources[key] = value
    }

    /// Modify a resource by delta
    public func modifyResource(_ key: String, by delta: Int) {
        let current = playerResources[key] ?? 0
        playerResources[key] = current + delta
    }

    /// Process a transaction
    public func processTransaction(_ transaction: Transaction) -> Bool {
        return economyManager.process(transaction, resources: &playerResources)
    }

    // MARK: - Flag Management

    /// Set a world flag
    public func setFlag(_ flag: String, value: Bool = true) {
        worldFlags[flag] = value
    }

    /// Check a world flag
    public func hasFlag(_ flag: String) -> Bool {
        return worldFlags[flag] ?? false
    }

    // MARK: - Event Tracking

    /// Mark an event as completed
    public func markEventCompleted(_ eventId: String) {
        completedEvents.insert(eventId)
    }

    /// Check if event was completed
    public func isEventCompleted(_ eventId: String) -> Bool {
        return completedEvents.contains(eventId)
    }

    // MARK: - Save/Load

    public func autoSave() {
        // Subclass implementation
    }

    public func save() {
        // Subclass implementation
    }

    public func load() {
        // Subclass implementation
    }

    // MARK: - Context Building

    /// Build event context for event filtering
    public func buildEventContext(
        currentLocation: String,
        locationState: String
    ) -> EventContext {
        return EventContext(
            currentLocation: currentLocation,
            locationState: locationState,
            pressure: pressureEngine.currentPressure,
            flags: worldFlags,
            resources: playerResources,
            completedEvents: completedEvents
        )
    }
}

// MARK: - Action Types

/// Standard game actions
public enum StandardAction: TimedAction {
    case travel(from: String, to: String, isNeighbor: Bool)
    case rest
    case explore(instant: Bool)
    case trade
    case interact(targetId: String)
    case combat(enemyId: String)
    case useAbility(abilityId: String)
    case custom(id: String, cost: Int)

    public var timeCost: Int {
        switch self {
        case .travel(_, _, let isNeighbor):
            return isNeighbor ? 1 : 2
        case .rest:
            return 1
        case .explore(let instant):
            return instant ? 0 : 1
        case .trade:
            return 1
        case .interact:
            return 1
        case .combat:
            return 1
        case .useAbility:
            return 1
        case .custom(_, let cost):
            return cost
        }
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Core/PressureEngine.swift
// ==========================================

import Foundation

// MARK: - Pressure Engine Implementation
// Generic pressure/tension system that drives game escalation.

/// Default implementation of PressureEngineProtocol
public final class PressureEngine: PressureEngineProtocol {
    // MARK: - Properties

    public private(set) var currentPressure: Int
    public let rules: PressureRuleSet

    /// Track which thresholds have been triggered
    private var triggeredThresholds: Set<Int> = []

    // MARK: - Initialization

    public init(rules: PressureRuleSet) {
        self.rules = rules
        self.currentPressure = rules.initialPressure
    }

    // MARK: - PressureEngineProtocol

    /// Escalate pressure based on rules and current time
    public func escalate(at currentTime: Int) {
        let delta = rules.calculateEscalation(currentPressure: currentPressure, currentTime: currentTime)
        adjust(by: delta)
    }

    /// Manually adjust pressure (can be positive or negative)
    public func adjust(by delta: Int) {
        let newPressure = currentPressure + delta
        currentPressure = min(max(0, newPressure), rules.maxPressure)
    }

    /// Get effects that should trigger at current pressure level
    public func currentEffects() -> [WorldEffect] {
        return rules.checkThresholds(pressure: currentPressure)
    }

    // MARK: - Utility

    /// Reset pressure (for new game)
    public func reset() {
        currentPressure = rules.initialPressure
        triggeredThresholds.removeAll()
    }

    /// Set pressure directly (for save/load)
    public func setPressure(_ value: Int) {
        currentPressure = min(max(0, value), rules.maxPressure)
    }

    // MARK: - Save/Load Support

    /// Get triggered thresholds for save
    public func getTriggeredThresholds() -> Set<Int> {
        return triggeredThresholds
    }

    /// Restore triggered thresholds from save
    /// Call this after loading game to prevent duplicate threshold events
    public func setTriggeredThresholds(_ thresholds: Set<Int>) {
        triggeredThresholds = thresholds
    }

    /// Reconstruct triggered thresholds from current pressure value
    /// Use this when loading a save that doesn't have explicit thresholds saved
    /// All thresholds below or equal to current pressure are marked as triggered
    public func syncTriggeredThresholdsFromPressure() {
        triggeredThresholds.removeAll()
        // Use checkThresholds to find which effects would trigger at current pressure
        // Then mark standard threshold levels (10, 20, 30, etc.) as triggered
        // This is a heuristic - actual threshold levels depend on the rule set
        let standardThresholds = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
        for threshold in standardThresholds where threshold <= currentPressure {
            triggeredThresholds.insert(threshold)
        }
    }

    /// Get pressure as percentage (0.0 - 1.0)
    public var pressurePercentage: Double {
        guard rules.maxPressure > 0 else { return 0 }
        return Double(currentPressure) / Double(rules.maxPressure)
    }

    /// Check if at maximum pressure (game over condition)
    public var isAtMaximum: Bool {
        currentPressure >= rules.maxPressure
    }
}

// MARK: - Standard Pressure Rule Set

/// Basic pressure rules with configurable parameters
public struct StandardPressureRules: PressureRuleSet {
    public let maxPressure: Int
    public let initialPressure: Int
    public let escalationInterval: Int
    public let escalationAmount: Int

    /// Thresholds that trigger effects [pressure: effects]
    public let thresholds: [Int: [WorldEffect]]

    public init(
        maxPressure: Int = 100,
        initialPressure: Int = 30,
        escalationInterval: Int = 3,
        escalationAmount: Int = 2,
        thresholds: [Int: [WorldEffect]] = [:]
    ) {
        self.maxPressure = maxPressure
        self.initialPressure = initialPressure
        self.escalationInterval = escalationInterval
        self.escalationAmount = escalationAmount
        self.thresholds = thresholds
    }

    public func calculateEscalation(currentPressure: Int, currentTime: Int) -> Int {
        // Standard: add escalationAmount every escalationInterval
        return escalationAmount
    }

    public func checkThresholds(pressure: Int) -> [WorldEffect] {
        var effects: [WorldEffect] = []

        for (threshold, thresholdEffects) in thresholds {
            if pressure >= threshold {
                effects.append(contentsOf: thresholdEffects)
            }
        }

        return effects
    }
}

// MARK: - Adaptive Pressure Rules

/// Pressure rules that adapt based on game state
public struct AdaptivePressureRules: PressureRuleSet {
    public let maxPressure: Int
    public let initialPressure: Int
    public let escalationInterval: Int
    public let baseEscalationAmount: Int

    /// Multiplier based on current pressure (higher pressure = faster escalation)
    public let accelerationFactor: Double

    /// Thresholds with effects
    public let thresholds: [Int: [WorldEffect]]

    public var escalationAmount: Int { baseEscalationAmount }

    public init(
        maxPressure: Int = 100,
        initialPressure: Int = 30,
        escalationInterval: Int = 3,
        baseEscalationAmount: Int = 2,
        accelerationFactor: Double = 0.01,
        thresholds: [Int: [WorldEffect]] = [:]
    ) {
        self.maxPressure = maxPressure
        self.initialPressure = initialPressure
        self.escalationInterval = escalationInterval
        self.baseEscalationAmount = baseEscalationAmount
        self.accelerationFactor = accelerationFactor
        self.thresholds = thresholds
    }

    public func calculateEscalation(currentPressure: Int, currentTime: Int) -> Int {
        // Adaptive: base amount + acceleration based on current pressure
        let acceleration = Int(Double(currentPressure) * accelerationFactor)
        return baseEscalationAmount + acceleration
    }

    public func checkThresholds(pressure: Int) -> [WorldEffect] {
        var effects: [WorldEffect] = []

        for (threshold, thresholdEffects) in thresholds {
            if pressure >= threshold {
                effects.append(contentsOf: thresholdEffects)
            }
        }

        return effects
    }
}

// MARK: - Pressure Change Event

/// Event fired when pressure changes significantly
public struct PressureChangeEvent {
    public let oldValue: Int
    public let newValue: Int
    public let delta: Int
    public let thresholdsCrossed: [Int]
    public let effectsTriggered: [WorldEffect]
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Core/RequirementsEvaluator.swift
// ==========================================

import Foundation

// MARK: - Requirements Evaluator
// Ð›Ð¾Ð³Ð¸ÐºÐ° Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ Ñ‚Ñ€ÐµÐ±Ð¾Ð²Ð°Ð½Ð¸Ð¹, Ð²Ñ‹Ð½ÐµÑÐµÐ½Ð½Ð°Ñ Ð¸Ð· Definitions Ð² Engine Core
// Definitions Ð¾ÑÑ‚Ð°ÑŽÑ‚ÑÑ "Ñ‚ÑƒÐ¿Ñ‹Ð¼Ð¸ Ð´Ð°Ð½Ð½Ñ‹Ð¼Ð¸", Ð° Ð»Ð¾Ð³Ð¸ÐºÐ° Ð¶Ð¸Ð²Ñ‘Ñ‚ Ð·Ð´ÐµÑÑŒ

/// ÐŸÑ€Ð¾Ñ‚Ð¾ÐºÐ¾Ð» Ð´Ð»Ñ Ð¾Ñ†ÐµÐ½ÐºÐ¸ Ñ‚Ñ€ÐµÐ±Ð¾Ð²Ð°Ð½Ð¸Ð¹
public protocol RequirementsEvaluating {
    /// ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÑ‚, Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ñ‹ Ð»Ð¸ Ñ‚Ñ€ÐµÐ±Ð¾Ð²Ð°Ð½Ð¸Ñ Ð²Ñ‹Ð±Ð¾Ñ€Ð°
    func canMeet(
        requirements: ChoiceRequirements,
        resources: [String: Int],
        flags: Set<String>,
        balance: Int
    ) -> Bool

    /// ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÑ‚, Ð´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½ Ð»Ð¸ Ð²Ñ‹Ð±Ð¾Ñ€ Ð² Ñ‚ÐµÐºÑƒÑ‰ÐµÐ¼ ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ðµ
    func isChoiceAvailable(
        choice: ChoiceDefinition,
        resources: [String: Int],
        flags: Set<String>,
        balance: Int
    ) -> Bool
}

/// Ð¡Ñ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ñ‹Ð¹ evaluator Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ Ñ‚Ñ€ÐµÐ±Ð¾Ð²Ð°Ð½Ð¸Ð¹
public struct RequirementsEvaluator: RequirementsEvaluating {

    /// ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÑ‚, Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ñ‹ Ð»Ð¸ Ñ‚Ñ€ÐµÐ±Ð¾Ð²Ð°Ð½Ð¸Ñ
    public func canMeet(
        requirements: ChoiceRequirements,
        resources: [String: Int],
        flags: Set<String>,
        balance: Int
    ) -> Bool {
        // Check resources
        for (resourceId, minValue) in requirements.minResources {
            if (resources[resourceId] ?? 0) < minValue {
                return false
            }
        }

        // Check required flags
        for flag in requirements.requiredFlags {
            if !flags.contains(flag) {
                return false
            }
        }

        // Check forbidden flags
        for flag in requirements.forbiddenFlags {
            if flags.contains(flag) {
                return false
            }
        }

        // Check balance range
        if let min = requirements.minBalance, balance < min {
            return false
        }
        if let max = requirements.maxBalance, balance > max {
            return false
        }

        return true
    }

    /// ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÑ‚, Ð´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½ Ð»Ð¸ Ð²Ñ‹Ð±Ð¾Ñ€ (ÐµÑÐ»Ð¸ ÐµÑÑ‚ÑŒ requirements - Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÑ‚ Ð¸Ñ…)
    public func isChoiceAvailable(
        choice: ChoiceDefinition,
        resources: [String: Int],
        flags: Set<String>,
        balance: Int
    ) -> Bool {
        guard let requirements = choice.requirements else {
            return true  // ÐÐµÑ‚ Ñ‚Ñ€ÐµÐ±Ð¾Ð²Ð°Ð½Ð¸Ð¹ = Ð²ÑÐµÐ³Ð´Ð° Ð´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½
        }
        return canMeet(
            requirements: requirements,
            resources: resources,
            flags: flags,
            balance: balance
        )
    }
}

// MARK: - Shared Instance

/// Ð“Ð»Ð¾Ð±Ð°Ð»ÑŒÐ½Ñ‹Ð¹ evaluator Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ Ñ‚Ñ€ÐµÐ±Ð¾Ð²Ð°Ð½Ð¸Ð¹
public enum Requirements {
    public static var evaluator: RequirementsEvaluating = RequirementsEvaluator()
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Core/TimeEngine.swift
// ==========================================

import Foundation

// MARK: - Time Engine Implementation
// Generic time management system for turn-based games.

/// Default implementation of TimeEngineProtocol
public final class TimeEngine: TimeEngineProtocol {
    // MARK: - Properties

    public private(set) var currentTime: Int = 0
    public weak var delegate: TimeSystemDelegate?

    /// Thresholds that have been triggered (to avoid re-triggering)
    private var triggeredThresholds: Set<Int> = []

    /// Configurable threshold intervals (e.g., [3, 6, 9] or just [3] for "every 3")
    private let thresholdInterval: Int

    // MARK: - Initialization

    /// Initialize with a threshold interval (e.g., 3 for "every 3 time units")
    public init(thresholdInterval: Int = 3) {
        self.thresholdInterval = thresholdInterval
    }

    // MARK: - TimeEngineProtocol

    /// Advance time by cost units
    /// Invariant: Time cannot go backwards
    public func advance(cost: Int) {
        guard cost > 0 else {
            // Instant actions (cost = 0) don't advance time
            return
        }

        let previousTime = currentTime
        currentTime += cost

        // Notify delegate of each tick
        delegate?.onTimeTick(currentTime: currentTime, delta: cost)

        // Check for threshold crossings
        checkThresholdCrossings(from: previousTime, to: currentTime)
    }

    /// Check if current time has passed a threshold interval
    public func checkThreshold(_ interval: Int) -> Bool {
        guard interval > 0 else { return false }
        return currentTime % interval == 0 && currentTime > 0
    }

    // MARK: - Private Methods

    private func checkThresholdCrossings(from previousTime: Int, to newTime: Int) {
        guard thresholdInterval > 0 else { return }

        // Find all threshold crossings in the range
        let previousThreshold = previousTime / thresholdInterval
        let newThreshold = newTime / thresholdInterval

        if newThreshold > previousThreshold {
            for threshold in (previousThreshold + 1)...newThreshold {
                let thresholdTime = threshold * thresholdInterval
                delegate?.onTimeThreshold(currentTime: newTime, threshold: thresholdTime)
            }
        }
    }

    // MARK: - Utility

    /// Reset time (for new game)
    public func reset() {
        currentTime = 0
        triggeredThresholds.removeAll()
    }

    /// Set time directly (for save/load)
    public func setTime(_ time: Int) {
        currentTime = max(0, time)
    }
}

// MARK: - Time Cost Constants

/// Standard time costs for common actions
public enum StandardTimeCost: Int, TimedAction {
    case instant = 0
    case quick = 1
    case standard = 2
    case extended = 3
    case long = 4

    public var timeCost: Int { rawValue }
}

// MARK: - TimedAction Extensions

/// Simple timed action wrapper
public struct SimpleTimedAction: TimedAction {
    public let timeCost: Int
    public let actionId: String

    public init(cost: Int, id: String = "") {
        self.timeCost = cost
        self.actionId = id
    }
}

/// Travel action with variable cost
public struct TravelAction: TimedAction {
    public let fromLocation: String
    public let toLocation: String
    public let isNeighbor: Bool

    public var timeCost: Int {
        isNeighbor ? 1 : 2
    }
}

/// Rest action
public struct RestAction: TimedAction {
    public let timeCost: Int = 1
}

/// Exploration action
public struct ExploreAction: TimedAction {
    public let isInstant: Bool
    public var timeCost: Int { isInstant ? 0 : 1 }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Core/TwilightGameAction.swift
// ==========================================

import Foundation

// MARK: - Twilight Marches Game Actions
// All player actions go through these - UI never mutates state directly

/// All possible player actions in Twilight Marches
public enum TwilightGameAction: TimedAction, Equatable {
    // MARK: - Movement
    /// Travel to another region
    case travel(toRegionId: UUID)

    // MARK: - Region Actions
    /// Rest in current region (heals, costs time)
    case rest

    /// Explore current region (triggers events)
    case explore

    /// Trade at market (if available)
    case trade

    /// Strengthen anchor in current region
    case strengthenAnchor

    // MARK: - Event Handling
    /// Choose an option in an event
    case chooseEventOption(eventId: UUID, choiceIndex: Int)

    /// Resolve a mini-game result
    case resolveMiniGame(input: MiniGameInput)

    // MARK: - Combat Setup
    /// Start combat with encounter
    case startCombat(encounterId: UUID)

    /// Initialize combat: shuffle deck and draw initial hand
    case combatInitialize

    // MARK: - Combat Actions
    /// Perform basic attack in combat
    case combatAttack(bonusDice: Int, bonusDamage: Int, isFirstAttack: Bool)

    /// Play a card in combat
    case playCard(cardId: UUID, targetId: UUID?)

    /// Apply card ability effect
    case combatApplyEffect(effect: CombatActionEffect)

    /// End combat turn (goes to enemy phase)
    case endCombatTurn

    /// Perform enemy attack
    case combatEnemyAttack(damage: Int)

    /// End turn phase: discard hand, draw new cards, restore faith
    case combatEndTurnPhase

    /// Flee from combat
    case combatFlee

    /// Finish combat with result
    case combatFinish(victory: Bool)

    // MARK: - UI Actions
    /// Dismiss current event (after UI handles it)
    case dismissCurrentEvent

    /// Dismiss day event notification
    case dismissDayEvent

    // MARK: - Special
    /// Skip/pass turn
    case skipTurn

    /// Custom action for extensibility
    case custom(id: String, timeCost: Int)

    // MARK: - TimedAction Conformance

    public var timeCost: Int {
        switch self {
        case .travel:
            // Travel cost determined by engine based on distance
            // Default to 1, actual cost calculated in engine
            return 1

        case .rest:
            return 1

        case .explore:
            return 1

        case .trade:
            return 0  // Trading doesn't cost time

        case .strengthenAnchor:
            return 1

        case .chooseEventOption:
            return 0  // Events are part of explore/travel

        case .resolveMiniGame:
            return 0  // Mini-game is part of event

        case .startCombat:
            return 0  // Combat is part of event

        case .combatInitialize:
            return 0  // Setup, no time cost

        case .combatAttack:
            return 0  // Within combat turn

        case .playCard:
            return 0  // Cards are within combat turn

        case .combatApplyEffect:
            return 0  // Effect application

        case .endCombatTurn:
            return 0  // Turn management

        case .combatEnemyAttack:
            return 0  // Enemy phase

        case .combatEndTurnPhase:
            return 0  // End of turn

        case .combatFlee:
            return 0  // Escape

        case .combatFinish:
            return 0  // Combat end

        case .dismissCurrentEvent:
            return 0  // UI action, no time cost

        case .dismissDayEvent:
            return 0  // UI action, no time cost

        case .skipTurn:
            return 1

        case .custom(_, let cost):
            return cost
        }
    }
}

// MARK: - Mini-Game Input

/// Input data for resolving a mini-game action
/// Different from MiniGameResult in MiniGameChallengeDefinition.swift (serializable state diff)
public struct MiniGameInput: Equatable {
    public let challengeId: UUID
    public let success: Bool
    public let score: Int?
    public let bonusRewards: [String: Int]

    public init(challengeId: UUID, success: Bool, score: Int? = nil, bonusRewards: [String: Int] = [:]) {
        self.challengeId = challengeId
        self.success = success
        self.score = score
        self.bonusRewards = bonusRewards
    }
}

// MARK: - Combat Effect

/// Effect to apply during combat (from cards or abilities)
public enum CombatActionEffect: Equatable {
    /// Heal player
    case heal(amount: Int)

    /// Deal damage to enemy
    case damageEnemy(amount: Int)

    /// Draw cards
    case drawCards(count: Int)

    /// Gain faith
    case gainFaith(amount: Int)

    /// Spend faith
    case spendFaith(amount: Int)

    /// Take damage (sacrifice)
    case takeDamage(amount: Int)

    /// Remove curse
    case removeCurse(type: String?)

    /// Shift balance
    case shiftBalance(towards: String, amount: Int)

    /// Add bonus dice for next attack
    case addBonusDice(count: Int)

    /// Add bonus damage for next attack
    case addBonusDamage(amount: Int)

    /// Summon spirit to attack enemy
    case summonSpirit(power: Int, realm: String)
}

// MARK: - Action Result

/// Result of performing a game action
public struct ActionResult: Equatable {
    /// Whether the action succeeded
    public let success: Bool

    /// Error if action failed
    public let error: ActionError?

    /// State changes that occurred
    public let stateChanges: [StateChange]

    /// Events triggered by this action
    public let triggeredEvents: [UUID]

    /// New current event (if any)
    public let currentEvent: UUID?

    /// Combat started (if any)
    public let combatStarted: Bool

    /// Game ended (if any)
    public let gameEnded: GameEndResult?

    // MARK: - Convenience Initializers

    public init(
        success: Bool,
        error: ActionError?,
        stateChanges: [StateChange],
        triggeredEvents: [UUID],
        currentEvent: UUID?,
        combatStarted: Bool,
        gameEnded: GameEndResult?
    ) {
        self.success = success
        self.error = error
        self.stateChanges = stateChanges
        self.triggeredEvents = triggeredEvents
        self.currentEvent = currentEvent
        self.combatStarted = combatStarted
        self.gameEnded = gameEnded
    }

    public static func success(
        changes: [StateChange] = [],
        triggeredEvents: [UUID] = [],
        currentEvent: UUID? = nil,
        combatStarted: Bool = false
    ) -> ActionResult {
        ActionResult(
            success: true,
            error: nil,
            stateChanges: changes,
            triggeredEvents: triggeredEvents,
            currentEvent: currentEvent,
            combatStarted: combatStarted,
            gameEnded: nil
        )
    }

    public static func failure(_ error: ActionError) -> ActionResult {
        ActionResult(
            success: false,
            error: error,
            stateChanges: [],
            triggeredEvents: [],
            currentEvent: nil,
            combatStarted: false,
            gameEnded: nil
        )
    }

    public static func gameOver(_ result: GameEndResult) -> ActionResult {
        ActionResult(
            success: true,
            error: nil,
            stateChanges: [],
            triggeredEvents: [],
            currentEvent: nil,
            combatStarted: false,
            gameEnded: result
        )
    }
}

// MARK: - Action Error

/// Errors that can occur when performing actions
public enum ActionError: Error, Equatable {
    // Validation errors
    case invalidAction(reason: String)
    case regionNotAccessible(regionId: UUID)
    case regionNotNeighbor(regionId: UUID)
    case actionNotAvailableInRegion(action: String, regionType: String)

    // Resource errors
    case insufficientResources(resource: String, required: Int, available: Int)
    case healthTooLow

    // State errors
    case gameNotInProgress
    case combatInProgress
    case eventInProgress
    case noActiveEvent
    case noActiveCombat

    // Event errors
    case eventNotFound(eventId: UUID)
    case invalidChoiceIndex(index: Int, maxIndex: Int)
    case choiceRequirementsNotMet(reason: String)

    // Combat errors
    case cardNotInHand(cardId: UUID)
    case notEnoughActions
    case invalidTarget

    public var localizedDescription: String {
        switch self {
        case .invalidAction(let reason):
            return L10n.errorInvalidAction.localized(with: reason)
        case .regionNotAccessible(let id):
            return L10n.errorRegionNotAccessible.localized(with: String(id.uuidString.prefix(8)))
        case .regionNotNeighbor(let id):
            return L10n.errorRegionNotNeighbor.localized(with: String(id.uuidString.prefix(8)))
        case .actionNotAvailableInRegion(let action, let type):
            return L10n.errorActionNotAvailable.localized(with: action, type)
        case .insufficientResources(let resource, let required, let available):
            return L10n.errorInsufficientResources.localized(with: resource, required, available)
        case .healthTooLow:
            return L10n.errorHealthTooLow.localized
        case .gameNotInProgress:
            return L10n.errorGameNotInProgress.localized
        case .combatInProgress:
            return L10n.errorCombatInProgress.localized
        case .eventInProgress:
            return L10n.errorEventInProgress.localized
        case .noActiveEvent:
            return L10n.errorNoActiveEvent.localized
        case .noActiveCombat:
            return L10n.errorNoActiveCombat.localized
        case .eventNotFound(let id):
            return L10n.errorEventNotFound.localized(with: String(id.uuidString.prefix(8)))
        case .invalidChoiceIndex(let index, let max):
            return L10n.errorInvalidChoiceIndex.localized(with: index, max)
        case .choiceRequirementsNotMet(let reason):
            return L10n.errorChoiceRequirementsNotMet.localized(with: reason)
        case .cardNotInHand(let id):
            return L10n.errorCardNotInHand.localized(with: String(id.uuidString.prefix(8)))
        case .notEnoughActions:
            return L10n.errorNotEnoughActions.localized
        case .invalidTarget:
            return L10n.errorInvalidTarget.localized
        }
    }
}

// MARK: - State Change

/// A single state change from an action
public enum StateChange: Equatable {
    // Player changes
    case healthChanged(delta: Int, newValue: Int)
    case faithChanged(delta: Int, newValue: Int)
    case balanceChanged(delta: Int, newValue: Int)
    case strengthChanged(delta: Int, newValue: Int)

    // World changes
    case tensionChanged(delta: Int, newValue: Int)
    case dayAdvanced(newDay: Int)
    case regionChanged(regionId: UUID)
    case regionStateChanged(regionId: UUID, newState: String)
    case anchorIntegrityChanged(anchorId: UUID, delta: Int, newValue: Int)

    // Flags and progress
    case flagSet(key: String, value: Bool)
    case questProgressed(questId: String, newStage: Int)
    case eventCompleted(eventId: UUID)
    case questStarted(questId: String)
    case objectiveCompleted(questId: String, objectiveId: String)
    case questCompleted(questId: String)
    case questFailed(questId: String)

    // Cards and deck
    case cardAdded(cardId: UUID, zone: String)
    case cardRemoved(cardId: UUID, zone: String)
    case cardMoved(cardId: UUID, fromZone: String, toZone: String)

    // Combat
    case enemyDamaged(enemyId: UUID, damage: Int, newHealth: Int)
    case enemyDefeated(enemyId: UUID)
    case combatEnded(victory: Bool)

    // Custom
    case custom(key: String, description: String)
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Core/TwilightGameEngine.swift
// ==========================================

import Foundation
import Combine

// MARK: - Twilight Marches Game Engine
// The central game orchestrator - ALL game actions go through here

/// Main game engine for Twilight Marches
/// UI should NEVER mutate state directly - always go through performAction()
public final class TwilightGameEngine: ObservableObject {

    // MARK: - Published State (for UI binding)
    // Audit v1.1 Issue #1, #8: UI reads directly from Engine, not WorldState

    /// Current in-game day number
    @Published public private(set) var currentDay: Int = 0
    /// World tension level (0-100), drives degradation and difficulty
    @Published public private(set) var worldTension: Int = 30
    /// UUID of the region the player is currently in
    @Published public private(set) var currentRegionId: UUID?
    /// Whether the game has ended (victory or defeat)
    @Published public private(set) var isGameOver: Bool = false
    /// Result of the game if it has ended
    @Published public private(set) var gameResult: GameEndResult?

    /// UUID of the event currently being presented to the player
    @Published public private(set) var currentEventId: UUID?
    /// Whether the player is currently in combat
    @Published public private(set) var isInCombat: Bool = false

    /// Result of the last performed action
    @Published public private(set) var lastActionResult: ActionResult?

    // MARK: - Published State for UI (Engine-First Architecture)

    /// All regions with their current state - UI reads this directly
    @Published public private(set) var publishedRegions: [UUID: EngineRegionState] = [:]

    /// Player stats - UI reads these directly instead of Player model
    @Published public private(set) var playerHealth: Int = 10
    @Published public private(set) var playerMaxHealth: Int = 10
    @Published public private(set) var playerFaith: Int = 3
    @Published public private(set) var playerMaxFaith: Int = 10
    @Published public private(set) var playerBalance: Int = 50
    @Published public private(set) var playerName: String = "Ð“ÐµÑ€Ð¾Ð¹"
    @Published public private(set) var heroId: String?  // Hero definition ID for data-driven hero system

    /// Character stats (Engine-First) - used for combat calculations
    @Published public private(set) var playerStrength: Int = 5
    @Published public private(set) var playerDexterity: Int = 0
    @Published public private(set) var playerConstitution: Int = 0
    @Published public private(set) var playerIntelligence: Int = 0
    @Published public private(set) var playerWisdom: Int = 0
    @Published public private(set) var playerCharisma: Int = 0

    /// Active curses on player (Engine-First)
    @Published public private(set) var playerActiveCurses: [ActiveCurse] = []

    /// World flags - for quest/event conditions
    @Published public private(set) var publishedWorldFlags: [String: Bool] = [:]

    /// Current event being displayed to player
    @Published public private(set) var currentEvent: GameEvent?

    /// Day event notification (tension increase, degradation, etc.)
    @Published public private(set) var lastDayEvent: DayEvent?

    /// Active quests
    @Published public private(set) var publishedActiveQuests: [Quest] = []

    /// Event log (last 100 entries)
    @Published public private(set) var publishedEventLog: [EventLogEntry] = []

    /// Light/Dark balance of the world
    @Published public private(set) var lightDarkBalance: Int = 50

    /// Main quest stage (1-5)
    @Published public private(set) var mainQuestStage: Int = 1

    // MARK: - UI Convenience Accessors (Engine-First Architecture)

    /// Get regions as sorted array for UI iteration
    public var regionsArray: [EngineRegionState] {
        publishedRegions.values.sorted { $0.name < $1.name }
    }

    /// Get current region
    public var currentRegion: EngineRegionState? {
        guard let id = currentRegionId else { return nil }
        return publishedRegions[id]
    }

    /// Check if player can afford faith cost
    public func canAffordFaith(_ cost: Int) -> Bool {
        return playerFaith >= cost
    }

    /// Check if region is neighbor to current region
    public func isNeighbor(regionId: UUID) -> Bool {
        guard let current = currentRegion else { return false }
        return current.neighborIds.contains(regionId)
    }

    /// Calculate travel cost to target region (1 = neighbor, 2 = distant)
    public func calculateTravelCost(to targetId: UUID) -> Int {
        return isNeighbor(regionId: targetId) ? 1 : 2
    }

    /// Check if travel to region is allowed (only neighbors allowed)
    public func canTravelTo(regionId: UUID) -> Bool {
        guard regionId != currentRegionId else { return false }
        return isNeighbor(regionId: regionId)
    }

    /// Get neighboring region names that connect to target (for routing hints)
    public func getRoutingHint(to targetId: UUID) -> [String] {
        guard let current = currentRegion else { return [] }

        // If already neighbor, no hint needed
        if current.neighborIds.contains(targetId) { return [] }

        // Find which neighbors connect to target
        var connectingNeighbors: [String] = []
        for neighborId in current.neighborIds {
            guard let neighbor = regions[neighborId] else { continue }
            if neighbor.neighborIds.contains(targetId) {
                connectingNeighbors.append(neighbor.name)
            }
        }

        return connectingNeighbors
    }

    /// Player balance description for UI
    public var playerBalanceDescription: String {
        switch playerBalance {
        case 70...100: return "Ð¡Ð²ÐµÑ‚"
        case 31..<70: return "Ð Ð°Ð²Ð½Ð¾Ð²ÐµÑÐ¸Ðµ"
        default: return "Ð¢ÑŒÐ¼Ð°"
        }
    }

    // MARK: - Hero Abilities (Engine-First)

    /// Get hero definition from registry
    public var heroDefinition: HeroDefinition? {
        guard let heroId = heroId else { return nil }
        return HeroRegistry.shared.hero(id: heroId)
    }

    /// Get hero's special ability
    private var heroAbility: HeroAbility? {
        return heroDefinition?.specialAbility
    }

    /// Check if player has a specific curse (Engine-First)
    public func hasCurse(_ type: CurseType) -> Bool {
        return playerActiveCurses.contains { $0.type == type }
    }

    /// Get damage modifier from curses (weakness: -1, shadowOfNav: +3)
    public func getCurseDamageDealtModifier() -> Int {
        var modifier = 0
        if hasCurse(.weakness) { modifier -= 1 }
        if hasCurse(.shadowOfNav) { modifier += 3 }
        return modifier
    }

    /// Get damage taken modifier from curses (fear: +1)
    public func getCurseDamageTakenModifier() -> Int {
        var modifier = 0
        if hasCurse(.fear) { modifier += 1 }
        return modifier
    }

    /// Get bonus dice from hero ability (e.g., Tracker on first attack)
    public func getHeroBonusDice(isFirstAttack: Bool) -> Int {
        guard let ability = heroAbility,
              ability.trigger == .onAttack else { return 0 }

        // Check ability condition
        if let condition = ability.condition {
            switch condition.type {
            case .firstAttack:
                guard isFirstAttack else { return 0 }
            default:
                break
            }
        }

        return ability.effects.first { $0.type == .bonusDice }?.value ?? 0
    }

    /// Get bonus damage from hero ability (e.g., Berserker when HP < 50%)
    public func getHeroDamageBonus(targetFullHP: Bool = false) -> Int {
        guard let ability = heroAbility,
              ability.trigger == .onDamageDealt else { return 0 }

        // Check ability condition
        if let condition = ability.condition {
            switch condition.type {
            case .hpBelowPercent:
                let threshold = condition.value ?? 50
                guard playerHealth < playerMaxHealth * threshold / 100 else { return 0 }
            case .targetFullHP:
                guard targetFullHP else { return 0 }
            default:
                break
            }
        }

        return ability.effects.first { $0.type == .bonusDamage }?.value ?? 0
    }

    /// Get damage reduction from hero ability (e.g., Priest vs dark sources)
    public func getHeroDamageReduction(fromDarkSource: Bool = false) -> Int {
        guard let ability = heroAbility,
              ability.trigger == .onDamageReceived else { return 0 }

        // Check ability condition
        if let condition = ability.condition {
            switch condition.type {
            case .damageSourceDark:
                guard fromDarkSource else { return 0 }
            default:
                break
            }
        }

        return ability.effects.first { $0.type == .damageReduction }?.value ?? 0
    }

    /// Check if hero gains faith at end of turn (e.g., Mage meditation)
    public var shouldGainFaithEndOfTurn: Bool {
        guard let ability = heroAbility,
              ability.trigger == .turnEnd else { return false }
        return ability.effects.contains { $0.type == .gainFaith }
    }

    /// Calculate total damage dealt with curses and hero abilities
    public func calculateDamageDealt(_ baseDamage: Int, targetFullHP: Bool = false) -> Int {
        let curseModifier = getCurseDamageDealtModifier()
        let heroBonus = getHeroDamageBonus(targetFullHP: targetFullHP)
        return max(0, baseDamage + curseModifier + heroBonus)
    }

    /// Take damage with curse modifiers and hero abilities
    public func takeDamageWithModifiers(_ baseDamage: Int, fromDarkSource: Bool = false) {
        let curseModifier = getCurseDamageTakenModifier()
        let heroReduction = getHeroDamageReduction(fromDarkSource: fromDarkSource)
        let actualDamage = max(0, baseDamage + curseModifier - heroReduction)
        playerHealth = max(0, playerHealth - actualDamage)
    }

    /// Apply curse to player (Engine-First)
    public func applyCurse(type: CurseType, duration: Int, sourceCard: String? = nil) {
        let curse = ActiveCurse(type: type, duration: duration, sourceCard: sourceCard)
        playerActiveCurses.append(curse)
    }

    /// Remove curse from player (Engine-First)
    public func removeCurse(type: CurseType? = nil) {
        if let specificType = type {
            playerActiveCurses.removeAll { $0.type == specificType }
        } else if !playerActiveCurses.isEmpty {
            playerActiveCurses.removeFirst()
        }
    }

    /// Tick curses at end of turn (reduce duration, remove expired)
    public func tickCurses() {
        for i in (0..<playerActiveCurses.count).reversed() {
            playerActiveCurses[i].duration -= 1
            if playerActiveCurses[i].duration <= 0 {
                playerActiveCurses.remove(at: i)
            }
        }
    }

    /// World balance description
    public var worldBalanceDescription: String {
        switch lightDarkBalance {
        case 70...100: return "Ð¯Ð²ÑŒ ÑÐ¸Ð»ÑŒÐ½Ð°"
        case 31..<70: return "Ð¡ÑƒÐ¼Ñ€Ð°Ðº"
        default: return "ÐÐ°Ð²ÑŒ Ð½Ð°ÑÑ‚ÑƒÐ¿Ð°ÐµÑ‚"
        }
    }

    /// Check if region can rest
    public func canRestInCurrentRegion() -> Bool {
        guard let region = currentRegion else { return false }
        return region.state == .stable
    }

    /// Check if region can trade
    public func canTradeInCurrentRegion() -> Bool {
        guard let region = currentRegion else { return false }
        return region.canTrade
    }

    /// Check if exploration can find events in current region
    public func hasAvailableEventsInCurrentRegion() -> Bool {
        guard let regionId = currentRegionId,
              let region = publishedRegions[regionId] else { return false }

        // Engine-First: check content registry for events in this region
        // Use definitionId (from pack manifest) not type.rawValue
        let regionDefId = region.definitionId

        // Map region state to string for content registry
        let regionStateString = mapRegionStateToString(region.state)

        let events = contentRegistry.getAvailableEvents(
            forRegion: regionDefId,
            pressure: worldTension,
            regionState: regionStateString
        )

        // Also filter out completed one-time events (by definition ID)
        let availableEvents = events.filter { eventDef in
            if eventDef.isOneTime {
                return !completedEventIds.contains(eventDef.id)
            }
            return true
        }

        return !availableEvents.isEmpty
    }

    /// Map RegionState to string for ContentRegistry queries
    private func mapRegionStateToString(_ state: RegionState) -> String {
        switch state {
        case .stable: return "stable"
        case .borderland: return "borderland"
        case .breach: return "breach"
        }
    }

    // MARK: - Core Subsystems

    private let timeEngine: TimeEngine
    private let pressureEngine: PressureEngine
    private let economyManager: EconomyManager
    private let questTriggerEngine: QuestTriggerEngine

    // MARK: - Internal State

    private var regions: [UUID: EngineRegionState] = [:]
    private var completedEventIds: Set<String> = []  // Definition IDs (Epic 3: Stable IDs)
    private var worldFlags: [String: Bool] = [:]
    private var questStages: [String: Int] = [:]

    /// All events in the game (from ContentProvider)
    private var allEvents: [GameEvent] = []

    /// Active quests
    private var activeQuests: [Quest] = []

    /// Completed quest IDs
    private var completedQuestIds: Set<String> = []

    /// Event log
    private var eventLog: [EventLogEntry] = []

    /// Player deck (for save/load)
    private var _playerDeck: [Card] = []
    /// Public read-only accessor for deck (for testing/UI)
    public var playerDeck: [Card] { _playerDeck }

    /// Player's hand cards (Published for UI binding)
    @Published public private(set) var playerHand: [Card] = []

    private var _playerDiscard: [Card] = []
    /// Public read-only accessor for discard pile (for testing/UI)
    public var playerDiscard: [Card] { _playerDiscard }

    // MARK: - Combat State

    /// Current enemy card in combat
    @Published public private(set) var combatEnemy: Card?

    /// Enemy current health
    @Published public private(set) var combatEnemyHealth: Int = 0

    /// Combat actions remaining this turn
    @Published public private(set) var combatActionsRemaining: Int = 3

    /// Combat turn number
    @Published public private(set) var combatTurnNumber: Int = 1

    /// Bonus dice for next attack (from cards)
    private var combatBonusDice: Int = 0

    /// Bonus damage for next attack (from cards)
    private var combatBonusDamage: Int = 0

    /// Is this the first attack in this combat (for abilities)
    private var combatIsFirstAttack: Bool = true

    // MARK: - Content Registry

    /// Content registry for loading content packs
    private let contentRegistry: ContentRegistry

    /// Balance configuration from content pack
    private var balanceConfig: BalanceConfiguration

    // MARK: - Configuration Constants (from BalanceConfiguration)

    private var tensionTickInterval: Int { balanceConfig.pressure.effectiveTickInterval }
    private var restHealAmount: Int { balanceConfig.resources.restHealAmount ?? 3 }
    private var anchorStrengthenCost: Int { balanceConfig.anchor.strengthenCost }
    private var anchorStrengthenAmount: Int { balanceConfig.anchor.strengthenAmount }

    // MARK: - Initialization

    /// Initialize engine with a content registry for loading game data
    public init(registry: ContentRegistry = .shared) {
        self.contentRegistry = registry
        self.balanceConfig = registry.getBalanceConfig() ?? .default
        self.timeEngine = TimeEngine(thresholdInterval: 3)
        self.pressureEngine = PressureEngine(rules: TwilightPressureRules())
        self.economyManager = EconomyManager()
        self.questTriggerEngine = QuestTriggerEngine(contentRegistry: registry)
    }

    // MARK: - Setup

    /// Reset critical game state flags (called when starting new game or loading save)
    public func resetGameState() {
        isGameOver = false
        gameResult = nil
        currentEventId = nil
        currentEvent = nil
        lastDayEvent = nil
        isInCombat = false
        combatEnemy = nil
        combatEnemyHealth = 0
        combatTurnNumber = 0
    }

    // MARK: - Engine-First Initialization

    /// Initialize a new game without legacy WorldState
    /// This is the Engine-First way to start a game
    /// - Parameters:
    ///   - playerName: Character name for display
    ///   - heroId: Hero definition ID from HeroRegistry (data-driven hero system)
    ///   - startingDeck: Starting deck of cards (from CardRegistry.startingDeck)
    public func initializeNewGame(playerName: String = "Ð“ÐµÑ€Ð¾Ð¹", heroId: String? = nil, startingDeck: [Card] = []) {
        // Reset state
        isGameOver = false
        gameResult = nil
        currentEventId = nil
        currentEvent = nil
        lastDayEvent = nil
        isInCombat = false

        // Load balance config from content registry
        balanceConfig = contentRegistry.getBalanceConfig() ?? .default

        // Setup player from balance config and hero definition
        self.playerName = playerName
        self.heroId = heroId

        // Get hero stats from HeroRegistry if available
        if let heroId = heroId,
           let heroDef = HeroRegistry.shared.hero(id: heroId) {
            let stats = heroDef.baseStats
            playerHealth = stats.health
            playerMaxHealth = stats.maxHealth
            playerFaith = stats.faith
            playerMaxFaith = stats.maxFaith
            playerBalance = stats.startingBalance
            playerStrength = stats.strength
            playerDexterity = stats.dexterity
            playerConstitution = stats.constitution
            playerIntelligence = stats.intelligence
            playerWisdom = stats.wisdom
            playerCharisma = stats.charisma
        } else {
            // Default values from balance config
            playerHealth = balanceConfig.resources.startingHealth
            playerMaxHealth = balanceConfig.resources.maxHealth
            playerFaith = balanceConfig.resources.startingFaith
            playerMaxFaith = balanceConfig.resources.maxFaith
            playerBalance = 50
            playerStrength = 5
            playerDexterity = 0
            playerConstitution = 0
            playerIntelligence = 0
            playerWisdom = 0
            playerCharisma = 0
        }

        // Clear curses
        playerActiveCurses = []

        // Setup starting deck
        if !startingDeck.isEmpty {
            _playerDeck = startingDeck
            WorldRNG.shared.shuffle(&_playerDeck)
        }

        // Setup world from balance config
        currentDay = 0
        worldTension = balanceConfig.pressure.startingPressure
        lightDarkBalance = 50
        mainQuestStage = 1
        worldFlags = [:]
        completedEventIds = []
        completedQuestIds = []
        eventLog = []

        // Load regions from ContentRegistry
        setupRegionsFromRegistry()

        // Load events
        allEvents = createInitialEvents()

        // Load quests and start main quest
        let initialQuests = createInitialQuests()
        if let mainQuest = initialQuests.first(where: { $0.questType == .main }) {
            activeQuests = [mainQuest]
        }

        // Setup pressure engine
        pressureEngine.setPressure(worldTension)
        pressureEngine.syncTriggeredThresholdsFromPressure()

        // Update all published state
        updatePublishedState()
    }

    /// Setup regions from ContentProvider
    private func setupRegionsFromProvider(_ provider: ContentProvider) {
        let regionDefs = provider.getAllRegionDefinitions()
        var newRegions: [UUID: EngineRegionState] = [:]
        var stringToUUID: [String: UUID] = [:]  // Map string IDs to UUIDs

        // CRITICAL: Reset currentRegionId before creating new regions
        // This fixes a bug where old UUID from previous game could persist
        currentRegionId = nil

        // Determine entry region from manifest (no hardcoded entry point)
        let entryRegionId = contentRegistry.loadedPacks.values.first(where: { $0.manifest.entryRegionId != nil })?.manifest.entryRegionId

        // First pass: create regions and map IDs
        for def in regionDefs {
            let regionUUID = UUID()
            stringToUUID[def.id] = regionUUID

            let anchor = createEngineAnchor(from: provider.getAnchorDefinition(forRegion: def.id))
            let regionType = mapRegionType(fromString: def.regionType)
            let regionState = mapRegionState(def.initialState)

            let engineRegion = EngineRegionState(
                id: regionUUID,
                definitionId: def.id,  // Set definition ID for event lookup
                name: def.title.localized,
                type: regionType,
                state: regionState,
                anchor: anchor,
                neighborIds: [],  // Will be set in second pass
                neighborDefinitionIds: def.neighborIds,
                canTrade: regionState == .stable && regionType == .settlement
            )
            newRegions[regionUUID] = engineRegion

            // Set starting region from manifest entryRegionId
            if def.id == entryRegionId {
                currentRegionId = regionUUID
            }
        }

        // Second pass: resolve neighbor IDs
        for def in regionDefs {
            guard let regionUUID = stringToUUID[def.id],
                  var region = newRegions[regionUUID] else { continue }

            let neighborUUIDs = def.neighborIds.compactMap { stringToUUID[$0] }
            region = EngineRegionState(
                id: region.id,
                definitionId: region.definitionId,  // Preserve definition ID
                name: region.name,
                type: region.type,
                state: region.state,
                anchor: region.anchor,
                neighborIds: neighborUUIDs,
                neighborDefinitionIds: region.neighborDefinitionIds,
                canTrade: region.canTrade,
                visited: region.visited,
                reputation: region.reputation
            )
            newRegions[regionUUID] = region
        }

        regions = newRegions
        publishedRegions = newRegions
    }

    /// Setup regions from ContentRegistry (Engine-First architecture)
    private func setupRegionsFromRegistry() {
        let regionDefs = contentRegistry.getAllRegions()
        var newRegions: [UUID: EngineRegionState] = [:]
        var stringToUUID: [String: UUID] = [:]  // Map string IDs to UUIDs

        // CRITICAL: Reset currentRegionId before creating new regions
        // This fixes a bug where old UUID from previous game could persist
        currentRegionId = nil

        // Determine entry region from loaded pack manifest (no hardcoded fallback)
        let entryRegionId = contentRegistry.loadedPacks.values.first(where: { $0.manifest.entryRegionId != nil })?.manifest.entryRegionId

        // First pass: create regions and map IDs
        for def in regionDefs {
            let regionUUID = UUID()
            stringToUUID[def.id] = regionUUID

            let anchor = contentRegistry.getAnchor(forRegion: def.id).map { anchorDef in
                EngineAnchorState(
                    id: UUID(),
                    definitionId: anchorDef.id,
                    name: anchorDef.title.localized,
                    integrity: anchorDef.initialIntegrity
                )
            }

            let regionType = mapRegionType(fromString: def.regionType)
            let regionState = mapRegionState(def.initialState)

            let engineRegion = EngineRegionState(
                id: regionUUID,
                definitionId: def.id,  // CRITICAL: Set definition ID for event lookup
                name: def.title.localized,
                type: regionType,
                state: regionState,
                anchor: anchor,
                neighborIds: [],  // Will be set in second pass
                neighborDefinitionIds: def.neighborIds,
                canTrade: regionState == .stable && regionType == .settlement
            )
            newRegions[regionUUID] = engineRegion

            // Set starting region
            if def.id == entryRegionId {
                currentRegionId = regionUUID
            }
        }

        // Second pass: resolve neighbor IDs
        for def in regionDefs {
            guard let regionUUID = stringToUUID[def.id],
                  var region = newRegions[regionUUID] else { continue }

            let neighborUUIDs = def.neighborIds.compactMap { stringToUUID[$0] }
            region = EngineRegionState(
                id: region.id,
                definitionId: region.definitionId,  // Preserve definition ID
                name: region.name,
                type: region.type,
                state: region.state,
                anchor: region.anchor,
                neighborIds: neighborUUIDs,
                neighborDefinitionIds: region.neighborDefinitionIds,
                canTrade: region.canTrade,
                visited: region.visited,
                reputation: region.reputation
            )
            newRegions[regionUUID] = region
        }

        regions = newRegions
        publishedRegions = newRegions

        // Set first region as current if none set â€” prefer stable region
        if currentRegionId == nil {
            currentRegionId = newRegions.values.first(where: { $0.state == .stable })?.id
                ?? newRegions.values.first(where: { $0.state != .breach })?.id
                ?? newRegions.keys.first
        }
    }

    /// Create EngineAnchorState from AnchorDefinition
    private func createEngineAnchor(from def: AnchorDefinition?) -> EngineAnchorState? {
        guard let def = def else { return nil }
        return EngineAnchorState(
            id: UUID(),
            definitionId: def.id,
            name: def.title.localized,
            integrity: def.initialIntegrity
        )
    }

    /// Resolve neighbor region IDs from string IDs to UUIDs
    private func resolveNeighborIds(_ neighborStringIds: [String], from defs: [RegionDefinition]) -> [UUID] {
        // This would need to be implemented properly with a mapping
        // For now, return empty - neighbors will be set up separately
        return []
    }

    /// Map region type string from ContentPack to RegionType enum
    /// Uses RegionType(rawValue:) â€” no hardcoded game-specific strings in Engine
    private func mapRegionType(fromString typeString: String) -> RegionType {
        RegionType(rawValue: typeString.lowercased()) ?? .settlement
    }

    /// Map RegionStateType to RegionState
    private func mapRegionState(_ stateType: RegionStateType) -> RegionState {
        switch stateType {
        case .stable: return .stable
        case .borderland: return .borderland
        case .breach: return .breach
        }
    }

    /// Create initial events from ContentRegistry
    private func createInitialEvents() -> [GameEvent] {
        return contentRegistry.getAllEvents().map { $0.toGameEvent() }
    }

    /// Create initial quests from ContentRegistry
    private func createInitialQuests() -> [Quest] {
        return contentRegistry.getAllQuests().map { $0.toQuest() }
    }

    // MARK: - Main Action Entry Point

    /// Perform a game action - THE ONLY WAY to change game state
    /// Returns result with all state changes
    @discardableResult
    public func performAction(_ action: TwilightGameAction) -> ActionResult {
        // 0. Pre-validation
        guard !isGameOver else {
            return .failure(.gameNotInProgress)
        }

        // 1. Validate action
        let validationResult = validateAction(action)
        if let error = validationResult {
            return .failure(error)
        }

        // 2. Calculate actual time cost
        let timeCost = calculateTimeCost(for: action)

        // 3. Execute action and collect state changes
        var stateChanges: [StateChange] = []
        var triggeredEvents: [UUID] = []
        var newCurrentEvent: UUID? = nil
        var combatStarted = false

        // 4. Advance time (if action costs time)
        if timeCost > 0 {
            let timeChanges = advanceTime(by: timeCost)
            stateChanges.append(contentsOf: timeChanges)
        }

        // 5. Execute action-specific logic
        switch action {
        case .travel(let toRegionId):
            let (changes, events) = executeTravel(to: toRegionId)
            stateChanges.append(contentsOf: changes)
            triggeredEvents.append(contentsOf: events)
            if let event = events.first {
                newCurrentEvent = event
            }

        case .rest:
            let changes = executeRest()
            stateChanges.append(contentsOf: changes)

        case .explore:
            let (changes, events) = executeExplore()
            stateChanges.append(contentsOf: changes)
            triggeredEvents.append(contentsOf: events)
            if let event = events.first {
                newCurrentEvent = event
            }

        case .trade:
            // Trade handled by UI directly for now (market system)
            break

        case .strengthenAnchor:
            let changes = executeStrengthenAnchor()
            stateChanges.append(contentsOf: changes)

        case .chooseEventOption(let eventId, let choiceIndex):
            let changes = executeEventChoice(eventId: eventId, choiceIndex: choiceIndex)
            stateChanges.append(contentsOf: changes)
            currentEventId = nil

        case .resolveMiniGame(let input):
            let changes = executeMiniGameInput(input)
            stateChanges.append(contentsOf: changes)

        case .startCombat:
            combatStarted = true
            isInCombat = true
            combatTurnNumber = 1
            combatActionsRemaining = 3
            combatBonusDice = 0
            combatBonusDamage = 0
            combatIsFirstAttack = true
            // Enemy setup done when combat view appears

        case .combatInitialize:
            // Shuffle deck and draw initial hand
            // First, return all cards from hand and discard back to deck
            _playerDeck.append(contentsOf: playerHand)
            _playerDeck.append(contentsOf: _playerDiscard)
            playerHand.removeAll()
            _playerDiscard.removeAll()
            // Now shuffle and draw
            WorldRNG.shared.shuffle(&_playerDeck)
            let drawCount = min(5, _playerDeck.count)  // Default hand size = 5
            playerHand = Array(_playerDeck.prefix(drawCount))
            _playerDeck.removeFirst(drawCount)
            combatActionsRemaining = 3

        case .combatAttack(let bonusDice, let bonusDamage, let isFirstAttack):
            guard combatActionsRemaining > 0 else { break }
            combatActionsRemaining -= 1
            let changes = executeCombatAttack(bonusDice: bonusDice, bonusDamage: bonusDamage, isFirstAttack: isFirstAttack)
            stateChanges.append(contentsOf: changes)
            combatIsFirstAttack = false
            // Check if enemy defeated
            if combatEnemyHealth <= 0 {
                // Victory will be handled by combatFinish
            }

        case .playCard(let cardId, _):
            guard combatActionsRemaining > 0 else { break }
            if let cardIndex = playerHand.firstIndex(where: { $0.id == cardId }) {
                let card = playerHand[cardIndex]
                // Check faith cost
                if let cost = card.cost, cost > 0 {
                    guard playerFaith >= cost else { break }
                    playerFaith -= cost
                    stateChanges.append(.faithChanged(delta: -cost, newValue: playerFaith))
                }
                combatActionsRemaining -= 1
                // Move card from hand to discard
                playerHand.remove(at: cardIndex)
                _playerDiscard.append(card)
            }

        case .combatApplyEffect(let effect):
            let changes = executeCombatEffect(effect)
            stateChanges.append(contentsOf: changes)

        case .endCombatTurn:
            // Player ended their turn, enemy attacks next
            break

        case .combatEnemyAttack(let damage):
            // Enemy deals damage to player
            let actualDamage = min(damage, playerHealth)
            playerHealth = max(0, playerHealth - damage)
            stateChanges.append(.healthChanged(delta: -actualDamage, newValue: playerHealth))

        case .combatEndTurnPhase:
            // End of turn: discard hand, draw new cards, restore faith
            // Discard hand to discard pile
            _playerDiscard.append(contentsOf: playerHand)
            playerHand.removeAll()

            // Recycle discard into deck if needed
            if _playerDeck.isEmpty && !_playerDiscard.isEmpty {
                _playerDeck = _playerDiscard
                _playerDiscard.removeAll()
                WorldRNG.shared.shuffle(&_playerDeck)
            }

            // Draw new hand
            let drawCount = min(5, _playerDeck.count)
            playerHand = Array(_playerDeck.prefix(drawCount))
            _playerDeck.removeFirst(drawCount)

            // Restore faith
            playerFaith = min(playerFaith + 1, playerMaxFaith)
            stateChanges.append(.faithChanged(delta: 1, newValue: playerFaith))

            // Reset for next turn
            combatTurnNumber += 1
            combatActionsRemaining = 3
            combatBonusDice = 0
            combatBonusDamage = 0

        case .combatFlee:
            isInCombat = false
            combatEnemy = nil
            stateChanges.append(.combatEnded(victory: false))

        case .combatFinish(let victory):
            isInCombat = false
            combatEnemy = nil
            stateChanges.append(.combatEnded(victory: victory))
            if victory {
                stateChanges.append(.enemyDefeated(enemyId: UUID()))
            }

        case .dismissCurrentEvent:
            currentEvent = nil
            currentEventId = nil

        case .dismissDayEvent:
            lastDayEvent = nil

        case .skipTurn:
            // Just time passes
            break

        case .custom:
            // Custom action handling
            break
        }

        // 6. Check quest progress
        let questChanges = checkQuestProgress()
        stateChanges.append(contentsOf: questChanges)

        // 7. Check end conditions
        if let endResult = checkEndConditions() {
            isGameOver = true
            gameResult = endResult
            return .gameOver(endResult)
        }

        // 8. Update published state for UI
        updatePublishedState()

        // 9. Build and return result
        let result = ActionResult(
            success: true,
            error: nil,
            stateChanges: stateChanges,
            triggeredEvents: triggeredEvents,
            currentEvent: newCurrentEvent,
            combatStarted: combatStarted,
            gameEnded: nil
        )

        lastActionResult = result
        return result
    }

    // MARK: - Validation

    private func validateAction(_ action: TwilightGameAction) -> ActionError? {
        switch action {
        case .travel(let toRegionId):
            return validateTravel(to: toRegionId)

        case .rest:
            return validateRest()

        case .explore:
            if isInCombat { return .combatInProgress }
            return nil

        case .trade:
            return validateTrade()

        case .strengthenAnchor:
            return validateStrengthenAnchor()

        case .chooseEventOption(let eventId, let choiceIndex):
            return validateEventChoice(eventId: eventId, choiceIndex: choiceIndex)

        case .startCombat:
            if isInCombat { return .combatInProgress }
            return nil

        case .playCard, .endCombatTurn:
            if !isInCombat { return .noActiveCombat }
            return nil

        default:
            return nil
        }
    }

    private func validateTravel(to regionId: UUID) -> ActionError? {
        guard let currentId = currentRegionId,
              let currentRegion = regions[currentId] else {
            return .invalidAction(reason: "No current region")
        }

        // Check if target is neighbor
        if !currentRegion.neighborIds.contains(regionId) {
            return .regionNotNeighbor(regionId: regionId)
        }

        // Check if player can travel (health > 0, etc.)
        if playerHealth <= 0 {
            return .healthTooLow
        }

        return nil
    }

    private func validateRest() -> ActionError? {
        guard let currentId = currentRegionId,
              let region = regions[currentId] else {
            return .invalidAction(reason: "No current region")
        }

        // Check if region allows rest
        if region.state == .breach {
            return .actionNotAvailableInRegion(action: "rest", regionType: "breach")
        }

        return nil
    }

    private func validateTrade() -> ActionError? {
        guard let currentId = currentRegionId,
              let region = regions[currentId] else {
            return .invalidAction(reason: "No current region")
        }

        if !region.canTrade {
            return .actionNotAvailableInRegion(action: "trade", regionType: region.type.rawValue)
        }

        return nil
    }

    private func validateStrengthenAnchor() -> ActionError? {
        guard let currentId = currentRegionId,
              let region = regions[currentId] else {
            return .invalidAction(reason: "No current region")
        }

        if region.anchor == nil {
            return .actionNotAvailableInRegion(action: "strengthen anchor", regionType: "no anchor")
        }

        // Check resource cost
        let cost = anchorStrengthenCost
        if playerFaith < cost {
            return .insufficientResources(resource: "faith", required: cost, available: playerFaith)
        }

        return nil
    }

    private func validateEventChoice(eventId: UUID, choiceIndex: Int) -> ActionError? {
        guard currentEventId == eventId else {
            return .eventNotFound(eventId: eventId)
        }

        // Additional choice validation would go here
        return nil
    }

    // MARK: - Time Cost Calculation

    private func calculateTimeCost(for action: TwilightGameAction) -> Int {
        switch action {
        case .travel(let toRegionId):
            guard let currentId = currentRegionId,
                  let currentRegion = regions[currentId] else {
                return 1
            }
            // Neighbor = 1 day, far = 2 days
            return currentRegion.neighborIds.contains(toRegionId) ? 1 : 2

        default:
            return action.timeCost
        }
    }

    // MARK: - Time Advancement

    private func advanceTime(by days: Int) -> [StateChange] {
        var changes: [StateChange] = []

        for _ in 0..<days {
            currentDay += 1
            changes.append(.dayAdvanced(newDay: currentDay))

            // Check tension tick (every 3 days)
            if currentDay > 0 && currentDay % tensionTickInterval == 0 {
                let tensionIncrease = calculateTensionIncrease()
                worldTension = min(100, worldTension + tensionIncrease)
                changes.append(.tensionChanged(delta: tensionIncrease, newValue: worldTension))

                // World degradation
                let degradationChanges = processWorldDegradation()
                changes.append(contentsOf: degradationChanges)
            }
        }

        return changes
    }

    private func calculateTensionIncrease() -> Int {
        // Use TwilightPressureRules as single source of truth (Audit v1.1 Issue #6)
        return TwilightPressureRules.calculateTensionIncrease(daysPassed: currentDay)
    }

    private func processWorldDegradation() -> [StateChange] {
        var changes: [StateChange] = []

        // Degradation probability increases with world tension
        // (probability logic can be used when implementing random degradation checks)

        // Select region to degrade based on weights
        let degradableRegions = regions.values.filter {
            $0.state == .borderland || $0.state == .breach
        }

        guard !degradableRegions.isEmpty else { return changes }

        // Weighted selection using WorldRNG
        let weights = degradableRegions.map { DegradationRules.current.selectionWeight(for: $0.state) }
        let totalWeight = weights.reduce(0, +)

        if totalWeight > 0 {
            let roll = WorldRNG.shared.nextInt(in: 0...(totalWeight - 1))
            var cumulative = 0
            for (index, weight) in weights.enumerated() {
                cumulative += weight
                if roll < cumulative {
                    let region = Array(degradableRegions)[index]

                    // Check anchor resistance using probability
                    let anchorIntegrity = region.anchor?.integrity ?? 0
                    let resistProb = DegradationRules.current.resistanceProbability(anchorIntegrity: anchorIntegrity)
                    let resistRoll = Double(WorldRNG.shared.nextInt(in: 0...99)) / 100.0

                    if resistRoll >= resistProb {
                        // Anchor failed to resist - degrade region
                        if var mutableRegion = regions[region.id] {
                            let newState = degradeState(mutableRegion.state)
                            mutableRegion.state = newState
                            regions[region.id] = mutableRegion
                            changes.append(.regionStateChanged(regionId: region.id, newState: newState.rawValue))
                        }
                    }
                    break
                }
            }
        }

        return changes
    }

    private func degradeState(_ state: RegionState) -> RegionState {
        switch state {
        case .stable: return .borderland
        case .borderland: return .breach
        case .breach: return .breach  // Can't degrade further
        }
    }

    // MARK: - Action Execution

    private func executeTravel(to regionId: UUID) -> ([StateChange], [UUID]) {
        var changes: [StateChange] = []
        let events: [UUID] = []

        // Update current region
        currentRegionId = regionId
        changes.append(.regionChanged(regionId: regionId))

        // Note: Events are NOT auto-generated on arrival.
        // Player must explicitly choose to Explore to trigger events.
        // This allows player to Rest, Trade, or Strengthen Anchor first.

        return (changes, events)
    }

    private func executeRest() -> [StateChange] {
        var changes: [StateChange] = []

        // Heal player
        let healAmount = restHealAmount
        let newHealth = min(playerMaxHealth, playerHealth + healAmount)
        let delta = newHealth - playerHealth
        playerHealth = newHealth
        changes.append(.healthChanged(delta: delta, newValue: newHealth))

        return changes
    }

    private func executeExplore() -> ([StateChange], [UUID]) {
        let changes: [StateChange] = []
        var events: [UUID] = []

        guard let regionId = currentRegionId else {
            return (changes, events)
        }

        // Generate exploration event
        if let event = generateEvent(for: regionId, trigger: .exploration) {
            events.append(event)
            currentEventId = event
        }

        return (changes, events)
    }

    private func executeStrengthenAnchor() -> [StateChange] {
        var changes: [StateChange] = []

        guard let regionId = currentRegionId,
              var region = regions[regionId],
              var anchor = region.anchor else {
            return changes
        }

        // Spend faith
        let cost = anchorStrengthenCost
        playerFaith -= cost
        changes.append(.faithChanged(delta: -cost, newValue: playerFaith))

        // Strengthen anchor
        let strengthAmount = anchorStrengthenAmount
        let newIntegrity = min(100, anchor.integrity + strengthAmount)
        let delta = newIntegrity - anchor.integrity
        anchor.integrity = newIntegrity
        region.anchor = anchor
        regions[regionId] = region

        changes.append(.anchorIntegrityChanged(anchorId: anchor.id, delta: delta, newValue: newIntegrity))

        return changes
    }

    private func executeEventChoice(eventId: UUID, choiceIndex: Int) -> [StateChange] {
        var changes: [StateChange] = []

        // Get consequences from current event
        if let event = currentEvent,
           choiceIndex < event.choices.count {
            let choice = event.choices[choiceIndex]
            changes.append(contentsOf: applyConsequences(choice.consequences))
        }

        // Mark event completed if oneTime (using definition ID for persistence)
        if let defId = currentEvent?.definitionId {
            completedEventIds.insert(defId)
        }
        changes.append(.eventCompleted(eventId: eventId))

        currentEventId = nil

        return changes
    }

    private func executeMiniGameInput(_ input: MiniGameInput) -> [StateChange] {
        var changes: [StateChange] = []

        // Apply bonus rewards
        for (resource, amount) in input.bonusRewards {
            switch resource {
            case "health":
                let newHealth = min(playerMaxHealth, playerHealth + amount)
                playerHealth = newHealth
                changes.append(.healthChanged(delta: amount, newValue: newHealth))
            case "faith":
                let newFaith = playerFaith + amount
                playerFaith = newFaith
                changes.append(.faithChanged(delta: amount, newValue: newFaith))
            default:
                break
            }
        }

        return changes
    }

    // MARK: - Consequences

    private func applyConsequences(_ consequences: EventConsequences) -> [StateChange] {
        var changes: [StateChange] = []

        // Health
        if let healthDelta = consequences.healthChange, healthDelta != 0 {
            let newHealth = max(0, min(playerMaxHealth, playerHealth + healthDelta))
            playerHealth = newHealth
            changes.append(.healthChanged(delta: healthDelta, newValue: newHealth))
        }

        // Faith
        if let faithDelta = consequences.faithChange, faithDelta != 0 {
            let newFaith = max(0, playerFaith + faithDelta)
            playerFaith = newFaith
            changes.append(.faithChanged(delta: faithDelta, newValue: newFaith))
        }

        // Balance
        if let balanceDelta = consequences.balanceChange, balanceDelta != 0 {
            let newBalance = max(0, min(100, playerBalance + balanceDelta))
            playerBalance = newBalance
            changes.append(.balanceChanged(delta: balanceDelta, newValue: newBalance))
        }

        // Tension
        if let tensionDelta = consequences.tensionChange, tensionDelta != 0 {
            worldTension = max(0, min(100, worldTension + tensionDelta))
            changes.append(.tensionChanged(delta: tensionDelta, newValue: worldTension))
        }

        // Flags (setFlags is [String: Bool]?)
        if let flagsToSet = consequences.setFlags {
            for (flag, value) in flagsToSet {
                worldFlags[flag] = value
                changes.append(.flagSet(key: flag, value: value))
            }
        }

        return changes
    }

    // MARK: - Event Generation

    private func generateEvent(for regionId: UUID, trigger: EventTrigger) -> UUID? {
        // Engine-First: generate event from ContentRegistry
        guard let region = publishedRegions[regionId] else {
            return nil
        }
        let regionDefId = region.definitionId

        // Map region state to string for content registry
        let regionStateString = mapRegionStateToString(region.state)

        // Get available events from ContentRegistry
        let availableDefinitions = contentRegistry.getAvailableEvents(
            forRegion: regionDefId,
            pressure: worldTension,
            regionState: regionStateString
        )

        // Filter out completed one-time events (using definition IDs directly)
        let filteredDefinitions = availableDefinitions.filter { eventDef in
            if eventDef.isOneTime {
                return !completedEventIds.contains(eventDef.id)
            }
            return true
        }

        guard !filteredDefinitions.isEmpty else { return nil }

        // Weighted random selection
        let totalWeight = filteredDefinitions.reduce(0) { $0 + $1.weight }
        guard totalWeight > 0 else {
            // If all weights are 0, select randomly
            let selectedDef = filteredDefinitions[WorldRNG.shared.nextInt(in: 0...(filteredDefinitions.count - 1))]
            let gameEvent = selectedDef.toGameEvent(forRegion: regionDefId)
            currentEvent = gameEvent
            return gameEvent.id
        }

        let roll = WorldRNG.shared.nextInt(in: 0...(totalWeight - 1))
        var cumulative = 0
        for eventDef in filteredDefinitions {
            cumulative += eventDef.weight
            if roll < cumulative {
                let gameEvent = eventDef.toGameEvent(forRegion: regionDefId)
                currentEvent = gameEvent
                return gameEvent.id
            }
        }

        // Fallback to first event
        let selectedDef = filteredDefinitions[0]
        let gameEvent = selectedDef.toGameEvent(forRegion: regionDefId)
        currentEvent = gameEvent
        return gameEvent.id
    }

    // MARK: - Quest Progress

    private func checkQuestProgress() -> [StateChange] {
        // Engine-First: quest progress is now managed by QuestTriggerEngine
        // This is called after each action to check for auto-complete conditions
        return []
    }

    /// Process a quest trigger action through the new data-driven QuestTriggerEngine
    private func processQuestTriggerAction(_ action: QuestTriggerAction) -> [StateChange] {
        var changes: [StateChange] = []

        // Build context from current state
        let context = buildQuestTriggerContext()

        // Process through quest trigger engine
        let updates = questTriggerEngine.processAction(action, context: context)

        // Apply updates
        for update in updates {
            switch update.type {
            case .questStarted:
                // Start new quest
                if let questDef = contentRegistry.getQuest(id: update.questId) {
                    let quest = questDef.toQuest()
                    activeQuests.append(quest)
                    publishedActiveQuests = activeQuests
                    changes.append(.questStarted(questId: update.questId))
                }

            case .objectiveCompleted:
                // Update quest progress
                if let index = activeQuests.firstIndex(where: { $0.id.uuidString == update.questId || String(describing: $0.id) == update.questId }),
                   let objectiveId = update.objectiveId {
                    // Mark objective as completed
                    changes.append(.objectiveCompleted(questId: update.questId, objectiveId: objectiveId))

                    // Set flags
                    for flag in update.flagsToSet {
                        worldFlags[flag] = true
                        publishedWorldFlags = worldFlags
                        changes.append(.flagSet(key: flag, value: true))
                    }

                    // Check if quest completed (no next objective)
                    if update.nextObjectiveId == nil {
                        activeQuests[index].completed = true
                        completedQuestIds.insert(update.questId)
                        changes.append(.questCompleted(questId: update.questId))
                    }
                }

            case .questCompleted:
                // Quest fully completed
                completedQuestIds.insert(update.questId)
                changes.append(.questCompleted(questId: update.questId))

            case .questFailed:
                // Quest failed
                changes.append(.questFailed(questId: update.questId))
            }
        }

        return changes
    }

    /// Build QuestTriggerContext from current engine state
    private func buildQuestTriggerContext() -> QuestTriggerContext {
        // Build active quest states
        let questStates = activeQuests.compactMap { quest -> QuestState? in
            guard let questDef = contentRegistry.getQuest(id: quest.definitionId) else {
                return nil
            }

            // Determine current objective (simplified - uses stage)
            let currentObjectiveId = questDef.objectives.indices.contains(quest.stage - 1)
                ? questDef.objectives[quest.stage - 1].id
                : questDef.objectives.first?.id

            // Completed objectives are those before current stage
            let completedIds = Set(questDef.objectives.prefix(max(0, quest.stage - 1)).map { $0.id })

            return QuestState(
                definitionId: questDef.id,
                currentObjectiveId: currentObjectiveId,
                completedObjectiveIds: completedIds
            )
        }

        // Build resources dictionary
        let resources: [String: Int] = [
            "health": playerHealth,
            "faith": playerFaith,
            "balance": playerBalance,
            "tension": worldTension
        ]

        // Get current region ID as string
        let currentRegionStringId: String
        if let regionId = currentRegionId,
           let region = regions[regionId] {
            // Try to find matching definition by name
            if let def = contentRegistry.getAllRegions().first(where: { $0.title.localized == region.name }) {
                currentRegionStringId = def.id
            } else {
                currentRegionStringId = regionId.uuidString
            }
        } else {
            currentRegionStringId = ""
        }

        return QuestTriggerContext(
            activeQuests: questStates,
            completedQuestIds: completedQuestIds,
            worldFlags: worldFlags,
            resources: resources,
            currentDay: currentDay,
            currentRegionId: currentRegionStringId
        )
    }

    // MARK: - End Conditions

    private func checkEndConditions() -> GameEndResult? {
        // Defeat: tension 100%
        if worldTension >= 100 {
            return .defeat(reason: "ÐÐ°Ð¿Ñ€ÑÐ¶ÐµÐ½Ð¸Ðµ Ð¼Ð¸Ñ€Ð° Ð´Ð¾ÑÑ‚Ð¸Ð³Ð»Ð¾ Ð¼Ð°ÐºÑÐ¸Ð¼ÑƒÐ¼Ð°")
        }

        // Defeat: health 0
        if playerHealth <= 0 {
            return .defeat(reason: "Ð“ÐµÑ€Ð¾Ð¹ Ð¿Ð¾Ð³Ð¸Ð±")
        }

        // Victory: main quest completed (flag from BalanceConfiguration)
        if let victoryFlag = balanceConfig.endConditions.mainQuestCompleteFlag,
           worldFlags[victoryFlag] == true {
            return .victory(endingId: "main_quest_complete")
        }

        return nil
    }

    // syncToLegacy removed - Engine-First architecture

    // MARK: - Published State Update (Engine-First Architecture)

    /// Update all published properties from internal state
    /// Called after actions to keep UI in sync
    private func updatePublishedState() {
        // Update regions
        publishedRegions = regions

        // Update flags
        publishedWorldFlags = worldFlags

        // Update quests and log
        publishedActiveQuests = activeQuests
        publishedEventLog = Array(eventLog.suffix(100))

        // Clear current event if currentEventId is nil
        if currentEventId == nil {
            currentEvent = nil
        }
        // Note: currentEvent is set directly when generating events
        // Player stats are managed directly by the engine
    }

    // MARK: - Event Log

    /// Add entry to event log
    public func addLogEntry(
        regionName: String,
        eventTitle: String,
        choiceMade: String,
        outcome: String,
        type: EventLogType
    ) {
        let entry = EventLogEntry(
            dayNumber: currentDay,
            regionName: regionName,
            eventTitle: eventTitle,
            choiceMade: choiceMade,
            outcome: outcome,
            type: type
        )
        eventLog.append(entry)

        // Trim log to 100 entries
        if eventLog.count > 100 {
            eventLog.removeFirst(eventLog.count - 100)
        }

        publishedEventLog = eventLog
    }

    // MARK: - Day Events

    /// Trigger day event (tension increase, degradation, etc.)
    private func triggerDayEvent(_ event: DayEvent) {
        lastDayEvent = event
    }

    // MARK: - Combat Helper Methods

    /// Execute a combat attack with bonus dice and damage
    private func executeCombatAttack(bonusDice: Int, bonusDamage: Int, isFirstAttack: Bool) -> [StateChange] {
        var changes: [StateChange] = []

        guard let enemy = combatEnemy else {
            return changes
        }

        let monsterDef = enemy.defense ?? 10
        let monsterCurrentHP = combatEnemyHealth
        let monsterMaxHP = enemy.health ?? 10

        // Use CombatCalculator for attack calculation (Engine-First)
        let result = CombatCalculator.calculateAttackEngineFirst(
            engine: self,
            monsterDefense: monsterDef,
            monsterCurrentHP: monsterCurrentHP,
            monsterMaxHP: monsterMaxHP,
            bonusDice: bonusDice + combatBonusDice,
            bonusDamage: bonusDamage + combatBonusDamage,
            isFirstAttack: isFirstAttack
        )

        if result.isHit, let damageCalc = result.damageCalculation {
            let damage = damageCalc.total
            combatEnemyHealth = max(0, combatEnemyHealth - damage)
            changes.append(.enemyDamaged(enemyId: enemy.id, damage: damage, newHealth: combatEnemyHealth))
        }

        // Reset bonuses after attack
        combatBonusDice = 0
        combatBonusDamage = 0

        return changes
    }

    /// Execute a combat effect from card or ability
    private func executeCombatEffect(_ effect: CombatActionEffect) -> [StateChange] {
        var changes: [StateChange] = []

        switch effect {
        case .heal(let amount):
            let newHealth = min(playerMaxHealth, playerHealth + amount)
            let delta = newHealth - playerHealth
            playerHealth = newHealth
            changes.append(.healthChanged(delta: delta, newValue: newHealth))

        case .damageEnemy(let amount):
            if let enemy = combatEnemy {
                let actualDamage = calculateDamageDealt(amount)
                combatEnemyHealth = max(0, combatEnemyHealth - actualDamage)
                changes.append(.enemyDamaged(enemyId: enemy.id, damage: actualDamage, newHealth: combatEnemyHealth))
            }

        case .drawCards(let count):
            drawCardsEngineFirst(count: count)

        case .gainFaith(let amount):
            playerFaith = min(playerFaith + amount, playerMaxFaith)
            changes.append(.faithChanged(delta: amount, newValue: playerFaith))

        case .spendFaith(let amount):
            playerFaith = max(0, playerFaith - amount)
            changes.append(.faithChanged(delta: -amount, newValue: playerFaith))

        case .takeDamage(let amount):
            let actualDamage = min(amount, playerHealth)
            playerHealth = max(0, playerHealth - amount)
            changes.append(.healthChanged(delta: -actualDamage, newValue: playerHealth))

        case .removeCurse(let type):
            let curseType: CurseType? = type.flatMap { CurseType(rawValue: $0) }
            removeCurse(type: curseType)

        case .shiftBalance(let towards, let amount):
            let direction: CardBalance
            switch towards.lowercased() {
            case "light", "ÑÐ²ÐµÑ‚": direction = .light
            case "dark", "Ñ‚ÑŒÐ¼Ð°": direction = .dark
            default: direction = .neutral
            }

            let delta: Int
            switch direction {
            case .light: delta = amount
            case .dark: delta = -amount
            case .neutral: delta = 0
            }
            playerBalance = max(0, min(100, playerBalance + delta))
            changes.append(.balanceChanged(delta: amount, newValue: playerBalance))

        case .addBonusDice(let count):
            combatBonusDice += count

        case .addBonusDamage(let amount):
            combatBonusDamage += amount

        case .summonSpirit(let power, _):
            // Spirit attacks enemy immediately
            if let enemy = combatEnemy {
                combatEnemyHealth = max(0, combatEnemyHealth - power)
                changes.append(.enemyDamaged(enemyId: enemy.id, damage: power, newHealth: combatEnemyHealth))
            }
        }

        return changes
    }

    // MARK: - Combat Setup Methods

    /// Setup enemy for combat
    public func setupCombatEnemy(_ enemy: Card) {
        combatEnemy = enemy
        combatEnemyHealth = enemy.health ?? 10
        combatTurnNumber = 1
        combatActionsRemaining = 3
        combatBonusDice = 0
        combatBonusDamage = 0
        combatIsFirstAttack = true
        isInCombat = true
    }

    /// Get current combat state for UI
    public var combatState: CombatState? {
        guard isInCombat, let enemy = combatEnemy else { return nil }
        return CombatState(
            enemy: enemy,
            enemyHealth: combatEnemyHealth,
            turnNumber: combatTurnNumber,
            actionsRemaining: combatActionsRemaining,
            bonusDice: combatBonusDice,
            bonusDamage: combatBonusDamage,
            isFirstAttack: combatIsFirstAttack,
            playerHand: playerHand
        )
    }

    // MARK: - Engine-First Card Management

    /// Draw cards in Engine-First mode with deck recycling
    private func drawCardsEngineFirst(count: Int) {
        var remaining = count
        while remaining > 0 {
            // Recycle discard into deck if needed
            if _playerDeck.isEmpty && !_playerDiscard.isEmpty {
                _playerDeck = _playerDiscard
                _playerDiscard.removeAll()
                WorldRNG.shared.shuffle(&_playerDeck)
            }

            // If still empty, stop
            if _playerDeck.isEmpty { break }

            // Draw one card
            playerHand.append(_playerDeck.removeFirst())
            remaining -= 1
        }
    }

    // MARK: - Save/Load Support Methods

    /// Get completed quest IDs for save
    public func getCompletedQuestIds() -> Set<String> {
        return completedQuestIds
    }

    /// Get quest stages for save
    public func getQuestStages() -> [String: Int] {
        return questStages
    }

    /// Get completed event IDs for save (definition IDs)
    public func getCompletedEventIds() -> Set<String> {
        return completedEventIds
    }

    /// Set regions from save
    public func setRegions(_ newRegions: [UUID: EngineRegionState]) {
        regions = newRegions
        publishedRegions = newRegions
    }

    /// Set world flags from save
    public func setWorldFlags(_ newFlags: [String: Bool]) {
        worldFlags = newFlags
        publishedWorldFlags = newFlags
    }

    /// Set completed event IDs from save (definition IDs)
    public func setCompletedEventIds(_ ids: Set<String>) {
        completedEventIds = ids
    }

    /// Set event log from save
    public func setEventLog(_ log: [EventLogEntry]) {
        eventLog = log
        publishedEventLog = Array(log.suffix(100))
    }

    /// Set main quest stage from save
    public func setMainQuestStage(_ stage: Int) {
        mainQuestStage = stage
    }

    /// Set completed quest IDs from save
    public func setCompletedQuestIds(_ ids: Set<String>) {
        completedQuestIds = ids
    }

    /// Set quest stages from save
    public func setQuestStages(_ stages: [String: Int]) {
        questStages = stages
    }

    /// Update published state after loading
    public func updatePublishedStateAfterLoad() {
        updatePublishedState()
    }
}

// MARK: - Event Trigger

/// Trigger type that causes an event to fire
public enum EventTrigger {
    case arrival
    case exploration
    case combat
    case quest
    case time
}

// MARK: - Engine Region State (Bridge from Legacy)

/// ÐžÐ±ÑŠÐµÐ´Ð¸Ð½Ñ‘Ð½Ð½Ð¾Ðµ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ Ñ€ÐµÐ³Ð¸Ð¾Ð½Ð° Ð´Ð»Ñ UI (Audit v1.1 Issue #9)
///
/// Ð­Ñ‚Ð¾ ÐŸÐ Ð•Ð”ÐŸÐžÐ§Ð¢Ð˜Ð¢Ð•Ð›Ð¬ÐÐÐ¯ Ð¼Ð¾Ð´ÐµÐ»ÑŒ Ð´Ð»Ñ UI:
/// - Ð¡Ð¾Ð·Ð´Ð°Ñ‘Ñ‚ÑÑ Ð¸Ð· legacy Region Ñ‡ÐµÑ€ÐµÐ· TwilightGameEngine.syncFromLegacy()
/// - ÐŸÑƒÐ±Ð»Ð¸ÐºÑƒÐµÑ‚ÑÑ Ñ‡ÐµÑ€ÐµÐ· engine.publishedRegions
/// - UI Ð´Ð¾Ð»Ð¶ÐµÐ½ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ engine.regionsArray Ð¸Ð»Ð¸ engine.currentRegion
///
/// ÐÑ€Ñ…Ð¸Ñ‚ÐµÐºÑ‚ÑƒÑ€Ð° Ð¼Ð¾Ð´ÐµÐ»ÐµÐ¹:
/// - `RegionDefinition` - ÑÑ‚Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ (ContentProvider)
/// - `RegionRuntimeState` - Ð¸Ð·Ð¼ÐµÐ½ÑÐµÐ¼Ð¾Ðµ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ (WorldRuntimeState)
/// - `EngineRegionState` - Ð¾Ð±ÑŠÐµÐ´Ð¸Ð½Ñ‘Ð½Ð½Ð¾Ðµ Ð´Ð»Ñ UI (ÑÑ‚Ð¾Ñ‚ struct)
/// - `Region` (legacy) - persistence Ð¸ ÑÐ¾Ð²Ð¼ÐµÑÑ‚Ð¸Ð¼Ð¾ÑÑ‚ÑŒ
public struct EngineRegionState: Identifiable {
    /// Unique runtime identifier for this region
    public let id: UUID
    /// Stable definition ID for serialization (from content pack)
    public let definitionId: String
    /// Localized display name
    public let name: String
    /// Region type (settlement, sacred, etc.)
    public let type: RegionType
    /// Current state (stable, borderland, breach)
    public var state: RegionState
    /// Anchor protecting this region, if any
    public var anchor: EngineAnchorState?
    /// Runtime UUIDs of neighboring regions
    public let neighborIds: [UUID]
    /// Stable definition IDs of neighboring regions for serialization
    public let neighborDefinitionIds: [String]
    /// Whether trading is available in this region
    public var canTrade: Bool
    /// Whether the player has visited this region
    public var visited: Bool = false
    /// Player reputation in this region
    public var reputation: Int = 0

    /// Create directly (Engine-First) - definitionId is REQUIRED
    public init(
        id: UUID = UUID(),
        definitionId: String,
        name: String,
        type: RegionType,
        state: RegionState,
        anchor: EngineAnchorState? = nil,
        neighborIds: [UUID] = [],
        neighborDefinitionIds: [String] = [],
        canTrade: Bool = false,
        visited: Bool = false,
        reputation: Int = 0
    ) {
        self.id = id
        self.definitionId = definitionId
        self.name = name
        self.type = type
        self.state = state
        self.anchor = anchor
        self.neighborIds = neighborIds
        self.neighborDefinitionIds = neighborDefinitionIds
        self.canTrade = canTrade
        self.visited = visited
        self.reputation = reputation
    }

    /// Can rest in this region
    public var canRest: Bool {
        state == .stable && (type == .settlement || type == .sacred)
    }
}

// MARK: - Engine Anchor State (Bridge from Legacy)

/// Internal state for engine anchor tracking (REQUIRED definitionId - Audit A1)
public struct EngineAnchorState {
    /// Unique runtime identifier
    public let id: UUID
    /// Stable definition ID for serialization
    public let definitionId: String
    /// Localized display name
    public let name: String
    /// Current integrity level (0-100)
    public var integrity: Int

    /// Create directly (Engine-First) - definitionId is REQUIRED
    public init(id: UUID = UUID(), definitionId: String, name: String, integrity: Int) {
        self.id = id
        self.definitionId = definitionId
        self.name = name
        self.integrity = max(0, min(100, integrity))
    }
}

// MARK: - Combat State (for UI)

/// Read-only combat state for UI binding
public struct CombatState {
    /// The enemy card being fought
    public let enemy: Card
    /// Enemy's current health points
    public let enemyHealth: Int
    /// Current combat turn number
    public let turnNumber: Int
    /// Actions remaining this turn
    public let actionsRemaining: Int
    /// Bonus dice accumulated for next attack
    public let bonusDice: Int
    /// Bonus damage accumulated for next attack
    public let bonusDamage: Int
    /// Whether the next attack is the first in this combat
    public let isFirstAttack: Bool
    /// Cards currently in the player's hand
    public let playerHand: [Card]

    /// Enemy's maximum health from card definition
    public var enemyMaxHealth: Int {
        enemy.health ?? 10
    }

    /// Enemy's defense value from card definition
    public var enemyDefense: Int {
        enemy.defense ?? 10
    }

    /// Enemy's attack power from card definition
    public var enemyPower: Int {
        enemy.power ?? 3
    }

    /// Initialize combat state with all required fields
    public init(
        enemy: Card,
        enemyHealth: Int,
        turnNumber: Int,
        actionsRemaining: Int,
        bonusDice: Int,
        bonusDamage: Int,
        isFirstAttack: Bool,
        playerHand: [Card]
    ) {
        self.enemy = enemy
        self.enemyHealth = enemyHealth
        self.turnNumber = turnNumber
        self.actionsRemaining = actionsRemaining
        self.bonusDice = bonusDice
        self.bonusDamage = bonusDamage
        self.isFirstAttack = isFirstAttack
        self.playerHand = playerHand
    }
}

// MARK: - Engine Persistence (Engine-First Save/Load)

public extension TwilightGameEngine {

    /// Create a save state from current engine state (Engine-First Architecture)
    /// This replaces GameState-based saves
    func createEngineSave() -> EngineSave {
        // Collect active pack versions
        var activePackSet: [String: String] = [:]
        var primaryCampaignPackId: String? = nil

        for (packId, pack) in ContentRegistry.shared.loadedPacks {
            activePackSet[packId] = pack.manifest.version.description

            // First campaign/full pack becomes the primary campaign pack
            if primaryCampaignPackId == nil &&
               (pack.manifest.packType == .campaign || pack.manifest.packType == .full) {
                primaryCampaignPackId = packId
            }
        }

        // Convert regions to save state
        let regionSaves = regions.values.map { RegionSaveState(from: $0) }

        // Convert event log
        let eventLogSaves = publishedEventLog.map { EventLogEntrySave(from: $0) }

        // Get current region definition ID
        var currentRegionDefId: String? = nil
        if let currentId = currentRegionId,
           let region = regions[currentId] {
            currentRegionDefId = region.definitionId
        }

        return EngineSave(
            version: EngineSave.currentVersion,
            savedAt: Date(),
            gameDuration: 0,  // TODO: Track game duration

            // Pack compatibility
            coreVersion: EngineSave.currentCoreVersion,
            activePackSet: activePackSet,
            formatVersion: EngineSave.currentFormatVersion,
            primaryCampaignPackId: primaryCampaignPackId,

            // Player state
            playerName: playerName,
            heroId: heroId,
            playerHealth: playerHealth,
            playerMaxHealth: playerMaxHealth,
            playerFaith: playerFaith,
            playerMaxFaith: playerMaxFaith,
            playerBalance: playerBalance,

            // Deck state (card IDs for stable serialization)
            deckCardIds: _playerDeck.map { $0.definitionId },
            handCardIds: playerHand.map { $0.definitionId },
            discardCardIds: _playerDiscard.map { $0.definitionId },

            // World state
            currentDay: currentDay,
            worldTension: worldTension,
            lightDarkBalance: lightDarkBalance,
            currentRegionId: currentRegionDefId,

            // Regions
            regions: regionSaves,

            // Quest state (using definitionId for stable serialization - Audit A1)
            mainQuestStage: mainQuestStage,
            activeQuestIds: publishedActiveQuests.map { $0.definitionId },
            completedQuestIds: Array(completedQuestIds),
            questStages: Dictionary(uniqueKeysWithValues: publishedActiveQuests.map { ($0.definitionId, $0.stage) }),

            // Events (already String definition IDs)
            completedEventIds: Array(completedEventIds),
            eventLog: eventLogSaves,

            // World flags
            worldFlags: publishedWorldFlags,

            // RNG state (Audit A2 - save for deterministic replay)
            rngSeed: WorldRNG.shared.currentSeed(),
            rngState: WorldRNG.shared.currentState()
        )
    }

    /// Restore engine state from a save (Engine-First Architecture)
    /// This replaces GameState-based loads
    func restoreFromEngineSave(_ save: EngineSave) {
        // Validate compatibility
        let compatibility = save.validateCompatibility(with: ContentRegistry.shared)

        // Log compatibility result
        #if DEBUG
        switch compatibility {
        case .fullyCompatible:
            print("âœ… Save is fully compatible")
        case .compatible(let warnings):
            print("âš ï¸ Save is compatible with warnings:")
            warnings.forEach { print("   - \($0)") }
        case .incompatible(let errors):
            print("âŒ Save is incompatible:")
            errors.forEach { print("   - \($0)") }
        }
        #endif

        if !compatibility.isLoadable {
            #if DEBUG
            print("âŒ Save cannot be loaded due to incompatibility")
            #endif
            // Even if incompatible, try to initialize a fallback state
            // so the user doesn't see a blank screen
            initializeFallbackState()
            return
        }

        // Restore player state
        playerName = save.playerName
        heroId = save.heroId
        playerHealth = save.playerHealth
        playerMaxHealth = save.playerMaxHealth
        playerFaith = save.playerFaith
        playerMaxFaith = save.playerMaxFaith
        playerBalance = save.playerBalance

        // Restore hero stats from heroId (stats that don't change during gameplay)
        if let heroId = save.heroId,
           let heroDef = HeroRegistry.shared.hero(id: heroId) {
            let stats = heroDef.baseStats
            playerStrength = stats.strength
            playerDexterity = stats.dexterity
            playerConstitution = stats.constitution
            playerIntelligence = stats.intelligence
            playerWisdom = stats.wisdom
            playerCharisma = stats.charisma
        }

        // Restore deck (convert card IDs back to cards)
        _playerDeck = save.deckCardIds.compactMap { CardFactory.shared.getCard(id: $0) }
        playerHand = save.handCardIds.compactMap { CardFactory.shared.getCard(id: $0) }
        _playerDiscard = save.discardCardIds.compactMap { CardFactory.shared.getCard(id: $0) }

        // Restore world state
        currentDay = save.currentDay
        worldTension = save.worldTension
        lightDarkBalance = save.lightDarkBalance

        // First pass: create map of definition IDs to UUIDs
        var defIdToUUID: [String: UUID] = [:]
        for regionSave in save.regions {
            let uuid = UUID()
            defIdToUUID[regionSave.definitionId] = uuid
        }

        // Second pass: create regions with resolved neighbor UUIDs
        var newRegions: [UUID: EngineRegionState] = [:]
        for regionSave in save.regions {
            guard let regionUUID = defIdToUUID[regionSave.definitionId] else { continue }

            // Resolve neighbor UUIDs from definition IDs
            let neighborUUIDs = regionSave.neighborDefinitionIds.compactMap { defIdToUUID[$0] }

            // Create anchor if present
            var anchor: EngineAnchorState? = nil
            if let anchorId = regionSave.anchorDefinitionId {
                // Look up anchor definition to get localized name
                let anchorDef = contentRegistry.getAnchor(id: anchorId)
                let anchorName = anchorDef?.title.localized ?? anchorId
                anchor = EngineAnchorState(
                    id: UUID(),
                    definitionId: anchorId,
                    name: anchorName,
                    integrity: regionSave.anchorIntegrity ?? 100
                )
            }

            // Create region with all data
            let region = EngineRegionState(
                id: regionUUID,
                definitionId: regionSave.definitionId,
                name: regionSave.name,
                type: RegionType(rawValue: regionSave.type) ?? .settlement,
                state: RegionState(rawValue: regionSave.state) ?? .stable,
                anchor: anchor,
                neighborIds: neighborUUIDs,
                neighborDefinitionIds: regionSave.neighborDefinitionIds,
                canTrade: regionSave.canTrade,
                visited: regionSave.visited,
                reputation: regionSave.reputation
            )
            newRegions[regionUUID] = region
        }

        regions = newRegions
        publishedRegions = newRegions

        // Restore current region
        if let currentDefId = save.currentRegionId {
            currentRegionId = defIdToUUID[currentDefId]
        }

        // Restore quest state
        mainQuestStage = save.mainQuestStage
        completedQuestIds = Set(save.completedQuestIds)

        // Restore active quests from definitionIds (using ContentRegistry)
        var restoredQuests: [Quest] = []
        for questDefId in save.activeQuestIds {
            if let questDef = contentRegistry.getQuest(id: questDefId) {
                var quest = questDef.toQuest()
                // Restore stage from saved data
                if let savedStage = save.questStages[questDefId] {
                    quest.stage = savedStage
                }
                restoredQuests.append(quest)
            }
        }
        activeQuests = restoredQuests
        publishedActiveQuests = restoredQuests

        // Restore completed events (already String definition IDs)
        completedEventIds = Set(save.completedEventIds)

        // Restore event log
        publishedEventLog = save.eventLog.map { $0.toEventLogEntry() }

        // Restore world flags
        publishedWorldFlags = save.worldFlags
        worldFlags = save.worldFlags

        // Restore RNG state (Audit 1.5 - determinism after load)
        WorldRNG.shared.restoreState(save.rngState)

        // Clear game over state
        isGameOver = false
        gameResult = nil
    }

    // MARK: - Fallback Initialization

    /// Initialize a minimal fallback state when save loading fails
    /// This prevents the user from seeing a blank/white screen
    private func initializeFallbackState() {
        #if DEBUG
        print("âš ï¸ Initializing fallback state due to save incompatibility")
        #endif

        // Initialize with minimal default values
        isGameOver = false
        gameResult = nil
        currentEventId = nil
        currentEvent = nil
        lastDayEvent = nil
        isInCombat = false

        playerName = "Ð“ÐµÑ€Ð¾Ð¹"
        playerHealth = 20
        playerMaxHealth = 20
        playerFaith = 10
        playerMaxFaith = 15
        playerBalance = 50
        playerStrength = 5

        currentDay = 1
        worldTension = 30
        lightDarkBalance = 50

        // Try to setup regions from registry (this is the critical part)
        setupRegionsFromRegistry()

        // If still no regions, this is a critical error
        if publishedRegions.isEmpty {
            #if DEBUG
            print("âŒ CRITICAL: No regions available even in fallback state!")
            print("   ContentRegistry has \(contentRegistry.getAllRegions().count) regions")
            #endif
        }
    }

    // MARK: - Test Helpers (Engine-First Architecture)

    /// Initialize engine from ContentRegistry for testing
    /// Note: Uses the already-configured contentRegistry, just sets up regions
    func initializeFromContentRegistry(_ registry: ContentRegistry) {
        // ContentRegistry is set in init, just setup regions
        setupRegionsFromRegistry()
    }

    /// Set player health directly (for testing)
    func setPlayerHealth(_ health: Int) {
        playerHealth = min(playerMaxHealth, max(0, health))
    }

    /// Set player max health directly (for testing)
    func setPlayerMaxHealth(_ maxHealth: Int) {
        playerMaxHealth = max(1, maxHealth)
        playerHealth = min(playerHealth, playerMaxHealth)
    }

    /// Set player faith directly (for testing)
    func setPlayerFaith(_ faith: Int) {
        playerFaith = min(playerMaxFaith, max(0, faith))
    }

    /// Set player balance directly (for testing)
    func setPlayerBalance(_ balance: Int) {
        playerBalance = min(100, max(0, balance))
    }

    /// Set player name directly (for testing)
    func setPlayerName(_ name: String) {
        playerName = name
    }

    /// Set hero ID directly (for testing)
    func setHeroId(_ id: String) {
        heroId = id
    }

    /// Set world tension directly (for testing)
    func setWorldTension(_ tension: Int) {
        worldTension = min(100, max(0, tension))
    }

    /// Set current region directly (for testing)
    func setCurrentRegion(_ regionId: UUID) {
        currentRegionId = regionId
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Combat/CombatCalculator.swift
// ==========================================

import Foundation

/// Attack result with full breakdown
public struct CombatResult {
    public let isHit: Bool
    public let attackRoll: AttackRoll
    public let defenseValue: Int
    public let damageCalculation: DamageCalculation?
    public let specialEffects: [CombatEffect]

    public init(
        isHit: Bool,
        attackRoll: AttackRoll,
        defenseValue: Int,
        damageCalculation: DamageCalculation?,
        specialEffects: [CombatEffect]
    ) {
        self.isHit = isHit
        self.attackRoll = attackRoll
        self.defenseValue = defenseValue
        self.damageCalculation = damageCalculation
        self.specialEffects = specialEffects
    }

    /// Text description for log
    public var logDescription: String {
        var lines: [String] = []

        // Ð—Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð°
        if isHit {
            lines.append(L10n.calcHit.localized)
        } else {
            lines.append(L10n.calcMiss.localized)
        }

        // Ð‘Ñ€Ð¾ÑÐ¾Ðº Ð°Ñ‚Ð°ÐºÐ¸
        lines.append(L10n.calcAttackVsDefense.localized(with: attackRoll.total, defenseValue))

        // Ð Ð°Ð·Ð±Ð¸Ð²ÐºÐ° Ð°Ñ‚Ð°ÐºÐ¸
        var attackParts: [String] = []
        attackParts.append(L10n.calcStrength.localized(with: attackRoll.baseStrength))

        if attackRoll.diceRolls.count == 1 {
            attackParts.append("ðŸŽ²\(attackRoll.diceRolls[0])")
        } else {
            let diceStr = attackRoll.diceRolls.map { "ðŸŽ²\($0)" }.joined(separator: "+")
            attackParts.append("(\(diceStr)=\(attackRoll.diceTotal))")
        }

        if attackRoll.bonusDice > 0 {
            attackParts.append(L10n.calcBonusDice.localized(with: attackRoll.bonusDice))
        }
        if attackRoll.bonusDamage > 0 {
            attackParts.append(L10n.calcBonusDamage.localized(with: attackRoll.bonusDamage))
        }

        lines.append("   = \(attackParts.joined(separator: " + "))")

        // ÐœÐ¾Ð´Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð¾Ñ€Ñ‹
        for effect in attackRoll.modifiers {
            lines.append("   \(effect.icon) \(effect.description): \(effect.value > 0 ? "+" : "")\(effect.value)")
        }

        // Ð Ð°ÑÑ‡Ñ‘Ñ‚ ÑƒÑ€Ð¾Ð½Ð° (ÐµÑÐ»Ð¸ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ðµ)
        if isHit, let damage = damageCalculation {
            lines.append(L10n.calcDamage.localized(with: damage.total))
            lines.append(L10n.calcBaseDamage.localized(with: damage.base))

            for modifier in damage.modifiers {
                lines.append("   \(modifier.icon) \(modifier.description): \(modifier.value > 0 ? "+" : "")\(modifier.value)")
            }
        }

        // Ð¡Ð¿ÐµÑ†ÑÑ„Ñ„ÐµÐºÑ‚Ñ‹
        for effect in specialEffects {
            lines.append("\(effect.icon) \(effect.description)")
        }

        return lines.joined(separator: "\n")
    }
}

/// Attack roll
public struct AttackRoll {
    public let baseStrength: Int
    public let diceRolls: [Int]
    public let bonusDice: Int
    public let bonusDamage: Int
    public let modifiers: [CombatModifier]

    public init(baseStrength: Int, diceRolls: [Int], bonusDice: Int, bonusDamage: Int, modifiers: [CombatModifier]) {
        self.baseStrength = baseStrength
        self.diceRolls = diceRolls
        self.bonusDice = bonusDice
        self.bonusDamage = bonusDamage
        self.modifiers = modifiers
    }

    public var diceTotal: Int {
        diceRolls.reduce(0, +)
    }

    public var total: Int {
        baseStrength + diceTotal + bonusDamage + modifiers.reduce(0) { $0 + $1.value }
    }
}

/// Damage calculation
public struct DamageCalculation {
    public let base: Int
    public let modifiers: [CombatModifier]

    public init(base: Int, modifiers: [CombatModifier]) {
        self.base = base
        self.modifiers = modifiers
    }

    public var total: Int {
        max(1, base + modifiers.reduce(0) { $0 + $1.value })
    }
}

/// Combat modifier
public struct CombatModifier {
    public let source: ModifierSource
    public let value: Int
    public let description: String

    public init(source: ModifierSource, value: Int, description: String) {
        self.source = source
        self.value = value
        self.description = description
    }

    public var icon: String {
        switch source {
        case .heroAbility: return "â­"
        case .curse: return "ðŸ’€"
        case .card: return "ðŸƒ"
        case .equipment: return "ðŸ›¡ï¸"
        case .buff: return "âœ¨"
        case .debuff: return "âš¡"
        case .spirit: return "ðŸ‘»"
        case .environment: return "ðŸŒ"
        }
    }
}

/// Modifier source
public enum ModifierSource {
    case heroAbility
    case curse
    case card
    case equipment
    case buff
    case debuff
    case spirit
    case environment
}

/// Combat effect (events in combat)
public struct CombatEffect {
    public let icon: String
    public let description: String
    public let type: CombatEffectType

    public init(icon: String, description: String, type: CombatEffectType) {
        self.icon = icon
        self.description = description
        self.type = type
    }
}

/// Combat effect type
public enum CombatEffectType {
    case damage
    case heal
    case buff
    case debuff
    case summon
    case special
}

/// Combat calculator - computes attack result with full breakdown
public struct CombatCalculator {

    // MARK: - Engine-First Attack Calculation

    /// Calculate player attack without requiring Player model (Engine-First Architecture)
    /// Uses engine stats directly for full independence from legacy Player
    public static func calculateAttackEngineFirst(
        engine: TwilightGameEngine,
        monsterDefense: Int,
        monsterCurrentHP: Int,
        monsterMaxHP: Int,
        bonusDice: Int,
        bonusDamage: Int,
        isFirstAttack: Bool
    ) -> CombatResult {
        var modifiers: [CombatModifier] = []
        var damageModifiers: [CombatModifier] = []
        let specialEffects: [CombatEffect] = []

        let isTargetFullHP = monsterCurrentHP == monsterMaxHP

        // Roll dice
        var totalDice = 1 + bonusDice

        // Hero ability: bonus dice (e.g., Tracker on first attack)
        let heroBonusDice = engine.getHeroBonusDice(isFirstAttack: isFirstAttack)
        if heroBonusDice > 0 {
            totalDice += heroBonusDice
            modifiers.append(CombatModifier(
                source: .heroAbility,
                value: 0,
                description: L10n.calcHeroAbilityDice.localized(with: heroBonusDice)
            ))
        }

        var diceRolls: [Int] = []
        for _ in 0..<totalDice {
            diceRolls.append(WorldRNG.shared.nextInt(in: 1...6))
        }

        // Create attack roll
        let attackRoll = AttackRoll(
            baseStrength: engine.playerStrength,
            diceRolls: diceRolls,
            bonusDice: bonusDice,
            bonusDamage: bonusDamage,
            modifiers: modifiers
        )

        let isHit = attackRoll.total >= monsterDefense

        var damageCalculation: DamageCalculation? = nil

        if isHit {
            let baseDamage = max(1, attackRoll.total - monsterDefense + 2)

            // Curse damage modifiers
            if engine.hasCurse(.weakness) {
                damageModifiers.append(CombatModifier(
                    source: .curse,
                    value: -1,
                    description: L10n.calcCurseWeakness.localized
                ))
            }

            if engine.hasCurse(.shadowOfNav) {
                damageModifiers.append(CombatModifier(
                    source: .curse,
                    value: +3,
                    description: L10n.calcCurseShadowOfNav.localized
                ))
            }

            // Hero ability damage bonus
            let heroDamageBonus = engine.getHeroDamageBonus(targetFullHP: isTargetFullHP)
            if heroDamageBonus > 0 {
                damageModifiers.append(CombatModifier(
                    source: .heroAbility,
                    value: heroDamageBonus,
                    description: L10n.calcHeroAbility.localized
                ))
            }

            damageCalculation = DamageCalculation(
                base: baseDamage,
                modifiers: damageModifiers
            )
        }

        return CombatResult(
            isHit: isHit,
            attackRoll: attackRoll,
            defenseValue: monsterDefense,
            damageCalculation: damageCalculation,
            specialEffects: specialEffects
        )
    }

    // MARK: - Attack Calculation with CombatPlayerContext

    /// Calculate player attack using CombatPlayerContext (Engine-First Architecture)
    /// Replaces legacy calculatePlayerAttack that used Player model
    public static func calculatePlayerAttack(
        context: CombatPlayerContext,
        monsterDefense: Int,
        monsterCurrentHP: Int,
        monsterMaxHP: Int,
        bonusDice: Int,
        bonusDamage: Int,
        isFirstAttack: Bool
    ) -> CombatResult {

        var modifiers: [CombatModifier] = []
        var damageModifiers: [CombatModifier] = []
        let specialEffects: [CombatEffect] = []

        let isTargetFullHP = monsterCurrentHP == monsterMaxHP

        // Roll dice
        var totalDice = 1 + bonusDice

        // Hero ability: bonus dice (e.g., Tracker on first attack)
        let heroBonusDice = context.getHeroBonusDice(isFirstAttack: isFirstAttack)
        if heroBonusDice > 0 {
            totalDice += heroBonusDice
            modifiers.append(CombatModifier(
                source: .heroAbility,
                value: 0,  // Doesn't add to attack directly, only the dice roll
                description: L10n.calcHeroAbilityDice.localized(with: heroBonusDice)
            ))
        }

        var diceRolls: [Int] = []
        for _ in 0..<totalDice {
            diceRolls.append(WorldRNG.shared.nextInt(in: 1...6))
        }

        // Create attack roll
        let attackRoll = AttackRoll(
            baseStrength: context.strength,
            diceRolls: diceRolls,
            bonusDice: bonusDice,
            bonusDamage: bonusDamage,
            modifiers: modifiers
        )

        let isHit = attackRoll.total >= monsterDefense

        var damageCalculation: DamageCalculation? = nil

        if isHit {
            let baseDamage = max(1, attackRoll.total - monsterDefense + 2)

            // Curse damage modifiers
            if context.hasCurse(.weakness) {
                damageModifiers.append(CombatModifier(
                    source: .curse,
                    value: -1,
                    description: L10n.calcCurseWeakness.localized
                ))
            }

            if context.hasCurse(.shadowOfNav) {
                damageModifiers.append(CombatModifier(
                    source: .curse,
                    value: +3,
                    description: L10n.calcCurseShadowOfNav.localized
                ))
            }

            // Hero ability damage bonus (checks conditions like HP < 50% or target at full HP)
            let heroDamageBonus = context.getHeroDamageBonus(targetFullHP: isTargetFullHP)
            if heroDamageBonus > 0 {
                damageModifiers.append(CombatModifier(
                    source: .heroAbility,
                    value: heroDamageBonus,
                    description: L10n.calcHeroAbility.localized
                ))
            }

            damageCalculation = DamageCalculation(
                base: baseDamage,
                modifiers: damageModifiers
            )
        }

        return CombatResult(
            isHit: isHit,
            attackRoll: attackRoll,
            defenseValue: monsterDefense,
            damageCalculation: damageCalculation,
            specialEffects: specialEffects
        )
    }
}

// MARK: - Combat Player Context

/// Context struct that replaces Player model for combat calculations
/// Used by CombatCalculator and CombatModule (Engine-First Architecture)
public struct CombatPlayerContext {
    public let health: Int
    public let maxHealth: Int
    public let faith: Int
    public let balance: Int
    public let strength: Int
    public let activeCurses: [CurseType]
    public let heroBonusDice: Int
    public let heroDamageBonus: Int

    public init(
        health: Int,
        maxHealth: Int,
        faith: Int,
        balance: Int,
        strength: Int,
        activeCurses: [CurseType],
        heroBonusDice: Int,
        heroDamageBonus: Int
    ) {
        self.health = health
        self.maxHealth = maxHealth
        self.faith = faith
        self.balance = balance
        self.strength = strength
        self.activeCurses = activeCurses
        self.heroBonusDice = heroBonusDice
        self.heroDamageBonus = heroDamageBonus
    }

    /// Check if player has a specific curse
    public func hasCurse(_ type: CurseType) -> Bool {
        return activeCurses.contains(type)
    }

    /// Get bonus dice from hero ability
    public func getHeroBonusDice(isFirstAttack: Bool) -> Int {
        // Hero ability logic would check conditions here
        // For now, return the stored value
        return heroBonusDice
    }

    /// Get bonus damage from hero ability
    public func getHeroDamageBonus(targetFullHP: Bool) -> Int {
        // Hero ability logic would check conditions here
        // For now, return the stored value
        return heroDamageBonus
    }

    /// Get damage reduction from hero ability (e.g., Priest vs dark sources)
    public func getHeroDamageReduction(fromDarkSource: Bool) -> Int {
        // Hero ability logic would check conditions here
        return 0
    }

    /// Create from TwilightGameEngine (Engine-First)
    public static func from(engine: TwilightGameEngine) -> CombatPlayerContext {
        CombatPlayerContext(
            health: engine.playerHealth,
            maxHealth: engine.playerMaxHealth,
            faith: engine.playerFaith,
            balance: engine.playerBalance,
            strength: engine.playerStrength,
            activeCurses: engine.playerActiveCurses.map { $0.type },
            heroBonusDice: engine.getHeroBonusDice(isFirstAttack: true),
            heroDamageBonus: engine.getHeroDamageBonus(targetFullHP: false)
        )
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Config/DegradationRules.swift
// ==========================================

import Foundation

// MARK: - Degradation Rules
// ÐŸÑ€Ð°Ð²Ð¸Ð»Ð° Ð´ÐµÐ³Ñ€Ð°Ð´Ð°Ñ†Ð¸Ð¸ Ñ€ÐµÐ³Ð¸Ð¾Ð½Ð¾Ð², Ð²Ñ‹Ð½ÐµÑÐµÐ½Ð½Ñ‹Ðµ Ð¸Ð· WorldState Ð² Engine Config
// ÐŸÐ¾Ð·Ð²Ð¾Ð»ÑÐµÑ‚ Ð½Ð°ÑÑ‚Ñ€Ð°Ð¸Ð²Ð°Ñ‚ÑŒ Ð¿Ð¾Ð²ÐµÐ´ÐµÐ½Ð¸Ðµ Ð´ÐµÐ³Ñ€Ð°Ð´Ð°Ñ†Ð¸Ð¸ Ð±ÐµÐ· Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ ÐºÐ¾Ð´Ð°

/// ÐŸÑ€Ð¾Ñ‚Ð¾ÐºÐ¾Ð» Ð¿Ñ€Ð°Ð²Ð¸Ð» Ð´ÐµÐ³Ñ€Ð°Ð´Ð°Ñ†Ð¸Ð¸ Ð´Ð»Ñ Ñ€Ð°Ð·Ð½Ñ‹Ñ… ÐºÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ð¹ Ð¸Ð³Ñ€Ñ‹
public protocol DegradationRuleSet {
    /// Ð’ÐµÑ Ñ€ÐµÐ³Ð¸Ð¾Ð½Ð° Ð´Ð»Ñ Ð²Ñ‹Ð±Ð¾Ñ€Ð° ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð° Ð½Ð° Ð´ÐµÐ³Ñ€Ð°Ð´Ð°Ñ†Ð¸ÑŽ
    func selectionWeight(for regionState: RegionState) -> Int

    /// Ð’ÐµÑ€Ð¾ÑÑ‚Ð½Ð¾ÑÑ‚ÑŒ ÑÐ¾Ð¿Ñ€Ð¾Ñ‚Ð¸Ð²Ð»ÐµÐ½Ð¸Ñ ÑÐºÐ¾Ñ€Ñ (0.0 - 1.0)
    /// Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ð²ÐµÑ€Ð¾ÑÑ‚Ð½Ð¾ÑÑ‚ÑŒ Ñ‚Ð¾Ð³Ð¾, Ñ‡Ñ‚Ð¾ ÑÐºÐ¾Ñ€ÑŒ ÑÐ¾Ð¿Ñ€Ð¾Ñ‚Ð¸Ð²Ð»ÑÐµÑ‚ÑÑ Ð´ÐµÐ³Ñ€Ð°Ð´Ð°Ñ†Ð¸Ð¸
    func resistanceProbability(anchorIntegrity: Int) -> Double

    /// Ð£Ñ€Ð¾Ð½ ÑÐºÐ¾Ñ€ÑŽ Ð¿Ñ€Ð¸ Ð´ÐµÐ³Ñ€Ð°Ð´Ð°Ñ†Ð¸Ð¸
    var degradationAmount: Int { get }

    /// ÐœÐ¸Ð½Ð¸Ð¼Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Tension Ð´Ð»Ñ Ð·Ð°Ð¿ÑƒÑÐºÐ° Ð´ÐµÐ³Ñ€Ð°Ð´Ð°Ñ†Ð¸Ð¸
    var minimumTensionForDegradation: Int { get }
}

/// Default degradation rules for world region state changes
public struct TwilightDegradationRules: DegradationRuleSet {

    /// Ð’ÐµÑÐ° Ð²Ñ‹Ð±Ð¾Ñ€Ð° Ñ€ÐµÐ³Ð¸Ð¾Ð½Ð°:
    /// - Stable (70-100%): 0 â€” Ð½Ðµ Ð´ÐµÐ³Ñ€Ð°Ð´Ð¸Ñ€ÑƒÐµÑ‚ Ð½Ð°Ð¿Ñ€ÑÐ¼ÑƒÑŽ
    /// - Borderland (30-69%): 1 â€” ÑƒÐ¼ÐµÑ€ÐµÐ½Ð½Ñ‹Ð¹ Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚
    /// - Breach (0-29%): 2 â€” Ð²Ñ‹ÑÐ¾ÐºÐ¸Ð¹ Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚ (ÑƒÐ¶Ðµ ÑÐ»Ð°Ð±Ñ‹Ðµ Ñ€ÐµÐ³Ð¸Ð¾Ð½Ñ‹ ÑƒÑ…ÑƒÐ´ÑˆÐ°ÑŽÑ‚ÑÑ Ð±Ñ‹ÑÑ‚Ñ€ÐµÐµ)
    public func selectionWeight(for regionState: RegionState) -> Int {
        switch regionState {
        case .stable:
            return 0
        case .borderland:
            return 1
        case .breach:
            return 2
        }
    }

    /// Ð’ÐµÑ€Ð¾ÑÑ‚Ð½Ð¾ÑÑ‚ÑŒ ÑÐ¾Ð¿Ñ€Ð¾Ñ‚Ð¸Ð²Ð»ÐµÐ½Ð¸Ñ: Ñ‡ÐµÐ¼ Ð²Ñ‹ÑˆÐµ integrity, Ñ‚ÐµÐ¼ Ð±Ð¾Ð»ÑŒÑˆÐµ ÑˆÐ°Ð½Ñ ÑÐ¾Ð¿Ñ€Ð¾Ñ‚Ð¸Ð²Ð»ÑÑ‚ÑŒÑÑ
    /// Ð¤Ð¾Ñ€Ð¼ÑƒÐ»Ð°: P(resist) = integrity / 100
    /// - integrity 100% â†’ 100% ÑÐ¾Ð¿Ñ€Ð¾Ñ‚Ð¸Ð²Ð»ÐµÐ½Ð¸Ðµ
    /// - integrity 50% â†’ 50% ÑÐ¾Ð¿Ñ€Ð¾Ñ‚Ð¸Ð²Ð»ÐµÐ½Ð¸Ðµ
    /// - integrity 0% â†’ 0% ÑÐ¾Ð¿Ñ€Ð¾Ñ‚Ð¸Ð²Ð»ÐµÐ½Ð¸Ðµ
    public func resistanceProbability(anchorIntegrity: Int) -> Double {
        return Double(anchorIntegrity) / 100.0
    }

    /// Ð£Ñ€Ð¾Ð½ ÑÐºÐ¾Ñ€ÑŽ Ð¿Ñ€Ð¸ Ð´ÐµÐ³Ñ€Ð°Ð´Ð°Ñ†Ð¸Ð¸: -20% integrity
    public let degradationAmount: Int = 20

    /// Ð”ÐµÐ³Ñ€Ð°Ð´Ð°Ñ†Ð¸Ñ Ð¿Ñ€Ð¾Ð¸ÑÑ…Ð¾Ð´Ð¸Ñ‚ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¿Ñ€Ð¸ Tension >= 0 (Ð²ÑÐµÐ³Ð´Ð° Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð°)
    public let minimumTensionForDegradation: Int = 0
}

// MARK: - Shared Instance

/// Ð“Ð»Ð¾Ð±Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ð¿Ñ€Ð°Ð²Ð¸Ð»Ð° Ð´ÐµÐ³Ñ€Ð°Ð´Ð°Ñ†Ð¸Ð¸ (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ TwilightDegradationRules)
public enum DegradationRules {
    public static var current: DegradationRuleSet = TwilightDegradationRules()

    /// Ð¡Ð±Ñ€Ð¾ÑÐ¸Ñ‚ÑŒ Ð½Ð° Ð´ÐµÑ„Ð¾Ð»Ñ‚Ð½Ñ‹Ðµ Ð¿Ñ€Ð°Ð²Ð¸Ð»Ð°
    public static func reset() {
        current = TwilightDegradationRules()
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Config/TwilightMarchesConfig.swift
// ==========================================

import Foundation

// MARK: - Twilight Marches Configuration
// Game-specific configuration for "Ð¡ÑƒÐ¼Ñ€Ð°Ñ‡Ð½Ñ‹Ðµ ÐŸÑ€ÐµÐ´ÐµÐ»Ñ‹" (Twilight Marches)
// This is the "cartridge" that configures the generic engine.

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARK: - Resources
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Resources used in Twilight Marches
public enum TwilightResource: String, CaseIterable {
    case health
    case maxHealth
    case faith
    case maxFaith
    case balance  // 0 = Dark, 100 = Light

    public var id: String { rawValue }

    /// Default starting values
    public var defaultValue: Int {
        switch self {
        case .health: return 10
        case .maxHealth: return 10
        case .faith: return 3
        case .maxFaith: return 10
        case .balance: return 50
        }
    }
}

/// Build initial resources dictionary
public func twilightInitialResources() -> [String: Int] {
    var resources: [String: Int] = [:]
    for resource in TwilightResource.allCases {
        resources[resource.id] = resource.defaultValue
    }
    return resources
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARK: - Pressure Rules (WorldTension)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Twilight Marches pressure (WorldTension) rules
/// SINGLE SOURCE OF TRUTH for tension escalation formula (Audit v1.1 Issue #6)
public struct TwilightPressureRules: PressureRuleSet {
    public let maxPressure: Int = 100
    public let initialPressure: Int = 30
    public let escalationInterval: Int = 3  // Every 3 days
    public let escalationAmount: Int = 3    // Base +3 tension (increased for balance)

    /// Thresholds and their effects
    public var thresholds: [Int: [WorldEffect]] {
        return [
            50: [.regionDegradation(probability: 0.3)],
            75: [.regionDegradation(probability: 0.5), .globalEvent(eventId: "world_shift_warning")],
            90: [.regionDegradation(probability: 0.7), .anchorWeakening(amount: 10)]
        ]
    }

    /// Canonical escalation formula: base + (daysPassed / 10)
    /// - Day 1-9: +3
    /// - Day 10-19: +4
    /// - Day 20-29: +5
    /// Creates increasing urgency as game progresses
    public func calculateEscalation(currentPressure: Int, currentTime: Int) -> Int {
        let escalationBonus = currentTime / 10
        return escalationAmount + escalationBonus
    }

    /// Static helper for use outside of PressureEngine context
    /// Both WorldState and TwilightGameEngine should use this
    public static func calculateTensionIncrease(daysPassed: Int) -> Int {
        let base = 3  // escalationAmount
        let escalationBonus = daysPassed / 10
        return base + escalationBonus
    }

    public func checkThresholds(pressure: Int) -> [WorldEffect] {
        var effects: [WorldEffect] = []

        for (threshold, thresholdEffects) in thresholds {
            if pressure >= threshold {
                effects.append(contentsOf: thresholdEffects)
            }
        }

        return effects
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARK: - Region Configuration
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Region states in Twilight Marches
public enum TwilightRegionState: String, Codable, CaseIterable {
    case stable
    case borderland
    case breach

    /// Degradation weight (higher = degrades faster)
    public var degradationWeight: Int {
        switch self {
        case .stable: return 0
        case .borderland: return 1
        case .breach: return 2
        }
    }

    /// Can player rest in this state?
    public var canRest: Bool {
        self == .stable
    }

    /// Can player trade in this state?
    public var canTrade: Bool {
        self == .stable
    }

    /// Combat modifier
    public var combatModifier: Int {
        switch self {
        case .stable: return 0
        case .borderland: return 1
        case .breach: return 2
        }
    }

    /// Next degraded state
    public var degraded: TwilightRegionState? {
        switch self {
        case .stable: return .borderland
        case .borderland: return .breach
        case .breach: return nil
        }
    }

    /// Previous improved state
    public var improved: TwilightRegionState? {
        switch self {
        case .stable: return nil
        case .borderland: return .stable
        case .breach: return .borderland
        }
    }
}

/// Region type
public enum TwilightRegionType: String, Codable, CaseIterable {
    case village
    case forest
    case fortress
    case swamp
    case ruins
    case sanctuary
    case cursedLand
}

/// Region definition (static data)
public struct TwilightRegionDefinition: Codable {
    public let id: String
    public let name: String
    public let type: TwilightRegionType
    public let initialState: TwilightRegionState
    public let neighborIds: [String]
    public let hasAnchor: Bool
    public let anchorName: String?

    /// Initial anchor integrity (if has anchor)
    public var initialAnchorIntegrity: Int { hasAnchor ? 100 : 0 }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARK: - Curse Configuration
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Curse types in Twilight Marches
public enum TwilightCurseType: String, Codable, CaseIterable {
    case weakness
    case fear
    case exhaustion
    case greed
    case shadowOfNav
    case bloodCurse
    case sealOfNav
}

/// Curse definition (static data)
public struct TwilightCurseDefinition {
    public let type: TwilightCurseType
    public let name: String
    public let description: String
    public let removalCost: Int
    public let damageModifier: Int      // Modifier to damage dealt
    public let damageTakenModifier: Int // Modifier to damage received
    public let actionModifier: Int      // Modifier to actions per turn
    public let specialEffect: String?   // ID of special effect

    public static let definitions: [TwilightCurseType: TwilightCurseDefinition] = [
        .weakness: TwilightCurseDefinition(
            type: .weakness,
            name: L10n.curseWeaknessName.localized,
            description: L10n.curseWeaknessDescription.localized,
            removalCost: 2,
            damageModifier: -1,
            damageTakenModifier: 0,
            actionModifier: 0,
            specialEffect: nil
        ),
        .fear: TwilightCurseDefinition(
            type: .fear,
            name: L10n.curseFearName.localized,
            description: L10n.curseFearDescription.localized,
            removalCost: 2,
            damageModifier: 0,
            damageTakenModifier: 1,
            actionModifier: 0,
            specialEffect: nil
        ),
        .exhaustion: TwilightCurseDefinition(
            type: .exhaustion,
            name: L10n.curseExhaustionName.localized,
            description: L10n.curseExhaustionDescription.localized,
            removalCost: 3,
            damageModifier: 0,
            damageTakenModifier: 0,
            actionModifier: -1,
            specialEffect: nil
        ),
        .greed: TwilightCurseDefinition(
            type: .greed,
            name: L10n.curseGreedName.localized,
            description: L10n.curseGreedDescription.localized,
            removalCost: 4,
            damageModifier: 0,
            damageTakenModifier: 0,
            actionModifier: 0,
            specialEffect: "balance_shift_dark"
        ),
        .shadowOfNav: TwilightCurseDefinition(
            type: .shadowOfNav,
            name: L10n.curseShadowOfNavName.localized,
            description: L10n.curseShadowOfNavDescription.localized,
            removalCost: 5,
            damageModifier: 3,
            damageTakenModifier: 0,
            actionModifier: 0,
            specialEffect: "balance_shift_dark_on_combat"
        ),
        .bloodCurse: TwilightCurseDefinition(
            type: .bloodCurse,
            name: L10n.curseBloodCurseName.localized,
            description: L10n.curseBloodCurseDescription.localized,
            removalCost: 6,
            damageModifier: 0,
            damageTakenModifier: 0,
            actionModifier: 0,
            specialEffect: "heal_on_kill_dark"
        ),
        .sealOfNav: TwilightCurseDefinition(
            type: .sealOfNav,
            name: L10n.curseSealOfNavName.localized,
            description: L10n.curseSealOfNavDescription.localized,
            removalCost: 8,
            damageModifier: 0,
            damageTakenModifier: 0,
            actionModifier: 0,
            specialEffect: "block_sustain_cards"
        )
    ]

    public static func get(_ type: TwilightCurseType) -> TwilightCurseDefinition? {
        return definitions[type]
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARK: - Balance (Light/Dark) Configuration
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Balance state classification
public enum TwilightBalanceState: String {
    case light
    case neutral
    case dark

    public static func classify(balance: Int) -> TwilightBalanceState {
        if balance >= 70 { return .light }
        if balance <= 30 { return .dark }
        return .neutral
    }
}

/// Balance thresholds
public struct TwilightBalanceConfig {
    public static let min = 0
    public static let max = 100
    public static let initial = 50
    public static let lightThreshold = 70
    public static let darkThreshold = 30
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARK: - Combat Configuration
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Combat configuration for Twilight Marches
public struct TwilightCombatConfig {
    /// Dice type (e.g., d6)
    public static let diceMax = 6

    /// Base damage bonus
    public static let baseDamageBonus = 2

    /// Actions per combat turn
    public static let actionsPerTurn = 3

    /// Cards drawn at turn start
    public static let cardsDrawnPerTurn = 5

    /// Maximum hand size
    public static let maxHandSize = 7

    /// Calculate damage: playerPower + diceRoll - enemyDefense + bonus
    public static func calculateDamage(
        playerPower: Int,
        diceRoll: Int,
        enemyDefense: Int,
        curseModifier: Int,
        regionModifier: Int
    ) -> Int {
        let baseDamage = playerPower + diceRoll - enemyDefense + baseDamageBonus
        let modifiedDamage = baseDamage + curseModifier
        return max(1, modifiedDamage) // Minimum 1 damage
    }

    /// Roll dice (deterministic via WorldRNG)
    public static func rollDice() -> Int {
        return WorldRNG.shared.nextInt(in: 1...diceMax)
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARK: - Anchor Configuration
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Anchor integrity thresholds
public struct TwilightAnchorConfig {
    public static let maxIntegrity = 100
    public static let stableThreshold = 70   // Above = region stable
    public static let breachThreshold = 30   // Below = region breach

    public static let strengthenAmount = 20
    public static let degradeAmount = 20

    /// Determine region state based on anchor integrity
    public static func regionStateForIntegrity(_ integrity: Int) -> TwilightRegionState {
        if integrity >= stableThreshold { return .stable }
        if integrity > breachThreshold { return .borderland }
        return .breach
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARK: - Time Configuration
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Time-related configuration
public struct TwilightTimeConfig {
    /// Days for tension increase
    public static let tensionIncreaseInterval = 3

    /// Tension increase amount (increased from 2 to 3 for balance)
    public static let tensionIncreaseAmount = 3

    /// Travel costs
    public static let neighborTravelCost = 1
    public static let distantTravelCost = 2

    /// Action costs
    public static let restCost = 1
    public static let strengthenAnchorCost = 1
    public static let exploreCost = 1
    public static let instantCost = 0
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARK: - Victory/Defeat Conditions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Victory conditions for Twilight Marches
public struct TwilightVictoryConfig {
    /// Main quest completion flag
    public static let mainQuestCompleteFlag = "act5_completed"

    /// Main quest final stage
    public static let mainQuestFinalStage = 5
}

/// Defeat conditions for Twilight Marches
public struct TwilightDefeatConfig {
    /// Health defeat threshold
    public static let healthDefeatThreshold = 0

    /// Tension defeat threshold
    public static let tensionDefeatThreshold = 100

    /// Critical anchor destruction flag
    public static let criticalAnchorDestroyedFlag = "critical_anchor_destroyed"
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARK: - Factory
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Factory for creating Twilight Marches game components
public enum TwilightMarchesFactory {
    /// Create pressure rules
    public static func createPressureRules() -> TwilightPressureRules {
        return TwilightPressureRules()
    }

    /// Create initial player resources
    public static func createInitialResources() -> [String: Int] {
        return twilightInitialResources()
    }

    /// Create resource caps
    public static func createResourceCaps() -> [String: Int] {
        return [
            TwilightResource.health.id: TwilightResource.maxHealth.defaultValue,
            TwilightResource.faith.id: TwilightResource.maxFaith.defaultValue,
            TwilightResource.balance.id: TwilightBalanceConfig.max
        ]
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Heroes/AbilityRegistry.swift
// ==========================================

import Foundation

/// Ð ÐµÐµÑÑ‚Ñ€ ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚ÐµÐ¹ Ð³ÐµÑ€Ð¾ÐµÐ² - data-driven Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° Ð¸Ð· JSON
/// Ð—Ð°Ð¼ÐµÐ½ÑÐµÑ‚ Ñ…Ð°Ñ€Ð´ÐºÐ¾Ð´ Ð² HeroAbility.forAbilityId()
public final class AbilityRegistry {

    // MARK: - Singleton

    public static let shared = AbilityRegistry()

    // MARK: - Storage

    /// Ð—Ð°Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚Ð¸ Ð¿Ð¾ ID
    private var abilities: [String: HeroAbility] = [:]

    // MARK: - Init

    private init() {
        // Ð¡Ð¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚Ð¸ Ð·Ð°Ð³Ñ€ÑƒÐ¶Ð°ÑŽÑ‚ÑÑ Ð¸Ð· ContentPack (hero_abilities.json)
        // ÐŸÑƒÑÑ‚Ð¾Ð¹ init - Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð·Ð°Ð³Ñ€ÑƒÐ¶Ð°ÑŽÑ‚ÑÑ Ñ‡ÐµÑ€ÐµÐ· loadFromJSON()
    }

    // MARK: - Registration

    /// Ð—Ð°Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚ÑŒ
    public func register(_ ability: HeroAbility) {
        abilities[ability.id] = ability
    }

    /// Ð—Ð°Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾ ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚ÐµÐ¹
    public func registerAll(_ newAbilities: [HeroAbility]) {
        for ability in newAbilities {
            register(ability)
        }
    }

    /// ÐžÑ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ Ñ€ÐµÐµÑÑ‚Ñ€
    public func clear() {
        abilities.removeAll()
    }

    /// ÐŸÐµÑ€ÐµÐ·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ Ñ€ÐµÐµÑÑ‚Ñ€ (Ð¾Ñ‡Ð¸ÑÑ‚ÐºÐ° Ð´Ð»Ñ Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€Ð½Ð¾Ð¹ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸)
    public func reload() {
        clear()
    }

    // MARK: - Queries

    /// ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚ÑŒ Ð¿Ð¾ ID
    public func ability(id: String) -> HeroAbility? {
        return abilities[id]
    }

    /// Ð’ÑÐµ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ðµ ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚Ð¸
    public var allAbilities: [HeroAbility] {
        return Array(abilities.values)
    }

    /// ÐšÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð·Ð°Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ñ… ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚ÐµÐ¹
    public var count: Int {
        return abilities.count
    }

    // MARK: - JSON Loading

    /// Ð—Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚Ð¸ Ð¸Ð· JSON Ñ„Ð°Ð¹Ð»Ð°
    public func loadFromJSON(at url: URL) {
        guard let data = try? Data(contentsOf: url) else {
            #if DEBUG
            print("AbilityRegistry: Failed to load JSON from \(url)")
            #endif
            return
        }

        do {
            let decoder = JSONDecoder()
            decoder.keyDecodingStrategy = .convertFromSnakeCase
            let jsonAbilities = try decoder.decode([JSONAbilityDefinition].self, from: data)
            let converted = jsonAbilities.compactMap { $0.toHeroAbility() }
            registerAll(converted)
            #if DEBUG
            print("AbilityRegistry: Loaded \(converted.count) abilities from \(url.lastPathComponent)")
            #endif
        } catch {
            #if DEBUG
            print("AbilityRegistry: Failed to decode abilities: \(error)")
            #endif
        }
    }

}

// MARK: - JSON Ability Definition

/// JSON ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð° Ð´Ð»Ñ ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚Ð¸
public struct JSONAbilityDefinition: Codable {
    public let id: String
    public let name: LocalizedString
    public let description: LocalizedString
    public let icon: String
    public let type: String
    public let trigger: String
    public let condition: JSONAbilityCondition?
    public let effects: [JSONAbilityEffect]
    public let cooldown: Int
    public let cost: JSONAbilityCost?

    public func toHeroAbility() -> HeroAbility? {
        // ÐšÐ¾Ð½Ð²ÐµÑ€Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ Ñ‚Ð¸Ð¿
        guard let abilityType = HeroAbilityType(rawValue: type) else {
            #if DEBUG
            print("AbilityRegistry: Unknown ability type '\(type)' for '\(id)'")
            #endif
            return nil
        }

        // ÐšÐ¾Ð½Ð²ÐµÑ€Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ Ñ‚Ñ€Ð¸Ð³Ð³ÐµÑ€
        let abilityTrigger = AbilityTrigger.fromString(trigger) ?? .always

        // ÐšÐ¾Ð½Ð²ÐµÑ€Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ ÑƒÑÐ»Ð¾Ð²Ð¸Ðµ
        let abilityCondition = condition?.toAbilityCondition()

        // ÐšÐ¾Ð½Ð²ÐµÑ€Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ ÑÑ„Ñ„ÐµÐºÑ‚Ñ‹
        let abilityEffects = effects.compactMap { $0.toHeroAbilityEffect() }

        // ÐšÐ¾Ð½Ð²ÐµÑ€Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ ÑÑ‚Ð¾Ð¸Ð¼Ð¾ÑÑ‚ÑŒ
        let abilityCost = cost?.toAbilityCost()

        return HeroAbility(
            id: id,
            name: .inline(name),
            description: .inline(description),
            icon: icon,
            type: abilityType,
            trigger: abilityTrigger,
            condition: abilityCondition,
            effects: abilityEffects,
            cooldown: cooldown,
            cost: abilityCost
        )
    }
}

/// JSON ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð° Ð´Ð»Ñ ÑƒÑÐ»Ð¾Ð²Ð¸Ñ ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚Ð¸
public struct JSONAbilityCondition: Codable {
    public let type: String
    public let value: Int?
    public let stringValue: String?

    public func toAbilityCondition() -> AbilityCondition? {
        guard let conditionType = AbilityConditionType(rawValue: type) else {
            // Try converting from snake_case
            let camelType = type.replacingOccurrences(of: "_", with: "")
            for enumCase in AbilityConditionType.allCases {
                if enumCase.rawValue.lowercased() == camelType.lowercased() {
                    return AbilityCondition(type: enumCase, value: value, stringValue: stringValue)
                }
            }
            #if DEBUG
            print("AbilityRegistry: Unknown condition type '\(type)'")
            #endif
            return nil
        }
        return AbilityCondition(type: conditionType, value: value, stringValue: stringValue)
    }
}

/// JSON ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð° Ð´Ð»Ñ ÑÑ„Ñ„ÐµÐºÑ‚Ð° ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚Ð¸
public struct JSONAbilityEffect: Codable {
    public let type: String
    public let value: Int
    public let description: String?

    public func toHeroAbilityEffect() -> HeroAbilityEffect? {
        guard let effectType = HeroAbilityEffectType(rawValue: type) else {
            // Try converting from snake_case
            let camelType = type.replacingOccurrences(of: "_", with: "")
            for enumCase in HeroAbilityEffectType.allCases {
                if enumCase.rawValue.lowercased() == camelType.lowercased() {
                    return HeroAbilityEffect(type: enumCase, value: value, description: description)
                }
            }
            #if DEBUG
            print("AbilityRegistry: Unknown effect type '\(type)'")
            #endif
            return nil
        }
        return HeroAbilityEffect(type: effectType, value: value, description: description)
    }
}

/// JSON ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð° Ð´Ð»Ñ ÑÑ‚Ð¾Ð¸Ð¼Ð¾ÑÑ‚Ð¸ ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚Ð¸
public struct JSONAbilityCost: Codable {
    public let type: String
    public let value: Int

    public func toAbilityCost() -> AbilityCost? {
        guard let costType = AbilityCostType(rawValue: type) else {
            #if DEBUG
            print("AbilityRegistry: Unknown cost type '\(type)'")
            #endif
            return nil
        }
        return AbilityCost(type: costType, value: value)
    }
}

// MARK: - AbilityTrigger Extension

extension AbilityTrigger {
    /// ÐšÐ¾Ð½Ð²ÐµÑ€Ñ‚Ð°Ñ†Ð¸Ñ Ð¸Ð· snake_case ÑÑ‚Ñ€Ð¾ÐºÐ¸
    public static func fromString(_ string: String) -> AbilityTrigger? {
        // ÐŸÑ€ÑÐ¼Ð¾Ðµ ÑÐ¾Ð²Ð¿Ð°Ð´ÐµÐ½Ð¸Ðµ
        if let trigger = AbilityTrigger(rawValue: string) {
            return trigger
        }

        // ÐšÐ¾Ð½Ð²ÐµÑ€Ñ‚Ð°Ñ†Ð¸Ñ snake_case -> camelCase
        let mapping: [String: AbilityTrigger] = [
            "always": .always,
            "turn_start": .turnStart,
            "turn_end": .turnEnd,
            "on_attack": .onAttack,
            "on_damage_received": .onDamageReceived,
            "on_damage_dealt": .onDamageDealt,
            "on_card_played": .onCardPlayed,
            "on_combat_start": .onCombatStart,
            "on_combat_end": .onCombatEnd,
            "on_explore": .onExplore,
            "manual": .manual
        ]

        return mapping[string]
    }
}



// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Heroes/HeroAbility.swift
// ==========================================

import Foundation

/// Hero ability
/// Defines unique actions and passive effects of the hero
public struct HeroAbility: Codable, Equatable {
    /// Unique ability identifier
    public let id: String

    /// Ability name (supports inline LocalizedString or StringKey)
    public let name: LocalizableText

    /// Description for UI (supports inline LocalizedString or StringKey)
    public let description: LocalizableText

    /// Icon (SF Symbol or emoji)
    public let icon: String

    /// Ability type
    public let type: HeroAbilityType

    /// Activation trigger (for passives)
    public let trigger: AbilityTrigger

    /// Activation condition
    public let condition: AbilityCondition?

    /// Ability effects
    public let effects: [HeroAbilityEffect]

    /// Cooldown (in turns, 0 = no cooldown)
    public let cooldown: Int

    /// Activation cost (for active abilities)
    public let cost: AbilityCost?

    public init(
        id: String,
        name: LocalizableText,
        description: LocalizableText,
        icon: String,
        type: HeroAbilityType,
        trigger: AbilityTrigger,
        condition: AbilityCondition?,
        effects: [HeroAbilityEffect],
        cooldown: Int,
        cost: AbilityCost?
    ) {
        self.id = id
        self.name = name
        self.description = description
        self.icon = icon
        self.type = type
        self.trigger = trigger
        self.condition = condition
        self.effects = effects
        self.cooldown = cooldown
        self.cost = cost
    }
}

/// Hero ability type
public enum HeroAbilityType: String, Codable {
    /// Passive - works automatically
    case passive

    /// Active - requires manual activation
    case active

    /// Reactive - triggers in response to event
    case reactive

    /// Ultimate - powerful ability with long cooldown
    case ultimate
}

/// Ability activation trigger
public enum AbilityTrigger: String, Codable, CaseIterable {
    /// Always active
    case always

    /// At turn start
    case turnStart

    /// At turn end
    case turnEnd

    /// On attack
    case onAttack

    /// On damage received
    case onDamageReceived

    /// On damage dealt
    case onDamageDealt

    /// On card played
    case onCardPlayed

    /// On combat start
    case onCombatStart

    /// On combat end
    case onCombatEnd

    /// On explore
    case onExplore

    /// Manual activation
    case manual
}

/// Ability activation condition
public struct AbilityCondition: Codable, Equatable {
    public let type: AbilityConditionType
    public let value: Int?
    public let stringValue: String?

    public init(type: AbilityConditionType, value: Int? = nil, stringValue: String? = nil) {
        self.type = type
        self.value = value
        self.stringValue = stringValue
    }
}

/// Condition type
public enum AbilityConditionType: String, Codable, CaseIterable {
    /// HP below percent
    case hpBelowPercent

    /// HP above percent
    case hpAbovePercent

    /// Target at full HP
    case targetFullHP

    /// First attack in combat
    case firstAttack

    /// Damage source is dark
    case damageSourceDark

    /// Damage source is light
    case damageSourceLight

    /// Has specific curse
    case hasCurse

    /// Balance above value
    case balanceAbove

    /// Balance below value
    case balanceBelow

    /// Has card in hand
    case hasCardInHand
}

/// Hero ability effect
public struct HeroAbilityEffect: Codable, Equatable {
    public let type: HeroAbilityEffectType
    public let value: Int
    public let description: String?

    public init(type: HeroAbilityEffectType, value: Int, description: String? = nil) {
        self.type = type
        self.value = value
        self.description = description
    }
}

/// Ability effect type
public enum HeroAbilityEffectType: String, Codable, CaseIterable {
    /// Damage bonus
    case bonusDamage

    /// Damage reduction
    case damageReduction

    /// Additional attack dice
    case bonusDice

    /// Heal HP
    case heal

    /// Gain faith
    case gainFaith

    /// Lose faith
    case loseFaith

    /// Shift balance to Light
    case shiftLight

    /// Shift balance to Dark
    case shiftDark

    /// Draw card
    case drawCard

    /// Discard card
    case discardCard

    /// Apply curse to enemy
    case applyCurseToEnemy

    /// Remove curse
    case removeCurse

    /// Defense bonus
    case bonusDefense

    /// Summon spirit
    case summonSpirit

    /// Bonus to next attack
    case bonusNextAttack

    /// Reroll dice
    case rerollDice
}

/// Ability activation cost
public struct AbilityCost: Codable, Equatable {
    public let type: AbilityCostType
    public let value: Int

    public init(type: AbilityCostType, value: Int) {
        self.type = type
        self.value = value
    }
}

/// Cost type
public enum AbilityCostType: String, Codable {
    case health
    case faith
    case card
    case action
}

// MARK: - Ability Lookup

extension HeroAbility {
    /// ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚ÑŒ Ð¿Ð¾ ID (data-driven Ñ‡ÐµÑ€ÐµÐ· AbilityRegistry)
    /// Ð¡Ð¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚Ð¸ Ð·Ð°Ð³Ñ€ÑƒÐ¶Ð°ÑŽÑ‚ÑÑ Ð¸Ð· hero_abilities.json Ð² ContentPack
    public static func forAbilityId(_ id: String) -> HeroAbility? {
        return AbilityRegistry.shared.ability(id: id)
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Heroes/HeroDefinition.swift
// ==========================================

import Foundation

/// Structure with hero stats
public struct HeroStats: Codable, Equatable {
    public let health: Int
    public let maxHealth: Int
    public let strength: Int
    public let dexterity: Int
    public let constitution: Int
    public let intelligence: Int
    public let wisdom: Int
    public let charisma: Int
    public let faith: Int
    public let maxFaith: Int
    public let startingBalance: Int

    public init(
        health: Int,
        maxHealth: Int,
        strength: Int,
        dexterity: Int,
        constitution: Int,
        intelligence: Int,
        wisdom: Int,
        charisma: Int,
        faith: Int,
        maxFaith: Int,
        startingBalance: Int
    ) {
        self.health = health
        self.maxHealth = maxHealth
        self.strength = strength
        self.dexterity = dexterity
        self.constitution = constitution
        self.intelligence = intelligence
        self.wisdom = wisdom
        self.charisma = charisma
        self.faith = faith
        self.maxFaith = maxFaith
        self.startingBalance = startingBalance
    }
}

/// Protocol for hero definition (Data Layer)
/// Describes static hero data that doesn't change during game
/// Heroes are loaded from Content Pack - no hardcoded classes
public protocol HeroDefinition {
    /// Unique identifier (from JSON)
    var id: String { get }

    /// Localized name (supports inline LocalizedString or StringKey)
    var name: LocalizableText { get }

    /// Hero description for UI (supports inline LocalizedString or StringKey)
    var description: LocalizableText { get }

    /// Hero icon (SF Symbol or emoji)
    var icon: String { get }

    /// Base stats
    var baseStats: HeroStats { get }

    /// Special ability
    var specialAbility: HeroAbility { get }

    /// Starting deck (card IDs)
    var startingDeckCardIDs: [String] { get }

    /// Hero availability (for DLC/unlock)
    var availability: HeroAvailability { get }
}

/// Hero availability
public enum HeroAvailability: Codable, Equatable {
    case alwaysAvailable
    case requiresUnlock(condition: String)
    case dlc(packID: String)
}

/// Standard hero definition implementation
public struct StandardHeroDefinition: HeroDefinition, Codable {
    public let id: String
    public let name: LocalizableText
    public let description: LocalizableText
    public let icon: String
    public let baseStats: HeroStats
    public let specialAbility: HeroAbility
    public let startingDeckCardIDs: [String]
    public let availability: HeroAvailability

    public init(
        id: String,
        name: LocalizableText,
        description: LocalizableText,
        icon: String,
        baseStats: HeroStats,
        specialAbility: HeroAbility,
        startingDeckCardIDs: [String] = [],
        availability: HeroAvailability = .alwaysAvailable
    ) {
        self.id = id
        self.name = name
        self.description = description
        self.icon = icon
        self.baseStats = baseStats
        self.specialAbility = specialAbility
        self.startingDeckCardIDs = startingDeckCardIDs
        self.availability = availability
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Heroes/HeroRegistry.swift
// ==========================================

import Foundation

/// Hero registry - centralized storage of all hero definitions
/// Heroes are loaded from Content Pack (JSON) - no hardcoded classes
public final class HeroRegistry {

    // MARK: - Singleton

    public static let shared = HeroRegistry()

    // MARK: - Storage

    /// Ð—Ð°Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ Ð³ÐµÑ€Ð¾ÐµÐ²
    private var definitions: [String: HeroDefinition] = [:]

    /// ÐŸÐ¾Ñ€ÑÐ´Ð¾Ðº Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ Ð³ÐµÑ€Ð¾ÐµÐ² Ð² UI
    private var displayOrder: [String] = []

    /// Ð˜ÑÑ‚Ð¾Ñ‡Ð½Ð¸ÐºÐ¸ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð³ÐµÑ€Ð¾ÐµÐ² (Ð´Ð»Ñ Ð¼Ð¾Ð´ÑƒÐ»ÑŒÐ½Ð¾ÑÑ‚Ð¸)
    private var dataSources: [HeroDataSource] = []

    // MARK: - Init

    private init() {
        registerBuiltInHeroes()
    }

    // MARK: - Registration

    /// Register a hero definition in the registry.
    /// - Parameter definition: The hero definition to register.
    /// - Note: If a hero with the same ID exists, it will be replaced.
    ///         Heroes are added to display order in registration sequence.
    public func register(_ definition: HeroDefinition) {
        definitions[definition.id] = definition
        if !displayOrder.contains(definition.id) {
            displayOrder.append(definition.id)
        }
    }

    /// Register multiple hero definitions at once.
    /// - Parameter definitions: Array of hero definitions to register.
    public func registerAll(_ definitions: [HeroDefinition]) {
        for definition in definitions {
            register(definition)
        }
    }

    /// Remove a hero from the registry.
    /// - Parameter id: The unique identifier of the hero to remove.
    public func unregister(id: String) {
        definitions.removeValue(forKey: id)
        displayOrder.removeAll { $0 == id }
    }

    /// Clear all registered heroes and display order.
    /// - Note: Does not remove data sources; call `reload()` to repopulate.
    public func clear() {
        definitions.removeAll()
        displayOrder.removeAll()
    }

    /// Reload all heroes from registered data sources.
    /// - Note: Clears existing registrations before reloading.
    public func reload() {
        clear()
        registerBuiltInHeroes()
        for source in dataSources {
            registerAll(source.loadHeroes())
        }
    }

    // MARK: - Data Sources

    /// Add a data source and immediately load its heroes.
    /// - Parameter source: The hero data source to add.
    public func addDataSource(_ source: HeroDataSource) {
        dataSources.append(source)
        registerAll(source.loadHeroes())
    }

    /// Remove a data source and unregister all its heroes.
    /// - Parameter source: The hero data source to remove.
    public func removeDataSource(_ source: HeroDataSource) {
        if let index = dataSources.firstIndex(where: { $0.id == source.id }) {
            let source = dataSources.remove(at: index)
            for hero in source.loadHeroes() {
                unregister(id: hero.id)
            }
        }
    }

    // MARK: - Queries

    /// Get a hero definition by its unique identifier.
    /// - Parameter id: The hero's unique identifier.
    /// - Returns: The hero definition, or `nil` if not found.
    public func hero(id: String) -> HeroDefinition? {
        return definitions[id]
    }

    /// All registered heroes in display order.
    public var allHeroes: [HeroDefinition] {
        return displayOrder.compactMap { definitions[$0] }
    }

    /// The first hero in display order (useful for defaults).
    public var firstHero: HeroDefinition? {
        return allHeroes.first
    }

    /// Get heroes available to the player based on unlock status.
    /// - Parameters:
    ///   - unlockedConditions: Set of unlocked condition flags.
    ///   - ownedDLCs: Set of owned DLC pack identifiers.
    /// - Returns: Array of hero definitions the player can select.
    public func availableHeroes(unlockedConditions: Set<String> = [], ownedDLCs: Set<String> = []) -> [HeroDefinition] {
        return allHeroes.filter { hero in
            switch hero.availability {
            case .alwaysAvailable:
                return true
            case .requiresUnlock(let condition):
                return unlockedConditions.contains(condition)
            case .dlc(let packID):
                return ownedDLCs.contains(packID)
            }
        }
    }

    /// Number of registered heroes.
    public var count: Int {
        return definitions.count
    }

    // MARK: - Built-in Heroes

    /// Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° Ð³ÐµÑ€Ð¾ÐµÐ² Ð¸Ð· JSON Ñ„Ð°Ð¹Ð»Ð° Ð² Ð±Ð°Ð½Ð´Ð»Ðµ (legacy)
    /// NOTE: Ð¡ Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´Ð¾Ð¼ Ð½Ð° ContentPack ÑÐ¸ÑÑ‚ÐµÐ¼Ñƒ, Ð³ÐµÑ€Ð¾Ð¸ Ð·Ð°Ð³Ñ€ÑƒÐ¶Ð°ÑŽÑ‚ÑÑ Ñ‡ÐµÑ€ÐµÐ·
    /// ContentRegistry.loadPack(), ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð²Ñ‹Ð·Ñ‹Ð²Ð°ÐµÑ‚ HeroRegistry.register() Ð´Ð»Ñ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ Ð³ÐµÑ€Ð¾Ñ.
    /// Ð­Ñ‚Ð¾Ñ‚ Ð¼ÐµÑ‚Ð¾Ð´ Ð¾ÑÑ‚Ð°Ð²Ð»ÐµÐ½ Ð´Ð»Ñ Ð¾Ð±Ñ€Ð°Ñ‚Ð½Ð¾Ð¹ ÑÐ¾Ð²Ð¼ÐµÑÑ‚Ð¸Ð¼Ð¾ÑÑ‚Ð¸ Ñ Bundle.main ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð¾Ð¹.
    private func registerBuiltInHeroes() {
        // ÐŸÑ€Ð¾Ð±ÑƒÐµÐ¼ Ð·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ Ð¸Ð· Bundle.main (ÑÑ‚Ð°Ñ€Ð°Ñ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð°)
        // Ð•ÑÐ»Ð¸ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾ - ÑÑ‚Ð¾ OK, Ð³ÐµÑ€Ð¾Ð¸ Ð±ÑƒÐ´ÑƒÑ‚ Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ñ‹ Ñ‡ÐµÑ€ÐµÐ· ContentPack
        if let heroesURL = Bundle.main.url(
            forResource: "heroes",
            withExtension: "json",
            subdirectory: "ContentPacks/TwilightMarches/Characters"
        ) {
            let dataSource = JSONHeroDataSource(
                id: "bundle_heroes",
                name: "Bundle Heroes",
                fileURL: heroesURL
            )
            registerAll(dataSource.loadHeroes())
            return
        }

        if let heroesURL = Bundle.main.url(forResource: "heroes", withExtension: "json") {
            let dataSource = JSONHeroDataSource(
                id: "bundle_heroes",
                name: "Bundle Heroes",
                fileURL: heroesURL
            )
            registerAll(dataSource.loadHeroes())
            return
        }

        // ÐÐµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾ Ð² Bundle.main - ÑÑ‚Ð¾ Ð½Ð¾Ñ€Ð¼Ð°Ð»ÑŒÐ½Ð¾ Ð¿Ñ€Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ð¸ ContentPack ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹
        // Ð“ÐµÑ€Ð¾Ð¸ Ð±ÑƒÐ´ÑƒÑ‚ Ð·Ð°Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ñ‹ ÐºÐ¾Ð³Ð´Ð° ContentRegistry Ð·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ Ð¿Ð°Ðº
        #if DEBUG
        print("HeroRegistry: Heroes will be loaded via ContentPack system")
        #endif
    }
}

// MARK: - Hero Data Source Protocol

/// Protocol for hero data sources
/// Allows loading heroes from different sources (JSON, server, DLC)
public protocol HeroDataSource {
    /// Unique source identifier
    var id: String { get }

    /// Source name (for debugging)
    var name: String { get }

    /// Load heroes from source
    func loadHeroes() -> [HeroDefinition]
}

// MARK: - JSON Data Source

/// Hero loader from JSON file
public struct JSONHeroDataSource: HeroDataSource {
    public let id: String
    public let name: String
    public let fileURL: URL

    public init(id: String, name: String, fileURL: URL) {
        self.id = id
        self.name = name
        self.fileURL = fileURL
    }

    public func loadHeroes() -> [HeroDefinition] {
        guard let data = try? Data(contentsOf: fileURL) else {
            #if DEBUG
            print("HeroRegistry: Failed to load JSON from \(fileURL)")
            #endif
            return []
        }

        do {
            let decoder = JSONDecoder()
            decoder.keyDecodingStrategy = .convertFromSnakeCase
            let decoded = try decoder.decode([JSONHeroDefinition].self, from: data)
            return decoded.map { $0.toStandard() }
        } catch {
            #if DEBUG
            print("HeroRegistry: Failed to decode heroes: \(error)")
            #endif
            return []
        }
    }
}

/// JSON ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð° Ð´Ð»Ñ stats
public struct JSONHeroStats: Codable {
    let health: Int
    let maxHealth: Int
    let strength: Int
    let dexterity: Int
    let constitution: Int
    let intelligence: Int
    let wisdom: Int
    let charisma: Int
    let faith: Int
    let maxFaith: Int
    let startingBalance: Int

    func toHeroStats() -> HeroStats {
        HeroStats(
            health: health,
            maxHealth: maxHealth,
            strength: strength,
            dexterity: dexterity,
            constitution: constitution,
            intelligence: intelligence,
            wisdom: wisdom,
            charisma: charisma,
            faith: faith,
            maxFaith: maxFaith,
            startingBalance: startingBalance
        )
    }
}

/// JSON-ÑÐ¾Ð²Ð¼ÐµÑÑ‚Ð¸Ð¼Ð¾Ðµ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ð³ÐµÑ€Ð¾Ñ (data-driven)
public struct JSONHeroDefinition: Codable {
    let id: String
    let name: String
    let nameRu: String?
    let description: String
    let descriptionRu: String?
    let icon: String
    let baseStats: JSONHeroStats
    let abilityId: String
    let startingDeckCardIds: [String]
    let availability: String?

    func toStandard() -> StandardHeroDefinition {
        // Convert legacy name/nameRu to LocalizableText
        let localizedName: LocalizableText
        if name.contains(".") && !name.contains(" ") && name.first?.isLowercase == true {
            // Looks like a StringKey
            localizedName = .key(StringKey(name))
        } else {
            localizedName = .inline(LocalizedString(en: name, ru: nameRu ?? name))
        }

        let localizedDescription: LocalizableText
        if description.contains(".") && !description.contains(" ") && description.first?.isLowercase == true {
            localizedDescription = .key(StringKey(description))
        } else {
            localizedDescription = .inline(LocalizedString(en: description, ru: descriptionRu ?? description))
        }

        // ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÐ¼ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾ÑÑ‚ÑŒ
        let heroAvailability: HeroAvailability
        switch availability?.lowercased() {
        case "always_available", nil:
            heroAvailability = .alwaysAvailable
        case let str where str?.hasPrefix("requires_unlock:") == true:
            let condition = String(str!.dropFirst("requires_unlock:".count))
            heroAvailability = .requiresUnlock(condition: condition)
        case let str where str?.hasPrefix("dlc:") == true:
            let packId = String(str!.dropFirst("dlc:".count))
            heroAvailability = .dlc(packID: packId)
        default:
            heroAvailability = .alwaysAvailable
        }

        // ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚ÑŒ Ð¿Ð¾ ID
        guard let ability = HeroAbility.forAbilityId(abilityId) else {
            #if DEBUG
            print("HeroRegistry: ERROR - Unknown ability ID '\(abilityId)' for hero '\(id)'")
            #endif
            fatalError("Missing ability definition for '\(abilityId)'. Add it to HeroAbility.forAbilityId() or hero_abilities.json")
        }

        return StandardHeroDefinition(
            id: id,
            name: localizedName,
            description: localizedDescription,
            icon: icon,
            baseStats: baseStats.toHeroStats(),
            specialAbility: ability,
            startingDeckCardIDs: startingDeckCardIds,
            availability: heroAvailability
        )
    }
}

// MARK: - DLC Data Source

/// Hero data source from a DLC/expansion pack.
public struct DLCHeroDataSource: HeroDataSource {
    /// Unique identifier for this data source.
    public let id: String

    /// Human-readable name (for debugging).
    public let name: String

    /// Associated DLC pack identifier.
    public let packID: String

    /// Hero definitions from this DLC.
    public let heroes: [HeroDefinition]

    /// Initialize a DLC hero data source.
    public init(id: String, name: String, packID: String, heroes: [HeroDefinition]) {
        self.id = id
        self.name = name
        self.packID = packID
        self.heroes = heroes
    }

    public func loadHeroes() -> [HeroDefinition] {
        return heroes
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Cards/CardDefinition.swift
// ==========================================

import Foundation

/// ÐŸÑ€Ð¾Ñ‚Ð¾ÐºÐ¾Ð» Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ ÐºÐ°Ñ€Ñ‚Ñ‹ (Data Layer)
/// ÐžÐ¿Ð¸ÑÑ‹Ð²Ð°ÐµÑ‚ ÑÑ‚Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ ÐºÐ°Ñ€Ñ‚Ñ‹, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ Ð½Ðµ Ð¼ÐµÐ½ÑÑŽÑ‚ÑÑ Ð²Ð¾ Ð²Ñ€ÐµÐ¼Ñ Ð¸Ð³Ñ€Ñ‹
public protocol CardDefinition {
    /// Ð£Ð½Ð¸ÐºÐ°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¸Ð´ÐµÐ½Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð¾Ñ€ ÐºÐ°Ñ€Ñ‚Ñ‹
    var id: String { get }

    /// Ð›Ð¾ÐºÐ°Ð»Ð¸Ð·Ð¾Ð²Ð°Ð½Ð½Ð¾Ðµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ (supports inline LocalizedString or StringKey)
    var name: LocalizableText { get }

    /// Ð¢Ð¸Ð¿ ÐºÐ°Ñ€Ñ‚Ñ‹
    var cardType: CardType { get }

    /// Ð ÐµÐ´ÐºÐ¾ÑÑ‚ÑŒ
    var rarity: CardRarity { get }

    /// ÐžÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð´Ð»Ñ UI (supports inline LocalizedString or StringKey)
    var description: LocalizableText { get }

    /// Ð˜ÐºÐ¾Ð½ÐºÐ° ÐºÐ°Ñ€Ñ‚Ñ‹ (SF Symbol Ð¸Ð»Ð¸ emoji)
    var icon: String { get }

    /// ÐÐ°Ð±Ð¾Ñ€/Ð´Ð¾Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ
    var expansionSet: ExpansionSet { get }

    /// ÐŸÑ€Ð¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð½Ð¾ÑÑ‚ÑŒ ÐºÐ°Ñ€Ñ‚Ñ‹ (ÐºÐ¾Ð¼Ñƒ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð°)
    var ownership: CardOwnership { get }

    /// Ð­Ñ„Ñ„ÐµÐºÑ‚Ñ‹ ÐºÐ°Ñ€Ñ‚Ñ‹
    var abilities: [CardAbility] { get }

    /// Ð¡Ñ‚Ð¾Ð¸Ð¼Ð¾ÑÑ‚ÑŒ Ð²ÐµÑ€Ñ‹ Ð´Ð»Ñ Ð¿Ð¾ÐºÑƒÐ¿ÐºÐ¸
    var faithCost: Int { get }

    /// Ð‘Ð°Ð»Ð°Ð½Ñ Ð¡Ð²ÐµÑ‚/Ð¢ÑŒÐ¼Ð°
    var balance: CardBalance? { get }

    /// Ð Ð¾Ð»ÑŒ ÐºÐ°Ñ€Ñ‚Ñ‹ Ð² ÐºÐ°Ð¼Ð¿Ð°Ð½Ð¸Ð¸
    var role: CardRole? { get }
}

/// ÐŸÑ€Ð¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð½Ð¾ÑÑ‚ÑŒ ÐºÐ°Ñ€Ñ‚Ñ‹ - Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÑ‚ ÐºÑ‚Ð¾ Ð¼Ð¾Ð¶ÐµÑ‚ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ ÐºÐ°Ñ€Ñ‚Ñƒ
/// ÐÐ½Ð°Ð»Ð¾Ð³ ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹ ÑÐ¸Ð³Ð½Ð°Ñ‚ÑƒÑ€Ð½Ñ‹Ñ… ÐºÐ°Ñ€Ñ‚ Ð¸Ð· Arkham Horror LCG
public enum CardOwnership: Equatable {
    /// Ð‘Ð°Ð·Ð¾Ð²Ð°Ñ ÐºÐ°Ñ€Ñ‚Ð° - Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð° Ð²ÑÐµÐ¼
    case universal

    /// Ð¡Ð¸Ð³Ð½Ð°Ñ‚ÑƒÑ€Ð½Ð°Ñ ÐºÐ°Ñ€Ñ‚Ð° Ð³ÐµÑ€Ð¾Ñ - Ð¿Ñ€Ð¸Ð²ÑÐ·Ð°Ð½Ð° Ðº ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ð¾Ð¼Ñƒ Ð³ÐµÑ€Ð¾ÑŽ Ð¿Ð¾ ID
    /// ÐšÐ°Ðº Ð² Arkham Horror LCG, Ð³Ð´Ðµ Ñƒ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ ÑÐ»ÐµÐ´Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ ÐµÑÑ‚ÑŒ ÑÐ²Ð¾Ð¸ ÑƒÐ½Ð¸ÐºÐ°Ð»ÑŒÐ½Ñ‹Ðµ ÐºÐ°Ñ€Ñ‚Ñ‹
    case heroSignature(heroID: String)

    /// ÐšÐ°Ñ€Ñ‚Ð° ÐºÐ»Ð°ÑÑÐ° - Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð° Ð³ÐµÑ€Ð¾ÑÐ¼ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ñ‘Ð½Ð½Ð¾Ð³Ð¾ ÐºÐ»Ð°ÑÑÐ°
    case classSpecific(className: String)

    /// ÐšÐ°Ñ€Ñ‚Ð° Ð½Ð°Ð±Ð¾Ñ€Ð°/Ð´Ð¾Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ - Ñ‚Ñ€ÐµÐ±ÑƒÐµÑ‚ Ð²Ð»Ð°Ð´ÐµÐ½Ð¸Ñ DLC
    case expansion(setID: String)

    /// ÐšÐ°Ñ€Ñ‚Ð° Ñ Ñ‚Ñ€ÐµÐ±Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼ Ñ€Ð°Ð·Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²ÐºÐ¸
    case requiresUnlock(condition: String)

    /// ÐšÐ°Ñ€Ñ‚Ð° Ñ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¸Ð¼Ð¸ ÑƒÑÐ»Ð¾Ð²Ð¸ÑÐ¼Ð¸ (Ð²ÑÐµ Ð´Ð¾Ð»Ð¶Ð½Ñ‹ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÑÑ‚ÑŒÑÑ)
    case composite([CardOwnership])
}

// MARK: - CardOwnership Codable

extension CardOwnership: Codable {
    private enum CodingKeys: String, CodingKey {
        case universal
        case heroSignature = "hero_signature"
        case classSpecific = "class_specific"
        case expansion
        case requiresUnlock = "requires_unlock"
        case composite
    }

    public init(from decoder: Decoder) throws {
        // Try string first (for "universal")
        if let container = try? decoder.singleValueContainer(),
           let stringValue = try? container.decode(String.self) {
            if stringValue == "universal" {
                self = .universal
                return
            }
        }

        // Try keyed container for complex types
        let container = try decoder.container(keyedBy: CodingKeys.self)

        if let heroID = try container.decodeIfPresent(String.self, forKey: .heroSignature) {
            self = .heroSignature(heroID: heroID)
        } else if let className = try container.decodeIfPresent(String.self, forKey: .classSpecific) {
            self = .classSpecific(className: className)
        } else if let setID = try container.decodeIfPresent(String.self, forKey: .expansion) {
            self = .expansion(setID: setID)
        } else if let condition = try container.decodeIfPresent(String.self, forKey: .requiresUnlock) {
            self = .requiresUnlock(condition: condition)
        } else if let items = try container.decodeIfPresent([CardOwnership].self, forKey: .composite) {
            self = .composite(items)
        } else {
            self = .universal
        }
    }

    public func encode(to encoder: Encoder) throws {
        switch self {
        case .universal:
            var container = encoder.singleValueContainer()
            try container.encode("universal")

        case .heroSignature(let heroID):
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(heroID, forKey: .heroSignature)

        case .classSpecific(let className):
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(className, forKey: .classSpecific)

        case .expansion(let setID):
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(setID, forKey: .expansion)

        case .requiresUnlock(let condition):
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(condition, forKey: .requiresUnlock)

        case .composite(let items):
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(items, forKey: .composite)
        }
    }
}

/// Ð¡Ñ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð°Ñ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ ÐºÐ°Ñ€Ñ‚Ñ‹
public struct StandardCardDefinition: CardDefinition, Codable {
    public let id: String
    public let name: LocalizableText
    public let cardType: CardType
    public let rarity: CardRarity
    public let description: LocalizableText
    public let icon: String
    public let expansionSet: ExpansionSet
    public let ownership: CardOwnership
    public let abilities: [CardAbility]
    public let faithCost: Int
    public let balance: CardBalance?
    public let role: CardRole?

    // Ð”Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹
    public let power: Int?
    public let defense: Int?
    public let health: Int?
    public let realm: Realm?
    public let curseType: CurseType?

    public init(
        id: String,
        name: LocalizableText,
        cardType: CardType,
        rarity: CardRarity = .common,
        description: LocalizableText,
        icon: String = "ðŸƒ",
        expansionSet: ExpansionSet = .baseSet,
        ownership: CardOwnership = .universal,
        abilities: [CardAbility] = [],
        faithCost: Int = 3,
        balance: CardBalance? = nil,
        role: CardRole? = nil,
        power: Int? = nil,
        defense: Int? = nil,
        health: Int? = nil,
        realm: Realm? = nil,
        curseType: CurseType? = nil
    ) {
        self.id = id
        self.name = name
        self.cardType = cardType
        self.rarity = rarity
        self.description = description
        self.icon = icon
        self.expansionSet = expansionSet
        self.ownership = ownership
        self.abilities = abilities
        self.faithCost = faithCost
        self.balance = balance
        self.role = role
        self.power = power
        self.defense = defense
        self.health = health
        self.realm = realm
        self.curseType = curseType
    }

    /// ÐšÐ¾Ð½Ð²ÐµÑ€Ñ‚Ð°Ñ†Ð¸Ñ Ð² Ð¸Ð³Ñ€Ð¾Ð²ÑƒÑŽ Card
    public func toCard() -> Card {
        return Card(
            id: UUID(),
            definitionId: id,  // Content Pack ID
            name: name.resolved,
            type: cardType,
            rarity: rarity,
            description: description.resolved,
            power: power,
            defense: defense,
            health: health,
            abilities: abilities,
            balance: balance,
            realm: realm,
            curseType: curseType,
            expansionSet: expansionSet.rawValue,
            role: role,
            faithCost: faithCost
        )
    }
}

// MARK: - Card Ownership Extensions

extension CardOwnership {
    /// ÐŸÑ€Ð¾Ð²ÐµÑ€Ð¸Ñ‚ÑŒ, Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð° Ð»Ð¸ ÐºÐ°Ñ€Ñ‚Ð° Ð´Ð»Ñ Ð³ÐµÑ€Ð¾Ñ
    func isAvailable(
        forHeroID heroID: String?,
        heroClass: String? = nil,
        ownedExpansions: Set<String> = [],
        unlockedConditions: Set<String> = []
    ) -> Bool {
        switch self {
        case .universal:
            return true

        case .heroSignature(let requiredHeroID):
            return heroID == requiredHeroID

        case .classSpecific(let className):
            return heroClass == className

        case .expansion(let setID):
            return ownedExpansions.contains(setID)

        case .requiresUnlock(let condition):
            return unlockedConditions.contains(condition)

        case .composite(let requirements):
            return requirements.allSatisfy { requirement in
                requirement.isAvailable(
                    forHeroID: heroID,
                    heroClass: heroClass,
                    ownedExpansions: ownedExpansions,
                    unlockedConditions: unlockedConditions
                )
            }
        }
    }

    /// ÐžÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ ÑƒÑÐ»Ð¾Ð²Ð¸Ð¹ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð° Ð´Ð»Ñ UI
    var accessDescription: String {
        switch self {
        case .universal:
            return "Ð”Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð° Ð²ÑÐµÐ¼"

        case .heroSignature(let heroID):
            return "Ð¡Ð¸Ð³Ð½Ð°Ñ‚ÑƒÑ€Ð½Ð°Ñ ÐºÐ°Ñ€Ñ‚Ð° Ð³ÐµÑ€Ð¾Ñ: \(heroID)"

        case .classSpecific(let className):
            return "ÐšÐ°Ñ€Ñ‚Ð° ÐºÐ»Ð°ÑÑÐ°: \(className)"

        case .expansion(let setID):
            return "Ð¢Ñ€ÐµÐ±ÑƒÐµÑ‚ÑÑ Ð´Ð¾Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ: \(setID)"

        case .requiresUnlock(let condition):
            return "Ð¢Ñ€ÐµÐ±ÑƒÐµÑ‚ÑÑ: \(condition)"

        case .composite(let requirements):
            let descriptions = requirements.map { $0.accessDescription }
            return descriptions.joined(separator: " + ")
        }
    }
}

// MARK: - Signature Card Set

/// ÐÐ°Ð±Ð¾Ñ€ ÑÐ¸Ð³Ð½Ð°Ñ‚ÑƒÑ€Ð½Ñ‹Ñ… ÐºÐ°Ñ€Ñ‚ Ð³ÐµÑ€Ð¾Ñ
/// ÐšÐ°Ð¶Ð´Ñ‹Ð¹ Ð³ÐµÑ€Ð¾Ð¹ Ð¼Ð¾Ð¶ÐµÑ‚ Ð¸Ð¼ÐµÑ‚ÑŒ ÑƒÐ½Ð¸ÐºÐ°Ð»ÑŒÐ½Ñ‹Ðµ ÐºÐ°Ñ€Ñ‚Ñ‹, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ Ð½Ð°Ñ‡Ð¸Ð½Ð°ÑŽÑ‚ Ð² ÐµÐ³Ð¾ ÐºÐ¾Ð»Ð¾Ð´Ðµ
/// Ð¸Ð»Ð¸ Ð¼Ð¾Ð³ÑƒÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ñ‹ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ ÑÑ‚Ð¾Ð¼Ñƒ Ð³ÐµÑ€Ð¾ÑŽ
public struct HeroSignatureCards {
    /// ID Ð³ÐµÑ€Ð¾Ñ
    let heroID: String

    /// ÐžÐ±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ ÑÐ¸Ð³Ð½Ð°Ñ‚ÑƒÑ€Ð½Ñ‹Ðµ ÐºÐ°Ñ€Ñ‚Ñ‹ (Ð½Ð°Ñ‡Ð¸Ð½Ð°ÑŽÑ‚ Ð² ÐºÐ¾Ð»Ð¾Ð´Ðµ)
    let requiredCards: [CardDefinition]

    /// ÐžÐ¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ðµ ÑÐ¸Ð³Ð½Ð°Ñ‚ÑƒÑ€Ð½Ñ‹Ðµ ÐºÐ°Ñ€Ñ‚Ñ‹ (Ð¼Ð¾Ð¶Ð½Ð¾ Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð²Ð¾ Ð²Ñ€ÐµÐ¼Ñ ÐºÐ°Ð¼Ð¿Ð°Ð½Ð¸Ð¸)
    let optionalCards: [CardDefinition]

    /// Ð¡Ð»Ð°Ð±Ð¾ÑÑ‚ÑŒ Ð³ÐµÑ€Ð¾Ñ (Ð½ÐµÐ³Ð°Ñ‚Ð¸Ð²Ð½Ð°Ñ ÑÐ¸Ð³Ð½Ð°Ñ‚ÑƒÑ€Ð½Ð°Ñ ÐºÐ°Ñ€Ñ‚Ð°)
    /// ÐšÐ°Ðº Ð² Arkham Horror LCG, Ð³Ð´Ðµ Ñƒ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ ÑÐ»ÐµÐ´Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ ÐµÑÑ‚ÑŒ ÑÐ²Ð¾Ñ ÑÐ»Ð°Ð±Ð¾ÑÑ‚ÑŒ
    let weakness: CardDefinition?

    /// Ð’ÑÐµ ÐºÐ°Ñ€Ñ‚Ñ‹ ID
    var allCardIDs: [String] {
        var ids = requiredCards.map { $0.id }
        ids.append(contentsOf: optionalCards.map { $0.id })
        if let weakness = weakness {
            ids.append(weakness.id)
        }
        return ids
    }
}

// MARK: - Hero Card Pool

/// ÐŸÑƒÐ» ÐºÐ°Ñ€Ñ‚ Ð³ÐµÑ€Ð¾Ñ
/// ÐšÐ°Ñ€Ñ‚Ñ‹, Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ðµ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ð¾Ð¼Ñƒ Ð³ÐµÑ€Ð¾ÑŽ
public struct HeroCardPool {
    /// ID Ð³ÐµÑ€Ð¾Ñ
    let heroID: String

    /// Ð¡Ñ‚Ð°Ñ€Ñ‚Ð¾Ð²Ñ‹Ðµ ÐºÐ°Ñ€Ñ‚Ñ‹ (Ð´Ð¾Ð±Ð°Ð²Ð»ÑÑŽÑ‚ÑÑ Ð² Ð½Ð°Ñ‡Ð°Ð»ÑŒÐ½ÑƒÑŽ ÐºÐ¾Ð»Ð¾Ð´Ñƒ)
    let startingCards: [CardDefinition]

    /// ÐšÐ°Ñ€Ñ‚Ñ‹ Ð´Ð»Ñ Ð¿Ð¾ÐºÑƒÐ¿ÐºÐ¸ (Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹ Ð² Ð¼Ð°Ð³Ð°Ð·Ð¸Ð½Ðµ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ ÑÑ‚Ð¾Ð¼Ñƒ Ð³ÐµÑ€Ð¾ÑŽ)
    let purchasableCards: [CardDefinition]

    /// ÐšÐ°Ñ€Ñ‚Ñ‹ ÑƒÐ»ÑƒÑ‡ÑˆÐµÐ½Ð¸Ñ (Ð·Ð°Ð¼ÐµÐ½Ð° Ð±Ð°Ð·Ð¾Ð²Ñ‹Ñ… ÐºÐ°Ñ€Ñ‚ Ð½Ð° ÑƒÐ»ÑƒÑ‡ÑˆÐµÐ½Ð½Ñ‹Ðµ)
    let upgradeCards: [CardDefinition]

    /// Ð’ÑÐµ ÐºÐ°Ñ€Ñ‚Ñ‹ ID
    var allCardIDs: [String] {
        var ids = startingCards.map { $0.id }
        ids.append(contentsOf: purchasableCards.map { $0.id })
        ids.append(contentsOf: upgradeCards.map { $0.id })
        return ids
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Cards/CardFactory.swift
// ==========================================

import Foundation

// MARK: - Card Factory

/// Factory for creating runtime Card instances from Content Pack definitions
/// This is the ONLY authorized way to create Card instances at runtime.
///
/// The factory reads ONLY from ContentRegistry (which loads from JSON packs)
/// and converts definitions to runtime Card instances.
///
/// IMPORTANT: No fallback to CardRegistry or any code-based content sources.
/// All card creation must go through ContentRegistry (pack-driven).
public final class CardFactory {

    // MARK: - Singleton

    /// Shared singleton instance using the default ContentRegistry.
    public static let shared = CardFactory()

    // MARK: - Dependencies

    private let contentRegistry: ContentRegistry

    // MARK: - Initialization

    /// Creates a CardFactory backed by the given content registry.
    public init(contentRegistry: ContentRegistry = .shared) {
        self.contentRegistry = contentRegistry
    }

    // MARK: - Card Creation

    /// Get a runtime Card by ID
    /// - Parameter id: Card definition ID
    /// - Returns: Runtime Card instance or nil if not found
    public func getCard(id: String) -> Card? {
        // ContentRegistry is the ONLY source of cards (pack-driven)
        if let cardDef = contentRegistry.getCard(id: id) {
            return cardDef.toCard()
        }
        return nil
    }

    /// Get multiple cards by IDs
    /// - Parameter ids: Array of card IDs
    /// - Returns: Array of runtime Card instances (skipping not found)
    public func getCards(ids: [String]) -> [Card] {
        return ids.compactMap { getCard(id: $0) }
    }

    /// Get all available cards
    /// - Returns: Array of all runtime Card instances
    public func getAllCards() -> [Card] {
        // ContentRegistry is the ONLY source of cards (pack-driven)
        return contentRegistry.getAllCards().map { $0.toCard() }
    }

    /// Get cards by type
    /// - Parameter type: Card type to filter
    /// - Returns: Array of runtime Card instances of that type
    public func getCards(ofType type: CardType) -> [Card] {
        // ContentRegistry is the ONLY source of cards (pack-driven)
        return contentRegistry.getCards(ofType: type).map { $0.toCard() }
    }

    // MARK: - Starting Decks

    /// Create starting deck for a hero
    /// - Parameter heroId: Hero definition ID
    /// - Returns: Array of runtime Card instances for starting deck
    public func createStartingDeck(forHero heroId: String) -> [Card] {
        // ContentRegistry is the ONLY source of starting decks (pack-driven)
        let cards = contentRegistry.getStartingDeck(forHero: heroId)
        if !cards.isEmpty {
            return cards.map { $0.toCard() }
        }

        // Fallback: generic starter deck from ContentRegistry
        return createGenericStarterDeck()
    }


    /// Create generic starter deck (fallback)
    /// Returns empty if no starter deck defined in content packs.
    private func createGenericStarterDeck() -> [Card] {
        #if DEBUG
        print("âš ï¸ CardFactory: No starting deck found for hero. Ensure content pack defines starting_deck.")
        #endif
        return []
    }

    // MARK: - Encounter Deck

    /// Create encounter deck from content packs
    /// - Returns: Array of monster cards for encounters
    public func createEncounterDeck() -> [Card] {
        var deck: [Card] = []

        // Get all enemies from ContentRegistry
        for enemy in contentRegistry.getAllEnemies() {
            deck.append(enemy.toCard())
        }

        return deck
    }

    // MARK: - Market Cards

    /// Create market cards for purchasing
    /// - Parameter heroId: Optional hero ID for filtering
    /// - Returns: Array of purchasable cards
    public func createMarketCards(forHeroId heroId: String? = nil) -> [Card] {
        // ContentRegistry is the ONLY source of cards (pack-driven)
        // Filter for purchasable cards (exclude signature, legendary)
        return contentRegistry.getAllCards()
            .filter { card in
                // Exclude legendary cards (found only in dungeons)
                if card.rarity == .legendary { return false }
                return true
            }
            .map { $0.toCard() }
    }

    // MARK: - Character Cards

    /// Create guardian characters for character selection
    /// - Returns: Array of hero cards for selection screen
    /// - Note: Requires ContentPacks to be loaded. Returns empty if no packs.
    public func createGuardians() -> [Card] {
        var guardians: [Card] = []

        // Get heroes ONLY from ContentRegistry (no hardcoded fallback)
        for hero in contentRegistry.getAllHeroes() {
            guardians.append(heroToCard(hero))
        }

        if guardians.isEmpty {
            #if DEBUG
            print("âš ï¸ CardFactory: No heroes loaded from ContentPacks. Ensure packs are loaded.")
            #endif
        }

        return guardians
    }

    /// Convert hero definition to Card for UI display
    private func heroToCard(_ hero: StandardHeroDefinition) -> Card {
        return Card(
            id: UUID(),
            name: hero.name.localized,
            type: .character,
            rarity: .legendary,
            description: hero.description.localized,
            imageURL: nil,
            power: hero.baseStats.strength,
            defense: 0,
            health: hero.baseStats.health,
            abilities: [
                CardAbility(
                    name: hero.specialAbility.name.localized,
                    description: hero.specialAbility.description.localized,
                    effect: .custom(hero.specialAbility.description.localized)
                )
            ],
            faithCost: 0
        )
    }

    // MARK: - Boss Creation

    /// Create boss card by enemy ID
    /// - Parameter enemyId: Enemy definition ID
    /// - Returns: Boss card or nil
    public func createBoss(enemyId: String) -> Card? {
        if let enemy = contentRegistry.getEnemy(id: enemyId) {
            return enemy.toCard()
        }
        return nil
    }

}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Cards/CardRegistry.swift
// ==========================================

import Foundation

/// Ð ÐµÐµÑÑ‚Ñ€ ÐºÐ°Ñ€Ñ‚ - Ñ†ÐµÐ½Ñ‚Ñ€Ð°Ð»Ð¸Ð·Ð¾Ð²Ð°Ð½Ð½Ð¾Ðµ Ñ…Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ðµ Ð²ÑÐµÑ… Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ð¹ ÐºÐ°Ñ€Ñ‚
/// ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÑ‚:
/// - Ð£Ð½Ð¸Ð²ÐµÑ€ÑÐ°Ð»ÑŒÐ½Ñ‹Ðµ ÐºÐ°Ñ€Ñ‚Ñ‹ (Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹ Ð²ÑÐµÐ¼)
/// - Ð¡Ð¸Ð³Ð½Ð°Ñ‚ÑƒÑ€Ð½Ñ‹Ðµ ÐºÐ°Ñ€Ñ‚Ñ‹ Ð³ÐµÑ€Ð¾Ñ (ÑƒÐ½Ð¸ÐºÐ°Ð»ÑŒÐ½Ñ‹Ðµ ÐºÐ°Ñ€Ñ‚Ñ‹ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ð¾Ð³Ð¾ Ð¿ÐµÑ€ÑÐ¾Ð½Ð°Ð¶Ð° Ð¿Ð¾ heroID)
/// - DLC/Expansion ÐºÐ°Ñ€Ñ‚Ñ‹
public final class CardRegistry {

    // MARK: - Singleton

    public static let shared = CardRegistry()

    // MARK: - Storage

    /// Ð’ÑÐµ Ð·Ð°Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ ÐºÐ°Ñ€Ñ‚Ñ‹
    private var definitions: [String: CardDefinition] = [:]

    /// ÐŸÑƒÐ»Ñ‹ ÐºÐ°Ñ€Ñ‚ Ð³ÐµÑ€Ð¾ÐµÐ² (Ð¿Ð¾ heroID)
    private var heroPools: [String: HeroCardPool] = [:]

    /// Ð¡Ð¸Ð³Ð½Ð°Ñ‚ÑƒÑ€Ð½Ñ‹Ðµ ÐºÐ°Ñ€Ñ‚Ñ‹ Ð³ÐµÑ€Ð¾ÐµÐ²
    private var signatureCards: [String: HeroSignatureCards] = [:]

    /// Ð˜ÑÑ‚Ð¾Ñ‡Ð½Ð¸ÐºÐ¸ Ð´Ð°Ð½Ð½Ñ‹Ñ… ÐºÐ°Ñ€Ñ‚
    private var dataSources: [CardDataSource] = []

    // MARK: - Init

    private init() {
        // No hardcoded cards - all content comes from ContentPacks
        // Cards are loaded via PackLoader -> ContentRegistry
    }

    // MARK: - Registration

    /// Register a card definition in the registry.
    /// - Parameter definition: The card definition to register.
    /// - Note: If a card with the same ID already exists, it will be replaced.
    public func register(_ definition: CardDefinition) {
        definitions[definition.id] = definition
    }

    /// Register multiple card definitions at once.
    /// - Parameter definitions: Array of card definitions to register.
    public func registerAll(_ definitions: [CardDefinition]) {
        for definition in definitions {
            register(definition)
        }
    }

    /// Register a hero's card pool (starting, purchasable, and upgrade cards).
    /// - Parameter pool: The hero card pool containing all cards for a specific hero.
    public func registerHeroPool(_ pool: HeroCardPool) {
        heroPools[pool.heroID] = pool
        registerAll(pool.startingCards)
        registerAll(pool.purchasableCards)
        registerAll(pool.upgradeCards)
    }

    /// Register signature cards for a hero.
    /// - Parameter cards: The signature cards collection for a hero.
    public func registerSignatureCards(_ cards: HeroSignatureCards) {
        signatureCards[cards.heroID] = cards
        registerAll(cards.requiredCards)
        registerAll(cards.optionalCards)
        if let weakness = cards.weakness {
            register(weakness)
        }
    }

    /// Remove a card from the registry.
    /// - Parameter id: The unique identifier of the card to remove.
    public func unregister(id: String) {
        definitions.removeValue(forKey: id)
    }

    /// Clear all registered cards, hero pools, and signature cards.
    /// - Note: This does not remove data sources; call `reload()` to repopulate.
    public func clear() {
        definitions.removeAll()
        heroPools.removeAll()
        signatureCards.removeAll()
    }

    /// Reload all cards from registered data sources.
    /// - Note: Clears existing registrations before reloading.
    public func reload() {
        clear()
        // Load cards from data sources (ContentPacks)
        for source in dataSources {
            registerAll(source.loadCards())
        }
    }

    // MARK: - Data Sources

    /// Add a data source and immediately load its cards.
    /// - Parameter source: The card data source to add.
    public func addDataSource(_ source: CardDataSource) {
        dataSources.append(source)
        registerAll(source.loadCards())
    }

    /// Remove a data source and unregister all its cards.
    /// - Parameter source: The card data source to remove.
    public func removeDataSource(_ source: CardDataSource) {
        if let index = dataSources.firstIndex(where: { $0.id == source.id }) {
            let source = dataSources.remove(at: index)
            for card in source.loadCards() {
                unregister(id: card.id)
            }
        }
    }

    // MARK: - Queries

    /// Get a card definition by its unique identifier.
    /// - Parameter id: The card's unique identifier.
    /// - Returns: The card definition, or `nil` if not found.
    public func card(id: String) -> CardDefinition? {
        return definitions[id]
    }

    /// All registered card definitions.
    public var allCards: [CardDefinition] {
        return Array(definitions.values)
    }

    /// Get cards available for a specific hero considering ownership rules.
    /// - Parameters:
    ///   - heroID: The hero's unique identifier (for signature cards).
    ///   - ownedExpansions: Set of owned expansion/DLC identifiers.
    ///   - unlockedConditions: Set of unlocked condition flags.
    /// - Returns: Array of card definitions available to the hero.
    public func availableCards(
        forHeroID heroID: String?,
        ownedExpansions: Set<String> = [],
        unlockedConditions: Set<String> = []
    ) -> [CardDefinition] {
        return allCards.filter { card in
            card.ownership.isAvailable(
                forHeroID: heroID,
                ownedExpansions: ownedExpansions,
                unlockedConditions: unlockedConditions
            )
        }
    }

    /// All universal cards (available to all heroes).
    public var universalCards: [CardDefinition] {
        return allCards.filter { card in
            if case .universal = card.ownership { return true }
            return false
        }
    }

    /// Get signature cards for a specific hero.
    /// - Parameter heroID: The hero's unique identifier.
    /// - Returns: The hero's signature cards, or `nil` if none registered.
    public func signatureCards(forHeroID heroID: String) -> HeroSignatureCards? {
        return signatureCards[heroID]
    }

    /// Get the card pool for a specific hero.
    /// - Parameter heroID: The hero's unique identifier.
    /// - Returns: The hero's card pool, or `nil` if none registered.
    public func heroPool(for heroID: String) -> HeroCardPool? {
        return heroPools[heroID]
    }

    /// Build the starting deck for a hero.
    /// - Parameter heroID: The hero's unique identifier.
    /// - Returns: Array of Card instances for the hero's starting deck.
    /// - Note: Includes basic universal cards, hero pool cards, and signature cards.
    public func startingDeck(forHeroID heroID: String) -> [Card] {
        var deck: [Card] = []

        // 1. Ð‘Ð°Ð·Ð¾Ð²Ñ‹Ðµ ÑƒÐ½Ð¸Ð²ÐµÑ€ÑÐ°Ð»ÑŒÐ½Ñ‹Ðµ ÐºÐ°Ñ€Ñ‚Ñ‹
        let basicCards = universalCards.filter { $0.rarity == .common }
        for cardDef in basicCards.prefix(5) {
            if let def = cardDef as? StandardCardDefinition {
                deck.append(def.toCard())
            }
        }

        // 2. ÐšÐ°Ñ€Ñ‚Ñ‹ Ð³ÐµÑ€Ð¾Ñ (Ð¸Ð· Ð¿ÑƒÐ»Ð°)
        if let pool = heroPools[heroID] {
            for cardDef in pool.startingCards {
                if let def = cardDef as? StandardCardDefinition {
                    deck.append(def.toCard())
                }
            }
        }

        // 3. Ð¡Ð¸Ð³Ð½Ð°Ñ‚ÑƒÑ€Ð½Ñ‹Ðµ ÐºÐ°Ñ€Ñ‚Ñ‹ Ð³ÐµÑ€Ð¾Ñ
        if let signature = signatureCards[heroID] {
            for cardDef in signature.requiredCards {
                if let def = cardDef as? StandardCardDefinition {
                    deck.append(def.toCard())
                }
            }
            // Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ ÑÐ»Ð°Ð±Ð¾ÑÑ‚ÑŒ
            if let weakness = signature.weakness as? StandardCardDefinition {
                deck.append(weakness.toCard())
            }
        }

        return deck
    }

    /// Get cards available for purchase in the shop.
    /// - Parameters:
    ///   - heroID: The hero's unique identifier.
    ///   - ownedExpansions: Set of owned expansion/DLC identifiers.
    ///   - unlockedConditions: Set of unlocked condition flags.
    ///   - maxRarity: Maximum rarity to include (default: epic).
    /// - Returns: Array of purchasable card definitions.
    /// - Note: Excludes signature cards and legendary cards (dungeon rewards only).
    public func shopCards(
        forHeroID heroID: String?,
        ownedExpansions: Set<String> = [],
        unlockedConditions: Set<String> = [],
        maxRarity: CardRarity = .epic
    ) -> [CardDefinition] {
        return availableCards(
            forHeroID: heroID,
            ownedExpansions: ownedExpansions,
            unlockedConditions: unlockedConditions
        ).filter { card in
            // Exclude signature cards from shop
            if case .heroSignature = card.ownership { return false }
            // Exclude legendary (dungeon rewards only)
            if card.rarity == .legendary { return false }
            return card.rarity.order <= maxRarity.order
        }
    }

    /// Number of registered cards.
    public var count: Int {
        return definitions.count
    }

    // MARK: - Content Pack Integration
    // All cards are now loaded from ContentPacks via PackLoader.
    // No hardcoded cards in CardRegistry.
    // See: ContentPacks/TwilightMarches/Cards/cards.json
}

// MARK: - Card Data Source Protocol

/// Protocol for card data sources.
/// Allows loading cards from different sources (JSON files, server, DLC).
public protocol CardDataSource {
    /// Unique identifier for this data source.
    var id: String { get }

    /// Human-readable name (for debugging).
    var name: String { get }

    /// Load all cards from this data source.
    /// - Returns: Array of card definitions.
    func loadCards() -> [CardDefinition]
}

// MARK: - JSON Data Source

/// Card data source that loads from a JSON file.
public struct JSONCardDataSource: CardDataSource {
    /// Unique identifier for this data source.
    public let id: String

    /// Human-readable name (for debugging).
    public let name: String

    /// URL to the JSON file containing card definitions.
    public let fileURL: URL

    /// Load cards from the JSON file.
    /// - Returns: Array of card definitions, or empty array on error.
    public func loadCards() -> [CardDefinition] {
        guard let data = try? Data(contentsOf: fileURL) else {
            #if DEBUG
            print("CardRegistry: Failed to load JSON from \(fileURL)")
            #endif
            return []
        }

        do {
            let decoded = try JSONDecoder().decode([JSONCardDefinition].self, from: data)
            return decoded.map { $0.toStandard() }
        } catch {
            #if DEBUG
            print("CardRegistry: Failed to decode cards: \(error)")
            #endif
            return []
        }
    }
}

/// JSON-ÑÐ¾Ð²Ð¼ÐµÑÑ‚Ð¸Ð¼Ð¾Ðµ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ ÐºÐ°Ñ€Ñ‚Ñ‹
public struct JSONCardDefinition: Codable {
    let id: String
    let name: String
    let cardType: CardType
    let rarity: CardRarity
    let description: String
    let icon: String?
    let expansionSet: ExpansionSet?
    let faithCost: Int
    let balance: CardBalance?
    let role: CardRole?
    let power: Int?
    let defense: Int?
    let health: Int?
    // Simplified ownership for JSON
    let ownershipType: String?  // "universal", "hero:warrior_ragnar"

    func toStandard() -> StandardCardDefinition {
        let ownership: CardOwnership
        if let ownershipType = ownershipType {
            if ownershipType == "universal" {
                ownership = .universal
            } else if ownershipType.hasPrefix("hero:") {
                let heroID = String(ownershipType.dropFirst(5))
                ownership = .heroSignature(heroID: heroID)
            } else {
                ownership = .universal
            }
        } else {
            ownership = .universal
        }

        return StandardCardDefinition(
            id: id,
            name: .text(name),
            cardType: cardType,
            rarity: rarity,
            description: .text(description),
            icon: icon ?? "ðŸƒ",
            expansionSet: expansionSet ?? .baseSet,
            ownership: ownership,
            faithCost: faithCost,
            balance: balance,
            role: role,
            power: power,
            defense: defense,
            health: health
        )
    }
}

// MARK: - CardRarity Extension

extension CardRarity {
    /// ÐŸÐ¾Ñ€ÑÐ´Ð¾Ðº Ñ€ÐµÐ´ÐºÐ¾ÑÑ‚Ð¸ Ð´Ð»Ñ ÑÑ€Ð°Ð²Ð½ÐµÐ½Ð¸Ñ
    var order: Int {
        switch self {
        case .common: return 0
        case .uncommon: return 1
        case .rare: return 2
        case .epic: return 3
        case .legendary: return 4
        }
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Runtime/EngineTypes.swift
// ==========================================

import Foundation

// MARK: - Active Curse
// Tracking for curses applied to the player

/// Represents an active curse on the player
public struct ActiveCurse: Identifiable, Codable {
    public let id: UUID
    public let type: CurseType
    public var duration: Int  // turns remaining
    public let sourceCard: String?  // name of card that applied curse

    public init(id: UUID = UUID(), type: CurseType, duration: Int, sourceCard: String? = nil) {
        self.id = id
        self.type = type
        self.duration = duration
        self.sourceCard = sourceCard
    }
}

// MARK: - Event Log Entry

/// Record in the event log
public struct EventLogEntry: Identifiable, Codable {
    public let id: UUID
    public let dayNumber: Int
    public let timestamp: Date
    public let regionName: String
    public let eventTitle: String
    public let choiceMade: String
    public let outcome: String
    public let type: EventLogType

    public init(
        id: UUID = UUID(),
        dayNumber: Int,
        timestamp: Date = Date(),
        regionName: String,
        eventTitle: String,
        choiceMade: String,
        outcome: String,
        type: EventLogType
    ) {
        self.id = id
        self.dayNumber = dayNumber
        self.timestamp = timestamp
        self.regionName = regionName
        self.eventTitle = eventTitle
        self.choiceMade = choiceMade
        self.outcome = outcome
        self.type = type
    }
}

/// Type of event log entry
public enum EventLogType: String, Codable {
    case exploration    // Exploration
    case combat         // Combat
    case choice         // Choice
    case quest          // Quest
    case travel         // Travel
    case worldChange    // World change

    public var icon: String {
        switch self {
        case .exploration: return "magnifyingglass"
        case .combat: return "swords"
        case .choice: return "questionmark.circle"
        case .quest: return "scroll"
        case .travel: return "figure.walk"
        case .worldChange: return "globe"
        }
    }
}

// MARK: - Day Event

/// Event that occurred at the end of a day (for notifications)
public struct DayEvent: Identifiable {
    public let id = UUID()
    public let day: Int
    public let title: String
    public let description: String
    public let isNegative: Bool

    public init(day: Int, title: String, description: String, isNegative: Bool) {
        self.day = day
        self.title = title
        self.description = description
        self.isNegative = isNegative
    }

    public static func tensionIncrease(day: Int, newTension: Int) -> DayEvent {
        DayEvent(
            day: day,
            title: "ÐÐ°Ð¿Ñ€ÑÐ¶ÐµÐ½Ð¸Ðµ Ñ€Ð°ÑÑ‚Ñ‘Ñ‚",
            description: "ÐÐ°Ð¿Ñ€ÑÐ¶ÐµÐ½Ð¸Ðµ Ð¼Ð¸Ñ€Ð° Ð´Ð¾ÑÑ‚Ð¸Ð³Ð»Ð¾ \(newTension)%",
            isNegative: true
        )
    }

    public static func regionDegraded(day: Int, regionName: String, newState: RegionState) -> DayEvent {
        DayEvent(
            day: day,
            title: "Ð ÐµÐ³Ð¸Ð¾Ð½ Ð´ÐµÐ³Ñ€Ð°Ð´Ð¸Ñ€ÑƒÐµÑ‚",
            description: "\(regionName) Ñ‚ÐµÐ¿ÐµÑ€ÑŒ Ð² ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ð¸ \(newState.displayName)",
            isNegative: true
        )
    }

    public static func worldImproving(day: Int) -> DayEvent {
        DayEvent(
            day: day,
            title: "ÐœÐ¸Ñ€ Ð²Ð¾ÑÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÑ‚ÑÑ",
            description: "Ð¡Ð¸Ð»Ñ‹ Ð¯Ð²Ð¸ ÑƒÐºÑ€ÐµÐ¿Ð»ÑÑŽÑ‚ÑÑ",
            isNegative: false
        )
    }
}

// MARK: - Game End Result
// Note: GameEndResult is defined in Core/GameLoop.swift


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Runtime/EventRuntimeState.swift
// ==========================================

import Foundation

// MARK: - Event Runtime State
// Reference: Docs/EVENT_MODULE_ARCHITECTURE.md, Section 5
// Reference: Docs/MIGRATION_PLAN.md, Feature A2

/// Mutable runtime state for the event system.
/// Tracks which events have been completed, cooldowns, etc.
public struct EventRuntimeState: Codable, Equatable {
    // MARK: - Completion Tracking

    /// Set of completed one-time event IDs
    public var completedOneTimeEvents: Set<String>

    /// Count of times each event has occurred
    public var eventOccurrenceCount: [String: Int]

    // MARK: - Cooldowns

    /// Cooldown remaining for each event (turns until available)
    public var eventCooldowns: [String: Int]

    // MARK: - Current Event

    /// Currently active event ID (nil if no event active)
    public var activeEventId: String?

    /// Currently active mini-game challenge (nil if no mini-game active)
    public var activeMiniGameId: String?

    // MARK: - Selection State

    /// Last used random seed for deterministic replay
    public var lastSelectionSeed: UInt64

    // MARK: - Initialization

    public init(
        completedOneTimeEvents: Set<String> = [],
        eventOccurrenceCount: [String: Int] = [:],
        eventCooldowns: [String: Int] = [:],
        activeEventId: String? = nil,
        activeMiniGameId: String? = nil,
        lastSelectionSeed: UInt64 = 0
    ) {
        self.completedOneTimeEvents = completedOneTimeEvents
        self.eventOccurrenceCount = eventOccurrenceCount
        self.eventCooldowns = eventCooldowns
        self.activeEventId = activeEventId
        self.activeMiniGameId = activeMiniGameId
        self.lastSelectionSeed = lastSelectionSeed
    }

    // MARK: - Completion Operations

    /// Mark an event as completed
    mutating func markCompleted(_ eventId: String, isOneTime: Bool) {
        eventOccurrenceCount[eventId, default: 0] += 1
        if isOneTime {
            completedOneTimeEvents.insert(eventId)
        }
    }

    /// Check if a one-time event is completed
    public func isOneTimeCompleted(_ eventId: String) -> Bool {
        return completedOneTimeEvents.contains(eventId)
    }

    /// Get occurrence count for an event
    public func occurrenceCount(for eventId: String) -> Int {
        return eventOccurrenceCount[eventId] ?? 0
    }

    // MARK: - Cooldown Operations

    /// Set cooldown for an event
    mutating func setCooldown(_ eventId: String, turns: Int) {
        if turns > 0 {
            eventCooldowns[eventId] = turns
        }
    }

    /// Check if event is on cooldown
    public func isOnCooldown(_ eventId: String) -> Bool {
        return (eventCooldowns[eventId] ?? 0) > 0
    }

    /// Tick all cooldowns (call each turn)
    mutating func tickCooldowns() {
        for (eventId, remaining) in eventCooldowns {
            if remaining > 1 {
                eventCooldowns[eventId] = remaining - 1
            } else {
                eventCooldowns.removeValue(forKey: eventId)
            }
        }
    }

    // MARK: - Active Event Operations

    /// Start an event
    mutating func startEvent(_ eventId: String) {
        activeEventId = eventId
    }

    /// End the current event
    mutating func endEvent() {
        activeEventId = nil
        activeMiniGameId = nil
    }

    /// Start a mini-game within current event
    mutating func startMiniGame(_ challengeId: String) {
        activeMiniGameId = challengeId
    }

    /// End the current mini-game
    mutating func endMiniGame() {
        activeMiniGameId = nil
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Runtime/GameRuntimeState.swift
// ==========================================

import Foundation

// MARK: - Game Runtime State
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.2
// Reference: Docs/MIGRATION_PLAN.md, Feature A2

/// Combined runtime state for the entire game.
/// This is the single source of truth for game state.
/// All changes go through GameEngine.performAction().
public struct GameRuntimeState: Codable, Equatable {
    // MARK: - Component States

    /// World state (regions, anchors, flags, pressure, time)
    public var world: WorldRuntimeState

    /// Player state (resources, deck, balance, curses)
    public var player: PlayerRuntimeState

    /// Event state (completion tracking, cooldowns)
    public var events: EventRuntimeState

    /// Quest state (progress, completion)
    public var quests: QuestRuntimeState

    // MARK: - Game Meta

    /// Current game phase
    public var phase: EngineGamePhase

    /// Random seed for this playthrough
    public let playthroughSeed: UInt64

    /// Save slot identifier
    public var saveSlot: Int?

    // MARK: - Initialization

    public init(
        world: WorldRuntimeState,
        player: PlayerRuntimeState,
        events: EventRuntimeState = EventRuntimeState(),
        quests: QuestRuntimeState = QuestRuntimeState(),
        phase: EngineGamePhase = .playing,
        playthroughSeed: UInt64 = 0,
        saveSlot: Int? = nil
    ) {
        self.world = world
        self.player = player
        self.events = events
        self.quests = quests
        self.phase = phase
        self.playthroughSeed = playthroughSeed
        self.saveSlot = saveSlot
    }

    // MARK: - Convenience Accessors

    /// Current region ID
    public var currentRegionId: String {
        return world.currentRegionId
    }

    /// Current time (days)
    public var currentTime: Int {
        return world.currentTime
    }

    /// Current pressure
    public var currentPressure: Int {
        return world.pressure
    }

    /// Check game over conditions
    public var isGameOver: Bool {
        // Pressure maximum
        if world.isPressureMaximum {
            return true
        }
        // Player death (health <= 0)
        if player.getResource("health") <= 0 {
            return true
        }
        return false
    }

    /// Get combined flags (world + player)
    public func getAllFlags() -> Set<String> {
        var allFlags = Set<String>()
        for (key, value) in world.flags where value {
            allFlags.insert(key)
        }
        for (key, value) in player.flags where value {
            allFlags.insert(key)
        }
        return allFlags
    }
}

// MARK: - Factory Methods

extension GameRuntimeState {
    /// Create a new game state with default values
    public static func newGame(
        startingRegionId: String,
        startingResources: [String: Int],
        startingDeck: [String],
        seed: UInt64
    ) -> GameRuntimeState {
        let actualSeed = seed

        let world = WorldRuntimeState(
            currentRegionId: startingRegionId,
            currentTime: 0,
            pressure: 0
        )

        let player = PlayerRuntimeState(
            resources: startingResources,
            balance: 0,
            drawPile: startingDeck
        )

        return GameRuntimeState(
            world: world,
            player: player,
            playthroughSeed: actualSeed
        )
    }
}

// MARK: - Snapshot for Regression Testing

public extension GameRuntimeState {
    /// Create a snapshot for comparison
    struct Snapshot: Equatable {
        public let pressure: Int
        public let time: Int
        public let health: Int
        public let faith: Int
        public let balance: Int
        public let currentRegionId: String
        public let visitedRegionsCount: Int
        public let completedEventsCount: Int
        public let activeQuestsCount: Int
        public let deckSize: Int
        public let flagCount: Int
    }

    /// Generate snapshot for testing
    func snapshot() -> Snapshot {
        let visitedCount = world.regionsState.values.filter { $0.visitCount > 0 }.count

        return Snapshot(
            pressure: world.pressure,
            time: world.currentTime,
            health: player.getResource("health"),
            faith: player.getResource("faith"),
            balance: player.balance,
            currentRegionId: world.currentRegionId,
            visitedRegionsCount: visitedCount,
            completedEventsCount: events.completedOneTimeEvents.count,
            activeQuestsCount: quests.activeQuests.count,
            deckSize: player.totalCardCount,
            flagCount: getAllFlags().count
        )
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Runtime/PlayerRuntimeState.swift
// ==========================================

import Foundation

// MARK: - Player Runtime State
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.2
// Reference: Docs/MIGRATION_PLAN.md, Feature A2

/// Mutable runtime state of the player.
/// Tracks resources, deck, balance, curses, etc.
public struct PlayerRuntimeState: Codable, Equatable {
    // MARK: - Resources

    /// Player resources (health, faith, etc.)
    public var resources: [String: Int]

    // MARK: - Balance/Path

    /// Balance between Nav and Prav (-100 to +100)
    /// Negative = Nav (chaos), Positive = Prav (order)
    public var balance: Int

    // MARK: - Deck State

    /// Cards in draw pile (by card ID)
    public var drawPile: [String]

    /// Cards in hand
    public var hand: [String]

    /// Cards in discard pile
    public var discardPile: [String]

    /// Cards in exile (removed from game)
    public var exilePile: [String]

    // MARK: - Curses

    /// Active curse IDs
    public var activeCurses: Set<String>

    // MARK: - Player Flags

    /// Player-specific flags
    public var flags: [String: Bool]

    // MARK: - Initialization

    public init(
        resources: [String: Int] = [:],
        balance: Int = 0,
        drawPile: [String] = [],
        hand: [String] = [],
        discardPile: [String] = [],
        exilePile: [String] = [],
        activeCurses: Set<String> = [],
        flags: [String: Bool] = [:]
    ) {
        self.resources = resources
        self.balance = balance
        self.drawPile = drawPile
        self.hand = hand
        self.discardPile = discardPile
        self.exilePile = exilePile
        self.activeCurses = activeCurses
        self.flags = flags
    }

    // MARK: - Resource Operations

    /// Get resource value (0 if not set)
    public func getResource(_ resourceId: String) -> Int {
        return resources[resourceId] ?? 0
    }

    /// Set resource value
    public mutating func setResource(_ resourceId: String, value: Int) {
        resources[resourceId] = value
    }

    /// Modify resource by delta
    public mutating func modifyResource(_ resourceId: String, by delta: Int) {
        resources[resourceId] = (resources[resourceId] ?? 0) + delta
    }

    /// Check if player can afford a cost
    public func canAfford(_ costs: [String: Int]) -> Bool {
        for (resourceId, cost) in costs {
            if getResource(resourceId) < cost {
                return false
            }
        }
        return true
    }

    // MARK: - Balance Operations

    /// Shift balance (clamped to -100...100)
    public mutating func shiftBalance(by delta: Int) {
        balance = max(-100, min(100, balance + delta))
    }

    /// Check if balance is within range
    public func isBalanceInRange(_ range: ClosedRange<Int>) -> Bool {
        return range.contains(balance)
    }

    /// Balance alignment
    public var alignment: BalanceAlignment {
        if balance < -30 {
            return .nav
        } else if balance > 30 {
            return .prav
        } else {
            return .neutral
        }
    }

    // MARK: - Deck Operations

    /// Total cards in deck (all zones)
    public var totalCardCount: Int {
        return drawPile.count + hand.count + discardPile.count + exilePile.count
    }

    /// Add card to draw pile
    mutating func addCardToDrawPile(_ cardId: String) {
        drawPile.append(cardId)
    }

    /// Add card to discard pile
    mutating func addCardToDiscard(_ cardId: String) {
        discardPile.append(cardId)
    }

    /// Move card from hand to discard
    mutating func discardFromHand(_ cardId: String) -> Bool {
        if let index = hand.firstIndex(of: cardId) {
            hand.remove(at: index)
            discardPile.append(cardId)
            return true
        }
        return false
    }

    /// Exile a card (remove from game)
    mutating func exileCard(_ cardId: String, from zone: DeckZone) -> Bool {
        switch zone {
        case .draw:
            if let index = drawPile.firstIndex(of: cardId) {
                drawPile.remove(at: index)
                exilePile.append(cardId)
                return true
            }
        case .hand:
            if let index = hand.firstIndex(of: cardId) {
                hand.remove(at: index)
                exilePile.append(cardId)
                return true
            }
        case .discard:
            if let index = discardPile.firstIndex(of: cardId) {
                discardPile.remove(at: index)
                exilePile.append(cardId)
                return true
            }
        case .exile:
            return false // Already exiled
        }
        return false
    }

    /// Shuffle discard into draw pile
    /// Uses deterministic RNG for reproducibility
    mutating func shuffleDiscardIntoDraw() {
        drawPile.append(contentsOf: discardPile)
        discardPile.removeAll()
        WorldRNG.shared.shuffle(&drawPile)
    }

    // MARK: - Curse Operations

    /// Add a curse
    public mutating func addCurse(_ curseId: String) {
        activeCurses.insert(curseId)
    }

    /// Remove a curse
    public mutating func removeCurse(_ curseId: String) {
        activeCurses.remove(curseId)
    }

    /// Check if player has a curse
    public func hasCurse(_ curseId: String) -> Bool {
        return activeCurses.contains(curseId)
    }
}

// MARK: - Supporting Types

/// Deck zones
public enum DeckZone: String, Codable, Hashable {
    case draw
    case hand
    case discard
    case exile
}

/// Balance alignment
public enum BalanceAlignment: String, Codable, Hashable {
    case nav      // Chaos side
    case neutral
    case prav     // Order side
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Runtime/QuestRuntimeState.swift
// ==========================================

import Foundation

// MARK: - Quest Runtime State
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.2
// Reference: Docs/MIGRATION_PLAN.md, Feature A2

/// Mutable runtime state for the quest system.
/// Tracks quest progress, completion, etc.
public struct QuestRuntimeState: Codable, Equatable {
    // MARK: - Quest Tracking

    /// State of each quest (keyed by quest definition ID)
    public var questStates: [String: SingleQuestState]

    // MARK: - Initialization

    public init(questStates: [String: SingleQuestState] = [:]) {
        self.questStates = questStates
    }

    // MARK: - Quest Operations

    /// Get state for a specific quest
    public func getQuestState(_ questId: String) -> SingleQuestState? {
        return questStates[questId]
    }

    /// Start a new quest
    mutating func startQuest(_ questId: String, firstObjectiveId: String) {
        questStates[questId] = SingleQuestState(
            definitionId: questId,
            status: .active,
            currentObjectiveId: firstObjectiveId
        )
    }

    /// Update quest state
    mutating func updateQuest(_ questId: String, update: (inout SingleQuestState) -> Void) {
        if var state = questStates[questId] {
            update(&state)
            questStates[questId] = state
        }
    }

    /// Get all active quests
    public var activeQuests: [SingleQuestState] {
        return questStates.values.filter { $0.status == .active }
    }

    /// Get all completed quests
    public var completedQuests: [SingleQuestState] {
        return questStates.values.filter { $0.status == .completed }
    }
}

// MARK: - Single Quest State

/// Runtime state of a single quest.
public struct SingleQuestState: Codable, Equatable {
    /// Reference to quest definition
    public let definitionId: String

    /// Current quest status
    public var status: QuestStatus

    /// Current objective ID (nil if completed or failed)
    public var currentObjectiveId: String?

    /// Completed objective IDs
    public var completedObjectiveIds: Set<String>

    /// Failed objective IDs
    public var failedObjectiveIds: Set<String>

    /// Quest-specific flags
    public var flags: [String: Bool]

    /// Progress values for objectives (e.g., "kill_count": 3)
    public var progressValues: [String: Int]

    public init(
        definitionId: String,
        status: QuestStatus = .locked,
        currentObjectiveId: String? = nil,
        completedObjectiveIds: Set<String> = [],
        failedObjectiveIds: Set<String> = [],
        flags: [String: Bool] = [:],
        progressValues: [String: Int] = [:]
    ) {
        self.definitionId = definitionId
        self.status = status
        self.currentObjectiveId = currentObjectiveId
        self.completedObjectiveIds = completedObjectiveIds
        self.failedObjectiveIds = failedObjectiveIds
        self.flags = flags
        self.progressValues = progressValues
    }

    // MARK: - Objective Operations

    /// Complete current objective and move to next
    mutating func completeCurrentObjective(nextObjectiveId: String?) {
        if let currentId = currentObjectiveId {
            completedObjectiveIds.insert(currentId)
        }
        currentObjectiveId = nextObjectiveId

        // If no next objective, quest is complete
        if nextObjectiveId == nil {
            status = .completed
        }
    }

    /// Fail current objective
    mutating func failCurrentObjective() {
        if let currentId = currentObjectiveId {
            failedObjectiveIds.insert(currentId)
        }
        status = .failed
        currentObjectiveId = nil
    }

    /// Increment progress for a key
    mutating func incrementProgress(_ key: String, by amount: Int = 1) {
        progressValues[key, default: 0] += amount
    }

    /// Check progress against target
    public func checkProgress(_ key: String, target: Int) -> Bool {
        return (progressValues[key] ?? 0) >= target
    }
}

// MARK: - Quest Status

/// Possible statuses for a quest
public enum QuestStatus: String, Codable, Hashable {
    /// Quest not yet available/visible
    case locked

    /// Quest available but not started
    case available

    /// Quest in progress
    case active

    /// Quest successfully completed
    case completed

    /// Quest failed
    case failed
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Runtime/WorldRuntimeState.swift
// ==========================================

import Foundation

// MARK: - World Runtime State
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.2
// Reference: Docs/MIGRATION_PLAN.md, Feature A2

/// Mutable runtime state of the game world.
/// References Definitions by ID, never stores Definition data.
public struct WorldRuntimeState: Codable, Equatable {
    // MARK: - Current Position

    /// Current region ID
    public var currentRegionId: String

    // MARK: - Time

    /// Current game time (days passed)
    public var currentTime: Int

    // MARK: - Pressure

    /// Current world tension/pressure (0-100)
    public var pressure: Int

    /// Days since last pressure escalation
    public var daysSinceEscalation: Int

    // MARK: - Regions State

    /// Runtime state of each region (keyed by definition ID)
    public var regionsState: [String: RegionRuntimeState]

    // MARK: - Anchors State

    /// Runtime state of each anchor (keyed by definition ID)
    public var anchorsState: [String: AnchorRuntimeState]

    // MARK: - World Flags

    /// Global world flags
    public var flags: [String: Bool]

    // MARK: - Initialization

    public init(
        currentRegionId: String,
        currentTime: Int = 0,
        pressure: Int = 0,
        daysSinceEscalation: Int = 0,
        regionsState: [String: RegionRuntimeState] = [:],
        anchorsState: [String: AnchorRuntimeState] = [:],
        flags: [String: Bool] = [:]
    ) {
        self.currentRegionId = currentRegionId
        self.currentTime = currentTime
        self.pressure = pressure
        self.daysSinceEscalation = daysSinceEscalation
        self.regionsState = regionsState
        self.anchorsState = anchorsState
        self.flags = flags
    }

    // MARK: - Flag Operations

    mutating func setFlag(_ flag: String, value: Bool = true) {
        flags[flag] = value
    }

    public func hasFlag(_ flag: String) -> Bool {
        return flags[flag] ?? false
    }

    // MARK: - Region Operations

    public func getRegionState(_ regionId: String) -> RegionRuntimeState? {
        return regionsState[regionId]
    }

    mutating func updateRegion(_ regionId: String, update: (inout RegionRuntimeState) -> Void) {
        if var state = regionsState[regionId] {
            update(&state)
            regionsState[regionId] = state
        }
    }

    // MARK: - Pressure Operations

    /// Check if pressure is at maximum (game over condition)
    public var isPressureMaximum: Bool {
        return pressure >= 100
    }
}

// MARK: - Region Runtime State

/// Mutable runtime state of a single region.
public struct RegionRuntimeState: Codable, Equatable {
    /// Reference to the region definition
    public let definitionId: String

    /// Current state (stable/borderland/breach)
    public var currentState: RegionStateType

    /// Number of times player has visited
    public var visitCount: Int

    /// Whether region is discovered/visible on map
    public var isDiscovered: Bool

    /// Region-specific flags
    public var flags: [String: Bool]

    public init(
        definitionId: String,
        currentState: RegionStateType = .stable,
        visitCount: Int = 0,
        isDiscovered: Bool = false,
        flags: [String: Bool] = [:]
    ) {
        self.definitionId = definitionId
        self.currentState = currentState
        self.visitCount = visitCount
        self.isDiscovered = isDiscovered
        self.flags = flags
    }

    // MARK: - Operations

    public mutating func visit() {
        visitCount += 1
        isDiscovered = true
    }

    public mutating func degrade() -> Bool {
        guard let newState = currentState.degraded else { return false }
        currentState = newState
        return true
    }

    public mutating func restore() -> Bool {
        guard let newState = currentState.restored else { return false }
        currentState = newState
        return true
    }
}

// MARK: - Anchor Runtime State

/// Mutable runtime state of a single anchor.
public struct AnchorRuntimeState: Codable, Equatable {
    /// Reference to the anchor definition
    public let definitionId: String

    /// Current integrity (0-100)
    public var integrity: Int

    /// Whether anchor is active/usable
    public var isActive: Bool

    public init(
        definitionId: String,
        integrity: Int = 50,
        isActive: Bool = true
    ) {
        self.definitionId = definitionId
        self.integrity = integrity
        self.isActive = isActive
    }

    // MARK: - Operations

    mutating func strengthen(amount: Int, maxIntegrity: Int) {
        integrity = min(maxIntegrity, integrity + amount)
    }

    mutating func weaken(amount: Int) {
        integrity = max(0, integrity - amount)
        if integrity == 0 {
            isActive = false
        }
    }

    /// Calculate resistance chance (0.0 to 1.0)
    public func resistanceChance(divisor: Int = 100) -> Double {
        guard isActive else { return 0 }
        return Double(integrity) / Double(divisor)
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/ContentPacks/BalanceConfiguration.swift
// ==========================================

import Foundation

// MARK: - Balance Configuration

/// Configuration for game balance parameters loaded from content packs.
/// Replaces hardcoded balance values with data-driven configuration.
public struct BalanceConfiguration: Codable, Sendable {
    // MARK: - Resources

    /// Resource system configuration (health, faith, supplies, gold).
    public let resources: ResourceBalanceConfig

    // MARK: - Pressure/Tension

    /// Pressure system configuration (tension, escalation).
    public let pressure: PressureBalanceConfig

    // MARK: - Combat

    /// Combat system configuration (optional).
    public let combat: CombatBalanceConfig?

    // MARK: - Time

    /// Time system configuration (day/night cycle, action costs).
    public let time: TimeBalanceConfig

    // MARK: - Anchors

    /// Anchor system configuration (integrity, strengthening).
    public let anchor: AnchorBalanceConfig

    // MARK: - End Conditions

    /// Game end conditions (victory/defeat triggers).
    public let endConditions: EndConditionConfig

    // MARK: - Balance System (optional)

    /// Light/Dark balance system configuration.
    public let balanceSystem: BalanceSystemConfig?

    // MARK: - Defaults

    /// Default balance configuration for testing.
    public static let `default` = BalanceConfiguration(
        resources: .default,
        pressure: .default,
        combat: nil,
        time: .default,
        anchor: .default,
        endConditions: .default,
        balanceSystem: nil
    )
}

// MARK: - Resource Balance

/// Resource balance configuration (health, faith, supplies, gold).
public struct ResourceBalanceConfig: Codable, Sendable {
    /// Starting health value.
    public let startingHealth: Int

    /// Maximum health cap.
    public let maxHealth: Int

    /// Starting faith value.
    public let startingFaith: Int

    /// Maximum faith cap.
    public let maxFaith: Int

    /// Starting supplies value.
    public let startingSupplies: Int

    /// Maximum supplies cap.
    public let maxSupplies: Int

    /// Starting gold value.
    public let startingGold: Int

    /// Maximum gold cap.
    public let maxGold: Int

    /// Health restored when resting (optional, default 3).
    public let restHealAmount: Int?

    /// Starting balance value for Light/Dark system (optional).
    public let startingBalance: Int?

    /// Default resource configuration.
    public static let `default` = ResourceBalanceConfig(
        startingHealth: 20,
        maxHealth: 30,
        startingFaith: 10,
        maxFaith: 20,
        startingSupplies: 5,
        maxSupplies: 10,
        startingGold: 0,
        maxGold: 100,
        restHealAmount: 3,
        startingBalance: 50
    )
}

// MARK: - Pressure Balance

/// Pressure system balance configuration.
public struct PressureBalanceConfig: Codable, Sendable {
    /// Starting pressure level.
    public let startingPressure: Int

    /// Minimum pressure value.
    public let minPressure: Int

    /// Maximum pressure value.
    public let maxPressure: Int

    /// Pressure gain per turn.
    public let pressurePerTurn: Int

    /// Days between tension ticks (when tension increases automatically).
    public let tensionTickInterval: Int?

    /// Escalation interval (alias for tensionTickInterval).
    public let escalationInterval: Int?

    /// Pressure thresholds for escalation levels.
    public let thresholds: PressureThresholds

    /// Degradation settings for regions and anchors.
    public let degradation: DegradationConfig

    /// Get the effective tick interval (tensionTickInterval or escalationInterval).
    public var effectiveTickInterval: Int {
        tensionTickInterval ?? escalationInterval ?? 3
    }

    /// Default pressure configuration.
    public static let `default` = PressureBalanceConfig(
        startingPressure: 0,
        minPressure: 0,
        maxPressure: 100,
        pressurePerTurn: 5,
        tensionTickInterval: 3,
        escalationInterval: nil,
        thresholds: .default,
        degradation: .default
    )
}

/// Pressure thresholds for escalation levels.
public struct PressureThresholds: Codable, Sendable {
    /// Threshold for warning level (increased event danger).
    public let warning: Int

    /// Threshold for critical level.
    public let critical: Int

    /// Threshold for catastrophic level (game loss).
    public let catastrophic: Int

    /// Default thresholds.
    public static let `default` = PressureThresholds(
        warning: 30,
        critical: 60,
        catastrophic: 100
    )
}

/// Degradation configuration for regions and anchors.
public struct DegradationConfig: Codable, Sendable {
    /// Chance for region degradation at warning level.
    public let warningChance: Double

    /// Chance for region degradation at critical level.
    public let criticalChance: Double

    /// Chance for degradation at catastrophic level (optional).
    public let catastrophicChance: Double?

    /// Base chance for anchor integrity loss per turn.
    public let anchorDecayChance: Double

    /// Default degradation configuration.
    public static let `default` = DegradationConfig(
        warningChance: 0.1,
        criticalChance: 0.25,
        catastrophicChance: nil,
        anchorDecayChance: 0.05
    )
}

// MARK: - Combat Balance

/// Combat balance configuration.
public struct CombatBalanceConfig: Codable, Sendable {
    /// Base damage for attacks.
    public let baseDamage: Int

    /// Damage modifier per power point.
    public let powerModifier: Double

    /// Defense damage reduction factor.
    public let defenseReduction: Double

    /// Maximum dice value (optional).
    public let diceMax: Int?

    /// Actions allowed per turn (optional).
    public let actionsPerTurn: Int?

    /// Cards drawn per turn (optional).
    public let cardsDrawnPerTurn: Int?

    /// Maximum hand size (optional).
    public let maxHandSize: Int?

    /// Default combat configuration.
    public static let `default` = CombatBalanceConfig(
        baseDamage: 3,
        powerModifier: 1.0,
        defenseReduction: 0.5,
        diceMax: 6,
        actionsPerTurn: 3,
        cardsDrawnPerTurn: 5,
        maxHandSize: 7
    )
}

// MARK: - Time Balance

/// Time system balance configuration.
public struct TimeBalanceConfig: Codable, Sendable {
    /// Starting time of day.
    public let startingTime: Int

    /// Maximum days for campaign (optional).
    public let maxDays: Int?

    /// Time cost for travel action.
    public let travelCost: Int

    /// Time cost for exploration action.
    public let exploreCost: Int

    /// Time cost for rest action.
    public let restCost: Int

    /// Time cost for strengthening anchor (optional).
    public let strengthenAnchorCost: Int?

    /// Time cost for instant actions (optional).
    public let instantCost: Int?

    /// Default time configuration.
    public static let `default` = TimeBalanceConfig(
        startingTime: 8,
        maxDays: nil,
        travelCost: 2,
        exploreCost: 1,
        restCost: 4,
        strengthenAnchorCost: 1,
        instantCost: 0
    )
}

// MARK: - End Conditions

/// End condition configuration for victory and defeat.
public struct EndConditionConfig: Codable, Sendable {
    /// Health threshold for death (game over).
    public let deathHealth: Int

    /// Pressure threshold for loss (optional).
    public let pressureLoss: Int?

    /// Breach count for loss (optional).
    public let breachLoss: Int?

    /// Quest IDs that trigger victory.
    public let victoryQuests: [String]

    /// Flag set when main quest completes (optional).
    public let mainQuestCompleteFlag: String?

    /// Flag set when critical anchor destroyed (optional).
    public let criticalAnchorDestroyedFlag: String?

    /// Default end condition configuration.
    public static let `default` = EndConditionConfig(
        deathHealth: 0,
        pressureLoss: 100,
        breachLoss: nil,
        victoryQuests: [],
        mainQuestCompleteFlag: nil,
        criticalAnchorDestroyedFlag: nil
    )
}

// MARK: - Anchor Balance

/// Anchor system balance configuration.
public struct AnchorBalanceConfig: Codable, Sendable {
    /// Maximum anchor integrity.
    public let maxIntegrity: Int

    /// Amount to strengthen per action.
    public let strengthenAmount: Int

    /// Faith cost to strengthen anchor.
    public let strengthenCost: Int

    /// Integrity threshold for stable status.
    public let stableThreshold: Int

    /// Integrity threshold for breach.
    public let breachThreshold: Int

    /// Base decay rate per turn in threatened regions.
    public let decayPerTurn: Int

    /// Default anchor configuration.
    public static let `default` = AnchorBalanceConfig(
        maxIntegrity: 100,
        strengthenAmount: 15,
        strengthenCost: 5,
        stableThreshold: 70,
        breachThreshold: 0,
        decayPerTurn: 5
    )
}

// MARK: - Balance System

/// Light/Dark balance system configuration.
public struct BalanceSystemConfig: Codable, Sendable {
    /// Minimum balance value.
    public let min: Int

    /// Maximum balance value.
    public let max: Int

    /// Initial balance value.
    public let initial: Int

    /// Threshold for light alignment.
    public let lightThreshold: Int

    /// Threshold for dark alignment.
    public let darkThreshold: Int

    /// Default balance system configuration.
    public static let `default` = BalanceSystemConfig(
        min: 0,
        max: 100,
        initial: 50,
        lightThreshold: 70,
        darkThreshold: 30
    )
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/ContentPacks/BinaryPack.swift
// ==========================================

import Foundation
import Compression

// MARK: - Binary Pack Format
// .pack file = Header + gzip(JSON-encoded PackContent)

/// Magic bytes for .pack file identification
private let packMagic: [UInt8] = [0x54, 0x57, 0x50, 0x4B] // "TWPK"

/// Binary pack format version
private let packFormatVersion: UInt16 = 1

// MARK: - Pack Content (serializable)

/// All content in a pack, serializable to binary format
public struct PackContent: Codable {
    public let manifest: PackManifest
    public let regions: [String: RegionDefinition]
    public let events: [String: EventDefinition]
    public let quests: [String: QuestDefinition]
    public let anchors: [String: AnchorDefinition]
    public let heroes: [String: StandardHeroDefinition]
    public let cards: [String: StandardCardDefinition]
    public let enemies: [String: EnemyDefinition]
    public let abilities: [HeroAbility]
    public let balanceConfig: BalanceConfiguration?

    /// Create from LoadedPack
    public init(from pack: LoadedPack) {
        self.manifest = pack.manifest
        self.regions = pack.regions
        self.events = pack.events
        self.quests = pack.quests
        self.anchors = pack.anchors
        self.heroes = pack.heroes
        self.cards = pack.cards
        self.enemies = pack.enemies
        self.abilities = AbilityRegistry.shared.allAbilities
        self.balanceConfig = pack.balanceConfig
    }

    /// Convert to LoadedPack
    public func toLoadedPack(sourceURL: URL) -> LoadedPack {
        var pack = LoadedPack(manifest: manifest, sourceURL: sourceURL)
        pack.regions = regions
        pack.events = events
        pack.quests = quests
        pack.anchors = anchors
        pack.heroes = heroes
        pack.cards = cards
        pack.enemies = enemies
        pack.balanceConfig = balanceConfig
        return pack
    }
}

// MARK: - Binary Pack Writer

/// Compiles JSON packs to binary .pack format
public final class BinaryPackWriter {

    /// Compile a LoadedPack to binary .pack file
    /// - Parameters:
    ///   - pack: The loaded pack to compile
    ///   - outputURL: Destination URL for .pack file
    /// - Throws: Error if compilation fails
    public static func compile(_ pack: LoadedPack, to outputURL: URL) throws {
        let content = PackContent(from: pack)
        try compile(content, to: outputURL)
    }

    /// Compile PackContent to binary .pack file
    public static func compile(_ content: PackContent, to outputURL: URL) throws {
        // Encode to JSON
        let encoder = JSONEncoder()
        encoder.outputFormatting = [] // Compact, no pretty print
        let jsonData = try encoder.encode(content)

        // Compress with gzip
        let compressedData = try compress(jsonData)

        // Build file: Header + Compressed Data
        var fileData = Data()

        // Magic (4 bytes)
        fileData.append(contentsOf: packMagic)

        // Format version (2 bytes, little-endian)
        var version = packFormatVersion.littleEndian
        fileData.append(Data(bytes: &version, count: 2))

        // Original size (4 bytes, for decompression buffer allocation)
        var originalSize = UInt32(jsonData.count).littleEndian
        fileData.append(Data(bytes: &originalSize, count: 4))

        // Compressed data
        fileData.append(compressedData)

        // Write to file
        try fileData.write(to: outputURL)
    }

    /// Compress data using zlib
    private static func compress(_ data: Data) throws -> Data {
        let destinationBuffer = UnsafeMutablePointer<UInt8>.allocate(capacity: data.count)
        defer { destinationBuffer.deallocate() }

        let compressedSize = data.withUnsafeBytes { sourceBuffer -> Int in
            guard let sourcePtr = sourceBuffer.baseAddress?.assumingMemoryBound(to: UInt8.self) else {
                return 0
            }
            return compression_encode_buffer(
                destinationBuffer,
                data.count,
                sourcePtr,
                data.count,
                nil,
                COMPRESSION_ZLIB
            )
        }

        guard compressedSize > 0 else {
            throw PackLoadError.contentLoadFailed(file: "compression", underlyingError: NSError(domain: "BinaryPack", code: 1, userInfo: [NSLocalizedDescriptionKey: "Compression failed"]))
        }

        return Data(bytes: destinationBuffer, count: compressedSize)
    }
}

// MARK: - Binary Pack Reader

/// Loads binary .pack files
public final class BinaryPackReader {

    /// Load a .pack file
    /// - Parameter url: URL to .pack file
    /// - Returns: Loaded pack content
    /// - Throws: PackLoadError if loading fails
    public static func load(from url: URL) throws -> LoadedPack {
        let content = try loadContent(from: url)

        // Register abilities BEFORE creating LoadedPack
        AbilityRegistry.shared.registerAll(content.abilities)

        return content.toLoadedPack(sourceURL: url)
    }

    /// Load pack content from .pack file
    public static func loadContent(from url: URL) throws -> PackContent {
        guard FileManager.default.fileExists(atPath: url.path) else {
            throw PackLoadError.fileNotFound(url.path)
        }

        let fileData = try Data(contentsOf: url)

        // Verify minimum size (header = 10 bytes)
        guard fileData.count >= 10 else {
            throw PackLoadError.invalidManifest(reason: "File too small")
        }

        // Verify magic
        let magic = Array(fileData[0..<4])
        guard magic == packMagic else {
            throw PackLoadError.invalidManifest(reason: "Invalid pack file (bad magic)")
        }

        // Read format version (use loadUnaligned to handle sliced Data alignment)
        let formatVersion = fileData[4..<6].withUnsafeBytes { $0.loadUnaligned(as: UInt16.self).littleEndian }
        guard formatVersion == packFormatVersion else {
            throw PackLoadError.invalidManifest(reason: "Unsupported pack format version: \(formatVersion)")
        }

        // Read original size (use loadUnaligned for safety)
        let originalSize = Int(fileData[6..<10].withUnsafeBytes { $0.loadUnaligned(as: UInt32.self).littleEndian })

        // Decompress
        let compressedData = fileData[10...]
        let jsonData = try decompress(Data(compressedData), originalSize: originalSize)

        // Decode JSON
        let decoder = JSONDecoder()
        do {
            return try decoder.decode(PackContent.self, from: jsonData)
        } catch {
            throw PackLoadError.contentLoadFailed(file: url.lastPathComponent, underlyingError: error)
        }
    }

    /// Decompress data using zlib
    private static func decompress(_ data: Data, originalSize: Int) throws -> Data {
        let destinationBuffer = UnsafeMutablePointer<UInt8>.allocate(capacity: originalSize)
        defer { destinationBuffer.deallocate() }

        let decompressedSize = data.withUnsafeBytes { sourceBuffer -> Int in
            guard let sourcePtr = sourceBuffer.baseAddress?.assumingMemoryBound(to: UInt8.self) else {
                return 0
            }
            return compression_decode_buffer(
                destinationBuffer,
                originalSize,
                sourcePtr,
                data.count,
                nil,
                COMPRESSION_ZLIB
            )
        }

        guard decompressedSize == originalSize else {
            throw PackLoadError.contentLoadFailed(file: "decompression", underlyingError: NSError(domain: "BinaryPack", code: 2, userInfo: [NSLocalizedDescriptionKey: "Decompression failed: expected \(originalSize), got \(decompressedSize)"]))
        }

        return Data(bytes: destinationBuffer, count: decompressedSize)
    }

    /// Check if URL points to a valid .pack file (quick check, doesn't load content)
    public static func isValidPackFile(_ url: URL) -> Bool {
        guard url.pathExtension == "pack" else { return false }
        guard let handle = try? FileHandle(forReadingFrom: url) else { return false }
        defer { try? handle.close() }

        guard let magicData = try? handle.read(upToCount: 4) else { return false }
        return Array(magicData) == packMagic
    }
}

// MARK: - Pack File Extension

public extension URL {
    /// Check if this URL points to a .pack file
    var isPackFile: Bool {
        pathExtension == "pack"
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/ContentPacks/ConditionValidator.swift
// ==========================================

import Foundation

// MARK: - Condition Validator

/// Validates that all conditions in content packs use known types.
/// This prevents typos like "WorldResonanse" from going undetected.
///
/// Architecture note: All conditions in this engine use typed enums, not string expressions.
/// This provides compile-time and parse-time safety against typos.
public final class ConditionValidator {

    // MARK: - Whitelisted Condition Types

    /// All valid AbilityConditionType values (from HeroAbility.swift)
    public static let validAbilityConditionTypes: Set<String> = Set(
        AbilityConditionType.allCases.map { $0.rawValue }
    )

    /// All valid AbilityTrigger values
    public static let validAbilityTriggers: Set<String> = Set(
        AbilityTrigger.allCases.map { $0.rawValue }
    )

    /// All valid HeroAbilityEffectType values
    public static let validAbilityEffectTypes: Set<String> = Set(
        HeroAbilityEffectType.allCases.map { $0.rawValue }
    )

    /// All valid RegionState values
    public static let validRegionStates: Set<String> = Set(
        RegionState.allCases.map { $0.rawValue }
    )

    // MARK: - Validation Results

    /// Result of condition validation
    public struct ValidationResult {
        public let isValid: Bool
        public let errors: [String]
        public let warnings: [String]

        public static let valid = ValidationResult(isValid: true, errors: [], warnings: [])

        public static func invalid(errors: [String]) -> ValidationResult {
            ValidationResult(isValid: false, errors: errors, warnings: [])
        }
    }

    // MARK: - Validation Methods

    /// Validate all conditions in a loaded pack
    public static func validate(pack: LoadedPack) -> ValidationResult {
        var errors: [String] = []

        // Validate hero abilities
        // Note: Abilities are validated during JSON parsing via Codable enums
        // If parsing succeeds, conditions are already valid

        // Validate event availability
        for (eventId, event) in pack.events {
            if let regionStates = event.availability.regionStates {
                for state in regionStates {
                    if !validRegionStates.contains(state) {
                        errors.append("Event '\(eventId)' has unknown region state: '\(state)'")
                    }
                }
            }
        }

        // Validate quest availability
        for (questId, quest) in pack.quests {
            if let regionStates = quest.availability.regionStates {
                for state in regionStates {
                    if !validRegionStates.contains(state) {
                        errors.append("Quest '\(questId)' has unknown region state: '\(state)'")
                    }
                }
            }
        }

        // Validate enemy abilities
        for (_, enemy) in pack.enemies {
            for ability in enemy.abilities {
                // Abilities use typed enums - if they parsed, they're valid
                // This is a defense-in-depth check
                _ = ability.name // Access to ensure parsing succeeded
            }
        }

        if errors.isEmpty {
            return .valid
        } else {
            return .invalid(errors: errors)
        }
    }

    /// Validate a single ability condition
    public static func validateAbilityCondition(_ conditionType: String) -> Bool {
        return validAbilityConditionTypes.contains(conditionType)
    }

    /// Validate a single ability trigger
    public static func validateAbilityTrigger(_ trigger: String) -> Bool {
        return validAbilityTriggers.contains(trigger)
    }

    /// Validate a single ability effect type
    public static func validateAbilityEffectType(_ effectType: String) -> Bool {
        return validAbilityEffectTypes.contains(effectType)
    }

    /// Get all valid condition type names (for documentation/error messages)
    public static func allValidConditionTypes() -> [String] {
        return validAbilityConditionTypes.sorted()
    }

    /// Get all valid trigger names (for documentation/error messages)
    public static func allValidTriggers() -> [String] {
        return validAbilityTriggers.sorted()
    }

    /// Get all valid effect type names (for documentation/error messages)
    public static func allValidEffectTypes() -> [String] {
        return validAbilityEffectTypes.sorted()
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/ContentPacks/ContentManager.swift
// ==========================================

import Foundation

// MARK: - Content Manager
// Manages pack discovery, validation, loading, and hot-reload

/// Source location for content packs
public enum PackSource: Equatable, Hashable {
    /// Bundled in app (read-only, cannot hot-reload)
    case bundled(url: URL)
    /// External in Documents folder (hot-reloadable)
    case external(url: URL)

    /// The file URL for this pack source.
    public var url: URL {
        switch self {
        case .bundled(let url), .external(let url):
            return url
        }
    }

    /// Whether this pack source supports hot-reload.
    public var isReloadable: Bool {
        if case .external = self { return true }
        return false
    }

    /// Human-readable label for this pack source type.
    public var displayName: String {
        switch self {
        case .bundled: return "Bundled"
        case .external: return "External"
        }
    }
}

/// State of a pack in the content management system
public enum PackLoadState: Equatable {
    case discovered           // Found on disk, not validated
    case validating           // Validation in progress
    case validated(ValidationSummary)  // Validation complete
    case loading              // Loading into registry
    case loaded               // Successfully loaded into ContentRegistry
    case failed(String)       // Load/validation failed with error

    /// SF Symbol name representing the current load state.
    public var statusIcon: String {
        switch self {
        case .discovered: return "circle"
        case .validating: return "arrow.triangle.2.circlepath"
        case .validated(let summary):
            if summary.errorCount > 0 { return "xmark.circle" }
            if summary.warningCount > 0 { return "exclamationmark.triangle" }
            return "checkmark.circle"
        case .loading: return "arrow.triangle.2.circlepath"
        case .loaded: return "checkmark.circle.fill"
        case .failed: return "xmark.circle.fill"
        }
    }

    /// Color name representing the current load state.
    public var statusColor: String {
        switch self {
        case .discovered: return "gray"
        case .validating, .loading: return "blue"
        case .validated(let summary):
            if summary.errorCount > 0 { return "red" }
            if summary.warningCount > 0 { return "yellow"  }
            return "green"
        case .loaded: return "green"
        case .failed: return "red"
        }
    }

    /// Equatable conformance comparing load state cases.
    public static func == (lhs: PackLoadState, rhs: PackLoadState) -> Bool {
        switch (lhs, rhs) {
        case (.discovered, .discovered): return true
        case (.validating, .validating): return true
        case (.validated(let l), .validated(let r)): return l.packId == r.packId
        case (.loading, .loading): return true
        case (.loaded, .loaded): return true
        case (.failed(let l), .failed(let r)): return l == r
        default: return false
        }
    }
}

/// Validation summary for display
public struct ValidationSummary: Equatable {
    /// Identifier of the validated pack.
    public let packId: String
    /// Number of validation errors found.
    public let errorCount: Int
    /// Number of validation warnings found.
    public let warningCount: Int
    /// Number of informational messages.
    public let infoCount: Int
    /// Time taken to validate, in seconds.
    public let duration: TimeInterval
    /// Descriptive error messages.
    public let errors: [String]
    /// Descriptive warning messages.
    public let warnings: [String]

    /// Whether the pack passed validation with no errors.
    public var isValid: Bool { errorCount == 0 }

    /// Create a validation summary with the given counts and messages.
    public init(packId: String, errorCount: Int, warningCount: Int, infoCount: Int,
                duration: TimeInterval, errors: [String] = [], warnings: [String] = []) {
        self.packId = packId
        self.errorCount = errorCount
        self.warningCount = warningCount
        self.infoCount = infoCount
        self.duration = duration
        self.errors = errors
        self.warnings = warnings
    }
}

/// A pack managed by ContentManager
public struct ManagedPack: Identifiable {
    /// Unique pack identifier.
    public let id: String              // packId
    /// Where this pack was discovered from.
    public let source: PackSource
    /// Current load state of the pack.
    public var state: PackLoadState
    /// Pack manifest, if successfully read.
    public var manifest: PackManifest?
    /// Most recent validation result, if any.
    public var lastValidation: ValidationSummary?
    /// File size in bytes on disk.
    public var fileSize: Int64
    /// Last modification date of the pack file.
    public var modifiedAt: Date
    /// Date the pack was loaded into the registry, if loaded.
    public var loadedAt: Date?

    /// Whether this pack can be hot-reloaded.
    public var canReload: Bool {
        source.isReloadable && (state == .loaded || isValidatedSuccessfully)
    }

    /// Whether this pack can currently be validated.
    public var canValidate: Bool {
        switch state {
        case .validating, .loading: return false
        default: return true
        }
    }

    /// Whether this pack is ready to be loaded into the registry.
    public var canLoad: Bool {
        isValidatedSuccessfully && state != .loaded && state != .loading
    }

    /// Whether the pack passed validation without errors.
    public var isValidatedSuccessfully: Bool {
        if case .validated(let summary) = state {
            return summary.isValid
        }
        return false
    }

    /// Whether validation or loading produced errors.
    public var hasErrors: Bool {
        if case .validated(let summary) = state {
            return summary.errorCount > 0
        }
        if case .failed = state {
            return true
        }
        return false
    }

    /// Whether validation produced warnings.
    public var hasWarnings: Bool {
        if case .validated(let summary) = state {
            return summary.warningCount > 0
        }
        return false
    }
}

extension ManagedPack: Equatable {
    /// Equatable conformance comparing pack identity and state.
    public static func == (lhs: ManagedPack, rhs: ManagedPack) -> Bool {
        lhs.id == rhs.id &&
        lhs.source == rhs.source &&
        lhs.state == rhs.state &&
        lhs.fileSize == rhs.fileSize &&
        lhs.modifiedAt == rhs.modifiedAt &&
        lhs.loadedAt == rhs.loadedAt
    }
}

/// Errors during content reload
public enum ContentReloadError: Error, LocalizedError {
    case packNotFound(packId: String)
    case notReloadable(reason: String)
    case validationFailed(summary: ValidationSummary)
    case loadFailed(underlying: Error)

    /// Localized description of the reload error.
    public var errorDescription: String? {
        switch self {
        case .packNotFound(let id): return "Pack '\(id)' not found"
        case .notReloadable(let reason): return "Cannot reload: \(reason)"
        case .validationFailed(let summary): return "Validation failed with \(summary.errorCount) errors"
        case .loadFailed(let error): return "Load failed: \(error.localizedDescription)"
        }
    }
}

// MARK: - Content Manager

/// Engine-level content management with hot-reload support
public final class ContentManager {
    // MARK: - Singleton

    /// Shared singleton instance of the content manager.
    public static let shared = ContentManager()

    // MARK: - State

    private var managedPacks: [String: ManagedPack] = [:]
    private let queue = DispatchQueue(label: "content-manager", qos: .userInitiated)

    /// External packs folder name
    private let externalPacksFolderName = "Packs"

    private init() {}

    // MARK: - Pack Discovery

    /// Get URL for external packs directory (Documents/Packs/)
    public func externalPacksDirectory() -> URL {
        let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        let packsDir = documentsPath.appendingPathComponent(externalPacksFolderName)

        // Create directory if it doesn't exist
        if !FileManager.default.fileExists(atPath: packsDir.path) {
            try? FileManager.default.createDirectory(at: packsDir, withIntermediateDirectories: true)
        }

        return packsDir
    }

    /// Discover all available .pack files
    /// - Parameters:
    ///   - bundledURLs: URLs to bundled packs (from content modules)
    /// - Returns: Array of discovered packs
    public func discoverPacks(bundledURLs: [URL]) -> [ManagedPack] {
        var discovered: [ManagedPack] = []

        // Discover bundled packs
        for url in bundledURLs {
            if let pack = discoverPack(at: url, source: .bundled(url: url)) {
                discovered.append(pack)
            }
        }

        // Discover external packs in Documents/Packs/
        let externalDir = externalPacksDirectory()
        if let contents = try? FileManager.default.contentsOfDirectory(
            at: externalDir,
            includingPropertiesForKeys: [.fileSizeKey, .contentModificationDateKey]
        ) {
            for url in contents where url.pathExtension == "pack" {
                if let pack = discoverPack(at: url, source: .external(url: url)) {
                    // Don't add if bundled pack with same ID exists
                    if !discovered.contains(where: { $0.id == pack.id }) {
                        discovered.append(pack)
                    }
                }
            }
        }

        // Update internal state
        queue.sync {
            for pack in discovered {
                managedPacks[pack.id] = pack
            }
        }

        return discovered
    }

    /// Discover a single pack file
    private func discoverPack(at url: URL, source: PackSource) -> ManagedPack? {
        guard BinaryPackReader.isValidPackFile(url) else { return nil }

        // Get file attributes
        let attributes = try? FileManager.default.attributesOfItem(atPath: url.path)
        let fileSize = (attributes?[.size] as? Int64) ?? 0
        let modifiedAt = (attributes?[.modificationDate] as? Date) ?? Date()

        // Try to read manifest quickly
        let manifest = try? BinaryPackReader.readManifestOnly(from: url)
        let packId = manifest?.packId ?? url.deletingPathExtension().lastPathComponent

        // Check if already loaded in ContentRegistry
        let isLoaded = ContentRegistry.shared.loadedPacks[packId] != nil
        let state: PackLoadState = isLoaded ? .loaded : .discovered

        return ManagedPack(
            id: packId,
            source: source,
            state: state,
            manifest: manifest,
            lastValidation: nil,
            fileSize: fileSize,
            modifiedAt: modifiedAt,
            loadedAt: isLoaded ? Date() : nil
        )
    }

    /// Scan for changes in external packs directory and re-discover all packs.
    public func scanForChanges(bundledURLs: [URL]) -> [ManagedPack] {
        return discoverPacks(bundledURLs: bundledURLs)
    }

    // MARK: - Get State

    /// Get all managed packs
    public func getAllPacks() -> [ManagedPack] {
        return queue.sync { Array(managedPacks.values) }
    }

    /// Get a specific managed pack
    public func getPack(_ packId: String) -> ManagedPack? {
        return queue.sync { managedPacks[packId] }
    }

    /// Get bundled packs only
    public func getBundledPacks() -> [ManagedPack] {
        return queue.sync {
            managedPacks.values.filter { if case .bundled = $0.source { return true } else { return false } }
        }
    }

    /// Get external packs only
    public func getExternalPacks() -> [ManagedPack] {
        return queue.sync {
            managedPacks.values.filter { if case .external = $0.source { return true } else { return false } }
        }
    }

    // MARK: - Validation

    /// Validate a pack without loading it
    /// - Parameter packId: ID of pack to validate
    /// - Returns: Validation summary
    public func validatePack(_ packId: String) async -> ValidationSummary {
        guard let pack = getPack(packId) else {
            return ValidationSummary(
                packId: packId,
                errorCount: 1,
                warningCount: 0,
                infoCount: 0,
                duration: 0,
                errors: ["Pack not found"]
            )
        }

        // Update state to validating
        updatePackState(packId, state: .validating)

        // Perform validation
        let summary = await validatePackFile(at: pack.source.url)

        // Update state with result
        updatePackState(packId, state: .validated(summary), validation: summary)

        return summary
    }

    /// Validate a .pack file directly
    public func validatePackFile(at url: URL) async -> ValidationSummary {
        let startTime = Date()
        var errors: [String] = []
        var warnings: [String] = []
        var infoCount = 0

        // 1. Check file exists and is valid .pack
        guard BinaryPackReader.isValidPackFile(url) else {
            return ValidationSummary(
                packId: "unknown",
                errorCount: 1,
                warningCount: 0,
                infoCount: 0,
                duration: Date().timeIntervalSince(startTime),
                errors: ["Not a valid .pack file"]
            )
        }

        // 2. Load content
        let content: PackContent
        do {
            content = try BinaryPackReader.loadContent(from: url)
            infoCount += 1  // Successfully loaded
        } catch {
            return ValidationSummary(
                packId: "unknown",
                errorCount: 1,
                warningCount: 0,
                infoCount: 0,
                duration: Date().timeIntervalSince(startTime),
                errors: ["Failed to load pack: \(error.localizedDescription)"]
            )
        }

        let packId = content.manifest.packId

        // 3. Validate manifest
        if content.manifest.packId.isEmpty {
            errors.append("Pack ID is empty")
        }
        if content.manifest.displayName.en.isEmpty {
            warnings.append("Display name (en) is empty")
        }

        // 4. Validate cross-references
        let tempPack = content.toLoadedPack(sourceURL: url)

        // Check region neighbor references
        for (id, region) in tempPack.regions {
            for neighborId in region.neighborIds {
                if tempPack.regions[neighborId] == nil {
                    warnings.append("Region '\(id)' references missing neighbor '\(neighborId)'")
                }
            }
        }

        // Check event region references
        for (id, event) in tempPack.events {
            if let regionIds = event.availability.regionIds {
                for regionId in regionIds {
                    if tempPack.regions[regionId] == nil {
                        warnings.append("Event '\(id)' references missing region '\(regionId)'")
                    }
                }
            }
        }

        // Check hero starting deck references
        for (id, hero) in tempPack.heroes {
            for cardId in hero.startingDeckCardIDs {
                if tempPack.cards[cardId] == nil {
                    // Card might be in another pack, so just warn
                    warnings.append("Hero '\(id)' starting deck references card '\(cardId)' (may be in another pack)")
                }
            }
        }

        // Check anchor region references
        for (id, anchor) in tempPack.anchors {
            if tempPack.regions[anchor.regionId] == nil {
                warnings.append("Anchor '\(id)' references missing region '\(anchor.regionId)'")
            }
        }

        let duration = Date().timeIntervalSince(startTime)

        return ValidationSummary(
            packId: packId,
            errorCount: errors.count,
            warningCount: warnings.count,
            infoCount: infoCount,
            duration: duration,
            errors: errors,
            warnings: warnings
        )
    }

    // MARK: - Loading

    /// Load a pack into ContentRegistry
    /// - Parameter packId: ID of pack to load
    /// - Returns: Loaded pack
    public func loadPack(_ packId: String) async throws -> LoadedPack {
        guard let pack = getPack(packId) else {
            throw ContentReloadError.packNotFound(packId: packId)
        }

        // Update state
        updatePackState(packId, state: .loading)

        do {
            let loadedPack = try ContentRegistry.shared.loadPack(from: pack.source.url)
            updatePackState(packId, state: .loaded)
            queue.sync { managedPacks[packId]?.loadedAt = Date() }
            return loadedPack
        } catch {
            updatePackState(packId, state: .failed(error.localizedDescription))
            throw error
        }
    }

    // MARK: - Hot Reload

    /// Safely reload a pack with validation and rollback support
    /// - Parameter packId: ID of pack to reload
    /// - Returns: Result with new pack or error (old pack preserved on failure)
    public func safeReloadPack(_ packId: String) async -> Result<LoadedPack, ContentReloadError> {
        guard let pack = getPack(packId) else {
            return .failure(.packNotFound(packId: packId))
        }

        guard pack.source.isReloadable else {
            return .failure(.notReloadable(reason: "Bundled packs cannot be hot-reloaded"))
        }

        // 1. Validate BEFORE unloading
        updatePackState(packId, state: .validating)
        let validation = await validatePackFile(at: pack.source.url)

        guard validation.isValid else {
            updatePackState(packId, state: .validated(validation), validation: validation)
            return .failure(.validationFailed(summary: validation))
        }

        // 2. Perform safe reload via ContentRegistry
        updatePackState(packId, state: .loading)
        let result = ContentRegistry.shared.safeReloadPack(packId, from: pack.source.url)

        switch result {
        case .success(let newPack):
            updatePackState(packId, state: .loaded)
            queue.sync { managedPacks[packId]?.loadedAt = Date() }
            return .success(newPack)

        case .failure(let error):
            updatePackState(packId, state: .failed(error.localizedDescription))
            return .failure(.loadFailed(underlying: error))
        }
    }

    /// Check if a pack can be reloaded
    public func canReload(_ packId: String) -> Bool {
        return getPack(packId)?.canReload ?? false
    }

    // MARK: - Private Helpers

    private func updatePackState(_ packId: String, state: PackLoadState, validation: ValidationSummary? = nil) {
        queue.sync {
            managedPacks[packId]?.state = state
            if let validation = validation {
                managedPacks[packId]?.lastValidation = validation
            }
        }
    }

    // MARK: - Reset (for testing)

    /// Reset all managed packs
    public func reset() {
        queue.sync {
            managedPacks.removeAll()
        }
    }
}

// MARK: - BinaryPackReader Extension

extension BinaryPackReader {
    /// Read only the manifest from a .pack file (fast, for discovery)
    public static func readManifestOnly(from url: URL) throws -> PackManifest {
        let content = try loadContent(from: url)
        return content.manifest
    }
}



// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/ContentPacks/ContentRegistry.swift
// ==========================================

import Foundation

// MARK: - Content Registry

/// Central registry for all loaded game content
/// This is the primary interface for accessing content from loaded packs
public final class ContentRegistry {
    // MARK: - Singleton

    /// Shared singleton instance of the content registry.
    public static let shared = ContentRegistry()

    // MARK: - State

    /// All loaded packs, keyed by pack ID
    public private(set) var loadedPacks: [String: LoadedPack] = [:]

    /// Combined content from all packs (merged by priority)
    private var mergedRegions: [String: RegionDefinition] = [:]
    private var mergedEvents: [String: EventDefinition] = [:]
    private var mergedQuests: [String: QuestDefinition] = [:]
    private var mergedAnchors: [String: AnchorDefinition] = [:]
    private var mergedHeroes: [String: StandardHeroDefinition] = [:]
    private var mergedCards: [String: StandardCardDefinition] = [:]
    private var mergedEnemies: [String: EnemyDefinition] = [:]

    /// Active balance configuration (from highest priority pack)
    private var activeBalanceConfig: BalanceConfiguration?

    /// Pack load order (for priority resolution)
    private var loadOrder: [String] = []

    // MARK: - Initialization

    private init() {}

    // MARK: - Pack Loading

    /// Load multiple .pack files from URLs, sorted by priority
    /// Character packs are loaded before campaign packs
    /// - Parameter urls: URLs to .pack files
    /// - Returns: Array of loaded packs in load order
    /// - Throws: PackLoadError if loading fails
    @discardableResult
    public func loadPacks(from urls: [URL]) throws -> [LoadedPack] {
        // Load all pack contents
        var contentsWithUrls: [(content: PackContent, url: URL)] = []
        for url in urls {
            let content = try BinaryPackReader.loadContent(from: url)
            contentsWithUrls.append((content, url))
        }

        // Sort by pack type priority (character packs first, then campaigns)
        contentsWithUrls.sort { $0.content.manifest.packType.loadPriority < $1.content.manifest.packType.loadPriority }

        // Register packs in priority order
        var result: [LoadedPack] = []
        for (content, url) in contentsWithUrls {
            let pack = try registerPackContent(content, from: url)
            result.append(pack)
        }

        return result
    }

    /// Register pack content (internal helper)
    private func registerPackContent(_ content: PackContent, from url: URL) throws -> LoadedPack {
        // Register abilities BEFORE creating pack (needed for hero definitions)
        AbilityRegistry.shared.registerAll(content.abilities)

        let pack = content.toLoadedPack(sourceURL: url)

        // Check if already loaded
        if loadedPacks[pack.manifest.packId] != nil {
            throw PackLoadError.packAlreadyLoaded(packId: pack.manifest.packId)
        }

        // Verify Core compatibility
        guard pack.manifest.isCompatibleWithCore() else {
            throw PackLoadError.incompatibleCoreVersion(
                required: pack.manifest.coreVersionMin,
                current: CoreVersion.current
            )
        }

        // Check dependencies
        try validateDependencies(for: pack.manifest)

        // Register the pack
        loadedPacks[pack.manifest.packId] = pack
        loadOrder.append(pack.manifest.packId)

        // Merge content
        mergeContent(from: pack)

        return pack
    }

    /// Load a .pack file
    /// - Parameter url: URL to .pack file (binary format only)
    /// - Returns: The loaded pack
    /// - Throws: PackLoadError if loading fails
    @discardableResult
    public func loadPack(from url: URL) throws -> LoadedPack {
        // Verify it's a valid .pack file (checks extension AND magic bytes)
        guard BinaryPackReader.isValidPackFile(url) else {
            throw PackLoadError.invalidManifest(
                reason: "Invalid or missing .pack file. Only binary .pack files are supported. " +
                        "Use 'swift run pack-compiler compile' to compile JSON packs."
            )
        }

        // Load binary pack content
        let content = try BinaryPackReader.loadContent(from: url)
        return try registerPackContent(content, from: url)
    }

    /// Unload a pack
    /// - Parameter packId: ID of pack to unload
    public func unloadPack(_ packId: String) {
        guard loadedPacks[packId] != nil else { return }

        loadedPacks.removeValue(forKey: packId)
        loadOrder.removeAll { $0 == packId }

        // Rebuild merged content
        rebuildMergedContent()
    }

    /// Unload all packs
    public func unloadAllPacks() {
        loadedPacks.removeAll()
        loadOrder.removeAll()
        clearMergedContent()
    }

    // MARK: - Safe Reload (Hot-Reload Support)

    /// Safely reload a pack with rollback on failure
    /// - Parameters:
    ///   - packId: ID of pack to reload
    ///   - url: URL to new pack file
    /// - Returns: Result with loaded pack or error (old pack preserved on failure)
    public func safeReloadPack(_ packId: String, from url: URL) -> Result<LoadedPack, Error> {
        // Store old state for potential rollback
        let oldPack = loadedPacks[packId]
        let oldLoadOrder = loadOrder

        do {
            // Unload old pack
            unloadPack(packId)

            // Load new pack
            let newPack = try loadPack(from: url)

            #if DEBUG
            print("ContentRegistry: Successfully reloaded '\(packId)'")
            #endif

            return .success(newPack)
        } catch {
            // Rollback: restore old pack if it existed
            if let oldPack = oldPack {
                loadedPacks[packId] = oldPack
                // Restore load order
                loadOrder = oldLoadOrder
                rebuildMergedContent()

                #if DEBUG
                print("ContentRegistry: Rolled back to previous version of '\(packId)'")
                #endif
            }
            return .failure(error)
        }
    }

    // MARK: - Content Access

    /// Get region definition by ID
    public func getRegion(id: String) -> RegionDefinition? {
        return mergedRegions[id]
    }

    /// Get all region definitions
    public func getAllRegions() -> [RegionDefinition] {
        return Array(mergedRegions.values)
    }

    /// Get event definition by ID
    public func getEvent(id: String) -> EventDefinition? {
        return mergedEvents[id]
    }

    /// Get all event definitions
    public func getAllEvents() -> [EventDefinition] {
        return Array(mergedEvents.values)
    }

    /// Get quest definition by ID
    public func getQuest(id: String) -> QuestDefinition? {
        return mergedQuests[id]
    }

    /// Get all quest definitions
    public func getAllQuests() -> [QuestDefinition] {
        return Array(mergedQuests.values)
    }

    /// Get anchor definition by ID
    public func getAnchor(id: String) -> AnchorDefinition? {
        return mergedAnchors[id]
    }

    /// Get anchor for a specific region
    public func getAnchor(forRegion regionId: String) -> AnchorDefinition? {
        return mergedAnchors.values.first { $0.regionId == regionId }
    }

    /// Get all anchor definitions
    public func getAllAnchors() -> [AnchorDefinition] {
        return Array(mergedAnchors.values)
    }

    /// Get hero definition by ID
    public func getHero(id: String) -> StandardHeroDefinition? {
        return mergedHeroes[id]
    }

    /// Get all hero definitions
    public func getAllHeroes() -> [StandardHeroDefinition] {
        return Array(mergedHeroes.values)
    }

    /// Get card definition by ID
    public func getCard(id: String) -> StandardCardDefinition? {
        return mergedCards[id]
    }

    /// Get all card definitions
    public func getAllCards() -> [StandardCardDefinition] {
        return Array(mergedCards.values)
    }

    /// Get cards by type
    public func getCards(ofType type: CardType) -> [StandardCardDefinition] {
        return mergedCards.values.filter { $0.cardType == type }
    }

    /// Get enemy definition by ID
    public func getEnemy(id: String) -> EnemyDefinition? {
        return mergedEnemies[id]
    }

    /// Get all enemy definitions
    public func getAllEnemies() -> [EnemyDefinition] {
        return Array(mergedEnemies.values)
    }

    /// Get the active balance configuration
    public func getBalanceConfig() -> BalanceConfiguration? {
        return activeBalanceConfig
    }

    // MARK: - Query Methods

    /// Get events available for a region with given pressure and state
    /// - Parameters:
    ///   - regionId: Region definition ID (from pack manifest)
    ///   - pressure: Current world tension (0-100)
    ///   - regionState: Current region state (e.g., "stable", "borderland", "breach")
    public func getAvailableEvents(forRegion regionId: String, pressure: Int, regionState: String? = nil) -> [EventDefinition] {
        return mergedEvents.values.filter { event in
            // Check region ID matches (nil = any region)
            let regionMatches = event.availability.regionIds?.contains(regionId) ?? true

            // Check region state matches (nil = any state)
            let stateMatches: Bool
            if let requiredStates = event.availability.regionStates, !requiredStates.isEmpty {
                if let currentState = regionState {
                    stateMatches = requiredStates.contains(currentState)
                } else {
                    // No current state provided, assume all states match
                    stateMatches = true
                }
            } else {
                // No state requirements
                stateMatches = true
            }

            // Check pressure/tension matches
            let pressureMatches: Bool
            if let minPressure = event.availability.minPressure,
               let maxPressure = event.availability.maxPressure {
                pressureMatches = (minPressure...maxPressure).contains(pressure)
            } else if let minPressure = event.availability.minPressure {
                pressureMatches = pressure >= minPressure
            } else if let maxPressure = event.availability.maxPressure {
                pressureMatches = pressure <= maxPressure
            } else {
                pressureMatches = true
            }

            return regionMatches && stateMatches && pressureMatches
        }
    }

    /// Get starting deck for a hero
    public func getStartingDeck(forHero heroId: String) -> [StandardCardDefinition] {
        guard let hero = getHero(id: heroId) else { return [] }
        return hero.startingDeckCardIDs.compactMap { getCard(id: $0) }
    }

    // MARK: - Validation

    /// Validate all loaded content for cross-references
    public func validateAllContent() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []

        // Validate region neighbor references
        for (id, region) in mergedRegions {
            for neighborId in region.neighborIds {
                if mergedRegions[neighborId] == nil {
                    errors.append(ContentValidationError(
                        type: .brokenReference,
                        definitionId: id,
                        message: "Region references non-existent neighbor '\(neighborId)'"
                    ))
                }
            }
        }

        // Validate event region references
        for (id, event) in mergedEvents {
            if let regionIds = event.availability.regionIds {
                for regionId in regionIds {
                    if mergedRegions[regionId] == nil {
                        errors.append(ContentValidationError(
                            type: .brokenReference,
                            definitionId: id,
                            message: "Event references non-existent region '\(regionId)'"
                        ))
                    }
                }
            }
        }

        // Validate anchor region references
        for (id, anchor) in mergedAnchors {
            if mergedRegions[anchor.regionId] == nil {
                errors.append(ContentValidationError(
                    type: .brokenReference,
                    definitionId: id,
                    message: "Anchor references non-existent region '\(anchor.regionId)'"
                ))
            }
        }

        // Validate hero starting deck references
        for (id, hero) in mergedHeroes {
            for cardId in hero.startingDeckCardIDs {
                if mergedCards[cardId] == nil {
                    errors.append(ContentValidationError(
                        type: .brokenReference,
                        definitionId: id,
                        message: "Hero references non-existent card '\(cardId)'"
                    ))
                }
            }
        }

        // Check for duplicate IDs within same type (shouldn't happen with maps, but check pack sources)
        errors.append(contentsOf: checkDuplicateIds())

        return errors
    }

    // MARK: - Statistics

    /// Get combined inventory of all loaded content
    public var totalInventory: ContentInventory {
        ContentInventory(
            regionCount: mergedRegions.count,
            eventCount: mergedEvents.count,
            questCount: mergedQuests.count,
            heroCount: mergedHeroes.count,
            cardCount: mergedCards.count,
            anchorCount: mergedAnchors.count,
            enemyCount: 0, // TODO: Add enemy support
            hasBalanceConfig: activeBalanceConfig != nil,
            hasRulesExtension: false,
            hasCampaignContent: !mergedRegions.isEmpty || !mergedEvents.isEmpty,
            supportedLocales: collectSupportedLocales()
        )
    }

    /// Get list of all loaded pack IDs in load order
    public var loadedPackIds: [String] {
        return loadOrder
    }

    // MARK: - Pack Type Queries

    /// Get all loaded character packs
    public func getCharacterPacks() -> [LoadedPack] {
        return loadedPacks.values.filter { $0.manifest.packType.providesHeroes }
    }

    /// Get all loaded story/campaign packs
    public func getStoryPacks() -> [LoadedPack] {
        return loadedPacks.values.filter { $0.manifest.packType.providesStory }
    }

    /// Check if content is ready for gameplay (has both heroes and story)
    public var isReadyForGameplay: Bool {
        let hasHeroes = !mergedHeroes.isEmpty
        let hasStory = !mergedRegions.isEmpty || !mergedEvents.isEmpty || !mergedQuests.isEmpty
        return hasHeroes && hasStory
    }

    /// Check if at least one character pack is loaded
    public var hasCharacterPack: Bool {
        return !getCharacterPacks().isEmpty
    }

    /// Check if at least one story pack is loaded
    public var hasStoryPack: Bool {
        return !getStoryPacks().isEmpty
    }

    // MARK: - Season/Campaign Queries

    /// Get all packs belonging to a specific season
    /// - Parameter season: Season identifier (e.g., "season1")
    /// - Returns: Array of packs in that season
    public func getPacksBySeason(_ season: String) -> [LoadedPack] {
        return loadedPacks.values.filter { $0.manifest.season == season }
    }

    /// Get all packs in a campaign, sorted by campaign order
    /// - Parameter campaignId: Campaign identifier (e.g., "twilight-marches")
    /// - Returns: Array of packs sorted by campaignOrder
    public func getPacksByCampaign(_ campaignId: String) -> [LoadedPack] {
        return loadedPacks.values
            .filter { $0.manifest.campaignId == campaignId }
            .sorted { ($0.manifest.campaignOrder ?? 0) < ($1.manifest.campaignOrder ?? 0) }
    }

    /// Get all available seasons from loaded packs
    /// - Returns: Array of unique season identifiers, sorted alphabetically
    public func getAvailableSeasons() -> [String] {
        let seasons = Set(loadedPacks.values.compactMap { $0.manifest.season })
        return seasons.sorted()
    }

    /// Get all campaign IDs within a specific season
    /// - Parameter season: Season identifier
    /// - Returns: Array of unique campaign IDs in that season
    public func getCampaignsInSeason(_ season: String) -> [String] {
        let campaignIds = Set(
            loadedPacks.values
                .filter { $0.manifest.season == season }
                .compactMap { $0.manifest.campaignId }
        )
        return campaignIds.sorted()
    }

    /// Check if all acts of a campaign are loaded
    /// Uses campaignOrder to verify continuity (1, 2, 3...)
    /// - Parameter campaignId: Campaign identifier
    /// - Returns: true if campaign has sequential acts starting from 1
    public func isCampaignComplete(_ campaignId: String) -> Bool {
        let packs = getPacksByCampaign(campaignId)
        guard !packs.isEmpty else { return false }

        // Check for sequential campaignOrder starting from 1
        let orders = packs.compactMap { $0.manifest.campaignOrder }.sorted()
        guard !orders.isEmpty else { return true } // No order = single pack = complete

        // Verify sequence: [1], [1,2], [1,2,3], etc.
        for (index, order) in orders.enumerated() {
            if order != index + 1 {
                return false
            }
        }
        return true
    }

    /// Get the next pack in a campaign sequence after the given pack
    /// - Parameter packId: Current pack ID
    /// - Returns: Next pack in campaign order, or nil if last/not in campaign
    public func getNextPackInCampaign(after packId: String) -> LoadedPack? {
        guard let currentPack = loadedPacks[packId],
              let campaignId = currentPack.manifest.campaignId,
              let currentOrder = currentPack.manifest.campaignOrder else {
            return nil
        }

        let campaignPacks = getPacksByCampaign(campaignId)
        return campaignPacks.first { $0.manifest.campaignOrder == currentOrder + 1 }
    }

    /// Get packs required to play a specific pack (story continuity)
    /// - Parameter packId: Pack ID to check
    /// - Returns: Array of required packs that are loaded
    public func getRequiredPacks(for packId: String) -> [LoadedPack] {
        guard let pack = loadedPacks[packId],
              let requiredIds = pack.manifest.requiresPacks else {
            return []
        }
        return requiredIds.compactMap { loadedPacks[$0] }
    }

    /// Check if all required packs for a given pack are loaded
    /// - Parameter packId: Pack ID to check
    /// - Returns: true if all required packs are available
    public func hasAllRequiredPacks(for packId: String) -> Bool {
        guard let pack = loadedPacks[packId],
              let requiredIds = pack.manifest.requiresPacks else {
            return true // No requirements
        }
        return requiredIds.allSatisfy { loadedPacks[$0] != nil }
    }

    /// Validate that content requirements are met for gameplay
    /// Returns errors if story pack is loaded without character pack
    public func validateContentRequirements() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []

        // Story packs require at least one character pack
        if hasStoryPack && !hasCharacterPack {
            errors.append(ContentValidationError(
                type: .missingRequired,
                definitionId: "content-requirements",
                message: "Story pack requires at least one character pack to be loaded"
            ))
        }

        // Check that story packs have the heroes they recommend
        for pack in getStoryPacks() {
            for heroId in pack.manifest.recommendedHeroes {
                if getHero(id: heroId) == nil {
                    errors.append(ContentValidationError(
                        type: .brokenReference,
                        definitionId: pack.manifest.packId,
                        message: "Story pack recommends hero '\(heroId)' which is not available"
                    ))
                }
            }
        }

        return errors
    }

    // MARK: - Private Methods

    private func validateDependencies(for manifest: PackManifest) throws {
        for dependency in manifest.dependencies {
            if dependency.isOptional { continue }

            guard let loadedPack = loadedPacks[dependency.packId] else {
                throw PackLoadError.missingDependency(
                    packId: dependency.packId,
                    required: dependency.minVersion
                )
            }

            let loadedVersion = loadedPack.manifest.version
            if loadedVersion < dependency.minVersion {
                throw PackLoadError.dependencyVersionMismatch(
                    packId: dependency.packId,
                    required: dependency.minVersion,
                    found: loadedVersion
                )
            }

            if let maxVersion = dependency.maxVersion, loadedVersion > maxVersion {
                throw PackLoadError.dependencyVersionMismatch(
                    packId: dependency.packId,
                    required: dependency.minVersion,
                    found: loadedVersion
                )
            }
        }
    }

    private func mergeContent(from pack: LoadedPack) {
        // Merge regions (later packs override earlier)
        for (id, region) in pack.regions {
            mergedRegions[id] = region
        }

        // Merge events
        for (id, event) in pack.events {
            mergedEvents[id] = event
        }

        // Merge quests
        for (id, quest) in pack.quests {
            mergedQuests[id] = quest
        }

        // Merge anchors
        for (id, anchor) in pack.anchors {
            mergedAnchors[id] = anchor
        }

        // Merge heroes and register into HeroRegistry for backward compatibility
        for (id, hero) in pack.heroes {
            mergedHeroes[id] = hero
            HeroRegistry.shared.register(hero)
        }
        #if DEBUG
        if !pack.heroes.isEmpty {
            print("ContentRegistry: Registered \(pack.heroes.count) heroes into HeroRegistry")
        }
        #endif

        // Merge cards
        for (id, card) in pack.cards {
            mergedCards[id] = card
        }

        // Merge enemies
        for (id, enemy) in pack.enemies {
            mergedEnemies[id] = enemy
        }

        // Update balance config if pack provides one
        if let balanceConfig = pack.balanceConfig {
            activeBalanceConfig = balanceConfig
        }
    }

    private func rebuildMergedContent() {
        clearMergedContent()

        // Re-merge in load order
        for packId in loadOrder {
            if let pack = loadedPacks[packId] {
                mergeContent(from: pack)
            }
        }
    }

    private func clearMergedContent() {
        mergedRegions.removeAll()
        mergedEvents.removeAll()
        mergedQuests.removeAll()
        mergedAnchors.removeAll()
        mergedHeroes.removeAll()
        mergedCards.removeAll()
        mergedEnemies.removeAll()
        activeBalanceConfig = nil
    }

    private func checkDuplicateIds() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []

        // Track which pack each ID came from
        var regionSources: [String: [String]] = [:]
        var eventSources: [String: [String]] = [:]

        for packId in loadOrder {
            guard let pack = loadedPacks[packId] else { continue }

            for regionId in pack.regions.keys {
                regionSources[regionId, default: []].append(packId)
            }

            for eventId in pack.events.keys {
                eventSources[eventId, default: []].append(packId)
            }
        }

        // Report duplicates (informational - later packs override earlier)
        for (id, sources) in regionSources where sources.count > 1 {
            errors.append(ContentValidationError(
                type: .duplicateId,
                definitionId: id,
                message: "Region defined in multiple packs: \(sources.joined(separator: ", ")) (later overrides earlier)"
            ))
        }

        for (id, sources) in eventSources where sources.count > 1 {
            errors.append(ContentValidationError(
                type: .duplicateId,
                definitionId: id,
                message: "Event defined in multiple packs: \(sources.joined(separator: ", ")) (later overrides earlier)"
            ))
        }

        return errors
    }

    private func collectSupportedLocales() -> [String] {
        var locales = Set<String>()
        for pack in loadedPacks.values {
            for locale in pack.manifest.supportedLocales {
                locales.insert(locale)
            }
        }
        return Array(locales).sorted()
    }
}

// MARK: - Content Provider Protocol Conformance

extension ContentRegistry: ContentProvider {
    /// Get region definition by ID (ContentProvider protocol).
    public func getRegionDefinition(id: String) -> RegionDefinition? {
        return getRegion(id: id)
    }

    /// Get all region definitions (ContentProvider protocol).
    public func getAllRegionDefinitions() -> [RegionDefinition] {
        return getAllRegions()
    }

    /// Get event definition by ID (ContentProvider protocol).
    public func getEventDefinition(id: String) -> EventDefinition? {
        return getEvent(id: id)
    }

    /// Get all event definitions (ContentProvider protocol).
    public func getAllEventDefinitions() -> [EventDefinition] {
        return getAllEvents()
    }

    /// Get anchor definition by ID (ContentProvider protocol).
    public func getAnchorDefinition(id: String) -> AnchorDefinition? {
        return getAnchor(id: id)
    }

    /// Get anchor definition for a region (ContentProvider protocol).
    public func getAnchorDefinition(forRegion regionId: String) -> AnchorDefinition? {
        return getAnchor(forRegion: regionId)
    }

    /// Get all anchor definitions (ContentProvider protocol).
    public func getAllAnchorDefinitions() -> [AnchorDefinition] {
        return getAllAnchors()
    }

    /// Get event definitions for a specific region.
    public func getEventDefinitions(forRegion regionId: String) -> [EventDefinition] {
        return mergedEvents.values.filter { event in
            event.availability.regionIds?.contains(regionId) ?? false
        }
    }

    /// Get event definitions from a specific pool.
    public func getEventDefinitions(forPool poolId: String) -> [EventDefinition] {
        return mergedEvents.values.filter { event in
            event.poolIds.contains(poolId)
        }
    }

    /// Get all quest definitions (ContentProvider protocol).
    public func getAllQuestDefinitions() -> [QuestDefinition] {
        return getAllQuests()
    }

    /// Get quest definition by ID (ContentProvider protocol).
    public func getQuestDefinition(id: String) -> QuestDefinition? {
        return getQuest(id: id)
    }

    /// Get all mini-game challenges from loaded events.
    public func getAllMiniGameChallenges() -> [MiniGameChallengeDefinition] {
        return mergedEvents.values.compactMap { $0.miniGameChallenge }
    }

    /// Get mini-game challenge by ID.
    public func getMiniGameChallenge(id: String) -> MiniGameChallengeDefinition? {
        return mergedEvents.values.compactMap { $0.miniGameChallenge }.first { $0.id == id }
    }

    /// Validate all loaded content for errors and inconsistencies.
    public func validate() -> [ContentValidationError] {
        let validator = ContentValidator(provider: self)
        return validator.validate()
    }
}

// MARK: - Testing Support

extension ContentRegistry {
    /// Reset registry for testing
    /// - Warning: Only use in tests!
    public func resetForTesting() {
        unloadAllPacks()
    }

    /// Register mock content for testing
    /// - Warning: Only use in tests!
    public func registerMockContent(
        regions: [String: RegionDefinition] = [:],
        events: [String: EventDefinition] = [:],
        anchors: [String: AnchorDefinition] = [:],
        heroes: [String: StandardHeroDefinition] = [:],
        cards: [String: StandardCardDefinition] = [:],
        enemies: [String: EnemyDefinition] = [:]
    ) {
        mergedRegions = regions
        mergedEvents = events
        mergedAnchors = anchors
        mergedHeroes = heroes
        mergedCards = cards
        mergedEnemies = enemies
    }

    /// Load a mock pack for testing (simulates real pack loading)
    /// This properly tracks pack in loadedPacks and merges content
    /// - Warning: Only use in tests!
    @discardableResult
    public func loadMockPack(_ pack: LoadedPack) -> LoadedPack {
        let packId = pack.manifest.packId

        // Check if already loaded
        guard loadedPacks[packId] == nil else {
            return pack
        }

        // Register the pack
        loadedPacks[packId] = pack
        loadOrder.append(packId)

        // Merge content
        mergeContent(from: pack)

        return pack
    }

    /// Check for ID collisions between loaded packs
    /// Returns pairs of (entityType, id, packIds) for any collisions
    /// - Warning: Only use in tests!
    public func checkIdCollisions() -> [(entityType: String, id: String, packs: [String])] {
        var collisions: [(entityType: String, id: String, packs: [String])] = []

        // Check regions
        var regionSources: [String: [String]] = [:]
        for packId in loadOrder {
            guard let pack = loadedPacks[packId] else { continue }
            for regionId in pack.regions.keys {
                regionSources[regionId, default: []].append(packId)
            }
        }
        for (id, sources) in regionSources where sources.count > 1 {
            collisions.append(("Region", id, sources))
        }

        // Check events
        var eventSources: [String: [String]] = [:]
        for packId in loadOrder {
            guard let pack = loadedPacks[packId] else { continue }
            for eventId in pack.events.keys {
                eventSources[eventId, default: []].append(packId)
            }
        }
        for (id, sources) in eventSources where sources.count > 1 {
            collisions.append(("Event", id, sources))
        }

        // Check heroes
        var heroSources: [String: [String]] = [:]
        for packId in loadOrder {
            guard let pack = loadedPacks[packId] else { continue }
            for heroId in pack.heroes.keys {
                heroSources[heroId, default: []].append(packId)
            }
        }
        for (id, sources) in heroSources where sources.count > 1 {
            collisions.append(("Hero", id, sources))
        }

        // Check cards
        var cardSources: [String: [String]] = [:]
        for packId in loadOrder {
            guard let pack = loadedPacks[packId] else { continue }
            for cardId in pack.cards.keys {
                cardSources[cardId, default: []].append(packId)
            }
        }
        for (id, sources) in cardSources where sources.count > 1 {
            collisions.append(("Card", id, sources))
        }

        return collisions
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/ContentPacks/ExpressionParser.swift
// ==========================================

import Foundation

// MARK: - Expression Parser
// Validates string-based condition expressions in pack content.
// Ensures no typos in variable names or unknown functions.
// Reference: Audit v2.1, Section 3.1

/// Parses and validates condition expression strings from pack content.
/// Rejects unknown variables and functions at load time to prevent silent content defects.
public final class ExpressionParser {

    // MARK: - Known Variables

    /// Whitelisted variable names that can appear in condition expressions
    public static let knownVariables: Set<String> = [
        // World state
        "WorldTension", "worldTension",
        "LightDarkBalance", "lightDarkBalance",
        "CurrentDay", "currentDay",
        "WorldResonance", "worldResonance",

        // Player state
        "PlayerHealth", "playerHealth",
        "PlayerMaxHealth", "playerMaxHealth",
        "PlayerFaith", "playerFaith",
        "PlayerMaxFaith", "playerMaxFaith",
        "PlayerBalance", "playerBalance",

        // Region state
        "RegionState", "regionState",
        "RegionType", "regionType",

        // Quest state
        "MainQuestStage", "mainQuestStage",

        // Deck state
        "DeckSize", "deckSize",
        "HandSize", "handSize",
        "DiscardSize", "discardSize"
    ]

    // MARK: - Known Functions

    /// Whitelisted function names that can appear in condition expressions
    public static let knownFunctions: Set<String> = [
        "hasFlag",
        "notFlag",
        "hasQuest",
        "completedQuest",
        "visitedRegion",
        "hasCard",
        "hasAbility",
        "regionIs",
        "dayIs",
        "random"
    ]

    // MARK: - Errors

    /// Errors produced during expression parsing
    public enum ExpressionError: Error, Equatable {
        case invalidSyntax(String)
        case unknownVariable(String)
        case unknownFunction(String)
        case emptyExpression
    }

    // MARK: - Validation

    /// Validate a condition expression string.
    /// Returns nil if valid, or an ExpressionError if invalid.
    public static func validate(_ expression: String) -> ExpressionError? {
        let trimmed = expression.trimmingCharacters(in: .whitespacesAndNewlines)

        guard !trimmed.isEmpty else {
            return .emptyExpression
        }

        // Tokenize the expression
        let tokens = tokenize(trimmed)

        // Check each identifier token against known variables and functions
        for token in tokens {
            switch token {
            case .identifier(let name):
                if !knownVariables.contains(name) && !knownFunctions.contains(name) {
                    return .unknownVariable(name)
                }
            case .function(let name):
                if !knownFunctions.contains(name) {
                    return .unknownFunction(name)
                }
            case .operator_, .number, .string, .boolean, .paren:
                continue
            case .invalid(let text):
                return .invalidSyntax("Invalid token: \(text)")
            }
        }

        return nil // Valid
    }

    /// Validate all condition expressions in a collection.
    /// Returns array of (expression, error) pairs for invalid ones.
    public static func validateAll(_ expressions: [String]) -> [(String, ExpressionError)] {
        var errors: [(String, ExpressionError)] = []
        for expr in expressions {
            if let error = validate(expr) {
                errors.append((expr, error))
            }
        }
        return errors
    }

    // MARK: - Tokenization

    enum Token {
        case identifier(String)
        case function(String)
        case number(String)
        case string(String)
        case boolean(String)
        case operator_(String)
        case paren(String)
        case invalid(String)
    }

    static func tokenize(_ expression: String) -> [Token] {
        var tokens: [Token] = []
        var remaining = expression[expression.startIndex...]

        let operators: Set<String> = ["<", ">", "<=", ">=", "==", "!=", "&&", "||", "!", "+", "-", "*", "/"]

        while !remaining.isEmpty {
            // Skip whitespace
            if let first = remaining.first, first.isWhitespace {
                remaining = remaining.drop(while: { $0.isWhitespace })
                continue
            }

            guard let first = remaining.first else { break }

            // Parentheses
            if first == "(" || first == ")" {
                tokens.append(.paren(String(first)))
                remaining = remaining.dropFirst()
                continue
            }

            // String literals
            if first == "\"" {
                remaining = remaining.dropFirst()
                if let endQuote = remaining.firstIndex(of: "\"") {
                    let content = String(remaining[remaining.startIndex..<endQuote])
                    tokens.append(.string(content))
                    remaining = remaining[remaining.index(after: endQuote)...]
                } else {
                    tokens.append(.invalid("Unterminated string"))
                    break
                }
                continue
            }

            // Numbers (including negative)
            if first.isNumber || (first == "-" && remaining.dropFirst().first?.isNumber == true) {
                let numChars = remaining.prefix(while: { $0.isNumber || $0 == "." || $0 == "-" })
                tokens.append(.number(String(numChars)))
                remaining = remaining.dropFirst(numChars.count)
                continue
            }

            // Two-char operators
            if remaining.count >= 2 {
                let twoChar = String(remaining.prefix(2))
                if operators.contains(twoChar) {
                    tokens.append(.operator_(twoChar))
                    remaining = remaining.dropFirst(2)
                    continue
                }
            }

            // Single-char operators
            if operators.contains(String(first)) {
                tokens.append(.operator_(String(first)))
                remaining = remaining.dropFirst()
                continue
            }

            // Identifiers (variable names, function names, booleans)
            if first.isLetter || first == "_" {
                let ident = remaining.prefix(while: { $0.isLetter || $0.isNumber || $0 == "_" })
                let name = String(ident)
                remaining = remaining.dropFirst(ident.count)

                // Check for boolean literals
                if name == "true" || name == "false" {
                    tokens.append(.boolean(name))
                }
                // Check if followed by '(' â€” it's a function call
                else if remaining.first == "(" {
                    tokens.append(.function(name))
                }
                else {
                    tokens.append(.identifier(name))
                }
                continue
            }

            // Comma (used in function args)
            if first == "," {
                remaining = remaining.dropFirst()
                continue
            }

            // Unknown character
            tokens.append(.invalid(String(first)))
            remaining = remaining.dropFirst()
        }

        return tokens
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/ContentPacks/PackCompiler.swift
// ==========================================

import Foundation

// MARK: - Pack Compiler
// Compiles JSON content packs to binary .pack format
// Used at build-time, NOT at runtime

/// Compiles JSON packs to binary .pack format
public enum PackCompiler {

    /// Compile a JSON pack directory to a .pack file
    /// - Parameters:
    ///   - sourceURL: URL to pack directory containing manifest.json and content
    ///   - outputURL: Destination URL for the .pack file
    /// - Returns: Compilation result with statistics
    /// - Throws: PackLoadError if compilation fails
    @discardableResult
    public static func compile(from sourceURL: URL, to outputURL: URL) throws -> CompilationResult {
        let startTime = Date()

        // Load manifest
        let manifest = try PackManifest.load(from: sourceURL)

        // Verify Core compatibility
        guard manifest.isCompatibleWithCore() else {
            throw PackLoadError.incompatibleCoreVersion(
                required: manifest.coreVersionMin,
                current: CoreVersion.current
            )
        }

        // Load pack content using existing PackLoader (JSON parsing)
        let pack = try PackLoader.load(manifest: manifest, from: sourceURL)

        // Compile to binary
        try BinaryPackWriter.compile(pack, to: outputURL)

        let endTime = Date()
        let compilationTime = endTime.timeIntervalSince(startTime)

        // Calculate sizes
        let inputSize = try calculateDirectorySize(sourceURL)
        let outputSize = try FileManager.default.attributesOfItem(atPath: outputURL.path)[.size] as? Int64 ?? 0

        return CompilationResult(
            packId: manifest.packId,
            version: manifest.version,
            inputSize: inputSize,
            outputSize: outputSize,
            compilationTime: compilationTime,
            contentStats: ContentStats(from: pack)
        )
    }

    /// Compile multiple packs
    /// - Parameters:
    ///   - sources: Array of (sourceURL, outputURL) pairs
    /// - Returns: Array of compilation results
    public static func compileAll(_ sources: [(source: URL, output: URL)]) throws -> [CompilationResult] {
        var results: [CompilationResult] = []
        for (source, output) in sources {
            let result = try compile(from: source, to: output)
            results.append(result)
        }
        return results
    }

    /// Validate a pack without compiling
    /// - Parameter sourceURL: URL to pack directory
    /// - Returns: Validation result
    public static func validate(at sourceURL: URL) throws -> ValidationResult {
        // Load manifest
        let manifest = try PackManifest.load(from: sourceURL)

        // Check Core compatibility
        let coreCompatible = manifest.isCompatibleWithCore()

        // Try loading pack (validates all content)
        var contentValid = true
        var contentError: String? = nil

        do {
            _ = try PackLoader.load(manifest: manifest, from: sourceURL)
        } catch {
            contentValid = false
            contentError = error.localizedDescription
        }

        return ValidationResult(
            packId: manifest.packId,
            version: manifest.version,
            coreCompatible: coreCompatible,
            contentValid: contentValid,
            error: contentError
        )
    }

    // MARK: - Helpers

    private static func calculateDirectorySize(_ url: URL) throws -> Int64 {
        let resourceKeys: Set<URLResourceKey> = [.isRegularFileKey, .fileSizeKey]
        let enumerator = FileManager.default.enumerator(
            at: url,
            includingPropertiesForKeys: Array(resourceKeys)
        )

        var totalSize: Int64 = 0
        while let fileURL = enumerator?.nextObject() as? URL {
            let resourceValues = try fileURL.resourceValues(forKeys: resourceKeys)
            if resourceValues.isRegularFile == true {
                totalSize += Int64(resourceValues.fileSize ?? 0)
            }
        }
        return totalSize
    }
}

// MARK: - Compilation Result

/// Result of pack compilation
public struct CompilationResult {
    /// Identifier of the compiled pack
    public let packId: String
    /// Semantic version of the compiled pack
    public let version: SemanticVersion
    /// Total size of source files in bytes
    public let inputSize: Int64
    /// Size of the compiled .pack file in bytes
    public let outputSize: Int64
    /// Time taken to compile in seconds
    public let compilationTime: TimeInterval
    /// Statistics about the compiled content
    public let contentStats: ContentStats

    /// Compression ratio (output/input)
    public var compressionRatio: Double {
        guard inputSize > 0 else { return 0 }
        return Double(outputSize) / Double(inputSize)
    }

    /// Human-readable summary
    public var summary: String {
        let inputKB = Double(inputSize) / 1024
        let outputKB = Double(outputSize) / 1024
        let ratio = String(format: "%.1f%%", compressionRatio * 100)
        let time = String(format: "%.2fs", compilationTime)

        return """
        Pack: \(packId) v\(version)
        Size: \(String(format: "%.1f", inputKB))KB â†’ \(String(format: "%.1f", outputKB))KB (\(ratio))
        Time: \(time)
        Content: \(contentStats.summary)
        """
    }
}

/// Content statistics
public struct ContentStats {
    /// Number of regions in the pack
    public let regions: Int
    /// Number of events in the pack
    public let events: Int
    /// Number of quests in the pack
    public let quests: Int
    /// Number of heroes in the pack
    public let heroes: Int
    /// Number of cards in the pack
    public let cards: Int
    /// Number of enemies in the pack
    public let enemies: Int
    /// Number of anchors in the pack
    public let anchors: Int

    /// Initialize stats from a loaded pack
    public init(from pack: LoadedPack) {
        self.regions = pack.regions.count
        self.events = pack.events.count
        self.quests = pack.quests.count
        self.heroes = pack.heroes.count
        self.cards = pack.cards.count
        self.enemies = pack.enemies.count
        self.anchors = pack.anchors.count
    }

    /// Human-readable summary of content counts
    public var summary: String {
        var parts: [String] = []
        if regions > 0 { parts.append("\(regions) regions") }
        if events > 0 { parts.append("\(events) events") }
        if quests > 0 { parts.append("\(quests) quests") }
        if heroes > 0 { parts.append("\(heroes) heroes") }
        if cards > 0 { parts.append("\(cards) cards") }
        if enemies > 0 { parts.append("\(enemies) enemies") }
        return parts.joined(separator: ", ")
    }
}

/// Validation result
public struct ValidationResult {
    /// Identifier of the validated pack
    public let packId: String
    /// Semantic version of the validated pack
    public let version: SemanticVersion
    /// Whether the pack is compatible with the current core version
    public let coreCompatible: Bool
    /// Whether the pack content passed validation
    public let contentValid: Bool
    /// Error message if validation failed, nil otherwise
    public let error: String?

    /// True if both core-compatible and content-valid
    public var isValid: Bool {
        coreCompatible && contentValid
    }

    /// Human-readable validation summary with pass/fail status
    public var summary: String {
        if isValid {
            return "âœ… Pack '\(packId)' v\(version) is valid"
        } else {
            var issues: [String] = []
            if !coreCompatible { issues.append("Core version incompatible") }
            if !contentValid { issues.append(error ?? "Content validation failed") }
            return "âŒ Pack '\(packId)' v\(version): \(issues.joined(separator: ", "))"
        }
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/ContentPacks/PackLoader.swift
// ==========================================

import Foundation
import CryptoKit

// MARK: - Pack Loader

/// Loads content pack data from disk
/// Supports JSON format (Protobuf support planned)
public enum PackLoader {
    // MARK: - Main Loading

    /// Load a pack from a manifest and source URL
    /// - Parameters:
    ///   - manifest: The pack manifest
    ///   - url: URL to the pack directory
    /// - Returns: Fully loaded pack
    /// - Throws: PackLoadError if loading fails
    public static func load(manifest: PackManifest, from url: URL) throws -> LoadedPack {
        // Verify checksums before loading content (Epic 0.3)
        if let checksums = manifest.checksums {
            try verifyChecksums(checksums, in: url)
        }

        var pack = LoadedPack(
            manifest: manifest,
            sourceURL: url,
            loadedAt: Date()
        )

        // Load regions
        if let regionsPath = manifest.regionsPath {
            pack.regions = try loadRegions(from: url.appendingPathComponent(regionsPath))
            #if DEBUG
            print("PackLoader: Loaded \(pack.regions.count) regions from \(regionsPath)")
            #endif
        }

        // Load events
        if let eventsPath = manifest.eventsPath {
            pack.events = try loadEvents(from: url.appendingPathComponent(eventsPath))
            #if DEBUG
            print("PackLoader: Loaded \(pack.events.count) events from \(eventsPath)")
            #endif
        }

        // Load quests
        if let questsPath = manifest.questsPath {
            pack.quests = try loadQuests(from: url.appendingPathComponent(questsPath))
            #if DEBUG
            print("PackLoader: Loaded \(pack.quests.count) quests from \(questsPath)")
            #endif
        }

        // Load anchors
        if let anchorsPath = manifest.anchorsPath {
            pack.anchors = try loadAnchors(from: url.appendingPathComponent(anchorsPath))
            #if DEBUG
            print("PackLoader: Loaded \(pack.anchors.count) anchors from \(anchorsPath)")
            #endif
        }

        // Load hero abilities (before heroes, so abilities are available)
        if let abilitiesPath = manifest.abilitiesPath {
            loadAbilities(from: url.appendingPathComponent(abilitiesPath))
        }

        // Load heroes
        if let heroesPath = manifest.heroesPath {
            pack.heroes = try loadHeroes(from: url.appendingPathComponent(heroesPath))
            #if DEBUG
            print("PackLoader: Loaded \(pack.heroes.count) heroes from \(heroesPath)")
            #endif
        }

        // Load cards
        if let cardsPath = manifest.cardsPath {
            pack.cards = try loadCards(from: url.appendingPathComponent(cardsPath))
            #if DEBUG
            print("PackLoader: Loaded \(pack.cards.count) cards from \(cardsPath)")
            #endif
        }

        // Load balance configuration
        if let balancePath = manifest.balancePath {
            pack.balanceConfig = try loadBalanceConfig(from: url.appendingPathComponent(balancePath))
            #if DEBUG
            print("PackLoader: Loaded balance config from \(balancePath)")
            #endif
        }

        // Load enemies
        if let enemiesPath = manifest.enemiesPath {
            pack.enemies = try loadEnemies(from: url.appendingPathComponent(enemiesPath))
            #if DEBUG
            print("PackLoader: Loaded \(pack.enemies.count) enemies from \(enemiesPath)")
            #endif
        }

        // Load localization string tables (Epic 5)
        if let localizationPath = manifest.localizationPath {
            let locURL = url.appendingPathComponent(localizationPath)
            try LocalizationManager.shared.loadStringTables(
                for: manifest.packId,
                from: locURL,
                locales: manifest.supportedLocales
            )
        }

        #if DEBUG
        print("PackLoader: âœ… Pack '\(manifest.packId)' loaded successfully")
        print("  ðŸ“¦ Content summary: \(pack.regions.count) regions, \(pack.events.count) events, \(pack.quests.count) quests, \(pack.heroes.count) heroes, \(pack.cards.count) cards, \(pack.enemies.count) enemies")
        #endif

        return pack
    }

    // MARK: - Content Loading

    /// Load regions from path (file or directory)
    private static func loadRegions(from url: URL) throws -> [String: RegionDefinition] {
        var regions: [String: RegionDefinition] = [:]

        if isDirectory(url) {
            // Load all JSON files in directory
            let files = try jsonFiles(in: url)
            for file in files {
                let fileRegions = try loadJSONArray(RegionDefinition.self, from: file)
                for region in fileRegions {
                    regions[region.id] = region
                }
            }
        } else {
            // Load single file
            let fileRegions = try loadJSONArray(RegionDefinition.self, from: url)
            for region in fileRegions {
                regions[region.id] = region
            }
        }

        return regions
    }

    /// Load events from path (file or directory)
    private static func loadEvents(from url: URL) throws -> [String: EventDefinition] {
        var events: [String: EventDefinition] = [:]

        if isDirectory(url) {
            let files = try jsonFiles(in: url)
            for file in files {
                let fileEvents = try loadJSONArray(EventDefinition.self, from: file)
                for event in fileEvents {
                    events[event.id] = event
                }
            }
        } else {
            let fileEvents = try loadJSONArray(EventDefinition.self, from: url)
            for event in fileEvents {
                events[event.id] = event
            }
        }

        return events
    }

    /// Load quests from path (file or directory)
    private static func loadQuests(from url: URL) throws -> [String: QuestDefinition] {
        var quests: [String: QuestDefinition] = [:]

        if isDirectory(url) {
            let files = try jsonFiles(in: url)
            for file in files {
                let fileQuests = try loadJSONArray(QuestDefinition.self, from: file)
                for quest in fileQuests {
                    quests[quest.id] = quest
                }
            }
        } else {
            let fileQuests = try loadJSONArray(QuestDefinition.self, from: url)
            for quest in fileQuests {
                quests[quest.id] = quest
            }
        }

        return quests
    }

    /// Load anchors from path (file or directory)
    private static func loadAnchors(from url: URL) throws -> [String: AnchorDefinition] {
        var anchors: [String: AnchorDefinition] = [:]

        if isDirectory(url) {
            let files = try jsonFiles(in: url)
            for file in files {
                let fileAnchors = try loadJSONArray(AnchorDefinition.self, from: file)
                for anchor in fileAnchors {
                    anchors[anchor.id] = anchor
                }
            }
        } else {
            let fileAnchors = try loadJSONArray(AnchorDefinition.self, from: url)
            for anchor in fileAnchors {
                anchors[anchor.id] = anchor
            }
        }

        return anchors
    }

    /// Load abilities from JSON file (registers in AbilityRegistry)
    private static func loadAbilities(from url: URL) {
        // Abilities are registered globally in AbilityRegistry
        AbilityRegistry.shared.loadFromJSON(at: url)
    }

    /// Load heroes from path (file or directory)
    private static func loadHeroes(from url: URL) throws -> [String: StandardHeroDefinition] {
        var heroes: [String: StandardHeroDefinition] = [:]

        if isDirectory(url) {
            let files = try jsonFiles(in: url)
            for file in files {
                let fileHeroes = try loadJSONArray(PackHeroDefinition.self, from: file)
                for hero in fileHeroes {
                    let standard = hero.toStandard()
                    heroes[standard.id] = standard
                }
            }
        } else {
            let fileHeroes = try loadJSONArray(PackHeroDefinition.self, from: url)
            for hero in fileHeroes {
                let standard = hero.toStandard()
                heroes[standard.id] = standard
            }
        }

        return heroes
    }

    /// Load cards from path (file or directory) with localization
    private static func loadCards(from url: URL) throws -> [String: StandardCardDefinition] {
        var cards: [String: StandardCardDefinition] = [:]

        if isDirectory(url) {
            let files = try jsonFiles(in: url)
            for file in files {
                let fileCards = try loadJSONArray(PackCardDefinition.self, from: file)
                for card in fileCards {
                    let standard = card.toStandard()
                    cards[standard.id] = standard
                }
            }
        } else {
            let fileCards = try loadJSONArray(PackCardDefinition.self, from: url)
            for card in fileCards {
                let standard = card.toStandard()
                cards[standard.id] = standard
            }
        }

        return cards
    }

    /// Load balance configuration
    private static func loadBalanceConfig(from url: URL) throws -> BalanceConfiguration {
        return try loadJSON(BalanceConfiguration.self, from: url)
    }

    /// Load enemies from path (file or directory)
    private static func loadEnemies(from url: URL) throws -> [String: EnemyDefinition] {
        var enemies: [String: EnemyDefinition] = [:]

        if isDirectory(url) {
            let files = try jsonFiles(in: url)
            for file in files {
                let fileEnemies = try loadJSONArray(EnemyDefinition.self, from: file)
                for enemy in fileEnemies {
                    enemies[enemy.id] = enemy
                }
            }
        } else {
            let fileEnemies = try loadJSONArray(EnemyDefinition.self, from: url)
            for enemy in fileEnemies {
                enemies[enemy.id] = enemy
            }
        }

        return enemies
    }

    // MARK: - JSON Helpers

    /// Load a single JSON object
    private static func loadJSON<T: Decodable>(_ type: T.Type, from url: URL) throws -> T {
        do {
            let data = try Data(contentsOf: url)
            let decoder = JSONDecoder()
            decoder.dateDecodingStrategy = .iso8601
            decoder.keyDecodingStrategy = .convertFromSnakeCase
            return try decoder.decode(T.self, from: data)
        } catch {
            throw PackLoadError.contentLoadFailed(file: url.lastPathComponent, underlyingError: error)
        }
    }

    /// Load a JSON array (or single object as array)
    private static func loadJSONArray<T: Decodable>(_ type: T.Type, from url: URL) throws -> [T] {
        let data: Data
        do {
            data = try Data(contentsOf: url)
        } catch {
            throw PackLoadError.contentLoadFailed(file: url.lastPathComponent, underlyingError: error)
        }

        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        decoder.keyDecodingStrategy = .convertFromSnakeCase

        // Try array first
        do {
            return try decoder.decode([T].self, from: data)
        } catch let arrayError {
            #if DEBUG
            // Detailed error diagnostics
            print("PackLoader: Failed to decode \(url.lastPathComponent) as [\(T.self)]")
            if let decodingError = arrayError as? DecodingError {
                switch decodingError {
                case .typeMismatch(let type, let context):
                    print("  â†’ typeMismatch: expected \(type)")
                    print("  â†’ path: \(context.codingPath.map { $0.stringValue }.joined(separator: "."))")
                    print("  â†’ description: \(context.debugDescription)")
                case .valueNotFound(let type, let context):
                    print("  â†’ valueNotFound: \(type)")
                    print("  â†’ path: \(context.codingPath.map { $0.stringValue }.joined(separator: "."))")
                case .keyNotFound(let key, let context):
                    print("  â†’ keyNotFound: \(key.stringValue)")
                    print("  â†’ path: \(context.codingPath.map { $0.stringValue }.joined(separator: "."))")
                case .dataCorrupted(let context):
                    print("  â†’ dataCorrupted: \(context.debugDescription)")
                    print("  â†’ path: \(context.codingPath.map { $0.stringValue }.joined(separator: "."))")
                @unknown default:
                    print("  â†’ unknown error: \(decodingError)")
                }
            }
            #endif

            // Try single object as fallback
            do {
                let single = try decoder.decode(T.self, from: data)
                return [single]
            } catch {
                // Report the array error since that's what we expected
                throw PackLoadError.contentLoadFailed(file: url.lastPathComponent, underlyingError: arrayError)
            }
        }
    }

    // MARK: - File System Helpers

    /// Check if URL is a directory
    private static func isDirectory(_ url: URL) -> Bool {
        var isDir: ObjCBool = false
        return FileManager.default.fileExists(atPath: url.path, isDirectory: &isDir) && isDir.boolValue
    }

    /// Get all JSON files in a directory
    private static func jsonFiles(in url: URL) throws -> [URL] {
        let contents = try FileManager.default.contentsOfDirectory(
            at: url,
            includingPropertiesForKeys: nil
        )
        return contents.filter { $0.pathExtension.lowercased() == "json" }
    }

    // MARK: - Checksum Verification (Epic 0.3)

    /// Verify file checksums against manifest
    /// - Parameters:
    ///   - checksums: Dictionary of relative paths to expected SHA256 hashes
    ///   - packURL: Root URL of the pack
    /// - Throws: PackLoadError.checksumMismatch if verification fails
    private static func verifyChecksums(_ checksums: [String: String], in packURL: URL) throws {
        for (relativePath, expectedHash) in checksums {
            let fileURL = packURL.appendingPathComponent(relativePath)

            guard FileManager.default.fileExists(atPath: fileURL.path) else {
                throw PackLoadError.fileNotFound(relativePath)
            }

            let actualHash = try computeSHA256(of: fileURL)

            if actualHash.lowercased() != expectedHash.lowercased() {
                throw PackLoadError.checksumMismatch(
                    file: relativePath,
                    expected: expectedHash,
                    actual: actualHash
                )
            }
        }
    }

    /// Compute SHA256 hash of a file
    /// - Parameter url: File URL
    /// - Returns: Hex-encoded SHA256 hash string
    public static func computeSHA256(of url: URL) throws -> String {
        let data = try Data(contentsOf: url)
        let hash = SHA256.hash(data: data)
        return hash.map { String(format: "%02x", $0) }.joined()
    }
}

// MARK: - Pack Hero Definition

/// JSON ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð° Ð´Ð»Ñ stats Ð³ÐµÑ€Ð¾Ñ
private struct PackHeroStats: Codable {
    public let health: Int
    public let maxHealth: Int
    public let strength: Int
    public let dexterity: Int
    public let constitution: Int
    public let intelligence: Int
    public let wisdom: Int
    public let charisma: Int
    public let faith: Int
    public let maxFaith: Int
    public let startingBalance: Int

    public func toHeroStats() -> HeroStats {
        HeroStats(
            health: health,
            maxHealth: maxHealth,
            strength: strength,
            dexterity: dexterity,
            constitution: constitution,
            intelligence: intelligence,
            wisdom: wisdom,
            charisma: charisma,
            faith: faith,
            maxFaith: maxFaith,
            startingBalance: startingBalance
        )
    }
}

/// JSON-ÑÐ¾Ð²Ð¼ÐµÑÑ‚Ð¸Ð¼Ð¾Ðµ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ð³ÐµÑ€Ð¾Ñ Ð´Ð»Ñ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸ Ð¸Ð· Content Pack
/// Ð¡Ñ‚Ð°Ñ‚Ñ‹ Ð·Ð°Ð³Ñ€ÑƒÐ¶Ð°ÑŽÑ‚ÑÑ Ð¸Ð· JSON (data-driven)
private struct PackHeroDefinition: Codable {
    public let id: String
    public let name: String
    public let nameRu: String?
    public let description: String
    public let descriptionRu: String?
    public let icon: String
    public let baseStats: PackHeroStats
    public let abilityId: String
    public let startingDeckCardIds: [String]
    public let availability: String?

    /// ÐšÐ¾Ð½Ð²ÐµÑ€Ñ‚Ð°Ñ†Ð¸Ñ Ð² StandardHeroDefinition
    public func toStandard() -> StandardHeroDefinition {
        // ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÐ¼ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾ÑÑ‚ÑŒ
        let heroAvailability: HeroAvailability
        switch availability?.lowercased() {
        case "always_available", nil:
            heroAvailability = .alwaysAvailable
        case let str where str?.hasPrefix("requires_unlock:") == true:
            let condition = String(str!.dropFirst("requires_unlock:".count))
            heroAvailability = .requiresUnlock(condition: condition)
        case let str where str?.hasPrefix("dlc:") == true:
            let packId = String(str!.dropFirst("dlc:".count))
            heroAvailability = .dlc(packID: packId)
        default:
            heroAvailability = .alwaysAvailable
        }

        // Convert legacy name/nameRu to LocalizableText
        // If nameRu is provided, create inline LocalizedString
        // Otherwise, assume it might be a StringKey (if it looks like one) or use as single-language text
        let localizedName: LocalizableText
        if name.contains(".") && !name.contains(" ") && name.first?.isLowercase == true {
            // Looks like a StringKey (e.g., "hero.ragnar.name")
            localizedName = .key(StringKey(name))
        } else {
            // Legacy format: inline LocalizedString
            localizedName = .inline(LocalizedString(en: name, ru: nameRu ?? name))
        }

        let localizedDescription: LocalizableText
        if description.contains(".") && !description.contains(" ") && description.first?.isLowercase == true {
            // Looks like a StringKey
            localizedDescription = .key(StringKey(description))
        } else {
            // Legacy format: inline LocalizedString
            localizedDescription = .inline(LocalizedString(en: description, ru: descriptionRu ?? description))
        }

        // ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚ÑŒ Ð¿Ð¾ ID
        guard let ability = HeroAbility.forAbilityId(abilityId) else {
            #if DEBUG
            print("PackLoader: ERROR - Unknown ability ID '\(abilityId)' for hero '\(id)'")
            #endif
            fatalError("Missing ability definition for '\(abilityId)'. Add it to HeroAbility.forAbilityId() or hero_abilities.json")
        }

        return StandardHeroDefinition(
            id: id,
            name: localizedName,
            description: localizedDescription,
            icon: icon,
            baseStats: baseStats.toHeroStats(),
            specialAbility: ability,
            startingDeckCardIDs: startingDeckCardIds,
            availability: heroAvailability
        )
    }
}

// MARK: - Pack Card Definition

/// JSON-ÑÐ¾Ð²Ð¼ÐµÑÑ‚Ð¸Ð¼Ð¾Ðµ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ ÐºÐ°Ñ€Ñ‚Ñ‹ Ð´Ð»Ñ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸ Ð¸Ð· Content Pack Ñ Ð»Ð¾ÐºÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸ÐµÐ¹
private struct PackCardDefinition: Codable {
    public let id: String
    public let name: String
    public let nameRu: String?
    public let cardType: CardType
    public let rarity: CardRarity
    public let description: String
    public let descriptionRu: String?
    public let icon: String
    public let expansionSet: ExpansionSet
    public let ownership: CardOwnership
    public let abilities: [CardAbility]
    public let faithCost: Int
    public let balance: CardBalance?
    public let role: CardRole?
    public let power: Int?
    public let defense: Int?
    public let health: Int?
    public let realm: Realm?
    public let curseType: CurseType?

    /// ÐšÐ¾Ð½Ð²ÐµÑ€Ñ‚Ð°Ñ†Ð¸Ñ Ð² StandardCardDefinition Ñ Ð»Ð¾ÐºÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸ÐµÐ¹
    public func toStandard() -> StandardCardDefinition {
        // Convert legacy name/nameRu to LocalizableText
        // If name looks like a StringKey (lowercase.dot.separated), treat it as key
        // Otherwise, create inline LocalizedString from legacy format
        let localizedName: LocalizableText
        if name.contains(".") && !name.contains(" ") && name.first?.isLowercase == true {
            // Looks like a StringKey (e.g., "card.strike.name")
            localizedName = .key(StringKey(name))
        } else {
            // Legacy format: inline LocalizedString
            localizedName = .inline(LocalizedString(en: name, ru: nameRu ?? name))
        }

        let localizedDescription: LocalizableText
        if description.contains(".") && !description.contains(" ") && description.first?.isLowercase == true {
            // Looks like a StringKey
            localizedDescription = .key(StringKey(description))
        } else {
            // Legacy format: inline LocalizedString
            localizedDescription = .inline(LocalizedString(en: description, ru: descriptionRu ?? description))
        }

        return StandardCardDefinition(
            id: id,
            name: localizedName,
            cardType: cardType,
            rarity: rarity,
            description: localizedDescription,
            icon: icon,
            expansionSet: expansionSet,
            ownership: ownership,
            abilities: abilities,
            faithCost: faithCost,
            balance: balance,
            role: role,
            power: power,
            defense: defense,
            health: health,
            realm: realm,
            curseType: curseType
        )
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/ContentPacks/PackManifest.swift
// ==========================================

import Foundation

// MARK: - Pack Manifest

/// Metadata describing a content pack
/// This is the entry point for pack loading - every pack must have a manifest
public struct PackManifest: Codable {
    // MARK: - Identity

    /// Unique pack identifier (e.g., "twilight-marches-act1")
    public let packId: String

    /// Human-readable display name
    public let displayName: LocalizedString

    /// Pack description
    public let description: LocalizedString

    /// Pack version
    public let version: SemanticVersion

    /// Type of content this pack provides
    public let packType: PackType

    // MARK: - Compatibility

    /// Minimum required Core engine version
    public let coreVersionMin: SemanticVersion

    /// Maximum tested Core version (nil = any future version)
    public let coreVersionMax: SemanticVersion?

    /// Required dependencies on other packs
    public let dependencies: [PackDependency]

    /// Capabilities this pack requires from Core (for rules extensions)
    public let requiredCapabilities: [String]

    // MARK: - Content Entry Points

    /// Starting region ID for campaign packs
    public let entryRegionId: String?

    /// Starting quest ID for campaign packs
    public let entryQuestId: String?

    /// Recommended hero IDs for this campaign
    public let recommendedHeroes: [String]

    // MARK: - Character Pack Fields

    /// List of hero IDs provided by this pack (for character packs)
    public let heroIds: [String]?

    // MARK: - Story Pack Fields

    /// Minimum number of heroes required to play this story
    public let minHeroesRequired: Int?

    /// Maximum number of heroes supported
    public let maxHeroesSupported: Int?

    /// Difficulty rating (1-5)
    public let difficultyRating: Int?

    /// Estimated playtime in minutes
    public let estimatedPlaytimeMinutes: Int?

    /// Mission type: "campaign" for multi-session, "standalone" for single-session
    public let missionType: MissionType?

    // MARK: - Grouping & Organization

    /// Season this pack belongs to (e.g., "season1", "season2")
    public let season: String?

    /// Campaign ID for multi-part stories (e.g., "twilight-marches")
    public let campaignId: String?

    /// Order within campaign (1 = Act I, 2 = Act II, etc.)
    public let campaignOrder: Int?

    /// Bundle ID for purchasing (e.g., "twilight-marches-complete")
    public let bundleId: String?

    /// Packs required to play this one (for story continuity)
    public let requiresPacks: [String]?

    /// Localized season display name (e.g., "Season 1: Twilight")
    public let seasonDisplayName: LocalizedString?

    /// Localized campaign display name (e.g., "Twilight Marches")
    public let campaignDisplayName: LocalizedString?

    // MARK: - Metadata

    /// Pack author/publisher
    public let author: String

    /// License identifier
    public let license: String?

    /// Release date
    public let releaseDate: Date?

    /// Supported locales
    public let supportedLocales: [String]

    /// File checksums for integrity verification
    public let checksums: [String: String]?

    // MARK: - Content Paths (relative to pack root)

    /// Path to regions content
    public let regionsPath: String?

    /// Path to events content
    public let eventsPath: String?

    /// Path to quests content
    public let questsPath: String?

    /// Path to anchors content
    public let anchorsPath: String?

    /// Path to heroes content
    public let heroesPath: String?

    /// Path to hero abilities content
    public let abilitiesPath: String?

    /// Path to cards content
    public let cardsPath: String?

    /// Path to enemies content
    public let enemiesPath: String?

    /// Path to balance configuration
    public let balancePath: String?

    /// Path to localization files
    public let localizationPath: String?

    // MARK: - Coding Keys

    enum CodingKeys: String, CodingKey {
        case packId = "id"
        case displayName = "name"
        case description
        case version
        case packType = "type"
        case coreVersionMin = "core_version_min"
        case coreVersionMax = "core_version_max"
        case dependencies
        case requiredCapabilities = "required_capabilities"
        case entryRegionId = "entry_region"
        case entryQuestId = "entry_quest"
        case recommendedHeroes = "recommended_heroes"
        // Character pack fields
        case heroIds = "hero_ids"
        // Story pack fields
        case minHeroesRequired = "min_heroes_required"
        case maxHeroesSupported = "max_heroes_supported"
        case difficultyRating = "difficulty_rating"
        case estimatedPlaytimeMinutes = "estimated_playtime_minutes"
        case missionType = "mission_type"
        // Grouping & Organization
        case season
        case campaignId = "campaign_id"
        case campaignOrder = "campaign_order"
        case bundleId = "bundle_id"
        case requiresPacks = "requires_packs"
        case seasonDisplayName = "season_name"
        case campaignDisplayName = "campaign_name"
        // Metadata
        case author
        case license
        case releaseDate = "release_date"
        case supportedLocales = "locales"
        case checksums
        case regionsPath = "regions_path"
        case eventsPath = "events_path"
        case questsPath = "quests_path"
        case anchorsPath = "anchors_path"
        case heroesPath = "heroes_path"
        case abilitiesPath = "abilities_path"
        case cardsPath = "cards_path"
        case enemiesPath = "enemies_path"
        case balancePath = "balance_path"
        case localizationPath = "localization_path"
    }

    // MARK: - Initialization

    public init(
        packId: String,
        displayName: LocalizedString,
        description: LocalizedString,
        version: SemanticVersion,
        packType: PackType,
        coreVersionMin: SemanticVersion,
        coreVersionMax: SemanticVersion? = nil,
        dependencies: [PackDependency] = [],
        requiredCapabilities: [String] = [],
        entryRegionId: String? = nil,
        entryQuestId: String? = nil,
        recommendedHeroes: [String] = [],
        // Character pack fields
        heroIds: [String]? = nil,
        // Story pack fields
        minHeroesRequired: Int? = nil,
        maxHeroesSupported: Int? = nil,
        difficultyRating: Int? = nil,
        estimatedPlaytimeMinutes: Int? = nil,
        missionType: MissionType? = nil,
        // Grouping & Organization
        season: String? = nil,
        campaignId: String? = nil,
        campaignOrder: Int? = nil,
        bundleId: String? = nil,
        requiresPacks: [String]? = nil,
        seasonDisplayName: LocalizedString? = nil,
        campaignDisplayName: LocalizedString? = nil,
        // Metadata
        author: String,
        license: String? = nil,
        releaseDate: Date? = nil,
        supportedLocales: [String] = ["en"],
        checksums: [String: String]? = nil,
        regionsPath: String? = nil,
        eventsPath: String? = nil,
        questsPath: String? = nil,
        anchorsPath: String? = nil,
        heroesPath: String? = nil,
        abilitiesPath: String? = nil,
        cardsPath: String? = nil,
        enemiesPath: String? = nil,
        balancePath: String? = nil,
        localizationPath: String? = nil
    ) {
        self.packId = packId
        self.displayName = displayName
        self.description = description
        self.version = version
        self.packType = packType
        self.coreVersionMin = coreVersionMin
        self.coreVersionMax = coreVersionMax
        self.dependencies = dependencies
        self.requiredCapabilities = requiredCapabilities
        self.entryRegionId = entryRegionId
        self.entryQuestId = entryQuestId
        self.recommendedHeroes = recommendedHeroes
        self.heroIds = heroIds
        self.minHeroesRequired = minHeroesRequired
        self.maxHeroesSupported = maxHeroesSupported
        self.difficultyRating = difficultyRating
        self.estimatedPlaytimeMinutes = estimatedPlaytimeMinutes
        self.missionType = missionType
        self.season = season
        self.campaignId = campaignId
        self.campaignOrder = campaignOrder
        self.bundleId = bundleId
        self.requiresPacks = requiresPacks
        self.seasonDisplayName = seasonDisplayName
        self.campaignDisplayName = campaignDisplayName
        self.author = author
        self.license = license
        self.releaseDate = releaseDate
        self.supportedLocales = supportedLocales
        self.checksums = checksums
        self.regionsPath = regionsPath
        self.eventsPath = eventsPath
        self.questsPath = questsPath
        self.anchorsPath = anchorsPath
        self.heroesPath = heroesPath
        self.abilitiesPath = abilitiesPath
        self.cardsPath = cardsPath
        self.enemiesPath = enemiesPath
        self.balancePath = balancePath
        self.localizationPath = localizationPath
    }

    // MARK: - Validation

    /// Validate manifest structure
    public func validate() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []

        // Check required fields
        if packId.isEmpty {
            errors.append(ContentValidationError(
                type: .missingRequired,
                definitionId: "manifest",
                message: "Pack ID is required"
            ))
        }

        if displayName.localized.isEmpty {
            errors.append(ContentValidationError(
                type: .missingRequired,
                definitionId: "manifest",
                message: "Display name is required"
            ))
        }

        // Validate pack ID format (lowercase, alphanumeric, hyphens)
        let validIdPattern = "^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        if !packId.isEmpty,
           let regex = try? NSRegularExpression(pattern: validIdPattern),
           regex.firstMatch(in: packId, range: NSRange(packId.startIndex..., in: packId)) == nil {
            errors.append(ContentValidationError(
                type: .invalidRange,
                definitionId: "manifest.packId",
                message: "Pack ID must be lowercase alphanumeric with hyphens"
            ))
        }

        // Validate locales
        if supportedLocales.isEmpty {
            errors.append(ContentValidationError(
                type: .missingRequired,
                definitionId: "manifest.locales",
                message: "At least one locale must be supported"
            ))
        }

        // Campaign packs should have entry points (informational)
        // Note: This is a warning, not a blocking error

        return errors
    }

    /// Check if this pack is compatible with current Core version
    public func isCompatibleWithCore() -> Bool {
        let current = CoreVersion.current

        // Must meet minimum requirement
        guard current >= coreVersionMin else { return false }

        // If max is specified, must not exceed it
        if let max = coreVersionMax, current > max {
            return false
        }

        return true
    }
}

// MARK: - Manifest File Loading

public extension PackManifest {
    /// Standard manifest filename
    static let filename = "manifest.json"

    /// Custom date formatter that handles both "2026-01-01" and "2026-01-01T00:00:00Z"
    private static let flexibleDateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd"
        formatter.locale = Locale(identifier: "en_US_POSIX")
        formatter.timeZone = TimeZone(secondsFromGMT: 0)
        return formatter
    }()

    /// Load manifest from URL
    static func load(from url: URL) throws -> PackManifest {
        let manifestURL = url.appendingPathComponent(filename)

        guard FileManager.default.fileExists(atPath: manifestURL.path) else {
            throw PackLoadError.manifestNotFound(path: manifestURL.path)
        }

        do {
            let data = try Data(contentsOf: manifestURL)
            let decoder = JSONDecoder()
            // Use custom strategy that handles both date-only and ISO8601 formats
            decoder.dateDecodingStrategy = .custom { decoder in
                let container = try decoder.singleValueContainer()
                let dateString = try container.decode(String.self)

                // Try ISO8601 first
                if let date = ISO8601DateFormatter().date(from: dateString) {
                    return date
                }

                // Fallback to date-only format "yyyy-MM-dd"
                if let date = flexibleDateFormatter.date(from: dateString) {
                    return date
                }

                throw DecodingError.dataCorruptedError(
                    in: container,
                    debugDescription: "Invalid date format: \(dateString)"
                )
            }
            return try decoder.decode(PackManifest.self, from: data)
        } catch let error as DecodingError {
            throw PackLoadError.invalidManifest(reason: error.localizedDescription)
        }
    }

    /// Save manifest to URL
    func save(to url: URL) throws {
        let manifestURL = url.appendingPathComponent(Self.filename)
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        encoder.dateEncodingStrategy = .iso8601
        let data = try encoder.encode(self)
        try data.write(to: manifestURL)
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/ContentPacks/PackTypes.swift
// ==========================================

import Foundation

// MARK: - Semantic Versioning

/// Semantic version for Core and Packs
/// Format: MAJOR.MINOR.PATCH
public struct SemanticVersion: Comparable, Hashable, CustomStringConvertible {
    public let major: Int
    public let minor: Int
    public let patch: Int

    public var description: String { "\(major).\(minor).\(patch)" }

    public init(major: Int, minor: Int, patch: Int) {
        self.major = major
        self.minor = minor
        self.patch = patch
    }

    public init?(string: String) {
        let parts = string.split(separator: ".").compactMap { Int($0) }
        guard parts.count == 3 else { return nil }
        self.major = parts[0]
        self.minor = parts[1]
        self.patch = parts[2]
    }

    public static func < (lhs: SemanticVersion, rhs: SemanticVersion) -> Bool {
        if lhs.major != rhs.major { return lhs.major < rhs.major }
        if lhs.minor != rhs.minor { return lhs.minor < rhs.minor }
        return lhs.patch < rhs.patch
    }

    /// Check if this version is compatible with required version
    /// - Same MAJOR version required
    /// - MINOR can be >= required
    public func isCompatible(with required: SemanticVersion) -> Bool {
        return major == required.major && (minor > required.minor || (minor == required.minor && patch >= required.patch))
    }
}

// MARK: - SemanticVersion Codable

extension SemanticVersion: Codable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let string = try container.decode(String.self)
        let parts = string.split(separator: ".").compactMap { Int($0) }
        guard parts.count == 3 else {
            throw DecodingError.dataCorruptedError(
                in: container,
                debugDescription: "Invalid version format: \(string). Expected MAJOR.MINOR.PATCH"
            )
        }
        self.major = parts[0]
        self.minor = parts[1]
        self.patch = parts[2]
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(description)
    }
}

// MARK: - Pack Types

/// Types of content packs
public enum PackType: String, Codable {
    /// Campaign content: regions, events, quests, enemies, story
    case campaign

    /// Character/Hero content: heroes, starting decks, player cards
    /// Note: Called "Character Pack" (not "Investigator Pack" as in Arkham Horror)
    /// to match Twilight Marches theme
    case character

    /// Balance tuning: numbers, weights, costs (no new content)
    case balance

    /// Rules extension: new game mechanics, capabilities
    case rulesExtension = "rules_extension"

    /// Full standalone pack: complete game content
    case full

    /// Load priority for pack ordering (lower = loaded first)
    public var loadPriority: Int {
        switch self {
        case .character: return 100  // Characters first
        case .balance: return 200    // Balance tuning second
        case .campaign: return 300   // Campaigns after characters
        case .rulesExtension: return 400
        case .full: return 500       // Full packs last
        }
    }

    /// Whether this pack type provides heroes
    public var providesHeroes: Bool {
        switch self {
        case .character, .full: return true
        case .campaign, .balance, .rulesExtension: return false
        }
    }

    /// Whether this pack type provides story content
    public var providesStory: Bool {
        switch self {
        case .campaign, .full: return true
        case .character, .balance, .rulesExtension: return false
        }
    }
}

/// Mission type for story packs
public enum MissionType: String, Codable {
    /// Multi-session campaign that spans multiple play sessions
    case campaign

    /// Single-session standalone mission
    case standalone
}

/// Pack dependency declaration
public struct PackDependency: Codable, Hashable {
    /// ID of required pack
    public let packId: String

    /// Minimum required version
    public let minVersion: SemanticVersion

    /// Maximum compatible version (nil = any)
    public let maxVersion: SemanticVersion?

    /// Is this dependency optional?
    public let isOptional: Bool

    public init(packId: String, minVersion: SemanticVersion, maxVersion: SemanticVersion? = nil, isOptional: Bool = false) {
        self.packId = packId
        self.minVersion = minVersion
        self.maxVersion = maxVersion
        self.isOptional = isOptional
    }
}

// MARK: - Content Inventory

/// Summary of content provided by a pack
public struct ContentInventory: Codable {
    public let regionCount: Int
    public let eventCount: Int
    public let questCount: Int
    public let heroCount: Int
    public let cardCount: Int
    public let anchorCount: Int
    public let enemyCount: Int

    public let hasBalanceConfig: Bool
    public let hasRulesExtension: Bool
    public let hasCampaignContent: Bool

    /// Supported locales (e.g., ["en", "ru"])
    public let supportedLocales: [String]

    public static let empty = ContentInventory(
        regionCount: 0, eventCount: 0, questCount: 0,
        heroCount: 0, cardCount: 0, anchorCount: 0, enemyCount: 0,
        hasBalanceConfig: false, hasRulesExtension: false, hasCampaignContent: false,
        supportedLocales: []
    )
}

// MARK: - Pack Load Errors

/// Errors that can occur during pack loading
public enum PackLoadError: Error, LocalizedError {
    case manifestNotFound(path: String)
    case invalidManifest(reason: String)
    case incompatibleCoreVersion(required: SemanticVersion, current: SemanticVersion)
    case missingDependency(packId: String, required: SemanticVersion)
    case dependencyVersionMismatch(packId: String, required: SemanticVersion, found: SemanticVersion)
    case contentLoadFailed(file: String, underlyingError: Error)
    case validationFailed(errorCount: Int, firstError: String)
    case checksumMismatch(file: String, expected: String, actual: String)
    case fileNotFound(_ path: String)  // Epic 0.3: checksum verification
    case packAlreadyLoaded(packId: String)
    case circularDependency(chain: [String])

    public var errorDescription: String? {
        switch self {
        case .manifestNotFound(let path):
            return "Pack manifest not found at: \(path)"
        case .invalidManifest(let reason):
            return "Invalid pack manifest: \(reason)"
        case .incompatibleCoreVersion(let required, let current):
            return "Pack requires Core \(required), but running \(current)"
        case .missingDependency(let packId, let version):
            return "Missing dependency: \(packId) >= \(version)"
        case .dependencyVersionMismatch(let packId, let required, let found):
            return "Dependency \(packId) requires \(required), found \(found)"
        case .contentLoadFailed(let file, let error):
            return "Failed to load \(file): \(error.localizedDescription)"
        case .validationFailed(let errorCount, let firstError):
            return "Validation failed with \(errorCount) errors. First: \(firstError)"
        case .checksumMismatch(let file, let expected, let actual):
            return "Checksum mismatch for \(file): expected \(expected), got \(actual)"
        case .fileNotFound(let path):
            return "File not found: \(path)"
        case .packAlreadyLoaded(let packId):
            return "Pack already loaded: \(packId)"
        case .circularDependency(let chain):
            return "Circular dependency detected: \(chain.joined(separator: " -> "))"
        }
    }
}

// MARK: - Loaded Pack

/// Represents a successfully loaded pack
public struct LoadedPack {
    public let manifest: PackManifest
    public let sourceURL: URL
    public let loadedAt: Date

    /// Content provided by this pack (indexed by ID)
    public var regions: [String: RegionDefinition] = [:]
    public var events: [String: EventDefinition] = [:]
    public var quests: [String: QuestDefinition] = [:]
    public var anchors: [String: AnchorDefinition] = [:]
    public var heroes: [String: StandardHeroDefinition] = [:]
    public var cards: [String: StandardCardDefinition] = [:]
    public var enemies: [String: EnemyDefinition] = [:]

    /// Balance configuration (if pack provides one)
    public var balanceConfig: BalanceConfiguration?

    /// Computed inventory
    public var inventory: ContentInventory {
        ContentInventory(
            regionCount: regions.count,
            eventCount: events.count,
            questCount: quests.count,
            heroCount: heroes.count,
            cardCount: cards.count,
            anchorCount: anchors.count,
            enemyCount: enemies.count,
            hasBalanceConfig: balanceConfig != nil,
            hasRulesExtension: false, // TODO: Add rules extension support
            hasCampaignContent: !regions.isEmpty || !events.isEmpty || !quests.isEmpty,
            supportedLocales: manifest.supportedLocales
        )
    }

    public init(manifest: PackManifest, sourceURL: URL, loadedAt: Date = Date()) {
        self.manifest = manifest
        self.sourceURL = sourceURL
        self.loadedAt = loadedAt
    }
}

// MARK: - Core Version

/// Current version of the Core engine
/// This is the single source of truth for engine version
public struct CoreVersion {
    public static let current = SemanticVersion(major: 1, minor: 0, patch: 0)

    /// Minimum pack version that current core supports
    public static let minSupportedPackVersion = SemanticVersion(major: 1, minor: 0, patch: 0)
}

// MARK: - Content Cache Types

/// Metadata for cached content pack
/// Used to validate cache freshness without loading full content
public struct CacheMetadata: Codable {
    /// Pack identifier
    public let packId: String

    /// Pack version at cache time
    public let version: SemanticVersion

    /// SHA256 hash of all pack JSON files
    /// Used to detect content changes
    public let contentHash: String

    /// When the cache was created
    public let cachedAt: Date

    /// Engine version when cache was created
    /// Cache is invalidated if major/minor version changes
    public let engineVersion: String

    public init(packId: String, version: SemanticVersion, contentHash: String, cachedAt: Date, engineVersion: String) {
        self.packId = packId
        self.version = version
        self.contentHash = contentHash
        self.cachedAt = cachedAt
        self.engineVersion = engineVersion
    }

    /// Validates if cache is still fresh
    public func isValid(currentHash: String, currentEngineVersion: String) -> Bool {
        // Hash must match
        guard contentHash == currentHash else { return false }

        // Engine major.minor must match
        guard let cached = SemanticVersion(string: engineVersion),
              let current = SemanticVersion(string: currentEngineVersion) else {
            return false
        }

        return cached.major == current.major && cached.minor == current.minor
    }
}

/// Serialized pack data for persistent cache
/// Contains all content that can be restored without re-parsing JSON
public struct CachedPackData: Codable {
    /// Cache metadata for validation
    public let metadata: CacheMetadata

    /// Original manifest
    public let manifest: PackManifest

    /// All content indexed by ID
    public let regions: [String: RegionDefinition]
    public let events: [String: EventDefinition]
    public let quests: [String: QuestDefinition]
    public let anchors: [String: AnchorDefinition]
    public let heroes: [String: StandardHeroDefinition]
    public let cards: [String: StandardCardDefinition]
    public let enemies: [String: EnemyDefinition]

    /// Hero abilities (stored separately in AbilityRegistry at runtime)
    public let abilities: [HeroAbility]

    /// Balance configuration (if any)
    public let balanceConfig: BalanceConfiguration?

    /// Create from LoadedPack
    public init(from pack: LoadedPack, contentHash: String) {
        self.metadata = CacheMetadata(
            packId: pack.manifest.packId,
            version: pack.manifest.version,
            contentHash: contentHash,
            cachedAt: Date(),
            engineVersion: CoreVersion.current.description
        )
        self.manifest = pack.manifest
        self.regions = pack.regions
        self.events = pack.events
        self.quests = pack.quests
        self.anchors = pack.anchors
        self.heroes = pack.heroes
        self.cards = pack.cards
        self.enemies = pack.enemies
        // Capture abilities from AbilityRegistry at cache time
        self.abilities = AbilityRegistry.shared.allAbilities
        self.balanceConfig = pack.balanceConfig
    }

    /// Convert back to LoadedPack
    public func toLoadedPack(sourceURL: URL = URL(fileURLWithPath: "cached")) -> LoadedPack {
        var pack = LoadedPack(
            manifest: manifest,
            sourceURL: sourceURL,
            loadedAt: metadata.cachedAt
        )
        pack.regions = regions
        pack.events = events
        pack.quests = quests
        pack.anchors = anchors
        pack.heroes = heroes
        pack.cards = cards
        pack.enemies = enemies
        pack.balanceConfig = balanceConfig
        return pack
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/ContentPacks/PackValidator.swift
// ==========================================

import Foundation

// MARK: - Pack Validator

/// Comprehensive validator for content packs
/// Validates structure, references, balance, and content integrity
public final class PackValidator {
    // MARK: - Types

    /// Validation severity level
    public enum Severity: String, CaseIterable {
        case error = "ERROR"      // Pack cannot be loaded
        case warning = "WARNING"  // Pack loads but may have issues
        case info = "INFO"        // Informational, not a problem
    }

    /// Validation result for a single check
    public struct ValidationResult {
        public let severity: Severity
        public let category: String
        public let message: String
        public let file: String?
        public let line: Int?

        public var description: String {
            var desc = "[\(severity.rawValue)] \(category): \(message)"
            if let file = file {
                desc += " (in \(file)"
                if let line = line {
                    desc += ":\(line)"
                }
                desc += ")"
            }
            return desc
        }
    }

    /// Summary of validation results
    public struct ValidationSummary {
        public let packId: String
        public let results: [ValidationResult]
        public let duration: TimeInterval

        public var errorCount: Int { results.filter { $0.severity == .error }.count }
        public var warningCount: Int { results.filter { $0.severity == .warning }.count }
        public var infoCount: Int { results.filter { $0.severity == .info }.count }

        public var isValid: Bool { errorCount == 0 }

        var description: String {
            var lines: [String] = []
            lines.append("=== Pack Validation: \(packId) ===")
            lines.append("Duration: \(String(format: "%.2f", duration))s")
            lines.append("Errors: \(errorCount), Warnings: \(warningCount), Info: \(infoCount)")
            lines.append("")

            if !results.isEmpty {
                for result in results {
                    lines.append(result.description)
                }
            } else {
                lines.append("No issues found.")
            }

            lines.append("")
            lines.append(isValid ? "VALIDATION PASSED" : "VALIDATION FAILED")
            return lines.joined(separator: "\n")
        }
    }

    // MARK: - Properties

    private var results: [ValidationResult] = []
    private let packURL: URL
    private var manifest: PackManifest?
    private var loadedPack: LoadedPack?

    // MARK: - Initialization

    public init(packURL: URL) {
        self.packURL = packURL
    }

    // MARK: - Public API

    /// Validate a pack at the given URL
    /// - Returns: Validation summary with all results
    public func validate() -> ValidationSummary {
        let startTime = Date()
        results.removeAll()

        // Phase 1: Validate manifest
        validateManifest()

        // Phase 2: Validate file structure
        if manifest != nil {
            validateFileStructure()
        }

        // Phase 3: Load and validate content
        if manifest != nil {
            validateContent()
        }

        // Phase 4: Validate cross-references
        if loadedPack != nil {
            validateCrossReferences()
        }

        // Phase 5: Validate balance configuration
        if let pack = loadedPack, pack.balanceConfig != nil {
            validateBalanceConfig()
        }

        // Phase 6: Validate localization
        if let pack = loadedPack {
            validateLocalization(pack)
        }

        let duration = Date().timeIntervalSince(startTime)
        return ValidationSummary(
            packId: manifest?.packId ?? "unknown",
            results: results,
            duration: duration
        )
    }

    /// Validate pack and return just the error/warning count
    public static func quickValidate(packURL: URL) -> (errors: Int, warnings: Int) {
        let validator = PackValidator(packURL: packURL)
        let summary = validator.validate()
        return (summary.errorCount, summary.warningCount)
    }

    // MARK: - Phase 1: Manifest Validation

    private func validateManifest() {
        let manifestURL = packURL.appendingPathComponent("manifest.json")

        // Check manifest exists
        guard FileManager.default.fileExists(atPath: manifestURL.path) else {
            addError("Manifest", "manifest.json not found at pack root")
            return
        }

        // Try to load manifest
        do {
            manifest = try PackManifest.load(from: packURL)
        } catch {
            addError("Manifest", "Failed to parse manifest.json: \(error.localizedDescription)")
            return
        }

        guard let manifest = manifest else { return }

        // Validate required fields
        if manifest.packId.isEmpty {
            addError("Manifest", "packId is required")
        }

        if manifest.packId.contains(" ") {
            addWarning("Manifest", "packId should not contain spaces: '\(manifest.packId)'")
        }

        if manifest.displayName.en.isEmpty {
            addError("Manifest", "displayName.en is required")
        }

        // Validate version
        if manifest.version.major == 0 && manifest.version.minor == 0 && manifest.version.patch == 0 {
            addWarning("Manifest", "Version 0.0.0 suggests pack is not properly versioned")
        }

        // Validate Core compatibility
        if !manifest.isCompatibleWithCore() {
            addError("Manifest", "Pack requires Core version \(manifest.coreVersionMin), but current is \(CoreVersion.current)")
        }

        // Validate entry points for campaign packs
        if manifest.packType == .campaign || manifest.packType == .full {
            if manifest.entryRegionId == nil {
                addWarning("Manifest", "Campaign pack should specify entryRegionId")
            }
        }

        // Validate paths exist
        validateManifestPaths(manifest)

        addInfo("Manifest", "Loaded pack '\(manifest.packId)' v\(manifest.version)")
    }

    private func validateManifestPaths(_ manifest: PackManifest) {
        let paths = [
            ("regionsPath", manifest.regionsPath),
            ("eventsPath", manifest.eventsPath),
            ("heroesPath", manifest.heroesPath),
            ("cardsPath", manifest.cardsPath),
            ("balancePath", manifest.balancePath),
            ("localizationPath", manifest.localizationPath)
        ]

        for (name, path) in paths {
            if let path = path {
                let fullPath = packURL.appendingPathComponent(path)
                if !FileManager.default.fileExists(atPath: fullPath.path) {
                    addWarning("Manifest", "\(name) points to non-existent path: \(path)")
                }
            }
        }
    }

    // MARK: - Phase 2: File Structure Validation

    private func validateFileStructure() {
        guard let manifest = manifest else { return }

        // Check for required directories based on pack type
        switch manifest.packType {
        case .campaign, .full:
            checkDirectory("Campaign content", manifest.regionsPath)
            checkDirectory("Events", manifest.eventsPath)

        case .character:
            checkDirectory("Heroes", manifest.heroesPath)
            checkDirectory("Cards", manifest.cardsPath)

        case .balance:
            checkDirectory("Balance", manifest.balancePath)

        case .rulesExtension:
            break // No specific requirements
        }

        // Check localization
        if let locPath = manifest.localizationPath {
            let locURL = packURL.appendingPathComponent(locPath)
            if FileManager.default.fileExists(atPath: locURL.path) {
                for locale in manifest.supportedLocales {
                    let localeFile = locURL.appendingPathComponent("\(locale).json")
                    if !FileManager.default.fileExists(atPath: localeFile.path) {
                        addWarning("Localization", "Missing localization file for locale '\(locale)'")
                    }
                }
            }
        }
    }

    private func checkDirectory(_ name: String, _ path: String?) {
        guard let path = path else {
            addWarning("Structure", "\(name) path not specified in manifest")
            return
        }

        let fullPath = packURL.appendingPathComponent(path)
        var isDirectory: ObjCBool = false

        if !FileManager.default.fileExists(atPath: fullPath.path, isDirectory: &isDirectory) {
            addWarning("Structure", "\(name) directory not found: \(path)")
        } else if !isDirectory.boolValue {
            // Check if it's a file (like regions.json instead of regions/)
            if !fullPath.pathExtension.isEmpty {
                addInfo("Structure", "\(name) is a file: \(path)")
            }
        }
    }

    // MARK: - Phase 3: Content Validation

    private func validateContent() {
        guard let manifest = manifest else { return }

        do {
            loadedPack = try PackLoader.load(manifest: manifest, from: packURL)
            addInfo("Content", "Loaded \(loadedPack?.regions.count ?? 0) regions, \(loadedPack?.events.count ?? 0) events, \(loadedPack?.heroes.count ?? 0) heroes, \(loadedPack?.cards.count ?? 0) cards")
        } catch {
            addError("Content", "Failed to load pack content: \(error.localizedDescription)")
            return
        }

        guard let pack = loadedPack else { return }

        // Validate regions
        for (id, region) in pack.regions {
            validateRegion(id: id, region: region)
        }

        // Validate events
        for (id, event) in pack.events {
            validateEvent(id: id, event: event)
        }

        // Validate heroes
        for (id, hero) in pack.heroes {
            validateHero(id: id, hero: hero)
        }

        // Validate cards
        for (id, card) in pack.cards {
            validateCard(id: id, card: card)
        }

        // Validate anchors
        for (id, anchor) in pack.anchors {
            validateAnchor(id: id, anchor: anchor)
        }
    }

    private func validateRegion(id: String, region: RegionDefinition) {
        if region.title.en.isEmpty {
            addError("Region", "Region '\(id)' has empty English title")
        }

        if region.neighborIds.isEmpty {
            addWarning("Region", "Region '\(id)' has no neighbors (isolated)")
        }

        // Check for self-reference
        if region.neighborIds.contains(id) {
            addError("Region", "Region '\(id)' lists itself as neighbor")
        }
    }

    private func validateEvent(id: String, event: EventDefinition) {
        if event.title.en.isEmpty {
            addError("Event", "Event '\(id)' has empty English title")
        }

        if event.choices.isEmpty {
            addWarning("Event", "Event '\(id)' has no choices")
        }

        // Validate choices
        var choiceIds = Set<String>()
        for choice in event.choices {
            if choiceIds.contains(choice.id) {
                addError("Event", "Event '\(id)' has duplicate choice ID: \(choice.id)")
            }
            choiceIds.insert(choice.id)

            if choice.label.en.isEmpty {
                addWarning("Event", "Event '\(id)' choice '\(choice.id)' has empty label")
            }
        }

        // Validate weight
        if event.weight <= 0 {
            addWarning("Event", "Event '\(id)' has non-positive weight: \(event.weight)")
        }
    }

    private func validateHero(id: String, hero: StandardHeroDefinition) {
        if hero.name.isEmpty {
            addError("Hero", "Hero '\(id)' has empty name")
        }

        if hero.startingDeckCardIDs.isEmpty {
            addWarning("Hero", "Hero '\(id)' has empty starting deck")
        }

        // Check for duplicate cards in starting deck
        let uniqueCards = Set(hero.startingDeckCardIDs)
        if uniqueCards.count != hero.startingDeckCardIDs.count {
            addInfo("Hero", "Hero '\(id)' has duplicate cards in starting deck")
        }
    }

    private func validateCard(id: String, card: StandardCardDefinition) {
        if card.name.isEmpty {
            addError("Card", "Card '\(id)' has empty name")
        }

        if card.faithCost < 0 {
            addError("Card", "Card '\(id)' has negative faith cost: \(card.faithCost)")
        }
    }

    private func validateAnchor(id: String, anchor: AnchorDefinition) {
        if anchor.title.en.isEmpty {
            addError("Anchor", "Anchor '\(id)' has empty English title")
        }

        if anchor.initialIntegrity < 0 || anchor.initialIntegrity > anchor.maxIntegrity {
            addError("Anchor", "Anchor '\(id)' has invalid initial integrity: \(anchor.initialIntegrity) (max: \(anchor.maxIntegrity))")
        }

        if anchor.maxIntegrity <= 0 {
            addError("Anchor", "Anchor '\(id)' has non-positive max integrity: \(anchor.maxIntegrity)")
        }
    }

    // MARK: - Phase 4: Cross-Reference Validation

    private func validateCrossReferences() {
        guard let pack = loadedPack else { return }

        // Region neighbor references
        for (id, region) in pack.regions {
            for neighborId in region.neighborIds {
                if pack.regions[neighborId] == nil {
                    addError("Reference", "Region '\(id)' references non-existent neighbor '\(neighborId)'")
                }
            }
        }

        // Check bidirectional neighbors
        for (id, region) in pack.regions {
            for neighborId in region.neighborIds {
                if let neighbor = pack.regions[neighborId] {
                    if !neighbor.neighborIds.contains(id) {
                        addWarning("Reference", "Region '\(id)' â†’ '\(neighborId)' is not bidirectional")
                    }
                }
            }
        }

        // Anchor region references
        for (id, anchor) in pack.anchors {
            if pack.regions[anchor.regionId] == nil {
                addError("Reference", "Anchor '\(id)' references non-existent region '\(anchor.regionId)'")
            }
        }

        // Event region references
        for (id, event) in pack.events {
            if let regionIds = event.availability.regionIds {
                for regionId in regionIds {
                    if pack.regions[regionId] == nil {
                        addError("Reference", "Event '\(id)' references non-existent region '\(regionId)'")
                    }
                }
            }
        }

        // Hero starting deck references
        for (id, hero) in pack.heroes {
            for cardId in hero.startingDeckCardIDs {
                if pack.cards[cardId] == nil {
                    addError("Reference", "Hero '\(id)' references non-existent card '\(cardId)'")
                }
            }
        }

        // Entry region validation
        if let manifest = manifest, let entryRegionId = manifest.entryRegionId {
            if pack.regions[entryRegionId] == nil {
                addError("Reference", "Manifest entryRegionId '\(entryRegionId)' not found in regions")
            }
        }
    }

    // MARK: - Phase 5: Balance Validation

    private func validateBalanceConfig() {
        guard let pack = loadedPack, let balance = pack.balanceConfig else { return }

        // Resource validation
        if balance.resources.maxHealth <= 0 {
            addError("Balance", "maxHealth must be positive: \(balance.resources.maxHealth)")
        }

        if balance.resources.startingHealth > balance.resources.maxHealth {
            addError("Balance", "startingHealth (\(balance.resources.startingHealth)) exceeds maxHealth (\(balance.resources.maxHealth))")
        }

        if balance.resources.startingHealth <= 0 {
            addWarning("Balance", "startingHealth is non-positive: \(balance.resources.startingHealth)")
        }

        if balance.resources.maxFaith <= 0 {
            addError("Balance", "maxFaith must be positive: \(balance.resources.maxFaith)")
        }

        if balance.resources.startingFaith > balance.resources.maxFaith {
            addError("Balance", "startingFaith (\(balance.resources.startingFaith)) exceeds maxFaith (\(balance.resources.maxFaith))")
        }

        // Pressure validation
        if balance.pressure.maxPressure <= 0 {
            addError("Balance", "maxPressure must be positive: \(balance.pressure.maxPressure)")
        }

        if balance.pressure.startingPressure < 0 {
            addWarning("Balance", "startingPressure is negative: \(balance.pressure.startingPressure)")
        }

        if balance.pressure.startingPressure > balance.pressure.maxPressure {
            addError("Balance", "startingPressure (\(balance.pressure.startingPressure)) exceeds maxPressure (\(balance.pressure.maxPressure))")
        }

        // Anchor validation
        if balance.anchor.maxIntegrity <= 0 {
            addError("Balance", "anchor.maxIntegrity must be positive: \(balance.anchor.maxIntegrity)")
        }

        if balance.anchor.strengthenCost < 0 {
            addError("Balance", "anchor.strengthenCost cannot be negative: \(balance.anchor.strengthenCost)")
        }

        if balance.anchor.strengthenAmount <= 0 {
            addWarning("Balance", "anchor.strengthenAmount is non-positive: \(balance.anchor.strengthenAmount)")
        }

        addInfo("Balance", "Balance configuration validated")
    }

    // MARK: - Phase 6: Localization Validation

    private func validateLocalization(_ pack: LoadedPack) {
        guard let manifest = manifest else { return }

        // Collect all StringKey references from entities
        var referencedKeys = Set<String>()
        collectStringKeys(from: pack, into: &referencedKeys)

        // If no localization path and no string keys, skip detailed validation
        guard let locPath = manifest.localizationPath else {
            // Report info if pack uses no string keys
            if referencedKeys.isEmpty {
                addInfo("Localization", "Pack uses inline LocalizedString (legacy mode)")
            } else {
                addError("Localization", "Pack uses \(referencedKeys.count) StringKey references but has no localizationPath in manifest")
            }
            return
        }

        let locURL = packURL.appendingPathComponent(locPath)

        // Validate string tables exist for each declared locale
        var allTableKeys: [String: Set<String>] = [:]  // [locale: keys]

        for locale in manifest.supportedLocales {
            let localeFile = locURL.appendingPathComponent("\(locale).json")

            guard FileManager.default.fileExists(atPath: localeFile.path) else {
                addError("Localization", "Missing string table for declared locale '\(locale)' at \(locPath)/\(locale).json")
                continue
            }

            do {
                let data = try Data(contentsOf: localeFile)
                let table = try JSONDecoder().decode([String: String].self, from: data)
                allTableKeys[locale] = Set(table.keys)

                // Validate key format
                for key in table.keys {
                    let stringKey = StringKey(key)
                    if !stringKey.isValid {
                        addWarning("Localization", "Invalid key format '\(key)' in \(locale).json. Expected: lowercase.dot.separated")
                    }
                }

                addInfo("Localization", "Loaded \(table.count) keys from \(locale).json")
            } catch {
                addError("Localization", "Failed to parse \(locale).json: \(error.localizedDescription)")
            }
        }

        // Check for missing keys in each locale
        let englishKeys = allTableKeys["en"] ?? []

        for (locale, localeKeys) in allTableKeys {
            // Check referenced keys that are missing
            let missingReferenced = referencedKeys.subtracting(localeKeys)
            for key in missingReferenced.sorted().prefix(10) {
                addWarning("Localization", "StringKey '\(key)' referenced in content but not found in \(locale).json")
            }
            if missingReferenced.count > 10 {
                addWarning("Localization", "... and \(missingReferenced.count - 10) more missing keys in \(locale).json")
            }

            // Check for incomplete translations (present in en but not in other locales)
            if locale != "en" {
                let missingTranslations = englishKeys.subtracting(localeKeys)
                if !missingTranslations.isEmpty {
                    addWarning("Localization", "\(locale).json missing \(missingTranslations.count) translations present in en.json")
                }
            }
        }

        if referencedKeys.isEmpty && allTableKeys.values.allSatisfy({ $0.isEmpty }) {
            addInfo("Localization", "Pack has localization structure but no string keys used yet")
        } else {
            addInfo("Localization", "Localization validation complete: \(referencedKeys.count) keys referenced")
        }
    }

    /// Collect all StringKey values from pack entities
    private func collectStringKeys(from pack: LoadedPack, into keys: inout Set<String>) {
        // Collect from regions
        for (_, region) in pack.regions {
            if case .key(let k) = region.title { keys.insert(k.rawValue) }
            if case .key(let k) = region.description { keys.insert(k.rawValue) }
        }

        // Collect from events
        for (_, event) in pack.events {
            if case .key(let k) = event.title { keys.insert(k.rawValue) }
            if case .key(let k) = event.body { keys.insert(k.rawValue) }
            for choice in event.choices {
                if case .key(let k) = choice.label { keys.insert(k.rawValue) }
                if let tooltip = choice.tooltip, case .key(let k) = tooltip { keys.insert(k.rawValue) }
            }
        }

        // Collect from heroes
        for (_, hero) in pack.heroes {
            if case .key(let k) = hero.name { keys.insert(k.rawValue) }
            if case .key(let k) = hero.description { keys.insert(k.rawValue) }
            if case .key(let k) = hero.specialAbility.name { keys.insert(k.rawValue) }
            if case .key(let k) = hero.specialAbility.description { keys.insert(k.rawValue) }
        }

        // Collect from cards
        for (_, card) in pack.cards {
            if case .key(let k) = card.name { keys.insert(k.rawValue) }
            if case .key(let k) = card.description { keys.insert(k.rawValue) }
        }

        // Collect from enemies
        for (_, enemy) in pack.enemies {
            if case .key(let k) = enemy.name { keys.insert(k.rawValue) }
            if case .key(let k) = enemy.description { keys.insert(k.rawValue) }
            for ability in enemy.abilities {
                if case .key(let k) = ability.name { keys.insert(k.rawValue) }
                if case .key(let k) = ability.description { keys.insert(k.rawValue) }
            }
        }

        // Collect from anchors
        for (_, anchor) in pack.anchors {
            if case .key(let k) = anchor.title { keys.insert(k.rawValue) }
            if case .key(let k) = anchor.description { keys.insert(k.rawValue) }
        }

        // Collect from quests
        for (_, quest) in pack.quests {
            if case .key(let k) = quest.title { keys.insert(k.rawValue) }
            if case .key(let k) = quest.description { keys.insert(k.rawValue) }
            for objective in quest.objectives {
                if case .key(let k) = objective.description { keys.insert(k.rawValue) }
                if let hint = objective.hint, case .key(let k) = hint { keys.insert(k.rawValue) }
            }
        }
    }

    // MARK: - Helper Methods

    private func addError(_ category: String, _ message: String, file: String? = nil, line: Int? = nil) {
        results.append(ValidationResult(severity: .error, category: category, message: message, file: file, line: line))
    }

    private func addWarning(_ category: String, _ message: String, file: String? = nil, line: Int? = nil) {
        results.append(ValidationResult(severity: .warning, category: category, message: message, file: file, line: line))
    }

    private func addInfo(_ category: String, _ message: String, file: String? = nil, line: Int? = nil) {
        results.append(ValidationResult(severity: .info, category: category, message: message, file: file, line: line))
    }
}

// MARK: - CLI Support

extension PackValidator {
    /// Run validation and print results to console (DEBUG only)
    public static func validateAndPrint(packURL: URL) -> Bool {
        let validator = PackValidator(packURL: packURL)
        let summary = validator.validate()
        #if DEBUG
        print(summary.description)
        #endif
        return summary.isValid
    }

    /// Validate multiple packs (DEBUG only for console output)
    public static func validateMultiple(packURLs: [URL]) -> Bool {
        var allValid = true

        for url in packURLs {
            #if DEBUG
            print("\n" + String(repeating: "=", count: 60))
            #endif
            let isValid = validateAndPrint(packURL: url)
            allValid = allValid && isValid
        }

        #if DEBUG
        print("\n" + String(repeating: "=", count: 60))
        print(allValid ? "ALL PACKS VALID" : "SOME PACKS HAVE ERRORS")
        #endif

        return allValid
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Models/Card.swift
// ==========================================

import Foundation

public struct Card: Identifiable, Codable, Hashable, Sendable {
    public let id: UUID
    public let definitionId: String  // Content Pack ID for this card definition
    public let name: String
    public let type: CardType
    public let rarity: CardRarity
    public let description: String
    public let imageURL: String?

    // Stats
    public var power: Int?
    public var defense: Int?
    public var health: Int?
    public var cost: Int?

    // Abilities and traits
    public var abilities: [CardAbility]
    public var traits: [String]

    // Card-specific properties
    public var damageType: DamageType?
    public var range: Int?

    // Twilight Marches mechanics
    public var balance: CardBalance?  // Light/Dark alignment
    public var realm: Realm?  // Yav/Nav/Prav
    public var curseType: CurseType?  // For curse cards
    public var expansionSet: String?  // For DLC/expansions tracking
    public var role: CardRole?  // Functional role in campaign (Sustain/Control/Power/Utility)
    public var regionRequirement: String?  // Required region flag to purchase (for story pool)
    public var faithCost: Int  // Cost in faith to purchase from market

    public init(
        id: UUID = UUID(),
        definitionId: String = "",
        name: String,
        type: CardType,
        rarity: CardRarity = .common,
        description: String,
        imageURL: String? = nil,
        power: Int? = nil,
        defense: Int? = nil,
        health: Int? = nil,
        cost: Int? = nil,
        abilities: [CardAbility] = [],
        traits: [String] = [],
        damageType: DamageType? = nil,
        range: Int? = nil,
        balance: CardBalance? = nil,
        realm: Realm? = nil,
        curseType: CurseType? = nil,
        expansionSet: String? = nil,
        role: CardRole? = nil,
        regionRequirement: String? = nil,
        faithCost: Int = 3
    ) {
        self.id = id
        self.definitionId = definitionId
        self.name = name
        self.type = type
        self.rarity = rarity
        self.description = description
        self.imageURL = imageURL
        self.power = power
        self.defense = defense
        self.health = health
        self.cost = cost
        self.abilities = abilities
        self.traits = traits
        self.damageType = damageType
        self.range = range
        self.balance = balance
        self.realm = realm
        self.curseType = curseType
        self.expansionSet = expansionSet
        self.role = role
        self.regionRequirement = regionRequirement
        self.faithCost = faithCost
    }

    /// Calculate adjusted cost based on player's Light/Dark balance
    /// See EXPLORATION_CORE_DESIGN.md, section 23.4
    public func adjustedFaithCost(playerBalance: Int) -> Int {
        guard let cardBalance = balance else { return faithCost }

        switch cardBalance {
        case .light:
            // Light cards cheaper when player is aligned to light (>50)
            let discount = max(0, (playerBalance - 50) / 20)  // 0 to +2 discount
            return max(1, faithCost - discount)

        case .dark:
            // Dark cards cheaper when player is aligned to dark (<50)
            let discount = max(0, (50 - playerBalance) / 20)  // 0 to +2 discount
            return max(1, faithCost - discount)

        case .neutral:
            return faithCost  // Neutral always base cost
        }
    }
}

public struct CardAbility: Identifiable, Hashable, Sendable {
    public let id: UUID
    public let stringId: String?
    public let name: String
    public let description: String
    public let effect: AbilityEffect

    public init(
        id: UUID = UUID(),
        stringId: String? = nil,
        name: String,
        description: String,
        effect: AbilityEffect
    ) {
        self.id = id
        self.stringId = stringId
        self.name = name
        self.description = description
        self.effect = effect
    }
}

// MARK: - CardAbility Codable

extension CardAbility: Codable {
    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case nameRu = "name_ru"
        case description
        case descriptionRu = "description_ru"
        case effect
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        // Try to decode id as UUID first, then as String
        if let uuidId = try? container.decode(UUID.self, forKey: .id) {
            self.id = uuidId
            self.stringId = nil
        } else if let stringId = try? container.decode(String.self, forKey: .id) {
            self.stringId = stringId
            // Generate deterministic UUID from string
            self.id = UUID(uuidString: stringId.stableUUID) ?? UUID()
        } else {
            self.id = UUID()
            self.stringId = nil
        }

        // Handle localized name
        let name = try container.decode(String.self, forKey: .name)
        let nameRu = try container.decodeIfPresent(String.self, forKey: .nameRu)
        if Locale.current.language.languageCode?.identifier == "ru", let ru = nameRu {
            self.name = ru
        } else {
            self.name = name
        }

        // Handle localized description
        let description = try container.decode(String.self, forKey: .description)
        let descriptionRu = try container.decodeIfPresent(String.self, forKey: .descriptionRu)
        if Locale.current.language.languageCode?.identifier == "ru", let ru = descriptionRu {
            self.description = ru
        } else {
            self.description = description
        }

        self.effect = try container.decode(AbilityEffect.self, forKey: .effect)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        if let stringId = stringId {
            try container.encode(stringId, forKey: .id)
        } else {
            try container.encode(id, forKey: .id)
        }
        try container.encode(name, forKey: .name)
        try container.encode(description, forKey: .description)
        try container.encode(effect, forKey: .effect)
    }
}

private extension String {
    var stableUUID: String {
        var hash: UInt64 = 5381
        for char in self.utf8 {
            hash = ((hash << 5) &+ hash) &+ UInt64(char)
        }
        let hex = String(format: "%016llX", hash)
        let padded = hex.padding(toLength: 32, withPad: "0", startingAt: 0)
        let chars = Array(padded)
        return "\(String(chars[0..<8]))-\(String(chars[8..<12]))-\(String(chars[12..<16]))-\(String(chars[16..<20]))-\(String(chars[20..<32]))"
    }
}

public enum AbilityEffect: Hashable, Sendable {
    case damage(amount: Int, type: DamageType)
    case heal(amount: Int)
    case drawCards(count: Int)
    case addDice(count: Int)
    case reroll
    case explore
    case custom(String)

    // Twilight Marches mechanics
    case applyCurse(type: CurseType, duration: Int)  // Apply curse
    case removeCurse(type: CurseType?)  // Remove specific or any curse
    case summonSpirit(power: Int, realm: Realm)  // Summon spirit guardian
    case shiftBalance(towards: CardBalance, amount: Int)  // Shift light/dark balance
    case travelRealm(to: Realm)  // Travel between Yav/Nav/Prav
    case gainFaith(amount: Int)  // Gain faith resource
    case sacrifice(cost: Int, benefit: String)  // Sacrifice health/cards for benefit

    // Additional effects from JSON
    case permanentStat(stat: String, amount: Int)
    case temporaryStat(stat: String, amount: Int, duration: Int)
}

// MARK: - AbilityEffect Codable

extension AbilityEffect: Codable {
    private enum CodingKeys: String, CodingKey {
        case damage
        case heal
        case drawCards = "draw_cards"
        case addDice = "add_dice"
        case reroll
        case explore
        case custom
        case applyCurse = "apply_curse"
        case removeCurse = "remove_curse"
        case summonSpirit = "summon_spirit"
        case shiftBalance = "shift_balance"
        case travelRealm = "travel_realm"
        case gainFaith = "gain_faith"
        case faith
        case sacrifice
        case permanentStat = "permanent_stat"
        case temporaryStat = "temporary_stat"
    }

    private struct DamageValue: Codable {
        let amount: Int
        let type: String
    }

    private struct CurseValue: Codable {
        let type: String
        let duration: Int?
    }

    private struct SpiritValue: Codable {
        let power: Int
        let realm: String
    }

    private struct BalanceValue: Codable {
        let towards: String
        let amount: Int
    }

    private struct StatValue: Codable {
        let stat: String
        let amount: Int
        let duration: Int?
    }

    private struct SacrificeValue: Codable {
        let cost: Int
        let benefit: String
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        // Try each effect type
        if let damageValue = try container.decodeIfPresent(DamageValue.self, forKey: .damage) {
            self = .damage(amount: damageValue.amount, type: DamageType(rawValue: damageValue.type) ?? .physical)
        } else if let healAmount = try container.decodeIfPresent(Int.self, forKey: .heal) {
            self = .heal(amount: healAmount)
        } else if let drawCount = try container.decodeIfPresent(Int.self, forKey: .drawCards) {
            self = .drawCards(count: drawCount)
        } else if let diceCount = try container.decodeIfPresent(Int.self, forKey: .addDice) {
            self = .addDice(count: diceCount)
        } else if (try? container.decodeIfPresent(Bool.self, forKey: .reroll)) == true {
            self = .reroll
        } else if (try? container.decodeIfPresent(Bool.self, forKey: .explore)) == true {
            self = .explore
        } else if let curseValue = try container.decodeIfPresent(CurseValue.self, forKey: .applyCurse) {
            self = .applyCurse(type: CurseType(rawValue: curseValue.type) ?? .weakness, duration: curseValue.duration ?? 1)
        } else if let curseString = try container.decodeIfPresent(String.self, forKey: .applyCurse) {
            // Simple format: "apply_curse": "weakness"
            self = .applyCurse(type: CurseType(rawValue: curseString) ?? .weakness, duration: 1)
        } else if let curseType = try container.decodeIfPresent(String.self, forKey: .removeCurse) {
            self = .removeCurse(type: CurseType(rawValue: curseType))
        } else if let spiritValue = try container.decodeIfPresent(SpiritValue.self, forKey: .summonSpirit) {
            self = .summonSpirit(power: spiritValue.power, realm: Realm(rawValue: spiritValue.realm) ?? .yav)
        } else if let balanceValue = try container.decodeIfPresent(BalanceValue.self, forKey: .shiftBalance) {
            self = .shiftBalance(towards: CardBalance(rawValue: balanceValue.towards) ?? .neutral, amount: balanceValue.amount)
        } else if let realmString = try container.decodeIfPresent(String.self, forKey: .travelRealm) {
            self = .travelRealm(to: Realm(rawValue: realmString) ?? .yav)
        } else if let faithAmount = try container.decodeIfPresent(Int.self, forKey: .gainFaith) {
            self = .gainFaith(amount: faithAmount)
        } else if let faithAmount = try container.decodeIfPresent(Int.self, forKey: .faith) {
            // Alias for gain_faith
            self = .gainFaith(amount: faithAmount)
        } else if let sacrificeValue = try container.decodeIfPresent(SacrificeValue.self, forKey: .sacrifice) {
            self = .sacrifice(cost: sacrificeValue.cost, benefit: sacrificeValue.benefit)
        } else if let statValue = try container.decodeIfPresent(StatValue.self, forKey: .permanentStat) {
            self = .permanentStat(stat: statValue.stat, amount: statValue.amount)
        } else if let statValue = try container.decodeIfPresent(StatValue.self, forKey: .temporaryStat) {
            self = .temporaryStat(stat: statValue.stat, amount: statValue.amount, duration: statValue.duration ?? 1)
        } else if let customString = try container.decodeIfPresent(String.self, forKey: .custom) {
            self = .custom(customString)
        } else {
            // Default to custom with unknown
            self = .custom("unknown")
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        switch self {
        case .damage(let amount, let type):
            try container.encode(DamageValue(amount: amount, type: type.rawValue), forKey: .damage)
        case .heal(let amount):
            try container.encode(amount, forKey: .heal)
        case .drawCards(let count):
            try container.encode(count, forKey: .drawCards)
        case .addDice(let count):
            try container.encode(count, forKey: .addDice)
        case .reroll:
            try container.encode(true, forKey: .reroll)
        case .explore:
            try container.encode(true, forKey: .explore)
        case .custom(let string):
            try container.encode(string, forKey: .custom)
        case .applyCurse(let type, let duration):
            try container.encode(CurseValue(type: type.rawValue, duration: duration), forKey: .applyCurse)
        case .removeCurse(let type):
            try container.encode(type?.rawValue, forKey: .removeCurse)
        case .summonSpirit(let power, let realm):
            try container.encode(SpiritValue(power: power, realm: realm.rawValue), forKey: .summonSpirit)
        case .shiftBalance(let towards, let amount):
            try container.encode(BalanceValue(towards: towards.rawValue, amount: amount), forKey: .shiftBalance)
        case .travelRealm(let realm):
            try container.encode(realm.rawValue, forKey: .travelRealm)
        case .gainFaith(let amount):
            try container.encode(amount, forKey: .gainFaith)
        case .sacrifice(let cost, let benefit):
            try container.encode(SacrificeValue(cost: cost, benefit: benefit), forKey: .sacrifice)
        case .permanentStat(let stat, let amount):
            try container.encode(StatValue(stat: stat, amount: amount, duration: nil), forKey: .permanentStat)
        case .temporaryStat(let stat, let amount, let duration):
            try container.encode(StatValue(stat: stat, amount: amount, duration: duration), forKey: .temporaryStat)
        }
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Models/CardType.swift
// ==========================================

import Foundation

public enum CardType: String, Codable, Hashable, Sendable {
    case character
    case weapon
    case spell
    case armor
    case item
    case ally
    case blessing
    case monster
    case location
    case scenario

    // Twilight Marches specific card types
    case curse      // ÐŸÑ€Ð¾ÐºÐ»ÑÑ‚Ð¸Ñ - negative effects
    case spirit     // Ð”ÑƒÑ…Ð¸ - summonable allies/enemies
    case artifact   // ÐÑ€Ñ‚ÐµÑ„Ð°ÐºÑ‚Ñ‹ - powerful ancient items
    case ritual     // Ð Ð¸Ñ‚ÑƒÐ°Ð»Ñ‹ - special spells requiring preparation

    // Deck-building game card types
    case resource   // Ð ÐµÑÑƒÑ€ÑÑ‹ - used to purchase cards from market
    case attack     // ÐÑ‚Ð°ÐºÐ° - deal damage to enemies
    case defense    // Ð—Ð°Ñ‰Ð¸Ñ‚Ð° - block damage or protect
    case special    // ÐžÑÐ¾Ð±Ñ‹Ðµ - unique effects and abilities
}

public enum CardRarity: String, Codable, Hashable, Sendable {
    case common
    case uncommon
    case rare
    case epic
    case legendary
}

public enum DamageType: String, Codable, Hashable, Sendable {
    case physical
    case fire
    case cold
    case electricity
    case acid
    case mental
    case poison
    case arcane
}

// Twilight Marches: Balance system (Light/Dark)
public enum CardBalance: String, Codable, Hashable, Sendable {
    case light      // Cards from Prav, protective/healing
    case neutral    // Balanced cards
    case dark       // Cards from Nav, aggressive/cursing

    /// Initialize from Engine's AnchorInfluence
    /// Used by data-driven content loading
    public init(from influence: AnchorInfluence) {
        switch influence {
        case .light: self = .light
        case .neutral: self = .neutral
        case .dark: self = .dark
        }
    }
}

// Twilight Marches: Three Realms system
public enum Realm: String, Codable, Hashable, Sendable {
    case yav        // Ð¯Ð²ÑŒ - World of the Living (reality, settlements, heroes)
    case nav        // ÐÐ°Ð²ÑŒ - World of the Dead (spirits, undead, curses)
    case prav       // ÐŸÑ€Ð°Ð²ÑŒ - World of the Gods (higher powers, blessings, ancient magic)
}

// Twilight Marches: Functional Card Roles (Campaign system)
// See EXPLORATION_CORE_DESIGN.md, section 22
public enum CardRole: String, Codable, Hashable, Sendable {
    case sustain    // ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ° - healing, curse removal, recovery
    case control    // ÐšÐ¾Ð½Ñ‚Ñ€Ð¾Ð»ÑŒ - region stabilization, anchor protection, tension reduction
    case power      // Ð¡Ð¸Ð»Ð° - fast progress, elite enemies, rare rewards (always with a price)
    case utility    // Ð“Ð¸Ð±ÐºÐ¾ÑÑ‚ÑŒ - card draw, deck manipulation, preparation

    /// Default balance alignment for this role
    public var defaultBalance: CardBalance {
        switch self {
        case .sustain: return .light
        case .control: return .light
        case .power: return .dark
        case .utility: return .neutral
        }
    }

    /// Typical rarity for this role
    public var typicalRarity: [CardRarity] {
        switch self {
        case .sustain: return [.common, .uncommon]
        case .control: return [.rare, .epic]
        case .power: return [.uncommon, .rare]
        case .utility: return [.common, .uncommon]
        }
    }
}

// Twilight Marches: Curse system (PLAYABLE curses)
// See EXPLORATION_CORE_DESIGN.md, section 26
public enum CurseType: String, Codable, Hashable, Sendable {
    case weakness       // Ð¡Ð»Ð°Ð±Ð¾ÑÑ‚ÑŒ: -1 Ðº ÑƒÑ€Ð¾Ð½Ñƒ Ð´Ð¾ ÐºÐ¾Ð½Ñ†Ð° Ð±Ð¾Ñ (2 Ð²ÐµÑ€Ñ‹ ÑÐ½ÑÑ‚ÑŒ)
    case fear           // Ð¡Ñ‚Ñ€Ð°Ñ…: -1 Ðº Ð·Ð°Ñ‰Ð¸Ñ‚Ðµ Ð´Ð¾ ÐºÐ¾Ð½Ñ†Ð° Ð±Ð¾Ñ (2 Ð²ÐµÑ€Ñ‹)
    case exhaustion     // Ð˜ÑÑ‚Ð¾Ñ‰ÐµÐ½Ð¸Ðµ: -1 Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ Ð² ÑÑ‚Ð¾Ð¼ Ñ…Ð¾Ð´Ñƒ (3 Ð²ÐµÑ€Ñ‹)
    case greed          // Ð–Ð°Ð´Ð½Ð¾ÑÑ‚ÑŒ: +2 Ð²ÐµÑ€Ñ‹, Ð½Ð¾ WorldTension +1 (4 Ð²ÐµÑ€Ñ‹)
    case shadowOfNav    // Ð¢ÐµÐ½ÑŒ ÐÐ°Ð²Ð¸: +3 ÑƒÑ€Ð¾Ð½Ð°, Ð½Ð¾ -2 HP (5 Ð²ÐµÑ€Ñ‹)
    case bloodCurse     // ÐŸÑ€Ð¾ÐºÐ»ÑÑ‚Ð¸Ðµ ÐºÑ€Ð¾Ð²Ð¸: ÐŸÑ€Ð¸ ÑƒÐ±Ð¸Ð¹ÑÑ‚Ð²Ðµ +2 HP, Ð±Ð°Ð»Ð°Ð½Ñ Ðº Ñ‚ÑŒÐ¼Ðµ (6 Ð²ÐµÑ€Ñ‹)
    case sealOfNav      // ÐŸÐµÑ‡Ð°Ñ‚ÑŒ ÐÐ°Ð²Ð¸: ÐÐµÐ»ÑŒÐ·Ñ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Sustain ÐºÐ°Ñ€Ñ‚Ñ‹ (8 Ð²ÐµÑ€Ñ‹)

    /// Cost in faith to remove this curse
    public var removalCost: Int {
        switch self {
        case .weakness: return 2
        case .fear: return 2
        case .exhaustion: return 3
        case .greed: return 4
        case .shadowOfNav: return 5
        case .bloodCurse: return 6
        case .sealOfNav: return 8
        }
    }

    /// Localized name
    public var displayName: String {
        switch self {
        case .weakness: return L10n.curseWeakness.localized
        case .fear: return L10n.curseFear.localized
        case .exhaustion: return L10n.curseExhaustion.localized
        case .greed: return L10n.curseGreed.localized
        case .shadowOfNav: return L10n.curseShadowOfNav.localized
        case .bloodCurse: return L10n.curseBloodCurse.localized
        case .sealOfNav: return L10n.curseSealOfNav.localized
        }
    }
}

// Expansion tracking
public enum ExpansionSet: String, Codable, Sendable {
    case baseSet            // Ð‘Ð°Ð·Ð¾Ð²Ñ‹Ð¹ Ð½Ð°Ð±Ð¾Ñ€
    case twilightMarches    // Ð¡ÑƒÐ¼Ñ€Ð°Ñ‡Ð½Ñ‹Ðµ ÐŸÑ€ÐµÐ´ÐµÐ»Ñ‹ (campaign)
    case borderlands        // ÐŸÐ¾Ñ€ÑƒÐ±ÐµÐ¶ÑŒÐµ (first expansion)
    case deepForest         // Ð”Ñ€ÐµÐ¼ÑƒÑ‡Ð¸Ð¹ Ð›ÐµÑ
    case ancientRuins       // Ð”Ñ€ÐµÐ²Ð½Ð¸Ðµ Ð ÑƒÐ¸Ð½Ñ‹
    case frozenNorth        // Ð—Ð°Ð¼ÐµÑ€Ð·ÑˆÐ¸Ð¹ Ð¡ÐµÐ²ÐµÑ€
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Models/ExplorationModels.swift
// ==========================================

import Foundation

// MARK: - Region State

public enum RegionState: String, Codable, Hashable, CaseIterable {
    case stable         // Ð¡Ñ‚Ð°Ð±Ð¸Ð»ÑŒÐ½Ð°Ñ Ð¯Ð²ÑŒ - Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾
    case borderland     // ÐŸÐ¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÑŒÐµ - Ð¿Ð¾Ð²Ñ‹ÑˆÐµÐ½Ð½Ñ‹Ð¹ Ñ€Ð¸ÑÐº
    case breach         // ÐŸÑ€Ð¾Ñ€Ñ‹Ð² ÐÐ°Ð²Ð¸ - Ð¾Ð¿Ð°ÑÐ½Ð¾

    /// Initialize from Engine's RegionStateType
    /// Used by data-driven content loading
    public init(from engineState: RegionStateType) {
        switch engineState {
        case .stable: self = .stable
        case .borderland: self = .borderland
        case .breach: self = .breach
        }
    }

    public var displayName: String {
        switch self {
        case .stable: return L10n.regionStateStable.localized
        case .borderland: return L10n.regionStateBorderland.localized
        case .breach: return L10n.regionStateBreach.localized
        }
    }

    public var emoji: String {
        switch self {
        case .stable: return "ðŸŸ¢"
        case .borderland: return "ðŸŸ¡"
        case .breach: return "ðŸ”´"
        }
    }

    // MARK: - Combat Modifiers

    /// Ð‘Ð¾Ð½ÑƒÑ Ðº ÑÐ¸Ð»Ðµ Ð²Ñ€Ð°Ð³Ð° Ð² ÑÑ‚Ð¾Ð¼ Ñ€ÐµÐ³Ð¸Ð¾Ð½Ðµ
    public var enemyPowerBonus: Int {
        switch self {
        case .stable: return 0
        case .borderland: return 1
        case .breach: return 2
        }
    }

    /// Ð‘Ð¾Ð½ÑƒÑ Ðº Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÑŽ Ð²Ñ€Ð°Ð³Ð° Ð² ÑÑ‚Ð¾Ð¼ Ñ€ÐµÐ³Ð¸Ð¾Ð½Ðµ
    public var enemyHealthBonus: Int {
        switch self {
        case .stable: return 0
        case .borderland: return 2
        case .breach: return 5
        }
    }

    /// Ð‘Ð¾Ð½ÑƒÑ Ðº Ð·Ð°Ñ‰Ð¸Ñ‚Ðµ Ð²Ñ€Ð°Ð³Ð° Ð² ÑÑ‚Ð¾Ð¼ Ñ€ÐµÐ³Ð¸Ð¾Ð½Ðµ
    public var enemyDefenseBonus: Int {
        switch self {
        case .stable: return 0
        case .borderland: return 1
        case .breach: return 2
        }
    }
}

// MARK: - Combat Context

/// ÐšÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ Ð±Ð¾Ñ Ñ ÑƒÑ‡Ñ‘Ñ‚Ð¾Ð¼ Ñ€ÐµÐ³Ð¸Ð¾Ð½Ð° Ð¸ Ð¿Ñ€Ð¾ÐºÐ»ÑÑ‚Ð¸Ð¹
public struct CombatContext {
    public let regionState: RegionState
    public let playerCurses: [CurseType]

    public init(regionState: RegionState, playerCurses: [CurseType]) {
        self.regionState = regionState
        self.playerCurses = playerCurses
    }

    /// Ð Ð°ÑÑÑ‡Ð¸Ñ‚Ð°Ñ‚ÑŒ ÑÑ„Ñ„ÐµÐºÑ‚Ð¸Ð²Ð½ÑƒÑŽ ÑÐ¸Ð»Ñƒ Ð²Ñ€Ð°Ð³Ð°
    public func adjustedEnemyPower(_ basePower: Int) -> Int {
        return basePower + regionState.enemyPowerBonus
    }

    /// Ð Ð°ÑÑÑ‡Ð¸Ñ‚Ð°Ñ‚ÑŒ ÑÑ„Ñ„ÐµÐºÑ‚Ð¸Ð²Ð½Ð¾Ðµ Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÐµ Ð²Ñ€Ð°Ð³Ð°
    public func adjustedEnemyHealth(_ baseHealth: Int) -> Int {
        return baseHealth + regionState.enemyHealthBonus
    }

    /// Ð Ð°ÑÑÑ‡Ð¸Ñ‚Ð°Ñ‚ÑŒ ÑÑ„Ñ„ÐµÐºÑ‚Ð¸Ð²Ð½ÑƒÑŽ Ð·Ð°Ñ‰Ð¸Ñ‚Ñƒ Ð²Ñ€Ð°Ð³Ð°
    public func adjustedEnemyDefense(_ baseDefense: Int) -> Int {
        return baseDefense + regionState.enemyDefenseBonus
    }

    /// ÐžÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð¼Ð¾Ð´Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð¾Ñ€Ð¾Ð² Ñ€ÐµÐ³Ð¸Ð¾Ð½Ð° Ð´Ð»Ñ UI
    public var regionModifierDescription: String? {
        switch regionState {
        case .stable:
            return nil
        case .borderland:
            return L10n.combatModifierBorderland.localized
        case .breach:
            return L10n.combatModifierBreach.localized
        }
    }
}

// MARK: - Region Type

public enum RegionType: String, Codable, Hashable {
    case forest         // Ð›ÐµÑ
    case swamp          // Ð‘Ð¾Ð»Ð¾Ñ‚Ð¾
    case mountain       // Ð“Ð¾Ñ€Ñ‹
    case settlement     // ÐŸÐ¾ÑÐµÐ»ÐµÐ½Ð¸Ðµ
    case water          // Ð’Ð¾Ð´Ð½Ð°Ñ Ð·Ð¾Ð½Ð°
    case wasteland      // ÐŸÑƒÑÑ‚Ð¾ÑˆÑŒ
    case sacred         // Ð¡Ð²ÑÑ‰ÐµÐ½Ð½Ð¾Ðµ Ð¼ÐµÑÑ‚Ð¾

    public var displayName: String {
        switch self {
        case .forest: return L10n.regionTypeForest.localized
        case .swamp: return L10n.regionTypeSwamp.localized
        case .mountain: return L10n.regionTypeMountain.localized
        case .settlement: return L10n.regionTypeSettlement.localized
        case .water: return L10n.regionTypeWater.localized
        case .wasteland: return L10n.regionTypeWasteland.localized
        case .sacred: return L10n.regionTypeSacred.localized
        }
    }

    public var icon: String {
        switch self {
        case .forest: return "tree.fill"
        case .swamp: return "cloud.fog.fill"
        case .mountain: return "mountain.2.fill"
        case .settlement: return "house.fill"
        case .water: return "drop.fill"
        case .wasteland: return "wind"
        case .sacred: return "star.fill"
        }
    }
}

// MARK: - Anchor Type

public enum AnchorType: String, Codable {
    case shrine         // ÐšÐ°Ð¿Ð¸Ñ‰Ðµ
    case barrow         // ÐšÑƒÑ€Ð³Ð°Ð½
    case sacredTree     // Ð¡Ð²ÑÑ‰ÐµÐ½Ð½Ñ‹Ð¹ Ð´ÑƒÐ±
    case stoneIdol      // ÐšÐ°Ð¼ÐµÐ½Ð½Ð°Ñ Ð±Ð°Ð±Ð°
    case spring         // Ð Ð¾Ð´Ð½Ð¸Ðº
    case chapel         // Ð§Ð°ÑÐ¾Ð²Ð½Ñ
    case temple         // Ð¥Ñ€Ð°Ð¼
    case cross          // ÐžÐ±ÐµÑ‚Ð½Ñ‹Ð¹ ÐºÑ€ÐµÑÑ‚

    /// Initialize from JSON string (snake_case format)
    /// Used by data-driven content loading
    public init?(fromJSON string: String) {
        switch string {
        case "shrine": self = .shrine
        case "barrow": self = .barrow
        case "sacred_tree": self = .sacredTree
        case "stone_idol": self = .stoneIdol
        case "spring": self = .spring
        case "chapel": self = .chapel
        case "temple": self = .temple
        case "cross": self = .cross
        default: return nil
        }
    }

    public var displayName: String {
        switch self {
        case .shrine: return L10n.anchorTypeShrine.localized
        case .barrow: return L10n.anchorTypeBarrow.localized
        case .sacredTree: return L10n.anchorTypeSacredTree.localized
        case .stoneIdol: return L10n.anchorTypeStoneIdol.localized
        case .spring: return L10n.anchorTypeSpring.localized
        case .chapel: return L10n.anchorTypeChapel.localized
        case .temple: return L10n.anchorTypeTemple.localized
        case .cross: return L10n.anchorTypeCross.localized
        }
    }

    public var icon: String {
        switch self {
        case .shrine: return "flame.fill"
        case .barrow: return "mountain.2"
        case .sacredTree: return "leaf.fill"
        case .stoneIdol: return "figure.stand"
        case .spring: return "drop.circle.fill"
        case .chapel: return "building.columns.fill"
        case .temple: return "building.2.fill"
        case .cross: return "cross.fill"
        }
    }
}

// MARK: - Anchor

public struct Anchor: Identifiable, Codable {
    public let id: UUID
    public let name: String
    public let type: AnchorType
    public var integrity: Int          // 0-100%
    public var influence: CardBalance  // .light, .neutral, .dark
    public let power: Int              // Ð¡Ð¸Ð»Ð° Ð²Ð»Ð¸ÑÐ½Ð¸Ñ (1-10)

    public init(
        id: UUID = UUID(),
        name: String,
        type: AnchorType,
        integrity: Int = 100,
        influence: CardBalance = .light,
        power: Int = 5
    ) {
        self.id = id
        self.name = name
        self.type = type
        self.integrity = max(0, min(100, integrity))
        self.influence = influence
        self.power = power
    }

    // ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÑ‚ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ Ñ€ÐµÐ³Ð¸Ð¾Ð½Ð° Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ñ†ÐµÐ»Ð¾ÑÑ‚Ð½Ð¾ÑÑ‚Ð¸ ÑÐºÐ¾Ñ€Ñ
    public var determinedRegionState: RegionState {
        switch integrity {
        case 70...100:
            return .stable
        case 30..<70:
            return .borderland
        default:
            return .breach
        }
    }

    // ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ°, Ð¾ÑÐºÐ²ÐµÑ€Ð½ÐµÐ½ Ð»Ð¸ ÑÐºÐ¾Ñ€ÑŒ
    public var isDefiled: Bool {
        return influence == .dark
    }
}

// MARK: - Region

/// Legacy Region model used for world state persistence and direct UI binding.
///
/// MIGRATION (Audit v1.1 Issue #9):
/// - For new code prefer using Engine models:
///   - `RegionDefinition` - static data (from ContentProvider)
///   - `RegionRuntimeState` - mutable state (Engine/Runtime/WorldRuntimeState.swift)
///   - `EngineRegionState` - combined state for UI (TwilightGameEngine.swift)
/// - This model is preserved for: save serialization, legacy UI, unit tests
/// - After full UI migration to Engine this model will become internal for persistence
public struct Region: Identifiable, Codable {
    public let id: UUID
    public let definitionId: String        // Content Pack ID (e.g., "region_01", "market_square")
    public let name: String
    public let type: RegionType
    public var state: RegionState
    public var anchor: Anchor?
    public var availableEvents: [String]   // Event IDs
    public var activeQuests: [String]      // Active quest IDs
    public var reputation: Int             // -100 to 100
    public var visited: Bool               // Has player been here
    public var neighborIds: [UUID]         // Neighbor region IDs (travel = 1 day)

    public init(
        id: UUID = UUID(),
        definitionId: String = "",
        name: String,
        type: RegionType,
        state: RegionState = .stable,
        anchor: Anchor? = nil,
        availableEvents: [String] = [],
        activeQuests: [String] = [],
        reputation: Int = 0,
        visited: Bool = false,
        neighborIds: [UUID] = []
    ) {
        self.id = id
        self.definitionId = definitionId
        self.name = name
        self.type = type
        self.state = state
        self.anchor = anchor
        self.availableEvents = availableEvents
        self.activeQuests = activeQuests
        self.reputation = max(-100, min(100, reputation))
        self.visited = visited
        self.neighborIds = neighborIds
    }

    /// Check if region is neighbor
    public func isNeighbor(_ regionId: UUID) -> Bool {
        return neighborIds.contains(regionId)
    }

    // Update region state based on anchor
    public mutating func updateStateFromAnchor() {
        if let anchor = anchor {
            self.state = anchor.determinedRegionState
        } else {
            // Without anchor region is always in Breach
            self.state = .breach
        }
    }

    // Can trade in region
    public var canTrade: Bool {
        return state == .stable && type == .settlement && reputation >= 0
    }

    // Can rest in region
    public var canRest: Bool {
        return state == .stable && (type == .settlement || type == .sacred)
    }
}

// MARK: - Event Type

public enum EventType: String, Codable, Hashable {
    case combat         // Combat
    case ritual         // Ritual/Choice
    case narrative      // Narrative event
    case exploration    // Exploration
    case worldShift     // World shift

    public var displayName: String {
        switch self {
        case .combat: return L10n.eventTypeCombat.localized
        case .ritual: return L10n.eventTypeRitual.localized
        case .narrative: return L10n.eventTypeNarrative.localized
        case .exploration: return L10n.eventTypeExploration.localized
        case .worldShift: return L10n.eventTypeWorldShift.localized
        }
    }

    public var icon: String {
        switch self {
        case .combat: return "bolt.fill"
        case .ritual: return "sparkles"
        case .narrative: return "text.bubble.fill"
        case .exploration: return "magnifyingglass"
        case .worldShift: return "globe"
        }
    }
}

// MARK: - Event Choice

public struct EventChoice: Identifiable, Codable, Hashable {
    public let id: String
    public let text: String
    public let requirements: EventRequirements?
    public let consequences: EventConsequences

    public init(
        id: String,
        text: String,
        requirements: EventRequirements? = nil,
        consequences: EventConsequences
    ) {
        self.id = id
        self.text = text
        self.requirements = requirements
        self.consequences = consequences
    }
}

// MARK: - Event Requirements

public struct EventRequirements: Codable, Hashable {
    public var minimumFaith: Int?
    public var minimumHealth: Int?
    public var requiredBalance: CardBalance?    // Required balance
    public var requiredFlags: [String]?         // Required world flags

    public init(
        minimumFaith: Int? = nil,
        minimumHealth: Int? = nil,
        requiredBalance: CardBalance? = nil,
        requiredFlags: [String]? = nil
    ) {
        self.minimumFaith = minimumFaith
        self.minimumHealth = minimumHealth
        self.requiredBalance = requiredBalance
        self.requiredFlags = requiredFlags
    }

    /// Check if requirements can be met using engine properties directly
    /// - Parameters:
    ///   - playerFaith: Current player faith value
    ///   - playerHealth: Current player health value
    ///   - playerBalance: Current player balance (0-100 scale)
    ///   - worldFlags: Current world flags dictionary
    /// - Returns: true if all requirements are met
    public func canMeet(
        playerFaith: Int,
        playerHealth: Int,
        playerBalance: Int,
        worldFlags: [String: Bool]
    ) -> Bool {
        if let minFaith = minimumFaith, playerFaith < minFaith {
            return false
        }
        if let minHealth = minimumHealth, playerHealth < minHealth {
            return false
        }
        if let reqBalance = requiredBalance {
            // Check player balance (0-100 scale)
            let playerBalanceEnum: CardBalance
            if playerBalance >= 70 {
                playerBalanceEnum = .light
            } else if playerBalance <= 30 {
                playerBalanceEnum = .dark
            } else {
                playerBalanceEnum = .neutral
            }

            if playerBalanceEnum != reqBalance {
                return false
            }
        }
        if let reqFlags = requiredFlags {
            for flag in reqFlags {
                if worldFlags[flag] != true {
                    return false
                }
            }
        }
        return true
    }
}

// MARK: - Event Consequences

public struct EventConsequences: Codable, Hashable {
    public var faithChange: Int?
    public var healthChange: Int?
    public var balanceChange: Int?         // Light/Dark change (delta: +N shift to Light, -N to Dark)
    public var tensionChange: Int?
    public var reputationChange: Int?
    public var addCards: [String]?         // Card IDs to add
    public var addCurse: String?           // Curse ID
    public var giveArtifact: String?       // Artifact ID
    public var setFlags: [String: Bool]?   // Set flags
    public var anchorIntegrityChange: Int? // Anchor integrity change
    public var message: String?            // Message to player

    public init(
        faithChange: Int? = nil,
        healthChange: Int? = nil,
        balanceChange: Int? = nil,
        tensionChange: Int? = nil,
        reputationChange: Int? = nil,
        addCards: [String]? = nil,
        addCurse: String? = nil,
        giveArtifact: String? = nil,
        setFlags: [String: Bool]? = nil,
        anchorIntegrityChange: Int? = nil,
        message: String? = nil
    ) {
        self.faithChange = faithChange
        self.healthChange = healthChange
        self.balanceChange = balanceChange
        self.tensionChange = tensionChange
        self.reputationChange = reputationChange
        self.addCards = addCards
        self.addCurse = addCurse
        self.giveArtifact = giveArtifact
        self.setFlags = setFlags
        self.anchorIntegrityChange = anchorIntegrityChange
        self.message = message
    }
}

// MARK: - Game Event

public struct GameEvent: Identifiable, Codable, Hashable {
    public let id: UUID
    public let definitionId: String            // Content Pack ID (e.g., "village_elder_request")
    public let eventType: EventType
    public let title: String
    public let description: String
    public let regionTypes: [RegionType]       // In which region types can occur
    public let regionStates: [RegionState]     // In which states can occur
    public let choices: [EventChoice]
    public let questLinks: [String]            // Quest links
    public var oneTime: Bool                   // Happens only once
    public var completed: Bool                 // Already occurred
    public let monsterCard: Card?              // Monster card for combat events

    // New fields per documentation
    public let instant: Bool                   // true = no time cost (short narrative events)
    public let weight: Int                     // Weight for weighted selection (default 1)
    public let minTension: Int?                // Minimum tension level (0-100)
    public let maxTension: Int?                // Maximum tension level (0-100)
    public let requiredFlags: [String]?        // Flags that must be set
    public let forbiddenFlags: [String]?       // Flags that must NOT be set

    public init(
        id: UUID = UUID(),
        definitionId: String = "",
        eventType: EventType,
        title: String,
        description: String,
        regionTypes: [RegionType] = [],
        regionStates: [RegionState] = [.stable, .borderland, .breach],
        choices: [EventChoice],
        questLinks: [String] = [],
        oneTime: Bool = false,
        completed: Bool = false,
        monsterCard: Card? = nil,
        instant: Bool = false,
        weight: Int = 1,
        minTension: Int? = nil,
        maxTension: Int? = nil,
        requiredFlags: [String]? = nil,
        forbiddenFlags: [String]? = nil
    ) {
        self.id = id
        self.definitionId = definitionId
        self.eventType = eventType
        self.title = title
        self.description = description
        self.regionTypes = regionTypes
        self.regionStates = regionStates
        self.choices = choices
        self.questLinks = questLinks
        self.oneTime = oneTime
        self.completed = completed
        self.monsterCard = monsterCard
        self.instant = instant
        self.weight = max(1, weight)  // Minimum 1
        self.minTension = minTension
        self.maxTension = maxTension
        self.requiredFlags = requiredFlags
        self.forbiddenFlags = forbiddenFlags
    }

    // Check if event can occur in region
    public func canOccur(in region: Region) -> Bool {
        if completed && oneTime {
            return false
        }

        if !regionTypes.isEmpty && !regionTypes.contains(region.type) {
            return false
        }

        if !regionStates.contains(region.state) {
            return false
        }

        return true
    }

    /// Check with tension and world flags
    public func canOccur(in region: Region, worldTension: Int, worldFlags: [String: Bool]) -> Bool {
        // Basic checks
        guard canOccur(in: region) else { return false }

        // Check tension
        if let min = minTension, worldTension < min {
            return false
        }
        if let max = maxTension, worldTension > max {
            return false
        }

        // Check required flags
        if let required = requiredFlags {
            for flag in required {
                if worldFlags[flag] != true {
                    return false
                }
            }
        }

        // Check forbidden flags
        if let forbidden = forbiddenFlags {
            for flag in forbidden {
                if worldFlags[flag] == true {
                    return false
                }
            }
        }

        return true
    }
}

// MARK: - Quest Type

public enum QuestType: String, Codable {
    case main       // Main quest
    case side       // Side quest
}

// MARK: - Quest Objective

public struct QuestObjective: Identifiable, Codable {
    public let id: UUID
    public let description: String
    public var completed: Bool
    public var requiredFlags: [String]?  // Flags required to complete objective

    public init(id: UUID = UUID(), description: String, completed: Bool = false, requiredFlags: [String]? = nil) {
        self.id = id
        self.description = description
        self.completed = completed
        self.requiredFlags = requiredFlags
    }
}

// MARK: - Quest Rewards

public struct QuestRewards: Codable {
    public var faith: Int?
    public var cards: [String]?
    public var artifact: String?
    public var experience: Int?

    public init(faith: Int? = nil, cards: [String]? = nil, artifact: String? = nil, experience: Int? = nil) {
        self.faith = faith
        self.cards = cards
        self.artifact = artifact
        self.experience = experience
    }
}

// MARK: - Quest

/// Quest in game
/// For side quests use theme to define narrative theme
/// See EXPLORATION_CORE_DESIGN.md, section 30 (Side quests as "world mirrors")
public struct Quest: Identifiable, Codable {
    public let id: UUID
    public let definitionId: String            // Content Pack ID (REQUIRED - Audit A1)
    public let title: String
    public let description: String
    public let questType: QuestType
    public var stage: Int                      // Current quest stage (0 = not started)
    public var objectives: [QuestObjective]
    public let rewards: QuestRewards
    public var completed: Bool

    // Narrative System properties (see EXPLORATION_CORE_DESIGN.md, section 30)
    public var theme: SideQuestTheme?          // Quest theme (for side quests): consequence/warning/temptation
    public var mirrorFlag: String?             // Which player choice this quest "mirrors"

    public init(
        id: UUID = UUID(),
        definitionId: String,
        title: String,
        description: String,
        questType: QuestType,
        stage: Int = 0,
        objectives: [QuestObjective],
        rewards: QuestRewards,
        completed: Bool = false,
        theme: SideQuestTheme? = nil,
        mirrorFlag: String? = nil
    ) {
        self.id = id
        self.definitionId = definitionId
        self.title = title
        self.description = description
        self.questType = questType
        self.stage = stage
        self.objectives = objectives
        self.rewards = rewards
        self.completed = completed
        self.theme = theme
        self.mirrorFlag = mirrorFlag
    }

    // Check if all objectives completed
    public var allObjectivesCompleted: Bool {
        return objectives.allSatisfy { $0.completed }
    }

    /// Check if quest "mirrors" given flag
    public func mirrors(flag: String) -> Bool {
        return mirrorFlag == flag
    }
}

// MARK: - Deck Path (for Ending calculation)

/// Dominant deck path of player
/// See EXPLORATION_CORE_DESIGN.md, section 32.5
public enum DeckPath: String, Codable {
    case light      // Light cards dominant (>60%)
    case dark       // Dark cards dominant (>60%)
    case balance    // No clear dominance
}

// MARK: - Ending Profile

/// Campaign ending profile
/// See EXPLORATION_CORE_DESIGN.md, section 32.4
public struct EndingProfile: Identifiable, Codable {
    public let id: String
    public let title: String
    public let conditions: EndingConditions
    public let summary: String
    public let epilogue: EndingEpilogue
    public let unlocksForNextRun: [String]?

    public init(
        id: String,
        title: String,
        conditions: EndingConditions,
        summary: String,
        epilogue: EndingEpilogue,
        unlocksForNextRun: [String]? = nil
    ) {
        self.id = id
        self.title = title
        self.conditions = conditions
        self.summary = summary
        self.epilogue = epilogue
        self.unlocksForNextRun = unlocksForNextRun
    }
}

/// Conditions for obtaining ending
/// See EXPLORATION_CORE_DESIGN.md, section 32
public struct EndingConditions: Codable {
    // WorldTension conditions
    public let minTension: Int?                    // Minimum WorldTension
    public let maxTension: Int?                    // Maximum WorldTension

    // Deck path condition
    public let deckPath: DeckPath?                 // Required deck path

    // Flag conditions
    public let requiredFlags: [String]?            // Required flags
    public let forbiddenFlags: [String]?           // Forbidden flags

    // Anchor conditions
    public let minStableAnchors: Int?              // Minimum stable anchors
    public let maxBreachAnchors: Int?              // Maximum breach regions

    // Balance conditions
    public let minBalance: Int?                    // Minimum lightDarkBalance
    public let maxBalance: Int?                    // Maximum lightDarkBalance

    public init(
        minTension: Int? = nil,
        maxTension: Int? = nil,
        deckPath: DeckPath? = nil,
        requiredFlags: [String]? = nil,
        forbiddenFlags: [String]? = nil,
        minStableAnchors: Int? = nil,
        maxBreachAnchors: Int? = nil,
        minBalance: Int? = nil,
        maxBalance: Int? = nil
    ) {
        self.minTension = minTension
        self.maxTension = maxTension
        self.deckPath = deckPath
        self.requiredFlags = requiredFlags
        self.forbiddenFlags = forbiddenFlags
        self.minStableAnchors = minStableAnchors
        self.maxBreachAnchors = maxBreachAnchors
        self.minBalance = minBalance
        self.maxBalance = maxBalance
    }
}

/// Ending epilogue
public struct EndingEpilogue: Codable {
    public let anchors: String     // Fate of anchors
    public let hero: String        // Fate of hero
    public let world: String       // Fate of world

    public init(anchors: String, hero: String, world: String) {
        self.anchors = anchors
        self.hero = hero
        self.world = world
    }
}

// MARK: - Side Quest Theme

/// Side quest theme (affects tone and consequences)
/// See EXPLORATION_CORE_DESIGN.md, section 30.2
public enum SideQuestTheme: String, Codable {
    case consequence    // Consequence - world already suffered
    case warning        // Warning - can prevent degradation
    case temptation     // Temptation - quick gains for long-term damage
}

// MARK: - Main Quest Step

/// Main quest step
/// See EXPLORATION_CORE_DESIGN.md, section 29.3
public struct MainQuestStep: Identifiable, Codable {
    public let id: String
    public let title: String
    public let goal: String
    public let unlockConditions: QuestConditions
    public let completionConditions: QuestConditions
    public let effects: QuestEffects?

    public init(
        id: String,
        title: String,
        goal: String,
        unlockConditions: QuestConditions,
        completionConditions: QuestConditions,
        effects: QuestEffects? = nil
    ) {
        self.id = id
        self.title = title
        self.goal = goal
        self.unlockConditions = unlockConditions
        self.completionConditions = completionConditions
        self.effects = effects
    }
}

/// Conditions for quest (unlock or completion)
/// See EXPLORATION_CORE_DESIGN.md, section 29
public struct QuestConditions: Codable {
    public var requiredFlags: [String]?    // Flags that must be set
    public var forbiddenFlags: [String]?   // Flags that must NOT be set
    public var minTension: Int?            // Minimum WorldTension
    public var maxTension: Int?            // Maximum WorldTension
    public var minBalance: Int?            // Minimum lightDarkBalance
    public var maxBalance: Int?            // Maximum lightDarkBalance
    public var visitedRegions: [String]?   // Visited regions

    public init(
        requiredFlags: [String]? = nil,
        forbiddenFlags: [String]? = nil,
        minTension: Int? = nil,
        maxTension: Int? = nil,
        minBalance: Int? = nil,
        maxBalance: Int? = nil,
        visitedRegions: [String]? = nil
    ) {
        self.requiredFlags = requiredFlags
        self.forbiddenFlags = forbiddenFlags
        self.minTension = minTension
        self.maxTension = maxTension
        self.minBalance = minBalance
        self.maxBalance = maxBalance
        self.visitedRegions = visitedRegions
    }
}

/// Effects of completing quest step
public struct QuestEffects: Codable {
    public var unlockRegions: [String]?    // Unlock regions
    public var setFlags: [String]?         // Set flags
    public var tensionChange: Int?         // WorldTension change
    public var addCards: [String]?         // Add cards

    public init(
        unlockRegions: [String]? = nil,
        setFlags: [String]? = nil,
        tensionChange: Int? = nil,
        addCards: [String]? = nil
    ) {
        self.unlockRegions = unlockRegions
        self.setFlags = setFlags
        self.tensionChange = tensionChange
        self.addCards = addCards
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Utilities/WorldRNG.swift
// ==========================================

import Foundation

/// Deterministic random number generator for world events
/// Uses a seeded approach for reproducible results
public final class WorldRNG {
    /// Shared singleton instance with default seed.
    public static let shared = WorldRNG()

    private var seed: UInt64
    private var state: UInt64

    /// Initialize with an optional seed value for deterministic output.
    public init(seed: UInt64 = 0) {
        self.seed = seed
        self.state = seed
    }

    /// Reset the generator with a new seed value.
    public func setSeed(_ seed: UInt64) {
        self.seed = seed
        self.state = seed
    }

    /// Returns the original seed used to initialize the generator.
    public func currentSeed() -> UInt64 {
        return seed
    }

    /// Returns the current internal state for save/restore purposes.
    public func currentState() -> UInt64 {
        return state
    }

    /// Restore a previously saved internal state.
    public func restoreState(_ state: UInt64) {
        self.state = state
    }

    /// Generate next random UInt64 using xorshift64
    public func next() -> UInt64 {
        state ^= state << 13
        state ^= state >> 7
        state ^= state << 17
        return state
    }

    /// Generate random Int in range
    public func nextInt(in range: ClosedRange<Int>) -> Int {
        let random = next()
        let rangeSize = UInt64(range.upperBound - range.lowerBound + 1)
        return range.lowerBound + Int(random % rangeSize)
    }

    /// Generate random Double in 0..<1
    public func nextDouble() -> Double {
        return Double(next()) / Double(UInt64.max)
    }

    /// Generate random Bool
    public func nextBool() -> Bool {
        return next() % 2 == 0
    }

    /// Generate random Bool with probability
    public func nextBool(probability: Double) -> Bool {
        return nextDouble() < probability
    }

    /// Shuffle array in place
    public func shuffle<T>(_ array: inout [T]) {
        for i in stride(from: array.count - 1, through: 1, by: -1) {
            let j = nextInt(in: 0...i)
            array.swapAt(i, j)
        }
    }

    /// Return shuffled copy of array
    public func shuffled<T>(_ array: [T]) -> [T] {
        var copy = array
        shuffle(&copy)
        return copy
    }

    /// Pick random element from array
    public func randomElement<T>(from array: [T]) -> T? {
        guard !array.isEmpty else { return nil }
        let index = nextInt(in: 0...(array.count - 1))
        return array[index]
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Quest/QuestTriggerEngine.swift
// ==========================================

import Foundation

// MARK: - Quest Trigger Engine
// Data-driven quest progression system
// Replaces hardcoded checkQuestObjectives* methods in WorldState

/// Engine for evaluating quest triggers and updating quest progress
/// All quest logic is data-driven from QuestDefinition/ObjectiveDefinition
public final class QuestTriggerEngine {

    // MARK: - Dependencies

    private let contentRegistry: ContentRegistry

    // MARK: - Initialization

    public init(contentRegistry: ContentRegistry = .shared) {
        self.contentRegistry = contentRegistry
    }

    // MARK: - Action Processing

    /// Process a game action and return quest progress updates
    /// Called after every action to check if any quest objectives are triggered
    public func processAction(
        _ action: QuestTriggerAction,
        context: QuestTriggerContext
    ) -> [QuestProgressUpdate] {
        var updates: [QuestProgressUpdate] = []

        // Get all active quests
        let activeQuests = context.activeQuests

        for questState in activeQuests {
            guard let questDef = contentRegistry.getQuest(id: questState.definitionId) else {
                continue
            }

            // Check current objective
            guard let currentObjectiveId = questState.currentObjectiveId,
                  let objectiveDef = questDef.objectives.first(where: { $0.id == currentObjectiveId }) else {
                continue
            }

            // Evaluate if objective is completed by this action
            if evaluateCondition(objectiveDef.completionCondition, action: action, context: context) {
                let update = QuestProgressUpdate(
                    questId: questDef.id,
                    objectiveId: currentObjectiveId,
                    type: .objectiveCompleted,
                    nextObjectiveId: objectiveDef.nextObjectiveId,
                    flagsToSet: extractFlagsToSet(from: objectiveDef, questDef: questDef)
                )
                updates.append(update)
            }
        }

        // Check for newly available quests
        let newQuestUpdates = checkForNewQuests(action: action, context: context)
        updates.append(contentsOf: newQuestUpdates)

        return updates
    }

    // MARK: - Condition Evaluation

    /// Evaluate a single completion condition against an action
    public func evaluateCondition(
        _ condition: CompletionCondition,
        action: QuestTriggerAction,
        context: QuestTriggerContext
    ) -> Bool {
        switch condition {
        case .flagSet(let flagName):
            return context.worldFlags[flagName] == true

        case .visitRegion(let regionId):
            if case .visitedRegion(let visitedId) = action {
                return visitedId == regionId
            }
            return false

        case .eventCompleted(let eventId):
            if case .completedEvent(let completedId, _) = action {
                return completedId == eventId
            }
            return false

        case .choiceMade(let eventId, let choiceId):
            if case .completedEvent(let completedEventId, let selectedChoiceId) = action {
                return completedEventId == eventId && selectedChoiceId == choiceId
            }
            return false

        case .resourceThreshold(let resourceId, let minValue):
            let currentValue = context.resources[resourceId] ?? 0
            return currentValue >= minValue

        case .defeatEnemy(let enemyId):
            if case .defeatedEnemy(let defeatedId) = action {
                return defeatedId == enemyId
            }
            return false

        case .collectItem(let itemId):
            if case .collectedItem(let collectedId) = action {
                return collectedId == itemId
            }
            return false

        case .manual:
            if case .manualProgress = action {
                // Manual triggers need explicit objective ID match
                return true
            }
            return false
        }
    }

    // MARK: - New Quest Availability

    /// Check if any new quests become available after this action
    private func checkForNewQuests(
        action: QuestTriggerAction,
        context: QuestTriggerContext
    ) -> [QuestProgressUpdate] {
        var updates: [QuestProgressUpdate] = []

        let allQuests = contentRegistry.getAllQuests()
        let activeQuestIds = Set(context.activeQuests.map { $0.definitionId })
        let completedQuestIds = context.completedQuestIds

        for questDef in allQuests {
            // Skip already active or completed quests
            if activeQuestIds.contains(questDef.id) || completedQuestIds.contains(questDef.id) {
                continue
            }

            // Check availability conditions
            if isQuestAvailable(questDef, context: context) {
                if questDef.autoStart {
                    let update = QuestProgressUpdate(
                        questId: questDef.id,
                        objectiveId: questDef.objectives.first?.id,
                        type: .questStarted,
                        nextObjectiveId: questDef.objectives.first?.id,
                        flagsToSet: []
                    )
                    updates.append(update)
                }
            }
        }

        return updates
    }

    /// Check if a quest's availability conditions are met
    private func isQuestAvailable(_ quest: QuestDefinition, context: QuestTriggerContext) -> Bool {
        return checkAvailability(quest.availability, context: context)
    }

    // MARK: - Flag Extraction

    /// Extract flags that should be set when objective completes
    private func extractFlagsToSet(
        from objective: ObjectiveDefinition,
        questDef: QuestDefinition
    ) -> [String] {
        var flags: [String] = []

        // Check if this is the final objective
        if objective.nextObjectiveId == nil && objective.alternativeNextIds.isEmpty {
            // Quest completion - add completion flags from rewards
            flags.append(contentsOf: questDef.completionRewards.setFlags)
        }

        return flags
    }
}

// MARK: - Quest Trigger Action

/// Actions that can trigger quest progression
public enum QuestTriggerAction {
    /// Player visited a region
    case visitedRegion(regionId: String)

    /// Player completed an event with a specific choice
    case completedEvent(eventId: String, choiceId: String)

    /// Player defeated an enemy
    case defeatedEnemy(enemyId: String)

    /// Player collected an item
    case collectedItem(itemId: String)

    /// Flag was set (can trigger flag-based conditions)
    case flagSet(flagName: String)

    /// Manual progress trigger (for special cases)
    case manualProgress(objectiveId: String)

    /// Resource changed (can trigger threshold conditions)
    case resourceChanged(resourceId: String, newValue: Int)
}

// MARK: - Quest Trigger Context

/// Context needed for evaluating quest triggers
public struct QuestTriggerContext {
    /// Currently active quests with their state
    public let activeQuests: [QuestState]

    /// IDs of completed quests
    public let completedQuestIds: Set<String>

    /// Current world flags
    public let worldFlags: [String: Bool]

    /// Current resources (health, faith, etc.)
    public let resources: [String: Int]

    /// Current game day
    public let currentDay: Int

    /// Current region ID
    public let currentRegionId: String
}

/// Minimal quest state for trigger evaluation
public struct QuestState {
    public let definitionId: String
    public let currentObjectiveId: String?
    public let completedObjectiveIds: Set<String>
}

// MARK: - Quest Progress Update

/// Result of quest trigger evaluation
public struct QuestProgressUpdate {
    /// Quest that was updated
    public let questId: String

    /// Objective that was completed (if any)
    public let objectiveId: String?

    /// Type of update
    public let type: QuestUpdateType

    /// Next objective to activate (if any)
    public let nextObjectiveId: String?

    /// Flags to set as a result of this update
    public let flagsToSet: [String]
}

/// Type of quest update
public enum QuestUpdateType {
    case questStarted
    case objectiveCompleted
    case questCompleted
    case questFailed
}

// MARK: - Availability Check

extension QuestTriggerEngine {
    /// Check if availability conditions are met
    public func checkAvailability(_ availability: Availability, context: QuestTriggerContext) -> Bool {
        // Check required flags
        for flag in availability.requiredFlags {
            if context.worldFlags[flag] != true {
                return false
            }
        }

        // Check forbidden flags
        for flag in availability.forbiddenFlags {
            if context.worldFlags[flag] == true {
                return false
            }
        }

        // Check pressure/tension range
        if let minPressure = availability.minPressure {
            let tension = context.resources["tension"] ?? 0
            if tension < minPressure {
                return false
            }
        }
        if let maxPressure = availability.maxPressure {
            let tension = context.resources["tension"] ?? 0
            if tension > maxPressure {
                return false
            }
        }

        return true
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Events/EventPipeline.swift
// ==========================================

import Foundation

// MARK: - Event Pipeline
// Handles the complete flow: Selection â†’ Resolution â†’ Consequences

/// Main event processing pipeline
public final class EventPipeline {
    // MARK: - Dependencies

    private let selector: EventSelector
    private let resolver: EventResolver

    // MARK: - Initialization

    public init(
        selector: EventSelector = EventSelector(),
        resolver: EventResolver = EventResolver()
    ) {
        self.selector = selector
        self.resolver = resolver
    }

    // MARK: - Pipeline Methods

    /// Process a trigger and return available events
    public func getAvailableEvents(
        for context: EventContext,
        from events: [GameEvent]
    ) -> [GameEvent] {
        return selector.selectAvailableEvents(from: events, context: context)
    }

    /// Select a single event based on weights
    public func selectEvent(
        from events: [GameEvent],
        context: EventContext
    ) -> GameEvent? {
        let available = selector.selectAvailableEvents(from: events, context: context)
        return selector.weightedSelect(from: available)
    }

    /// Resolve an event choice and return state changes
    public func resolveChoice(
        event: GameEvent,
        choiceIndex: Int,
        context: EventResolutionContext
    ) -> EventResolutionResult {
        return resolver.resolve(event: event, choiceIndex: choiceIndex, context: context)
    }

    /// Check if a choice is available
    public func canChoose(
        event: GameEvent,
        choiceIndex: Int,
        context: EventContext
    ) -> (available: Bool, reason: String?) {
        guard choiceIndex < event.choices.count else {
            return (false, "Invalid choice index")
        }

        let choice = event.choices[choiceIndex]

        // Check requirements if present
        guard let requirements = choice.requirements else {
            return (true, nil)  // No requirements = always available
        }

        // Check minimum faith
        if let minFaith = requirements.minimumFaith {
            let currentFaith = context.resources["faith"] ?? 0
            if currentFaith < minFaith {
                return (false, "ÐÐµÐ´Ð¾ÑÑ‚Ð°Ñ‚Ð¾Ñ‡Ð½Ð¾ Ð²ÐµÑ€Ñ‹ (Ð½ÑƒÐ¶Ð½Ð¾ \(minFaith))")
            }
        }

        // Check minimum health
        if let minHealth = requirements.minimumHealth {
            let currentHealth = context.resources["health"] ?? 0
            if currentHealth < minHealth {
                return (false, "ÐÐµÐ´Ð¾ÑÑ‚Ð°Ñ‚Ð¾Ñ‡Ð½Ð¾ Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÑ (Ð½ÑƒÐ¶Ð½Ð¾ \(minHealth))")
            }
        }

        // Check required flags
        if let requiredFlags = requirements.requiredFlags {
            for flag in requiredFlags {
                if context.flags[flag] != true {
                    return (false, "Ð¢Ñ€ÐµÐ±ÑƒÐµÑ‚ÑÑ Ñ„Ð»Ð°Ð³: \(flag)")
                }
            }
        }

        return (true, nil)
    }
}

// MARK: - Event Selector

/// Handles event filtering and weighted selection
public final class EventSelector {
    public init() {}

    // MARK: - Selection

    /// Filter events by availability criteria
    public func selectAvailableEvents(
        from events: [GameEvent],
        context: EventContext
    ) -> [GameEvent] {
        return events.filter { event in
            isEventAvailable(event, context: context)
        }
    }

    /// Check if single event is available based on GameEvent's actual properties
    public func isEventAvailable(_ event: GameEvent, context: EventContext) -> Bool {
        // Check if already completed (for oneTime events)
        if event.oneTime && event.completed {
            return false
        }

        // Also check against context's completed set (uses stable definitionId, not UUID)
        if event.oneTime && context.completedEvents.contains(event.definitionId) {
            return false
        }

        // Check region type requirements (empty = any region)
        if !event.regionTypes.isEmpty {
            guard let regionType = RegionType(rawValue: context.currentLocation) else {
                return false
            }
            if !event.regionTypes.contains(regionType) {
                return false
            }
        }

        // Check region state requirements (empty = any state)
        if !event.regionStates.isEmpty {
            guard let regionState = RegionState(rawValue: context.locationState) else {
                return false
            }
            if !event.regionStates.contains(regionState) {
                return false
            }
        }

        // Check event's required flags against context flags
        if let eventRequiredFlags = event.requiredFlags {
            for flag in eventRequiredFlags where context.flags[flag] != true {
                return false
            }
        }

        // Check event's forbidden flags
        if let forbiddenFlags = event.forbiddenFlags {
            for flag in forbiddenFlags where context.flags[flag] == true {
                return false
            }
        }

        return true
    }

    /// Select event using weighted random selection
    public func weightedSelect(from events: [GameEvent]) -> GameEvent? {
        guard !events.isEmpty else { return nil }

        let totalWeight = events.reduce(0) { $0 + $1.weight }

        guard totalWeight > 0 else {
            // If all weights are 0, select randomly
            let index = WorldRNG.shared.nextInt(in: 0...(events.count - 1))
            return events[index]
        }

        let roll = WorldRNG.shared.nextInt(in: 0...(totalWeight - 1))
        var cumulative = 0

        for event in events {
            cumulative += event.weight
            if roll < cumulative {
                return event
            }
        }

        // Fallback (shouldn't reach here)
        return events.last
    }
}

// MARK: - Event Resolver

/// Handles event resolution and consequence calculation
public final class EventResolver {
    public init() {}

    // MARK: - Resolution

    /// Resolve an event choice
    public func resolve(
        event: GameEvent,
        choiceIndex: Int,
        context: EventResolutionContext
    ) -> EventResolutionResult {
        guard choiceIndex < event.choices.count else {
            return EventResolutionResult(
                success: false,
                error: "Invalid choice index",
                stateChanges: [],
                triggeredCombat: nil,
                triggeredMiniGame: nil,
                narrativeText: nil
            )
        }

        let choice = event.choices[choiceIndex]
        var stateChanges: [StateChange] = []

        // Apply consequences
        let consequences = choice.consequences

        // Health changes (optional Int?)
        if let healthDelta = consequences.healthChange, healthDelta != 0 {
            let newHealth = max(0, context.currentHealth + healthDelta)
            stateChanges.append(.healthChanged(
                delta: healthDelta,
                newValue: newHealth
            ))
        }

        // Faith changes (optional Int?)
        if let faithDelta = consequences.faithChange, faithDelta != 0 {
            let newFaith = max(0, context.currentFaith + faithDelta)
            stateChanges.append(.faithChanged(
                delta: faithDelta,
                newValue: newFaith
            ))
        }

        // Balance changes (optional Int?)
        if let balanceDelta = consequences.balanceChange, balanceDelta != 0 {
            let newBalance = max(0, min(100, context.currentBalance + balanceDelta))
            stateChanges.append(.balanceChanged(
                delta: balanceDelta,
                newValue: newBalance
            ))
        }

        // Tension changes (optional Int?)
        if let tensionDelta = consequences.tensionChange, tensionDelta != 0 {
            let newTension = max(0, min(100, context.currentTension + tensionDelta))
            stateChanges.append(.tensionChanged(
                delta: tensionDelta,
                newValue: newTension
            ))
        }

        // Set flags (optional dictionary)
        if let flagsToSet = consequences.setFlags {
            for (flag, value) in flagsToSet {
                stateChanges.append(.flagSet(key: flag, value: value))
            }
        }

        // Check for triggered combat (monster card in event)
        var triggeredCombat: UUID? = nil
        if event.monsterCard != nil {
            // Combat events have monsterCard, use event ID as combat trigger
            triggeredCombat = event.id
        }

        // Check for triggered mini-game (not directly in EventConsequences,
        // would be triggered through specific event types or flags)
        let triggeredMiniGame: UUID? = nil

        // Mark event as completed if oneTime
        if event.oneTime {
            stateChanges.append(.eventCompleted(eventId: event.id))
        }

        return EventResolutionResult(
            success: true,
            error: nil,
            stateChanges: stateChanges,
            triggeredCombat: triggeredCombat,
            triggeredMiniGame: triggeredMiniGame,
            narrativeText: consequences.message
        )
    }
}

// MARK: - Supporting Types
// Note: EventContext is defined in EngineProtocols.swift

/// Context for event resolution
public struct EventResolutionContext {
    public let currentHealth: Int
    public let currentFaith: Int
    public let currentBalance: Int
    public let currentTension: Int
    public let currentFlags: [String: Bool]

    public init(
        currentHealth: Int,
        currentFaith: Int,
        currentBalance: Int,
        currentTension: Int,
        currentFlags: [String: Bool]
    ) {
        self.currentHealth = currentHealth
        self.currentFaith = currentFaith
        self.currentBalance = currentBalance
        self.currentTension = currentTension
        self.currentFlags = currentFlags
    }
}

/// Result of event resolution
public struct EventResolutionResult {
    public let success: Bool
    public let error: String?
    public let stateChanges: [StateChange]
    public let triggeredCombat: UUID?
    public let triggeredMiniGame: UUID?
    public let narrativeText: String?
}

/// Event filter criteria for selection (different from EventRequirements in ExplorationModels)
public struct EventFilterCriteria {
    public var location: String?
    public var locationState: String?
    public var pressureRange: ClosedRange<Int>?
    public var requiredFlags: [String] = []
    public var forbiddenFlags: [String] = []
    public var minResources: [String: Int] = [:]

    public static let none = EventFilterCriteria()
}

// MARK: - GameEvent Extension

extension GameEvent {
    /// Event filter criteria for engine filtering
    public var filterCriteria: EventFilterCriteria {
        // Build filter criteria from event data
        // Note: Full implementation would extract criteria from regionTypes/regionStates
        let criteria = EventFilterCriteria()
        return criteria
    }
}

// Note: EventConsequences doesn't have triggeredEncounter or triggeredMiniGame
// Combat is triggered through GameEvent.monsterCard != nil
// Mini-games are triggered through specific event types or game logic


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Events/MiniGameDispatcher.swift
// ==========================================

import Foundation

// MARK: - MiniGame Dispatcher
// Routes mini-game challenges to appropriate resolvers
// Returns result as StateChange diff (no direct state mutation)

/// Dispatches mini-game challenges to resolvers
public final class MiniGameDispatcher {
    // MARK: - Resolvers

    private let combatResolver: CombatMiniGameResolver
    private let puzzleResolver: PuzzleMiniGameResolver
    private let skillCheckResolver: SkillCheckResolver

    // MARK: - Initialization

    public init() {
        self.combatResolver = CombatMiniGameResolver()
        self.puzzleResolver = PuzzleMiniGameResolver()
        self.skillCheckResolver = SkillCheckResolver()
    }

    // MARK: - Dispatch

    /// Dispatch a mini-game challenge and return result
    public func dispatch(
        challenge: MiniGameChallenge,
        context: MiniGameContext
    ) -> MiniGameDispatchResult {

        switch challenge.type {
        case .combat:
            return combatResolver.resolve(challenge: challenge, context: context)

        case .puzzle:
            return puzzleResolver.resolve(challenge: challenge, context: context)

        case .skillCheck:
            return skillCheckResolver.resolve(challenge: challenge, context: context)

        case .cardGame:
            // Card-based mini-game (future)
            return MiniGameDispatchResult.notImplemented(type: "cardGame")

        case .custom(let type):
            // Custom mini-game type
            return MiniGameDispatchResult.notImplemented(type: type)
        }
    }

    /// Check if challenge can be started
    public func canStartChallenge(
        _ challenge: MiniGameChallenge,
        context: MiniGameContext
    ) -> (canStart: Bool, reason: String?) {

        // Check health minimum
        if context.playerHealth <= 0 {
            return (false, "Player health too low")
        }

        // Check type-specific requirements
        switch challenge.type {
        case .combat:
            // Combat requires health > 0
            return (true, nil)

        case .skillCheck:
            // Skill checks may require specific resources
            if let requiredResource = challenge.requirements["resource"],
               let required = challenge.requirements["amount"] as? Int,
               (context.playerResources[requiredResource as? String ?? ""] ?? 0) < required {
                return (false, "Insufficient \(requiredResource)")
            }
            return (true, nil)

        default:
            return (true, nil)
        }
    }
}

// MARK: - Mini-Game Challenge

/// Definition of a mini-game challenge
public struct MiniGameChallenge {
    public let id: UUID
    public let type: MiniGameType
    public let difficulty: Int
    public let requirements: [String: Any]
    public let rewards: MiniGameRewards
    public let penalties: MiniGamePenalties

    public init(
        id: UUID = UUID(),
        type: MiniGameType,
        difficulty: Int = 1,
        requirements: [String: Any] = [:],
        rewards: MiniGameRewards = MiniGameRewards(),
        penalties: MiniGamePenalties = MiniGamePenalties()
    ) {
        self.id = id
        self.type = type
        self.difficulty = difficulty
        self.requirements = requirements
        self.rewards = rewards
        self.penalties = penalties
    }
}

/// Types of mini-games
public enum MiniGameType: Equatable {
    case combat
    case puzzle
    case skillCheck
    case cardGame
    case custom(String)
}

/// Rewards for completing mini-game
public struct MiniGameRewards {
    public var healthGain: Int = 0
    public var faithGain: Int = 0
    public var tensionReduction: Int = 0
    public var flagsToSet: [String] = []
    public var cardsToGain: [UUID] = []

    public init(
        healthGain: Int = 0,
        faithGain: Int = 0,
        tensionReduction: Int = 0,
        flagsToSet: [String] = [],
        cardsToGain: [UUID] = []
    ) {
        self.healthGain = healthGain
        self.faithGain = faithGain
        self.tensionReduction = tensionReduction
        self.flagsToSet = flagsToSet
        self.cardsToGain = cardsToGain
    }
}

/// Penalties for failing mini-game
public struct MiniGamePenalties {
    public var healthLoss: Int = 0
    public var faithLoss: Int = 0
    public var tensionIncrease: Int = 0
    public var balanceShift: Int = 0

    public init(
        healthLoss: Int = 0,
        faithLoss: Int = 0,
        tensionIncrease: Int = 0,
        balanceShift: Int = 0
    ) {
        self.healthLoss = healthLoss
        self.faithLoss = faithLoss
        self.tensionIncrease = tensionIncrease
        self.balanceShift = balanceShift
    }
}

// MARK: - Mini-Game Context

/// Context for mini-game resolution
public struct MiniGameContext {
    public let playerHealth: Int
    public let playerMaxHealth: Int
    public let playerStrength: Int
    public let playerFaith: Int
    public let playerBalance: Int
    public let playerResources: [String: Int]
    public let worldTension: Int
    public let currentFlags: [String: Bool]

    /// Build from engine properties directly (Engine-First Architecture)
    /// - Parameters:
    ///   - engine: The TwilightGameEngine instance
    /// - Returns: MiniGameContext with values from engine
    public static func from(engine: TwilightGameEngine) -> MiniGameContext {
        MiniGameContext(
            playerHealth: engine.playerHealth,
            playerMaxHealth: engine.playerMaxHealth,
            playerStrength: engine.playerStrength,
            playerFaith: engine.playerFaith,
            playerBalance: engine.playerBalance,
            playerResources: ["faith": engine.playerFaith, "health": engine.playerHealth],
            worldTension: engine.worldTension,
            currentFlags: engine.publishedWorldFlags
        )
    }

    /// Direct initializer for testing or manual construction
    public init(
        playerHealth: Int,
        playerMaxHealth: Int,
        playerStrength: Int,
        playerFaith: Int,
        playerBalance: Int,
        playerResources: [String: Int],
        worldTension: Int,
        currentFlags: [String: Bool]
    ) {
        self.playerHealth = playerHealth
        self.playerMaxHealth = playerMaxHealth
        self.playerStrength = playerStrength
        self.playerFaith = playerFaith
        self.playerBalance = playerBalance
        self.playerResources = playerResources
        self.worldTension = worldTension
        self.currentFlags = currentFlags
    }
}

// MARK: - Mini-Game Dispatch Result

/// Result of mini-game dispatch
public struct MiniGameDispatchResult {
    public let success: Bool
    public let completed: Bool
    public let stateChanges: [StateChange]
    public let narrativeText: String?
    public let error: String?

    public static func victory(changes: [StateChange], narrative: String? = nil) -> MiniGameDispatchResult {
        MiniGameDispatchResult(
            success: true,
            completed: true,
            stateChanges: changes,
            narrativeText: narrative,
            error: nil
        )
    }

    public static func defeat(changes: [StateChange], narrative: String? = nil) -> MiniGameDispatchResult {
        MiniGameDispatchResult(
            success: true,
            completed: true,
            stateChanges: changes,
            narrativeText: narrative,
            error: nil
        )
    }

    public static func inProgress(changes: [StateChange]) -> MiniGameDispatchResult {
        MiniGameDispatchResult(
            success: true,
            completed: false,
            stateChanges: changes,
            narrativeText: nil,
            error: nil
        )
    }

    public static func notImplemented(type: String) -> MiniGameDispatchResult {
        MiniGameDispatchResult(
            success: false,
            completed: false,
            stateChanges: [],
            narrativeText: nil,
            error: "Mini-game type '\(type)' not implemented"
        )
    }

    public static func failure(_ error: String) -> MiniGameDispatchResult {
        MiniGameDispatchResult(
            success: false,
            completed: false,
            stateChanges: [],
            narrativeText: nil,
            error: error
        )
    }
}

// MARK: - Combat Mini-Game Resolver

/// Resolves combat mini-games
public final class CombatMiniGameResolver {
    public func resolve(
        challenge: MiniGameChallenge,
        context: MiniGameContext
    ) -> MiniGameDispatchResult {

        var changes: [StateChange] = []

        // Simple combat resolution using WorldRNG
        let playerRoll = WorldRNG.shared.nextInt(in: 1...6) + context.playerStrength
        let enemyRoll = WorldRNG.shared.nextInt(in: 1...6) + challenge.difficulty

        if playerRoll >= enemyRoll {
            // Victory
            // Apply rewards
            if challenge.rewards.healthGain > 0 {
                let newHealth = min(context.playerMaxHealth, context.playerHealth + challenge.rewards.healthGain)
                changes.append(.healthChanged(delta: challenge.rewards.healthGain, newValue: newHealth))
            }

            if challenge.rewards.faithGain > 0 {
                let newFaith = context.playerFaith + challenge.rewards.faithGain
                changes.append(.faithChanged(delta: challenge.rewards.faithGain, newValue: newFaith))
            }

            for flag in challenge.rewards.flagsToSet {
                changes.append(.flagSet(key: flag, value: true))
            }

            return .victory(changes: changes, narrative: "ÐŸÐ¾Ð±ÐµÐ´Ð° Ð² Ð±Ð¾ÑŽ!")
        } else {
            // Defeat
            // Apply penalties
            if challenge.penalties.healthLoss > 0 {
                let newHealth = max(0, context.playerHealth - challenge.penalties.healthLoss)
                changes.append(.healthChanged(delta: -challenge.penalties.healthLoss, newValue: newHealth))
            }

            if challenge.penalties.balanceShift != 0 {
                let newBalance = max(0, min(100, context.playerBalance + challenge.penalties.balanceShift))
                changes.append(.balanceChanged(delta: challenge.penalties.balanceShift, newValue: newBalance))
            }

            return .defeat(changes: changes, narrative: "ÐŸÐ¾Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ Ð² Ð±Ð¾ÑŽ...")
        }
    }
}

// MARK: - Puzzle Mini-Game Resolver

/// Resolves puzzle mini-games
public final class PuzzleMiniGameResolver {
    public func resolve(
        challenge: MiniGameChallenge,
        context: MiniGameContext
    ) -> MiniGameDispatchResult {

        var changes: [StateChange] = []

        // Simple puzzle resolution based on faith/wisdom
        let successChance = min(90, 50 + context.playerFaith * 5)
        let roll = WorldRNG.shared.nextInt(in: 1...100)

        if roll <= successChance {
            // Success
            if challenge.rewards.faithGain > 0 {
                let newFaith = context.playerFaith + challenge.rewards.faithGain
                changes.append(.faithChanged(delta: challenge.rewards.faithGain, newValue: newFaith))
            }

            for flag in challenge.rewards.flagsToSet {
                changes.append(.flagSet(key: flag, value: true))
            }

            return .victory(changes: changes, narrative: "Ð—Ð°Ð³Ð°Ð´ÐºÐ° Ñ€Ð°Ð·Ð³Ð°Ð´Ð°Ð½Ð°!")
        } else {
            // Failure
            if challenge.penalties.tensionIncrease > 0 {
                let newTension = min(100, context.worldTension + challenge.penalties.tensionIncrease)
                changes.append(.tensionChanged(delta: challenge.penalties.tensionIncrease, newValue: newTension))
            }

            return .defeat(changes: changes, narrative: "Ð—Ð°Ð³Ð°Ð´ÐºÐ° Ð¾ÑÑ‚Ð°Ð»Ð°ÑÑŒ Ð½ÐµÑ€Ð°Ð·Ð³Ð°Ð´Ð°Ð½Ð½Ð¾Ð¹...")
        }
    }
}

// MARK: - Skill Check Resolver

/// Resolves skill check mini-games
public final class SkillCheckResolver {
    public func resolve(
        challenge: MiniGameChallenge,
        context: MiniGameContext
    ) -> MiniGameDispatchResult {

        var changes: [StateChange] = []

        // Skill check based on relevant stat
        let targetNumber = challenge.difficulty * 3
        let roll = WorldRNG.shared.nextInt(in: 1...20) + context.playerStrength

        if roll >= targetNumber {
            // Success
            for flag in challenge.rewards.flagsToSet {
                changes.append(.flagSet(key: flag, value: true))
            }

            return .victory(changes: changes, narrative: "ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð½Ð°Ð²Ñ‹ÐºÐ° Ð¿Ñ€Ð¾Ð¹Ð´ÐµÐ½Ð°!")
        } else {
            // Failure
            return .defeat(changes: changes, narrative: "ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð½Ð°Ð²Ñ‹ÐºÐ° Ð¿Ñ€Ð¾Ð²Ð°Ð»ÐµÐ½Ð°...")
        }
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Modules/CombatModule.swift
// ==========================================

import Foundation

// MARK: - Combat Module
// Engine integration for combat system
// Wraps CombatCalculator and provides state change diffs

/// Combat module for engine integration
public final class CombatModule {
    // MARK: - State

    private(set) var isInCombat: Bool = false
    private(set) var currentEncounter: CombatEncounter?
    private(set) var combatLog: [CombatLogEntry] = []
    private(set) var turnNumber: Int = 0
    private(set) var playerActionsRemaining: Int = 3

    // MARK: - Combat Entry

    /// Start combat with an encounter
    public func startCombat(encounter: CombatEncounter) -> [StateChange] {
        isInCombat = true
        currentEncounter = encounter
        combatLog = []
        turnNumber = 1
        playerActionsRemaining = 3

        return [
            .custom(key: "combat_started", description: "Combat started with \(encounter.name)")
        ]
    }

    /// End combat
    public func endCombat(victory: Bool) -> [StateChange] {
        let changes: [StateChange] = [
            .combatEnded(victory: victory)
        ]

        isInCombat = false
        currentEncounter = nil
        combatLog = []
        turnNumber = 0
        playerActionsRemaining = 0

        return changes
    }

    // MARK: - Combat Actions

    /// Execute player attack using CombatPlayerContext (Engine-First Architecture)
    public func executeAttack(
        context: CombatPlayerContext,
        bonusDice: Int = 0,
        bonusDamage: Int = 0,
        isFirstAttack: Bool = false
    ) -> CombatActionResult {

        guard let encounter = currentEncounter else {
            return CombatActionResult.failure("No active encounter")
        }

        guard playerActionsRemaining > 0 else {
            return CombatActionResult.failure("No actions remaining")
        }

        playerActionsRemaining -= 1

        // Use CombatCalculator with context
        let result = CombatCalculator.calculatePlayerAttack(
            context: context,
            monsterDefense: encounter.defense,
            monsterCurrentHP: encounter.currentHP,
            monsterMaxHP: encounter.maxHP,
            bonusDice: bonusDice,
            bonusDamage: bonusDamage,
            isFirstAttack: isFirstAttack
        )

        var stateChanges: [StateChange] = []
        var logEntry = CombatLogEntry(
            turn: turnNumber,
            actor: .player,
            action: "Attack",
            result: result.isHit ? "Hit" : "Miss",
            details: result.logDescription
        )

        if result.isHit, let damage = result.damageCalculation {
            // Apply damage to encounter
            currentEncounter?.currentHP -= damage.total
            stateChanges.append(.enemyDamaged(
                enemyId: encounter.id,
                damage: damage.total,
                newHealth: currentEncounter?.currentHP ?? 0
            ))

            // Check if defeated
            if currentEncounter?.currentHP ?? 0 <= 0 {
                stateChanges.append(.enemyDefeated(enemyId: encounter.id))
                logEntry.result = "Defeat!"
            }
        }

        combatLog.append(logEntry)

        return CombatActionResult.success(
            stateChanges: stateChanges,
            combatResult: result,
            encounterDefeated: currentEncounter?.currentHP ?? 0 <= 0
        )
    }

    /// Execute player card play using CombatPlayerContext (Engine-First Architecture)
    public func playCard(
        cardId: UUID,
        context: CombatPlayerContext,
        effects: [CardEffect]
    ) -> CombatActionResult {

        guard currentEncounter != nil else {
            return CombatActionResult.failure("No active encounter")
        }

        guard playerActionsRemaining > 0 else {
            return CombatActionResult.failure("No actions remaining")
        }

        playerActionsRemaining -= 1

        var stateChanges: [StateChange] = []

        // Apply card effects
        for effect in effects {
            switch effect {
            case .damage(let amount, _):
                currentEncounter?.currentHP -= amount
                if let encounter = currentEncounter {
                    stateChanges.append(.enemyDamaged(
                        enemyId: encounter.id,
                        damage: amount,
                        newHealth: encounter.currentHP
                    ))
                }

            case .heal(let amount):
                let newHealth = min(context.maxHealth, context.health + amount)
                stateChanges.append(.healthChanged(delta: amount, newValue: newHealth))

            case .drawCards(let count):
                stateChanges.append(.custom(key: "draw_cards", description: "Draw \(count) cards"))

            case .gainFaith(let amount):
                stateChanges.append(.faithChanged(delta: amount, newValue: context.faith + amount))

            case .bonusDice(let count):
                stateChanges.append(.custom(key: "bonus_dice", description: "Gained \(count) bonus dice"))

            case .bonusDamage(let amount):
                stateChanges.append(.custom(key: "bonus_damage", description: "Gained \(amount) bonus damage"))

            case .balanceShift(let amount):
                let newBalance = max(0, min(100, context.balance + amount))
                stateChanges.append(.balanceChanged(delta: amount, newValue: newBalance))
            }
        }

        // Check if encounter defeated
        if currentEncounter?.currentHP ?? 0 <= 0 {
            if let encounter = currentEncounter {
                stateChanges.append(.enemyDefeated(enemyId: encounter.id))
            }
        }

        let logEntry = CombatLogEntry(
            turn: turnNumber,
            actor: .player,
            action: "Card",
            result: "Applied",
            details: "Card effects applied"
        )
        combatLog.append(logEntry)

        return CombatActionResult.success(
            stateChanges: stateChanges,
            combatResult: nil,
            encounterDefeated: currentEncounter?.currentHP ?? 0 <= 0
        )
    }

    /// End player turn using CombatPlayerContext (Engine-First Architecture)
    public func endPlayerTurn(context: CombatPlayerContext) -> CombatActionResult {
        guard let encounter = currentEncounter else {
            return CombatActionResult.failure("No active encounter")
        }

        var stateChanges: [StateChange] = []

        // Enemy attack
        let enemyAttack = calculateEnemyAttack(encounter: encounter, context: context)
        stateChanges.append(contentsOf: enemyAttack.stateChanges)

        // Check if player defeated
        let playerDefeated = context.health + (enemyAttack.healthChange) <= 0

        // Start new turn
        turnNumber += 1
        playerActionsRemaining = 3

        // Apply exhaustion curse if present
        if context.hasCurse(.exhaustion) {
            playerActionsRemaining -= 1
            stateChanges.append(.custom(key: "exhaustion", description: "Exhaustion: -1 action"))
        }

        let logEntry = CombatLogEntry(
            turn: turnNumber - 1,
            actor: .enemy,
            action: "Attack",
            result: enemyAttack.hit ? "Hit" : "Miss",
            details: enemyAttack.description
        )
        combatLog.append(logEntry)

        return CombatActionResult.success(
            stateChanges: stateChanges,
            combatResult: nil,
            encounterDefeated: false,
            playerDefeated: playerDefeated
        )
    }

    // MARK: - Enemy AI

    private func calculateEnemyAttack(
        encounter: CombatEncounter,
        context: CombatPlayerContext
    ) -> (stateChanges: [StateChange], hit: Bool, healthChange: Int, description: String) {

        var stateChanges: [StateChange] = []

        // Enemy attack roll
        let attackRoll = WorldRNG.shared.nextInt(in: 1...6) + encounter.strength
        let playerDefense = 5 + (context.strength / 2)

        let hit = attackRoll >= playerDefense
        var healthChange = 0

        if hit {
            var damage = max(1, encounter.strength - 2)

            // Hero ability may reduce damage (e.g., Priest vs dark sources)
            let heroReduction = context.getHeroDamageReduction(fromDarkSource: true)
            damage = max(1, damage - heroReduction)

            healthChange = -damage
            stateChanges.append(.healthChanged(delta: -damage, newValue: context.health - damage))
        }

        let description = hit
            ? "Enemy hit for \(-healthChange) damage"
            : "Enemy missed"

        return (stateChanges, hit, healthChange, description)
    }
}

// MARK: - Combat Encounter

/// Combat encounter state
public struct CombatEncounter {
    public let id: UUID
    public let name: String
    public let maxHP: Int
    public var currentHP: Int
    public let strength: Int
    public let defense: Int
    public let isBoss: Bool

    public init(
        id: UUID = UUID(),
        name: String,
        maxHP: Int,
        strength: Int,
        defense: Int,
        isBoss: Bool = false
    ) {
        self.id = id
        self.name = name
        self.maxHP = maxHP
        self.currentHP = maxHP
        self.strength = strength
        self.defense = defense
        self.isBoss = isBoss
    }

    /// Create from Card (monster)
    /// Maps Card stats: health -> maxHP, power -> strength, defense -> defense
    /// Boss detection: legendary rarity or "boss" trait
    public static func from(card: Card) -> CombatEncounter {
        // Determine if card is a boss (legendary rarity or has boss trait)
        let isBoss = card.rarity == .legendary || card.traits.contains("boss")

        return CombatEncounter(
            id: card.id,
            name: card.name,
            maxHP: card.health ?? 10,
            strength: card.power ?? 3,
            defense: card.defense ?? 5,
            isBoss: isBoss
        )
    }
}

// MARK: - Combat Action Result

/// Result of combat action
public struct CombatActionResult {
    public let success: Bool
    public let error: String?
    public let stateChanges: [StateChange]
    public let combatResult: CombatResult?
    public let encounterDefeated: Bool
    public let playerDefeated: Bool

    public static func success(
        stateChanges: [StateChange],
        combatResult: CombatResult?,
        encounterDefeated: Bool,
        playerDefeated: Bool = false
    ) -> CombatActionResult {
        CombatActionResult(
            success: true,
            error: nil,
            stateChanges: stateChanges,
            combatResult: combatResult,
            encounterDefeated: encounterDefeated,
            playerDefeated: playerDefeated
        )
    }

    public static func failure(_ error: String) -> CombatActionResult {
        CombatActionResult(
            success: false,
            error: error,
            stateChanges: [],
            combatResult: nil,
            encounterDefeated: false,
            playerDefeated: false
        )
    }
}

// MARK: - Combat Log Entry

/// Entry in combat log
public struct CombatLogEntry {
    public let turn: Int
    public let actor: CombatActor
    public var action: String
    public var result: String
    public let details: String
}

public enum CombatActor {
    case player
    case enemy
}

// MARK: - Card Effect

/// Effects that cards can have in combat
public enum CardEffect {
    case damage(amount: Int, type: CombatDamageKind)
    case heal(amount: Int)
    case drawCards(count: Int)
    case gainFaith(amount: Int)
    case bonusDice(count: Int)
    case bonusDamage(amount: Int)
    case balanceShift(amount: Int)
}

/// Simplified damage categories for combat resolution
/// Different from DamageType in CardType.swift (detailed card damage types)
public enum CombatDamageKind {
    case physical
    case magical
    case light
    case dark
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Data/Providers/CodeContentProvider.swift
// ==========================================

import Foundation

// MARK: - Code Content Provider
// Reference: Docs/MIGRATION_PLAN.md, Feature A3
// Adapter for existing TwilightMarchesConfig content

/// Content provider that loads definitions from Swift code.
/// This is an adapter for the existing TwilightMarchesConfig.swift content.
/// Will be replaced/augmented by JSONContentProvider in Phase 5.
public class CodeContentProvider: ContentProvider {
    // MARK: - Cached Definitions

    private var regions: [String: RegionDefinition] = [:]
    private var anchors: [String: AnchorDefinition] = [:]
    private var events: [String: EventDefinition] = [:]
    private var quests: [String: QuestDefinition] = [:]
    private var miniGameChallenges: [String: MiniGameChallengeDefinition] = [:]

    // MARK: - Event Pool Index

    private var eventsByPool: [String: [EventDefinition]] = [:]
    private var eventsByRegion: [String: [EventDefinition]] = [:]

    // MARK: - Initialization

    public init() {
        loadContent()
    }

    /// Load all content from code definitions
    private func loadContent() {
        loadRegions()
        loadAnchors()
        loadEvents()
        loadQuests()
        loadMiniGameChallenges()
        buildEventIndices()
    }

    // MARK: - Content Loading (Override in subclass for actual content)

    /// Load region definitions
    /// Subclass should override to provide actual regions
    public func loadRegions() {
        // Default implementation - subclass overrides with actual content
        // Example region for testing (uses generic IDs, not game-specific):
        let testRegion = RegionDefinition(
            id: "test_region",
            title: .inline(LocalizedString(en: "Test Region", ru: "Ð¢ÐµÑÑ‚Ð¾Ð²Ñ‹Ð¹ Ð ÐµÐ³Ð¸Ð¾Ð½")),
            description: .inline(LocalizedString(en: "A test region", ru: "Ð¢ÐµÑÑ‚Ð¾Ð²Ñ‹Ð¹ Ñ€ÐµÐ³Ð¸Ð¾Ð½")),
            regionType: "test",
            neighborIds: ["test_neighbor"],
            initiallyDiscovered: true,
            anchorId: "test_anchor",
            eventPoolIds: ["pool_common"],
            initialState: .stable
        )
        regions[testRegion.id] = testRegion
    }

    /// Load anchor definitions
    public func loadAnchors() {
        // Default implementation - subclass overrides (uses generic IDs, not game-specific)
        let testAnchor = AnchorDefinition(
            id: "test_anchor",
            title: .inline(LocalizedString(en: "Test Anchor", ru: "Ð¢ÐµÑÑ‚Ð¾Ð²Ñ‹Ð¹ Ð¯ÐºÐ¾Ñ€ÑŒ")),
            description: .inline(LocalizedString(en: "A test anchor", ru: "Ð¢ÐµÑÑ‚Ð¾Ð²Ñ‹Ð¹ ÑÐºÐ¾Ñ€ÑŒ")),
            regionId: "test_region"
        )
        anchors[testAnchor.id] = testAnchor
    }

    /// Load event definitions
    public func loadEvents() {
        // Default implementation - subclass overrides
        let testEvent = EventDefinition(
            id: "event_test",
            title: .inline(LocalizedString(en: "Test Event", ru: "Ð¢ÐµÑÑ‚Ð¾Ð²Ð¾Ðµ Ð¡Ð¾Ð±Ñ‹Ñ‚Ð¸Ðµ")),
            body: .inline(LocalizedString(en: "A test event", ru: "Ð¢ÐµÑÑ‚Ð¾Ð²Ð¾Ðµ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ðµ")),
            eventKind: .inline,
            poolIds: ["pool_common"],
            choices: [
                ChoiceDefinition(
                    id: "choice_a",
                    label: .inline(LocalizedString(en: "Choice A", ru: "Ð’Ñ‹Ð±Ð¾Ñ€ Ð")),
                    consequences: ChoiceConsequences(resourceChanges: ["faith": -2])
                ),
                ChoiceDefinition(
                    id: "choice_b",
                    label: .inline(LocalizedString(en: "Choice B", ru: "Ð’Ñ‹Ð±Ð¾Ñ€ Ð‘")),
                    consequences: ChoiceConsequences(resourceChanges: ["health": -3])
                )
            ]
        )
        events[testEvent.id] = testEvent
    }

    /// Load quest definitions
    public func loadQuests() {
        // Default implementation - subclass overrides
        let testQuest = QuestDefinition(
            id: "quest_test",
            title: .inline(LocalizedString(en: "Test Quest", ru: "Ð¢ÐµÑÑ‚Ð¾Ð²Ð¾Ðµ Ð—Ð°Ð´Ð°Ð½Ð¸Ðµ")),
            description: .inline(LocalizedString(en: "A test quest", ru: "Ð¢ÐµÑÑ‚Ð¾Ð²Ð¾Ðµ Ð·Ð°Ð´Ð°Ð½Ð¸Ðµ")),
            objectives: [
                ObjectiveDefinition(
                    id: "obj_1",
                    description: .inline(LocalizedString(en: "Objective 1", ru: "Ð¦ÐµÐ»ÑŒ 1")),
                    completionCondition: .manual,
                    nextObjectiveId: "obj_2"
                ),
                ObjectiveDefinition(
                    id: "obj_2",
                    description: .inline(LocalizedString(en: "Objective 2", ru: "Ð¦ÐµÐ»ÑŒ 2")),
                    completionCondition: .manual
                )
            ]
        )
        quests[testQuest.id] = testQuest
    }

    /// Load mini-game challenge definitions
    public func loadMiniGameChallenges() {
        // Default implementation - subclass overrides
        let testCombat = MiniGameChallengeDefinition(
            id: "combat_test",
            challengeKind: .combat,
            difficulty: 5
        )
        miniGameChallenges[testCombat.id] = testCombat
    }

    /// Build event indices for fast lookup
    private func buildEventIndices() {
        eventsByPool.removeAll()
        eventsByRegion.removeAll()

        for event in events.values {
            // Index by pool
            for poolId in event.poolIds {
                eventsByPool[poolId, default: []].append(event)
            }

            // Index by region (from availability)
            if let regionIds = event.availability.regionIds {
                for regionId in regionIds {
                    eventsByRegion[regionId, default: []].append(event)
                }
            }
        }
    }

    // MARK: - JSON Event Loading Utility

    /// Load events from a JSON file URL
    /// - Parameter url: URL to the events.json file
    /// - Throws: Decoding errors
    public func loadEventsFromJSON(url: URL) throws {
        let data = try Data(contentsOf: url)
        let jsonEvents = try JSONDecoder().decode([JSONEventForLoading].self, from: data)
        for jsonEvent in jsonEvents {
            events[jsonEvent.id] = jsonEvent.toDefinition()
        }
        buildEventIndices()
    }

    // MARK: - Registration (for building content)

    public func registerRegion(_ region: RegionDefinition) {
        regions[region.id] = region
    }

    public func registerAnchor(_ anchor: AnchorDefinition) {
        anchors[anchor.id] = anchor
    }

    public func registerEvent(_ event: EventDefinition) {
        events[event.id] = event
    }

    public func registerQuest(_ quest: QuestDefinition) {
        quests[quest.id] = quest
    }

    public func registerMiniGameChallenge(_ challenge: MiniGameChallengeDefinition) {
        miniGameChallenges[challenge.id] = challenge
    }

    public func rebuildIndices() {
        buildEventIndices()
    }

    // MARK: - ContentProvider Implementation

    public func getAllRegionDefinitions() -> [RegionDefinition] {
        return Array(regions.values)
    }

    public func getRegionDefinition(id: String) -> RegionDefinition? {
        return regions[id]
    }

    public func getAllAnchorDefinitions() -> [AnchorDefinition] {
        return Array(anchors.values)
    }

    public func getAnchorDefinition(id: String) -> AnchorDefinition? {
        return anchors[id]
    }

    public func getAnchorDefinition(forRegion regionId: String) -> AnchorDefinition? {
        return anchors.values.first { $0.regionId == regionId }
    }

    public func getAllEventDefinitions() -> [EventDefinition] {
        return Array(events.values)
    }

    public func getEventDefinition(id: String) -> EventDefinition? {
        return events[id]
    }

    public func getEventDefinitions(forRegion regionId: String) -> [EventDefinition] {
        // Get events from region's pools
        guard let region = regions[regionId] else { return [] }

        var result: [EventDefinition] = []
        for poolId in region.eventPoolIds {
            result.append(contentsOf: eventsByPool[poolId] ?? [])
        }

        // Add events specifically for this region
        result.append(contentsOf: eventsByRegion[regionId] ?? [])

        // Remove duplicates while preserving order
        var seen = Set<String>()
        return result.filter { seen.insert($0.id).inserted }
    }

    public func getEventDefinitions(forPool poolId: String) -> [EventDefinition] {
        return eventsByPool[poolId] ?? []
    }

    public func getAllQuestDefinitions() -> [QuestDefinition] {
        return Array(quests.values)
    }

    public func getQuestDefinition(id: String) -> QuestDefinition? {
        return quests[id]
    }

    public func getAllMiniGameChallenges() -> [MiniGameChallengeDefinition] {
        return Array(miniGameChallenges.values)
    }

    public func getMiniGameChallenge(id: String) -> MiniGameChallengeDefinition? {
        return miniGameChallenges[id]
    }

    public func validate() -> [ContentValidationError] {
        let validator = ContentValidator(provider: self)
        return validator.validate()
    }
}

// MARK: - JSON Event Loading Structures

/// Simplified event_kind that can be either "inline" string or {"mini_game": "combat"} object
public enum JSONEventKindForLoading: Codable {
    case inline
    case miniGame(String)

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let stringValue = try? container.decode(String.self) {
            self = stringValue == "inline" ? .inline : .miniGame(stringValue)
            return
        }
        if let dictValue = try? container.decode([String: String].self),
           let miniGameType = dictValue["mini_game"] {
            self = .miniGame(miniGameType)
            return
        }
        self = .inline
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .inline: try container.encode("inline")
        case .miniGame(let type): try container.encode(["mini_game": type])
        }
    }

    public func toEventKind() -> EventKind {
        switch self {
        case .inline: return .inline
        case .miniGame(let type):
            switch type.lowercased() {
            case "combat": return .miniGame(.combat)
            case "ritual": return .miniGame(.ritual)
            case "exploration": return .miniGame(.exploration)
            case "dialogue": return .miniGame(.dialogue)
            case "puzzle": return .miniGame(.puzzle)
            default: return .miniGame(.combat)
            }
        }
    }
}

/// JSON structure for loading events from file
public struct JSONEventForLoading: Codable {
    public let id: String
    public let title: LocalizedString
    public let body: LocalizedString
    public let eventKind: JSONEventKindForLoading?
    public let eventType: String?
    public let poolIds: [String]?
    public let availability: JSONAvailabilityForLoading?
    public let weight: Int?
    public let isOneTime: Bool?
    public let isInstant: Bool?
    public let cooldown: Int?
    public let choices: [JSONChoiceForLoading]?
    public let miniGameChallenge: JSONMiniGameChallengeForLoading?

    enum CodingKeys: String, CodingKey {
        case id, title, body, availability, weight, choices
        case eventKind = "event_kind"
        case eventType = "event_type"
        case poolIds = "pool_ids"
        case isOneTime = "is_one_time"
        case isInstant = "is_instant"
        case cooldown
        case miniGameChallenge = "mini_game_challenge"
    }

    public func toDefinition() -> EventDefinition {
        let kind: EventKind
        if let ek = eventKind { kind = ek.toEventKind() }
        else if let et = eventType {
            switch et.lowercased() {
            case "combat": kind = .miniGame(.combat)
            case "ritual": kind = .miniGame(.ritual)
            case "exploration": kind = .miniGame(.exploration)
            default: kind = .inline
            }
        } else { kind = .inline }

        let avail = availability?.toAvailability() ?? .always
        let choiceDefs = choices?.map { $0.toDefinition() } ?? []

        let challenge: MiniGameChallengeDefinition?
        if let json = miniGameChallenge, let enemyId = json.enemyId {
            challenge = MiniGameChallengeDefinition(
                id: "challenge_\(enemyId)",
                challengeKind: .combat,
                difficulty: json.difficulty ?? 1,
                enemyId: enemyId,
                victoryConsequences: json.rewards?.toConsequences() ?? .none,
                defeatConsequences: json.penalties?.toConsequences() ?? .none
            )
        } else { challenge = nil }

        return EventDefinition(
            id: id,
            title: .inline(title),
            body: .inline(body),
            eventKind: kind,
            availability: avail,
            poolIds: poolIds ?? [],
            weight: weight ?? 10,
            isOneTime: isOneTime ?? false,
            choices: choiceDefs,
            miniGameChallenge: challenge
        )
    }
}

public struct JSONAvailabilityForLoading: Codable {
    public let regionStates: [String]?
    public let regionIds: [String]?
    public let minPressure: Int?
    public let maxPressure: Int?
    public let minBalance: Int?
    public let maxBalance: Int?
    public let requiredFlags: [String]?
    public let forbiddenFlags: [String]?

    enum CodingKeys: String, CodingKey {
        case regionStates = "region_states"
        case regionIds = "region_ids"
        case minPressure = "min_pressure"
        case maxPressure = "max_pressure"
        case minBalance = "min_balance"
        case maxBalance = "max_balance"
        case requiredFlags = "required_flags"
        case forbiddenFlags = "forbidden_flags"
    }

    public func toAvailability() -> Availability {
        Availability(
            requiredFlags: requiredFlags ?? [],
            forbiddenFlags: forbiddenFlags ?? [],
            minPressure: minPressure,
            maxPressure: maxPressure,
            minBalance: minBalance,
            maxBalance: maxBalance,
            regionStates: regionStates,
            regionIds: regionIds
        )
    }
}

public struct JSONChoiceForLoading: Codable {
    public let id: String
    public let label: LocalizedString
    public let tooltip: LocalizedString?
    public let requirements: JSONChoiceRequirementsForLoading?
    public let consequences: JSONChoiceConsequencesForLoading?

    public func toDefinition() -> ChoiceDefinition {
        ChoiceDefinition(
            id: id,
            label: .inline(label),
            tooltip: tooltip.map { .inline($0) },
            requirements: requirements?.toRequirements(),
            consequences: consequences?.toConsequences() ?? .none
        )
    }
}

public struct JSONChoiceRequirementsForLoading: Codable {
    public let minResources: [String: Int]?
    public let minFaith: Int?
    public let minHealth: Int?
    public let minBalance: Int?
    public let maxBalance: Int?
    public let requiredFlags: [String]?
    public let forbiddenFlags: [String]?

    enum CodingKeys: String, CodingKey {
        case minResources = "min_resources"
        case minFaith = "min_faith"
        case minHealth = "min_health"
        case minBalance = "min_balance"
        case maxBalance = "max_balance"
        case requiredFlags = "required_flags"
        case forbiddenFlags = "forbidden_flags"
    }

    public func toRequirements() -> ChoiceRequirements {
        var resources = minResources ?? [:]
        if let faith = minFaith { resources["faith"] = faith }
        if let health = minHealth { resources["health"] = health }
        return ChoiceRequirements(
            minResources: resources,
            requiredFlags: requiredFlags ?? [],
            forbiddenFlags: forbiddenFlags ?? [],
            minBalance: minBalance,
            maxBalance: maxBalance
        )
    }
}

public struct JSONChoiceConsequencesForLoading: Codable {
    public let resourceChanges: [String: Int]?
    public let setFlags: [String]?
    public let clearFlags: [String]?
    public let balanceDelta: Int?
    public let regionStateChange: JSONRegionStateChangeForLoading?
    public let questProgress: JSONQuestProgressForLoading?
    public let triggerEventId: String?
    public let resultKey: String?

    enum CodingKeys: String, CodingKey {
        case resourceChanges = "resource_changes"
        case setFlags = "set_flags"
        case clearFlags = "clear_flags"
        case balanceDelta = "balance_delta"
        case regionStateChange = "region_state_change"
        case questProgress = "quest_progress"
        case triggerEventId = "trigger_event_id"
        case resultKey = "result_key"
    }

    public func toConsequences() -> ChoiceConsequences {
        let stateChange: RegionStateChange?
        if let rsc = regionStateChange {
            let transition: RegionStateChange.StateTransition?
            switch rsc.transition?.lowercased() {
            case "restore": transition = .restore
            case "degrade": transition = .degrade
            default: transition = nil
            }
            stateChange = RegionStateChange(
                regionId: rsc.regionId,
                newState: nil,
                transition: transition
            )
        } else { stateChange = nil }

        let questProg: QuestProgressTrigger?
        if let qp = questProgress {
            let action: QuestProgressTrigger.QuestAction
            switch qp.action?.lowercased() {
            case "complete": action = .complete
            case "unlock": action = .unlock
            case "fail": action = .fail
            case "advance": action = .advance
            default: action = .complete
            }
            questProg = QuestProgressTrigger(
                questId: qp.questId ?? "",
                objectiveId: qp.objectiveId,
                action: action
            )
        } else { questProg = nil }

        return ChoiceConsequences(
            resourceChanges: resourceChanges ?? [:],
            setFlags: setFlags ?? [],
            clearFlags: clearFlags ?? [],
            balanceDelta: balanceDelta ?? 0,
            regionStateChange: stateChange,
            questProgress: questProg,
            resultKey: resultKey
        )
    }
}

public struct JSONRegionStateChangeForLoading: Codable {
    public let regionId: String?
    public let newState: String?
    public let transition: String?

    enum CodingKeys: String, CodingKey {
        case regionId = "region_id"
        case newState = "new_state"
        case transition
    }
}

public struct JSONQuestProgressForLoading: Codable {
    public let questId: String?
    public let objectiveId: String?
    public let action: String?

    enum CodingKeys: String, CodingKey {
        case questId = "quest_id"
        case objectiveId = "objective_id"
        case action
    }
}

public struct JSONMiniGameChallengeForLoading: Codable {
    public let enemyId: String?
    public let difficulty: Int?
    public let rewards: JSONChallengeConsequencesForLoading?
    public let penalties: JSONChallengeConsequencesForLoading?

    enum CodingKeys: String, CodingKey {
        case enemyId = "enemy_id"
        case difficulty, rewards, penalties
    }
}

public struct JSONChallengeConsequencesForLoading: Codable {
    public let resourceChanges: [String: Int]?
    public let setFlags: [String]?
    public let balanceShift: Int?

    enum CodingKeys: String, CodingKey {
        case resourceChanges = "resource_changes"
        case setFlags = "set_flags"
        case balanceShift = "balance_shift"
    }

    public func toConsequences() -> ChoiceConsequences {
        ChoiceConsequences(
            resourceChanges: resourceChanges ?? [:],
            setFlags: setFlags ?? [],
            clearFlags: [],
            balanceDelta: balanceShift ?? 0
        )
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Data/Providers/ContentProvider.swift
// ==========================================

import Foundation

// MARK: - Content Provider Protocol
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.3
// Reference: Docs/MIGRATION_PLAN.md, Feature A3

/// Protocol for loading game content definitions.
/// Abstracts the source of content (code, JSON, database, etc.)
public protocol ContentProvider {
    // MARK: - Regions

    /// Get all region definitions
    func getAllRegionDefinitions() -> [RegionDefinition]

    /// Get a specific region by ID
    func getRegionDefinition(id: String) -> RegionDefinition?

    // MARK: - Anchors

    /// Get all anchor definitions
    func getAllAnchorDefinitions() -> [AnchorDefinition]

    /// Get a specific anchor by ID
    func getAnchorDefinition(id: String) -> AnchorDefinition?

    /// Get anchor for a region
    func getAnchorDefinition(forRegion regionId: String) -> AnchorDefinition?

    // MARK: - Events

    /// Get all event definitions
    func getAllEventDefinitions() -> [EventDefinition]

    /// Get a specific event by ID
    func getEventDefinition(id: String) -> EventDefinition?

    /// Get events for a specific region
    func getEventDefinitions(forRegion regionId: String) -> [EventDefinition]

    /// Get events for a specific pool
    func getEventDefinitions(forPool poolId: String) -> [EventDefinition]

    // MARK: - Quests

    /// Get all quest definitions
    func getAllQuestDefinitions() -> [QuestDefinition]

    /// Get a specific quest by ID
    func getQuestDefinition(id: String) -> QuestDefinition?

    // MARK: - Mini-Game Challenges

    /// Get all mini-game challenge definitions
    func getAllMiniGameChallenges() -> [MiniGameChallengeDefinition]

    /// Get a specific challenge by ID
    func getMiniGameChallenge(id: String) -> MiniGameChallengeDefinition?

    // MARK: - Validation

    /// Validate all content for consistency
    func validate() -> [ContentValidationError]
}

// MARK: - Content Validation Error

/// Error found during content validation
public struct ContentValidationError: Equatable, CustomStringConvertible {
    /// Type of validation error
    public let type: ErrorType

    /// Affected definition ID
    public let definitionId: String

    /// Detailed error message
    public let message: String

    public var description: String {
        return "[\(type.rawValue)] \(definitionId): \(message)"
    }

    public enum ErrorType: String, Equatable {
        case duplicateId = "DUPLICATE_ID"
        case brokenReference = "BROKEN_REFERENCE"
        case invalidRange = "INVALID_RANGE"
        case missingRequired = "MISSING_REQUIRED"
        case emptyChoices = "EMPTY_CHOICES"
        case invalidLocalizationKey = "INVALID_KEY"
        case circularReference = "CIRCULAR_REF"
        case invalidExpression = "INVALID_EXPRESSION"
    }
}

// MARK: - Content Validator

/// Validates content from a provider
public struct ContentValidator {
    let provider: ContentProvider

    public init(provider: ContentProvider) {
        self.provider = provider
    }

    /// Run all validation checks
    public func validate() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []

        errors.append(contentsOf: validateUniqueIds())
        errors.append(contentsOf: validateRegionReferences())
        errors.append(contentsOf: validateAnchorReferences())
        errors.append(contentsOf: validateEventReferences())
        errors.append(contentsOf: validateQuestReferences())
        errors.append(contentsOf: validateEventChoices())
        errors.append(contentsOf: validateRanges())

        return errors
    }

    // MARK: - Validation Checks

    /// Check for duplicate IDs within each type
    private func validateUniqueIds() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []

        // Regions
        let regionIds = provider.getAllRegionDefinitions().map { $0.id }
        for (id, count) in Dictionary(grouping: regionIds, by: { $0 }).filter({ $0.value.count > 1 }) {
            errors.append(ContentValidationError(
                type: .duplicateId,
                definitionId: id,
                message: "Region ID appears \(count.count) times"
            ))
        }

        // Events
        let eventIds = provider.getAllEventDefinitions().map { $0.id }
        for (id, count) in Dictionary(grouping: eventIds, by: { $0 }).filter({ $0.value.count > 1 }) {
            errors.append(ContentValidationError(
                type: .duplicateId,
                definitionId: id,
                message: "Event ID appears \(count.count) times"
            ))
        }

        // Quests
        let questIds = provider.getAllQuestDefinitions().map { $0.id }
        for (id, count) in Dictionary(grouping: questIds, by: { $0 }).filter({ $0.value.count > 1 }) {
            errors.append(ContentValidationError(
                type: .duplicateId,
                definitionId: id,
                message: "Quest ID appears \(count.count) times"
            ))
        }

        return errors
    }

    /// Check that region neighbor references exist
    private func validateRegionReferences() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []
        let allRegionIds = Set(provider.getAllRegionDefinitions().map { $0.id })

        for region in provider.getAllRegionDefinitions() {
            for neighborId in region.neighborIds {
                if !allRegionIds.contains(neighborId) {
                    errors.append(ContentValidationError(
                        type: .brokenReference,
                        definitionId: region.id,
                        message: "Neighbor '\(neighborId)' does not exist"
                    ))
                }
            }
        }

        return errors
    }

    /// Check that anchor region references exist
    private func validateAnchorReferences() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []
        let allRegionIds = Set(provider.getAllRegionDefinitions().map { $0.id })

        for anchor in provider.getAllAnchorDefinitions() {
            if !allRegionIds.contains(anchor.regionId) {
                errors.append(ContentValidationError(
                    type: .brokenReference,
                    definitionId: anchor.id,
                    message: "Region '\(anchor.regionId)' does not exist"
                ))
            }
        }

        return errors
    }

    /// Check event references
    private func validateEventReferences() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []
        let allEventIds = Set(provider.getAllEventDefinitions().map { $0.id })
        let allRegionIds = Set(provider.getAllRegionDefinitions().map { $0.id })

        for event in provider.getAllEventDefinitions() {
            // Check region references in availability
            if let regionIds = event.availability.regionIds {
                for regionId in regionIds {
                    if !allRegionIds.contains(regionId) {
                        errors.append(ContentValidationError(
                            type: .brokenReference,
                            definitionId: event.id,
                            message: "Region '\(regionId)' in availability does not exist"
                        ))
                    }
                }
            }

            // Check trigger event references
            for choice in event.choices {
                if let triggerId = choice.consequences.triggerEventId {
                    if !allEventIds.contains(triggerId) {
                        errors.append(ContentValidationError(
                            type: .brokenReference,
                            definitionId: event.id,
                            message: "Trigger event '\(triggerId)' in choice '\(choice.id)' does not exist"
                        ))
                    }
                }
            }
        }

        return errors
    }

    /// Check quest references
    private func validateQuestReferences() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []
        let allEventIds = Set(provider.getAllEventDefinitions().map { $0.id })
        let allRegionIds = Set(provider.getAllRegionDefinitions().map { $0.id })

        for quest in provider.getAllQuestDefinitions() {
            let objectiveIds = Set(quest.objectives.map { $0.id })

            for objective in quest.objectives {
                // Check next objective reference
                if let nextId = objective.nextObjectiveId, !objectiveIds.contains(nextId) {
                    errors.append(ContentValidationError(
                        type: .brokenReference,
                        definitionId: quest.id,
                        message: "Objective '\(objective.id)' references non-existent next '\(nextId)'"
                    ))
                }

                // Check completion condition references
                switch objective.completionCondition {
                case .eventCompleted(let eventId):
                    if !allEventIds.contains(eventId) {
                        errors.append(ContentValidationError(
                            type: .brokenReference,
                            definitionId: quest.id,
                            message: "Objective '\(objective.id)' references non-existent event '\(eventId)'"
                        ))
                    }
                case .visitRegion(let regionId):
                    if !allRegionIds.contains(regionId) {
                        errors.append(ContentValidationError(
                            type: .brokenReference,
                            definitionId: quest.id,
                            message: "Objective '\(objective.id)' references non-existent region '\(regionId)'"
                        ))
                    }
                case .choiceMade(let eventId, _):
                    if !allEventIds.contains(eventId) {
                        errors.append(ContentValidationError(
                            type: .brokenReference,
                            definitionId: quest.id,
                            message: "Objective '\(objective.id)' references non-existent event '\(eventId)'"
                        ))
                    }
                default:
                    break
                }
            }
        }

        return errors
    }

    /// Check that events have valid choices
    private func validateEventChoices() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []

        for event in provider.getAllEventDefinitions() {
            // Inline events should have at least 2 choices
            if case .inline = event.eventKind {
                if event.choices.isEmpty {
                    errors.append(ContentValidationError(
                        type: .emptyChoices,
                        definitionId: event.id,
                        message: "Inline event has no choices"
                    ))
                } else if event.choices.count < 2 {
                    errors.append(ContentValidationError(
                        type: .emptyChoices,
                        definitionId: event.id,
                        message: "Inline event should have at least 2 choices"
                    ))
                }
            }

            // Check for duplicate choice IDs within event
            let choiceIds = event.choices.map { $0.id }
            for (id, count) in Dictionary(grouping: choiceIds, by: { $0 }).filter({ $0.value.count > 1 }) {
                errors.append(ContentValidationError(
                    type: .duplicateId,
                    definitionId: event.id,
                    message: "Choice ID '\(id)' appears \(count.count) times"
                ))
            }
        }

        return errors
    }

    /// Check pressure/balance ranges are valid
    private func validateRanges() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []

        for event in provider.getAllEventDefinitions() {
            // Check pressure range
            if let min = event.availability.minPressure, let max = event.availability.maxPressure {
                if min > max {
                    errors.append(ContentValidationError(
                        type: .invalidRange,
                        definitionId: event.id,
                        message: "minPressure (\(min)) > maxPressure (\(max))"
                    ))
                }
            }

            // Check balance range
            if let min = event.availability.minBalance, let max = event.availability.maxBalance {
                if min > max {
                    errors.append(ContentValidationError(
                        type: .invalidRange,
                        definitionId: event.id,
                        message: "minBalance (\(min)) > maxBalance (\(max))"
                    ))
                }
            }

            // Check choice requirements
            for choice in event.choices {
                if let requirements = choice.requirements {
                    let minBal = requirements.minBalance ?? -100
                    let maxBal = requirements.maxBalance ?? 100
                    if minBal < -100 || maxBal > 100 {
                        errors.append(ContentValidationError(
                            type: .invalidRange,
                            definitionId: event.id,
                            message: "Choice '\(choice.id)' has balance range outside -100...100"
                        ))
                    }
                }
            }
        }

        return errors
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Data/Providers/JSONContentProvider.swift
// ==========================================

import Foundation

// MARK: - JSON Content Provider
// Reference: Docs/MIGRATION_PLAN.md, Feature A3 / EPIC D
// Phase 5 Implementation - Real cartridge-data-driven

/// Content provider that loads definitions from JSON files.
/// This is the "cartridge" approach - content as external data.
public class JSONContentProvider: ContentProvider {
    // MARK: - Configuration

    /// Base path for content JSON files
    public let contentPath: String

    /// Bundle containing content (nil = main bundle)
    public let bundle: Bundle

    // MARK: - Cached Definitions (internal for @testable import)

    private(set) var regions: [String: RegionDefinition] = [:]
    private(set) var anchors: [String: AnchorDefinition] = [:]
    private(set) var events: [String: EventDefinition] = [:]
    private(set) var quests: [String: QuestDefinition] = [:]
    private(set) var miniGameChallenges: [String: MiniGameChallengeDefinition] = [:]

    // MARK: - Event Indices (internal for @testable import)

    private(set) var eventsByPool: [String: [EventDefinition]] = [:]
    private(set) var eventsByRegion: [String: [EventDefinition]] = [:]

    // MARK: - Loading State

    private(set) var isLoaded: Bool = false
    private(set) var loadErrors: [String] = []

    // MARK: - Initialization

    public init(contentPath: String = "Content", bundle: Bundle? = nil) {
        self.contentPath = contentPath
        self.bundle = bundle ?? Bundle.main
    }

    /// Initialize and load content
    convenience init(loadImmediately: Bool, contentPath: String = "Content", bundle: Bundle? = nil) {
        self.init(contentPath: contentPath, bundle: bundle)
        if loadImmediately {
            do {
                try loadAllContent()
            } catch {
                loadErrors.append("Failed to load content: \(error.localizedDescription)")
            }
        }
    }

    // MARK: - Loading

    /// Load all content from JSON files
    public func loadAllContent() throws {
        loadErrors.removeAll()

        // Load regions (files are at bundle root after Xcode copies them)
        if let regionsURL = bundle.url(forResource: "regions", withExtension: "json") {
            try loadRegions(from: regionsURL)
        } else {
            loadErrors.append("regions.json not found")
        }

        // Load anchors
        if let anchorsURL = bundle.url(forResource: "anchors", withExtension: "json") {
            try loadAnchors(from: anchorsURL)
        } else {
            loadErrors.append("anchors.json not found")
        }

        // Load quests
        if let questsURL = bundle.url(forResource: "quests", withExtension: "json") {
            try loadQuests(from: questsURL)
        } else {
            loadErrors.append("quests.json not found")
        }

        // Load challenges
        if let challengesURL = bundle.url(forResource: "challenges", withExtension: "json") {
            try loadChallenges(from: challengesURL)
        } else {
            loadErrors.append("challenges.json not found")
        }

        // Load event pools
        try loadEventPools()

        // Build indices
        buildEventIndices()

        isLoaded = true
    }

    /// Reload content (for development hot-reload)
    public func reloadContent() throws {
        regions.removeAll()
        anchors.removeAll()
        events.removeAll()
        quests.removeAll()
        miniGameChallenges.removeAll()
        eventsByPool.removeAll()
        eventsByRegion.removeAll()
        isLoaded = false

        try loadAllContent()
    }

    // MARK: - Individual Loaders

    private func loadRegions(from url: URL) throws {
        let data = try Data(contentsOf: url)
        let container = try JSONDecoder().decode(RegionsContainer.self, from: data)
        for region in container.regions {
            regions[region.id] = region.toDefinition()
        }
    }

    private func loadAnchors(from url: URL) throws {
        let data = try Data(contentsOf: url)
        let container = try JSONDecoder().decode(AnchorsContainer.self, from: data)
        for anchor in container.anchors {
            anchors[anchor.id] = anchor.toDefinition()
        }
    }

    private func loadQuests(from url: URL) throws {
        let data = try Data(contentsOf: url)
        // quests.json can be either a container with "quests" array or a direct array
        do {
            let container = try JSONDecoder().decode(QuestsContainer.self, from: data)
            for quest in container.quests {
                quests[quest.id] = quest.toDefinition()
            }
        } catch {
            // Try direct array format (like events.json)
            let questArray = try JSONDecoder().decode([JSONQuest].self, from: data)
            for quest in questArray {
                quests[quest.id] = quest.toDefinition()
            }
        }
    }

    private func loadChallenges(from url: URL) throws {
        let data = try Data(contentsOf: url)
        let container = try JSONDecoder().decode(ChallengesContainer.self, from: data)
        for challenge in container.challenges {
            miniGameChallenges[challenge.id] = challenge.toDefinition()
        }
    }

    private func loadEventPools() throws {
        // Events are now in events.json with pool_ids field, not separate pool files
        // Load events.json which contains all events with their pool associations
        if let eventsURL = bundle.url(forResource: "events", withExtension: "json") {
            try loadEvents(from: eventsURL)
        } else {
            loadErrors.append("events.json not found")
        }
    }

    private func loadEvents(from url: URL) throws {
        let data = try Data(contentsOf: url)
        // events.json is a direct array, not wrapped in a container
        let eventArray = try JSONDecoder().decode([JSONEvent].self, from: data)
        for event in eventArray {
            let definition = event.toDefinition()
            events[definition.id] = definition
        }
    }

    private func loadEventPool(from url: URL) throws {
        let data = try Data(contentsOf: url)
        let container = try JSONDecoder().decode(EventPoolContainer.self, from: data)
        for event in container.events {
            let definition = event.toDefinition()
            events[definition.id] = definition
        }
    }

    private func buildEventIndices() {
        eventsByPool.removeAll()
        eventsByRegion.removeAll()

        for event in events.values {
            // Index by pool
            for poolId in event.poolIds {
                eventsByPool[poolId, default: []].append(event)
            }

            // Index by region (from availability)
            if let regionIds = event.availability.regionIds {
                for regionId in regionIds {
                    eventsByRegion[regionId, default: []].append(event)
                }
            }
        }
    }

    // MARK: - ContentProvider Implementation

    public func getAllRegionDefinitions() -> [RegionDefinition] {
        return Array(regions.values)
    }

    public func getRegionDefinition(id: String) -> RegionDefinition? {
        return regions[id]
    }

    public func getAllAnchorDefinitions() -> [AnchorDefinition] {
        return Array(anchors.values)
    }

    public func getAnchorDefinition(id: String) -> AnchorDefinition? {
        return anchors[id]
    }

    public func getAnchorDefinition(forRegion regionId: String) -> AnchorDefinition? {
        return anchors.values.first { $0.regionId == regionId }
    }

    public func getAllEventDefinitions() -> [EventDefinition] {
        return Array(events.values)
    }

    public func getEventDefinition(id: String) -> EventDefinition? {
        return events[id]
    }

    public func getEventDefinitions(forRegion regionId: String) -> [EventDefinition] {
        guard let region = regions[regionId] else { return [] }

        var result: [EventDefinition] = []
        for poolId in region.eventPoolIds {
            result.append(contentsOf: eventsByPool[poolId] ?? [])
        }
        result.append(contentsOf: eventsByRegion[regionId] ?? [])

        var seen = Set<String>()
        return result.filter { seen.insert($0.id).inserted }
    }

    public func getEventDefinitions(forPool poolId: String) -> [EventDefinition] {
        return eventsByPool[poolId] ?? []
    }

    public func getAllQuestDefinitions() -> [QuestDefinition] {
        return Array(quests.values)
    }

    public func getQuestDefinition(id: String) -> QuestDefinition? {
        return quests[id]
    }

    public func getAllMiniGameChallenges() -> [MiniGameChallengeDefinition] {
        return Array(miniGameChallenges.values)
    }

    public func getMiniGameChallenge(id: String) -> MiniGameChallengeDefinition? {
        return miniGameChallenges[id]
    }

    public func validate() -> [ContentValidationError] {
        let validator = ContentValidator(provider: self)
        return validator.validate()
    }
}

// MARK: - JSON Schema Containers

/// Container for regions.json
private struct RegionsContainer: Codable {
    public let version: String?
    public let description: String?
    public let regions: [JSONRegion]
}

/// Container for anchors.json
private struct AnchorsContainer: Codable {
    public let version: String?
    public let description: String?
    public let anchors: [JSONAnchor]
}

/// Container for quests.json
private struct QuestsContainer: Codable {
    public let version: String?
    public let description: String?
    public let quests: [JSONQuest]
}

/// Container for challenges.json
private struct ChallengesContainer: Codable {
    public let version: String?
    public let description: String?
    public let challenges: [JSONChallenge]
}

/// Container for event pool files
private struct EventPoolContainer: Codable {
    public let version: String?
    public let poolId: String?
    public let description: String?
    public let events: [JSONEvent]
}

// MARK: - JSON Schema Types

private struct JSONRegion: Codable {
    public let id: String
    public let title: LocalizedString
    public let description: LocalizedString
    public let regionType: String?
    public let neighborIds: [String]
    public let initiallyDiscovered: Bool?
    public let anchorId: String?
    public let eventPoolIds: [String]?
    public let initialState: String?
    public let degradationWeight: Int?

    enum CodingKeys: String, CodingKey {
        case id, title, description, neighborIds, initiallyDiscovered, anchorId
        case eventPoolIds, initialState, degradationWeight
        case regionType = "region_type"
    }

    public func toDefinition() -> RegionDefinition {
        let state: RegionStateType
        switch initialState?.lowercased() {
        case "stable": state = .stable
        case "borderland": state = .borderland
        case "breach": state = .breach
        default: state = .stable
        }

        return RegionDefinition(
            id: id,
            title: .inline(title),
            description: .inline(description),
            regionType: regionType ?? "unknown",
            neighborIds: neighborIds,
            initiallyDiscovered: initiallyDiscovered ?? false,
            anchorId: anchorId,
            eventPoolIds: eventPoolIds ?? [],
            initialState: state,
            degradationWeight: degradationWeight ?? 1
        )
    }
}

private struct JSONAnchor: Codable {
    public let id: String
    public let title: LocalizedString
    public let description: LocalizedString
    public let regionId: String
    public let anchorType: String?
    public let initialInfluence: String?
    public let power: Int?
    public let initialIntegrity: Int?

    public func toDefinition() -> AnchorDefinition {
        let influence: AnchorInfluence
        switch initialInfluence?.lowercased() {
        case "light": influence = .light
        case "dark": influence = .dark
        default: influence = .neutral
        }

        return AnchorDefinition(
            id: id,
            title: .inline(title),
            description: .inline(description),
            regionId: regionId,
            anchorType: anchorType ?? "shrine",
            initialInfluence: influence,
            power: power ?? 5,
            initialIntegrity: initialIntegrity ?? 100
        )
    }
}

/// Represents event_kind which can be either a string "inline" or object {"mini_game": "combat"}
private enum JSONEventKind: Codable {
    case inline
    case miniGame(String)

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()

        // Try string first (e.g., "inline")
        if let stringValue = try? container.decode(String.self) {
            if stringValue == "inline" {
                self = .inline
            } else {
                // Treat other strings as mini_game type
                self = .miniGame(stringValue)
            }
            return
        }

        // Try object (e.g., {"mini_game": "combat"})
        if let dictValue = try? container.decode([String: String].self),
           let miniGameType = dictValue["mini_game"] {
            self = .miniGame(miniGameType)
            return
        }

        // Default to inline
        self = .inline
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .inline:
            try container.encode("inline")
        case .miniGame(let type):
            try container.encode(["mini_game": type])
        }
    }

    public func toEventKind() -> EventKind {
        switch self {
        case .inline:
            return .inline
        case .miniGame(let type):
            switch type.lowercased() {
            case "combat": return .miniGame(.combat)
            case "ritual": return .miniGame(.ritual)
            case "exploration": return .miniGame(.exploration)
            case "dialogue": return .miniGame(.dialogue)
            case "puzzle": return .miniGame(.puzzle)
            default: return .miniGame(.combat)
            }
        }
    }
}

private struct JSONEvent: Codable {
    public let id: String
    public let title: LocalizedString
    public let body: LocalizedString
    public let eventKind: JSONEventKind?
    public let eventType: String?
    public let poolIds: [String]?
    public let availability: JSONAvailability?
    public let weight: Int?
    public let isOneTime: Bool?
    public let isInstant: Bool?
    public let cooldown: Int?
    public let choices: [JSONChoice]?
    public let combatData: JSONCombatData?
    public let miniGameChallenge: JSONMiniGameChallenge?

    enum CodingKeys: String, CodingKey {
        case id, title, body, availability, weight, choices, combatData
        case eventKind = "event_kind"
        case eventType = "event_type"
        case poolIds = "pool_ids"
        case isOneTime = "is_one_time"
        case isInstant = "is_instant"
        case cooldown
        case miniGameChallenge = "mini_game_challenge"
    }

    public func toDefinition() -> EventDefinition {
        let kind: EventKind
        // Prefer eventKind (can be string or object), fall back to eventType (legacy string)
        if let ek = eventKind {
            kind = ek.toEventKind()
        } else if let et = eventType {
            switch et.lowercased() {
            case "combat": kind = .miniGame(.combat)
            case "ritual": kind = .miniGame(.ritual)
            case "exploration": kind = .miniGame(.exploration)
            default: kind = .inline
            }
        } else {
            kind = .inline
        }

        let avail = availability?.toAvailability() ?? .always

        let choiceDefs = choices?.map { $0.toDefinition() } ?? []

        // Create MiniGameChallengeDefinition from JSON mini_game_challenge
        let challenge: MiniGameChallengeDefinition?
        if let json = miniGameChallenge, let enemyId = json.enemyId {
            challenge = MiniGameChallengeDefinition(
                id: "challenge_\(enemyId)",
                challengeKind: .combat,
                difficulty: json.difficulty ?? 1,
                enemyId: enemyId,
                victoryConsequences: json.rewards?.toConsequences() ?? .none,
                defeatConsequences: json.penalties?.toConsequences() ?? .none
            )
        } else {
            challenge = nil
        }

        return EventDefinition(
            id: id,
            title: .inline(title),
            body: .inline(body),
            eventKind: kind,
            availability: avail,
            poolIds: poolIds ?? [],
            weight: weight ?? 10,
            isOneTime: isOneTime ?? false,
            choices: choiceDefs,
            miniGameChallenge: challenge
        )
    }
}

private struct JSONAvailability: Codable {
    public let regionStates: [String]?
    public let regionIds: [String]?
    public let minPressure: Int?
    public let maxPressure: Int?
    public let minBalance: Int?
    public let maxBalance: Int?
    public let requiredFlags: [String]?
    public let forbiddenFlags: [String]?

    enum CodingKeys: String, CodingKey {
        case regionStates = "region_states"
        case regionIds = "region_ids"
        case minPressure = "min_pressure"
        case maxPressure = "max_pressure"
        case minBalance = "min_balance"
        case maxBalance = "max_balance"
        case requiredFlags = "required_flags"
        case forbiddenFlags = "forbidden_flags"
    }

    public func toAvailability() -> Availability {
        return Availability(
            requiredFlags: requiredFlags ?? [],
            forbiddenFlags: forbiddenFlags ?? [],
            minPressure: minPressure,
            maxPressure: maxPressure,
            minBalance: minBalance,
            maxBalance: maxBalance,
            regionStates: regionStates,
            regionIds: regionIds
        )
    }
}

private struct JSONChoice: Codable {
    public let id: String
    public let label: LocalizedString
    public let tooltip: LocalizedString?
    public let requirements: JSONChoiceRequirements?
    public let consequences: JSONChoiceConsequences?

    public func toDefinition() -> ChoiceDefinition {
        let reqs = requirements?.toRequirements()
        let cons = consequences?.toConsequences() ?? .none

        return ChoiceDefinition(
            id: id,
            label: .inline(label),
            tooltip: tooltip.map { .inline($0) },
            requirements: reqs,
            consequences: cons
        )
    }
}

private struct JSONChoiceRequirements: Codable {
    public let minFaith: Int?
    public let minHealth: Int?
    public let minBalance: Int?
    public let maxBalance: Int?
    public let requiredFlags: [String]?
    public let forbiddenFlags: [String]?

    public func toRequirements() -> ChoiceRequirements {
        var minResources: [String: Int] = [:]
        if let faith = minFaith { minResources["faith"] = faith }
        if let health = minHealth { minResources["health"] = health }

        return ChoiceRequirements(
            minResources: minResources,
            requiredFlags: requiredFlags ?? [],
            forbiddenFlags: forbiddenFlags ?? [],
            minBalance: minBalance,
            maxBalance: maxBalance
        )
    }
}

private struct JSONChoiceConsequences: Codable {
    public let resourceChanges: [String: Int]?
    public let setFlags: [String: Bool]?
    public let clearFlags: [String]?
    public let balanceShift: Int?
    public let tensionChange: Int?
    public let reputationChange: Int?
    public let anchorIntegrityChange: Int?
    public let addCards: [String]?
    public let addCurse: String?
    public let giveArtifact: String?
    public let startCombat: Bool?
    public let startQuest: String?
    public let messageKey: String?

    public func toConsequences() -> ChoiceConsequences {
        let resources = resourceChanges ?? [:]

        // Convert flag dict to array
        let flags = setFlags?.filter { $0.value }.map { $0.key } ?? []
        let clear = clearFlags ?? []

        return ChoiceConsequences(
            resourceChanges: resources,
            setFlags: flags,
            clearFlags: clear,
            balanceDelta: balanceShift ?? 0,
            resultKey: messageKey
        )
    }
}

private struct JSONCombatData: Codable {
    public let enemyId: String?
    public let enemyName: String?
    public let enemyPower: Int?
    public let enemyDefense: Int?
    public let enemyHealth: Int?
    public let isBoss: Bool?
}

/// JSON representation of mini_game_challenge field in events
private struct JSONMiniGameChallenge: Codable {
    public let enemyId: String?
    public let difficulty: Int?
    public let rewards: JSONChallengeConsequences?
    public let penalties: JSONChallengeConsequences?

    enum CodingKeys: String, CodingKey {
        case enemyId = "enemy_id"
        case difficulty, rewards, penalties
    }
}

/// JSON representation of rewards/penalties in mini_game_challenge
private struct JSONChallengeConsequences: Codable {
    public let resourceChanges: [String: Int]?
    public let setFlags: [String]?
    public let balanceShift: Int?

    enum CodingKeys: String, CodingKey {
        case resourceChanges = "resource_changes"
        case setFlags = "set_flags"
        case balanceShift = "balance_shift"
    }

    public func toConsequences() -> ChoiceConsequences {
        return ChoiceConsequences(
            resourceChanges: resourceChanges ?? [:],
            setFlags: setFlags ?? [],
            clearFlags: [],
            balanceDelta: balanceShift ?? 0
        )
    }
}

private struct JSONQuest: Codable {
    public let id: String
    public let title: LocalizedString
    public let description: LocalizedString
    public let questKind: String?
    public let availability: JSONQuestAvailability?
    public let autoStart: Bool?
    public let objectives: [JSONObjective]?
    public let completionRewards: JSONQuestCompletionRewards?
    public let failurePenalties: JSONQuestCompletionRewards?

    enum CodingKeys: String, CodingKey {
        case id, title, description, objectives, availability
        case questKind = "quest_kind"
        case autoStart = "auto_start"
        case completionRewards = "completion_rewards"
        case failurePenalties = "failure_penalties"
    }

    public func toDefinition() -> QuestDefinition {
        let objDefs = objectives?.map { $0.toDefinition() } ?? []

        let kind: QuestKind
        switch questKind?.lowercased() {
        case "main": kind = .main
        case "side": kind = .side
        case "exploration": kind = .exploration
        case "challenge": kind = .challenge
        default: kind = .side
        }

        let avail = availability?.toAvailability() ?? .always
        let rewards = completionRewards?.toRewards() ?? .none
        let penalties = failurePenalties?.toRewards() ?? .none

        return QuestDefinition(
            id: id,
            title: .inline(title),
            description: .inline(description),
            objectives: objDefs,
            questKind: kind,
            availability: avail,
            autoStart: autoStart ?? false,
            completionRewards: rewards,
            failurePenalties: penalties
        )
    }
}

private struct JSONObjective: Codable {
    public let id: String
    public let description: LocalizedString
    public let hint: LocalizedString?
    public let completionCondition: JSONCompletionCondition?
    public let targetValue: Int?
    public let isOptional: Bool?
    public let nextObjectiveId: String?
    public let alternativeNextIds: [String]?

    enum CodingKeys: String, CodingKey {
        case id, description, hint
        case completionCondition = "completion_condition"
        case targetValue = "target_value"
        case isOptional = "is_optional"
        case nextObjectiveId = "next_objective_id"
        case alternativeNextIds = "alternative_next_ids"
    }

    public func toDefinition() -> ObjectiveDefinition {
        let condition = completionCondition?.toCondition() ?? .manual

        return ObjectiveDefinition(
            id: id,
            description: .inline(description),
            hint: hint.map { .inline($0) },
            completionCondition: condition,
            targetValue: targetValue ?? 1,
            isOptional: isOptional ?? false,
            nextObjectiveId: nextObjectiveId,
            alternativeNextIds: alternativeNextIds ?? []
        )
    }
}

/// Completion condition that can be either:
/// - Direct format: {"flag_set": "flag_name"} or {"visit_region": "region_id"}
/// - Object format: {"type": "flagset", "flag": "flag_name"}
private struct JSONCompletionCondition: Codable {
    // Direct format keys
    public let flagSet: String?
    public let visitRegion: String?
    public let eventCompleted: String?
    public let defeatEnemy: String?
    public let collectItem: String?

    // Choice made format: {"choice_made": {"event_id": "...", "choice_id": "..."}}
    public let choiceMade: JSONChoiceMadeCondition?

    // Resource threshold format: {"resource_threshold": {"resource_id": "...", "min_value": 10}}
    public let resourceThreshold: JSONResourceThresholdCondition?

    // Legacy object format fields
    public let type: String?
    public let regionId: String?
    public let eventId: String?
    public let flag: String?
    public let threshold: Int?

    enum CodingKeys: String, CodingKey {
        case flagSet = "flag_set"
        case visitRegion = "visit_region"
        case eventCompleted = "event_completed"
        case defeatEnemy = "defeat_enemy"
        case collectItem = "collect_item"
        case choiceMade = "choice_made"
        case resourceThreshold = "resource_threshold"
        case type, regionId, eventId, flag, threshold
    }

    public func toCondition() -> CompletionCondition {
        // Check direct format keys first
        if let flag = flagSet {
            return .flagSet(flag)
        }
        if let region = visitRegion {
            return .visitRegion(region)
        }
        if let event = eventCompleted {
            return .eventCompleted(event)
        }
        if let enemy = defeatEnemy {
            return .defeatEnemy(enemy)
        }
        if let item = collectItem {
            return .collectItem(item)
        }
        if let choice = choiceMade {
            return .choiceMade(eventId: choice.eventId ?? "", choiceId: choice.choiceId ?? "")
        }
        if let resource = resourceThreshold {
            return .resourceThreshold(resourceId: resource.resourceId ?? "", minValue: resource.minValue ?? 0)
        }

        // Fall back to legacy object format
        switch type?.lowercased() {
        case "visitregion", "visit_region":
            return .visitRegion(regionId ?? "")
        case "eventcompleted", "event_completed":
            return .eventCompleted(eventId ?? "")
        case "flagset", "flag_set":
            return .flagSet(flag ?? "")
        case "defeatenemy", "defeat_enemy":
            return .defeatEnemy(eventId ?? "")
        default:
            return .manual
        }
    }
}

private struct JSONChoiceMadeCondition: Codable {
    public let eventId: String?
    public let choiceId: String?

    enum CodingKeys: String, CodingKey {
        case eventId = "event_id"
        case choiceId = "choice_id"
    }
}

private struct JSONResourceThresholdCondition: Codable {
    public let resourceId: String?
    public let minValue: Int?

    enum CodingKeys: String, CodingKey {
        case resourceId = "resource_id"
        case minValue = "min_value"
    }
}

private struct JSONQuestAvailability: Codable {
    public let requiredFlags: [String]?
    public let forbiddenFlags: [String]?
    public let minPressure: Int?
    public let maxPressure: Int?
    public let minBalance: Int?
    public let maxBalance: Int?
    public let regionStates: [String]?
    public let regionIds: [String]?

    enum CodingKeys: String, CodingKey {
        case requiredFlags = "required_flags"
        case forbiddenFlags = "forbidden_flags"
        case minPressure = "min_pressure"
        case maxPressure = "max_pressure"
        case minBalance = "min_balance"
        case maxBalance = "max_balance"
        case regionStates = "region_states"
        case regionIds = "region_ids"
    }

    public func toAvailability() -> Availability {
        return Availability(
            requiredFlags: requiredFlags ?? [],
            forbiddenFlags: forbiddenFlags ?? [],
            minPressure: minPressure,
            maxPressure: maxPressure,
            minBalance: minBalance,
            maxBalance: maxBalance,
            regionStates: regionStates,
            regionIds: regionIds
        )
    }
}

private struct JSONQuestCompletionRewards: Codable {
    public let resourceChanges: [String: Int]?
    public let setFlags: [String]?
    public let cardIds: [String]?
    public let balanceDelta: Int?

    enum CodingKeys: String, CodingKey {
        case resourceChanges = "resource_changes"
        case setFlags = "set_flags"
        case cardIds = "card_ids"
        case balanceDelta = "balance_delta"
    }

    public func toRewards() -> QuestCompletionRewards {
        return QuestCompletionRewards(
            resourceChanges: resourceChanges ?? [:],
            setFlags: setFlags ?? [],
            cardIds: cardIds ?? [],
            balanceDelta: balanceDelta ?? 0
        )
    }
}

private struct JSONQuestRewards: Codable {
    public let resourceChanges: [String: Int]?
    public let setFlags: [String: Bool]?
    public let balanceShift: Int?
    public let tensionChange: Int?
    public let reputationChange: Int?
    public let giveArtifact: String?
    public let unlockRegions: [String]?
    public let addCurse: String?
}

private struct JSONChallenge: Codable {
    public let id: String
    public let challengeKind: String?
    public let difficulty: Int?
    public let titleKey: String?
    public let descriptionKey: String?
    public let enemyData: JSONCombatData?
    public let requirements: JSONChoiceRequirements?
    public let rewards: JSONChallengeRewards?
    public let penalties: JSONChallengePenalties?
    public let isBoss: Bool?

    public func toDefinition() -> MiniGameChallengeDefinition {
        let kind: MiniGameChallengeKind
        switch challengeKind?.lowercased() {
        case "combat": kind = .combat
        case "ritual": kind = .ritual
        case "exploration": kind = .exploration
        case "dialogue": kind = .dialogue
        case "puzzle": kind = .puzzle
        default: kind = .combat
        }

        return MiniGameChallengeDefinition(
            id: id,
            challengeKind: kind,
            difficulty: difficulty ?? 5,
            enemyId: enemyData?.enemyId
        )
    }
}

private struct JSONChallengeRewards: Codable {
    public let victoryFaith: Int?
    public let victoryBalance: Int?
    public let setFlags: [String: Bool]?
    public let discoverRegion: Bool?
    public let findArtifact: Bool?
}

private struct JSONChallengePenalties: Codable {
    public let defeatHealth: Int?
    public let defeatTension: Int?
    public let faithCost: Int?
    public let healthCost: Int?
    public let tensionGain: Int?
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Data/Definitions/AnchorDefinition.swift
// ==========================================

import Foundation

// MARK: - Anchor Influence

/// Influence alignment of an anchor (maps to CardBalance in legacy models)
public enum AnchorInfluence: String, Codable, Hashable {
    case light
    case neutral
    case dark
}

// MARK: - Anchor Definition
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.1
// Reference: Docs/EXPLORATION_CORE_DESIGN.md, Section 6

/// Immutable definition of an anchor point.
/// Anchors provide resistance to regional degradation.
/// Runtime state (current integrity, etc.) lives in AnchorRuntimeState.
public struct AnchorDefinition: GameDefinition {
    // MARK: - Identity

    /// Unique anchor identifier (e.g., "anchor_forest_shrine")
    public let id: String

    // MARK: - Localized Content

    /// Anchor name (supports inline LocalizedString or StringKey)
    public let title: LocalizableText

    /// Anchor description (supports inline LocalizedString or StringKey)
    public let description: LocalizableText

    // MARK: - Location

    /// ID of the region where this anchor is located
    public let regionId: String

    // MARK: - Type & Influence (Twilight Marches specific)

    /// Anchor type (e.g., "chapel", "shrine", "sacred_tree")
    public let anchorType: String

    /// Initial influence: "light", "neutral", or "dark"
    public let initialInfluence: AnchorInfluence

    /// Power level (radius of influence, 1-10)
    public let power: Int

    // MARK: - Mechanics

    /// Maximum integrity value (0-100)
    public let maxIntegrity: Int

    /// Initial integrity value
    public let initialIntegrity: Int

    /// Integrity gained per "strengthen" action
    public let strengthenAmount: Int

    /// Resource cost to strengthen (e.g., ["faith": 5])
    public let strengthenCost: ResourceTransaction

    // MARK: - Effects

    /// Resistance chance calculation: integrity / resistanceDivisor
    /// Default: 100 (so 50 integrity = 50% resistance)
    public let resistanceDivisor: Int

    // MARK: - Initialization

    public init(
        id: String,
        title: LocalizableText,
        description: LocalizableText,
        regionId: String,
        anchorType: String = "shrine",
        initialInfluence: AnchorInfluence = .neutral,
        power: Int = 5,
        maxIntegrity: Int = 100,
        initialIntegrity: Int = 50,
        strengthenAmount: Int = 15,
        strengthenCost: ResourceTransaction = .spend("faith", amount: 5),
        resistanceDivisor: Int = 100
    ) {
        self.id = id
        self.title = title
        self.description = description
        self.regionId = regionId
        self.anchorType = anchorType
        self.initialInfluence = initialInfluence
        self.power = power
        self.maxIntegrity = maxIntegrity
        self.initialIntegrity = initialIntegrity
        self.strengthenAmount = strengthenAmount
        self.strengthenCost = strengthenCost
        self.resistanceDivisor = resistanceDivisor
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Data/Definitions/EnemyDefinition.swift
// ==========================================

import Foundation

// MARK: - Enemy Definition
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.1
// Data-driven enemy definitions for combat events

/// Immutable definition of an enemy.
/// Used to create monster cards for combat events.
public struct EnemyDefinition: GameDefinition {
    // MARK: - Identity

    /// Unique enemy identifier (defined in content pack)
    public let id: String

    // MARK: - Localized Content

    /// Enemy name (supports inline LocalizedString or StringKey)
    public let name: LocalizableText

    /// Enemy description (supports inline LocalizedString or StringKey)
    public let description: LocalizableText

    // MARK: - Stats

    /// Base health points
    public let health: Int

    /// Base attack power
    public let power: Int

    /// Base defense
    public let defense: Int

    /// Difficulty rating (1-5, affects scaling)
    public let difficulty: Int

    // MARK: - Classification

    /// Enemy type classification
    public let enemyType: EnemyType

    /// Card rarity for loot/display
    public let rarity: CardRarity

    // MARK: - Abilities

    /// Special abilities this enemy has
    public let abilities: [EnemyAbility]

    // MARK: - Loot & Rewards

    /// Cards that can drop when defeated
    public let lootCardIds: [String]

    /// Faith reward when defeated
    public let faithReward: Int

    /// Balance change when defeated
    public let balanceDelta: Int

    // Note: No explicit CodingKeys needed - PackLoader uses .convertFromSnakeCase
    // which automatically converts enemy_type â†’ enemyType, faith_reward â†’ faithReward, etc.

    // MARK: - Initialization

    public init(
        id: String,
        name: LocalizableText,
        description: LocalizableText,
        health: Int,
        power: Int,
        defense: Int,
        difficulty: Int = 1,
        enemyType: EnemyType = .beast,
        rarity: CardRarity = .common,
        abilities: [EnemyAbility] = [],
        lootCardIds: [String] = [],
        faithReward: Int = 0,
        balanceDelta: Int = 0
    ) {
        self.id = id
        self.name = name
        self.description = description
        self.health = health
        self.power = power
        self.defense = defense
        self.difficulty = difficulty
        self.enemyType = enemyType
        self.rarity = rarity
        self.abilities = abilities
        self.lootCardIds = lootCardIds
        self.faithReward = faithReward
        self.balanceDelta = balanceDelta
    }

    /// Convert to legacy Card (monster type) for UI compatibility
    public func toCard() -> Card {
        return Card(
            id: UUID(uuidString: id.md5UUID) ?? UUID(),
            definitionId: id,  // Content Pack ID for tracking
            name: name.resolved,
            type: .monster,
            rarity: rarity,
            description: description.resolved,
            power: power,
            defense: defense,
            health: health
        )
    }
}

// MARK: - Enemy Type

public enum EnemyType: String, Codable, Hashable {
    case beast       // Wild animals
    case spirit      // Forest spirits, leshy
    case undead      // Risen dead, ghosts
    case demon       // Navi creatures
    case human       // Bandits, cultists
    case boss        // Major enemies
}

// MARK: - Enemy Ability

public struct EnemyAbility: Codable, Hashable, Identifiable {
    public let id: String
    public let name: LocalizableText
    public let description: LocalizableText
    public let effect: EnemyAbilityEffect

    public init(
        id: String,
        name: LocalizableText,
        description: LocalizableText,
        effect: EnemyAbilityEffect
    ) {
        self.id = id
        self.name = name
        self.description = description
        self.effect = effect
    }
}

public enum EnemyAbilityEffect: Codable, Hashable {
    /// Deal extra damage
    case bonusDamage(Int)

    /// Heal each turn
    case regeneration(Int)

    /// Reduce incoming damage
    case armor(Int)

    /// First strike - attacks before player
    case firstStrike

    /// Cannot be targeted by spells
    case spellImmune

    /// Applies curse on hit
    case applyCurse(String)

    /// Custom effect by ID
    case custom(String)

    // MARK: - Custom Codable for JSON compatibility
    // Note: No explicit snake_case mappings - PackLoader uses .convertFromSnakeCase
    // which automatically converts bonus_damage â†’ bonusDamage, etc.

    enum CodingKeys: String, CodingKey {
        case bonusDamage
        case regeneration
        case armor
        case firstStrike
        case spellImmune
        case applyCurse
        case custom
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        if let value = try container.decodeIfPresent(Int.self, forKey: .bonusDamage) {
            self = .bonusDamage(value)
        } else if let value = try container.decodeIfPresent(Int.self, forKey: .regeneration) {
            self = .regeneration(value)
        } else if let value = try container.decodeIfPresent(Int.self, forKey: .armor) {
            self = .armor(value)
        } else if (try? container.decodeIfPresent(Bool.self, forKey: .firstStrike)) == true {
            self = .firstStrike
        } else if (try? container.decodeIfPresent(Bool.self, forKey: .spellImmune)) == true {
            self = .spellImmune
        } else if let value = try container.decodeIfPresent(String.self, forKey: .applyCurse) {
            self = .applyCurse(value)
        } else if let value = try container.decodeIfPresent(String.self, forKey: .custom) {
            self = .custom(value)
        } else {
            // Default to custom with empty string if no recognized key
            self = .custom("unknown")
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        switch self {
        case .bonusDamage(let value):
            try container.encode(value, forKey: .bonusDamage)
        case .regeneration(let value):
            try container.encode(value, forKey: .regeneration)
        case .armor(let value):
            try container.encode(value, forKey: .armor)
        case .firstStrike:
            try container.encode(true, forKey: .firstStrike)
        case .spellImmune:
            try container.encode(true, forKey: .spellImmune)
        case .applyCurse(let value):
            try container.encode(value, forKey: .applyCurse)
        case .custom(let value):
            try container.encode(value, forKey: .custom)
        }
    }
}

// MARK: - String UUID Extension (reuse pattern)

private extension String {
    var md5UUID: String {
        var hash: UInt64 = 5381
        for char in self.utf8 {
            hash = ((hash << 5) &+ hash) &+ UInt64(char)
        }
        let hex = String(format: "%016llX", hash)
        let padded = hex.padding(toLength: 32, withPad: "0", startingAt: 0)
        let chars = Array(padded)
        return "\(String(chars[0..<8]))-\(String(chars[8..<12]))-\(String(chars[12..<16]))-\(String(chars[16..<20]))-\(String(chars[20..<32]))"
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Data/Definitions/EventDefinition.swift
// ==========================================

import Foundation

// MARK: - Event Definition
// Reference: Docs/EVENT_MODULE_ARCHITECTURE.md
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.1

/// Immutable definition of a game event.
/// Events can be Inline (resolve in flow) or Mini-Game (external module).
/// Runtime state (completion, cooldowns) lives in EventRuntimeState.
public struct EventDefinition: GameDefinition {
    // MARK: - Identity

    /// Unique event identifier (e.g., "event_forest_whispers")
    public let id: String

    // MARK: - Localized Content

    /// Event title (supports inline LocalizedString or StringKey)
    public let title: LocalizableText

    /// Event body/narrative text (supports inline LocalizedString or StringKey)
    public let body: LocalizableText

    // MARK: - Type Classification

    /// Event kind: inline or mini-game
    public let eventKind: EventKind

    // MARK: - Availability

    /// Conditions for this event to appear
    public let availability: Availability

    /// Event pool IDs this event belongs to
    public let poolIds: [String]

    /// Weight for random selection (higher = more likely)
    public let weight: Int

    // MARK: - Behavior Flags

    /// If true, event can only occur once per playthrough
    public let isOneTime: Bool

    /// If true, event resolves instantly (0 time cost)
    public let isInstant: Bool

    /// Cooldown in turns before event can reoccur (0 = no cooldown)
    public let cooldown: Int

    // MARK: - Content

    /// Choices available in this event (for inline events)
    public let choices: [ChoiceDefinition]

    /// Mini-game challenge (for mini-game events)
    public let miniGameChallenge: MiniGameChallengeDefinition?

    // MARK: - Initialization

    public init(
        id: String,
        title: LocalizableText,
        body: LocalizableText,
        eventKind: EventKind = .inline,
        availability: Availability = .always,
        poolIds: [String] = [],
        weight: Int = 10,
        isOneTime: Bool = false,
        isInstant: Bool = false,
        cooldown: Int = 0,
        choices: [ChoiceDefinition] = [],
        miniGameChallenge: MiniGameChallengeDefinition? = nil
    ) {
        self.id = id
        self.title = title
        self.body = body
        self.eventKind = eventKind
        self.availability = availability
        self.poolIds = poolIds
        self.weight = weight
        self.isOneTime = isOneTime
        self.isInstant = isInstant
        self.cooldown = cooldown
        self.choices = choices
        self.miniGameChallenge = miniGameChallenge
    }
}

// MARK: - Event Kind

/// Classification of event kinds (Engine-specific, distinct from legacy EventType)
/// Reference: Docs/EVENT_MODULE_ARCHITECTURE.md, Section 2
public enum EventKind: Codable, Hashable {
    /// Inline event - resolves within main game flow
    case inline

    /// Mini-game event - dispatches to external module
    case miniGame(MiniGameKind)

    /// All mini-game kinds
    public enum MiniGameKind: String, Codable, Hashable {
        case combat
        case ritual
        case exploration
        case dialogue
        case puzzle
    }

    // MARK: - Custom Codable

    /// Coding keys for JSON object format
    /// Note: When decoder uses convertFromSnakeCase, the JSON key "mini_game"
    /// is already converted to "miniGame", so we use that directly
    private enum CodingKeys: String, CodingKey {
        case miniGame
        // Alternative key for when convertFromSnakeCase is NOT used
        case miniGameSnake = "mini_game"
    }

    public init(from decoder: Decoder) throws {
        // Try decoding as a simple string first: "inline"
        if let container = try? decoder.singleValueContainer(),
           let stringValue = try? container.decode(String.self) {
            if stringValue == "inline" {
                self = .inline
            } else if let miniGameKind = MiniGameKind(rawValue: stringValue) {
                // Handle direct mini-game string: "combat", "ritual", etc.
                self = .miniGame(miniGameKind)
            } else {
                throw DecodingError.dataCorruptedError(
                    in: container,
                    debugDescription: "Unknown event kind: \(stringValue)"
                )
            }
            return
        }

        // Try decoding as object: {"mini_game": "combat"}
        // Try both key formats to support convertFromSnakeCase and regular decoding
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let miniGameString: String
        if let value = try container.decodeIfPresent(String.self, forKey: .miniGame) {
            miniGameString = value
        } else if let value = try container.decodeIfPresent(String.self, forKey: .miniGameSnake) {
            miniGameString = value
        } else {
            throw DecodingError.keyNotFound(
                CodingKeys.miniGame,
                DecodingError.Context(codingPath: container.codingPath, debugDescription: "Neither 'miniGame' nor 'mini_game' found")
            )
        }

        if let miniGameKind = MiniGameKind(rawValue: miniGameString) {
            self = .miniGame(miniGameKind)
        } else {
            throw DecodingError.dataCorruptedError(
                forKey: .miniGame,
                in: container,
                debugDescription: "Unknown mini-game kind: \(miniGameString)"
            )
        }
    }

    public func encode(to encoder: Encoder) throws {
        switch self {
        case .inline:
            var container = encoder.singleValueContainer()
            try container.encode("inline")
        case .miniGame(let kind):
            // Always encode with snake_case for JSON compatibility
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(kind.rawValue, forKey: .miniGameSnake)
        }
    }
}

// MARK: - Choice Definition

/// Immutable definition of a choice within an event.
public struct ChoiceDefinition: Codable, Hashable, Identifiable {
    // MARK: - Identity

    /// Unique choice identifier within the event
    public let id: String

    // MARK: - Localized Content

    /// Choice button text (supports inline LocalizedString or StringKey)
    public let label: LocalizableText

    /// Optional choice tooltip/description (supports inline LocalizedString or StringKey)
    public let tooltip: LocalizableText?

    // MARK: - Requirements

    /// Conditions for this choice to be available
    public let requirements: ChoiceRequirements?

    // MARK: - Consequences

    /// Outcomes when this choice is selected
    public let consequences: ChoiceConsequences

    // MARK: - Initialization

    public init(
        id: String,
        label: LocalizableText,
        tooltip: LocalizableText? = nil,
        requirements: ChoiceRequirements? = nil,
        consequences: ChoiceConsequences
    ) {
        self.id = id
        self.label = label
        self.tooltip = tooltip
        self.requirements = requirements
        self.consequences = consequences
    }
}

// MARK: - Choice Requirements

/// Requirements that must be met to select a choice
public struct ChoiceRequirements: Codable, Hashable {
    /// Minimum resource values required
    public let minResources: [String: Int]

    /// Flags that must be set
    public let requiredFlags: [String]

    /// Flags that must NOT be set
    public let forbiddenFlags: [String]

    /// Minimum balance required (nil = no minimum)
    public let minBalance: Int?

    /// Maximum balance allowed (nil = no maximum)
    public let maxBalance: Int?

    public init(
        minResources: [String: Int] = [:],
        requiredFlags: [String] = [],
        forbiddenFlags: [String] = [],
        minBalance: Int? = nil,
        maxBalance: Int? = nil
    ) {
        self.minResources = minResources
        self.requiredFlags = requiredFlags
        self.forbiddenFlags = forbiddenFlags
        self.minBalance = minBalance
        self.maxBalance = maxBalance
    }

    /// Convenience initializer with balance range
    public init(
        minResources: [String: Int] = [:],
        requiredFlags: [String] = [],
        forbiddenFlags: [String] = [],
        balanceRange: ClosedRange<Int>?
    ) {
        self.minResources = minResources
        self.requiredFlags = requiredFlags
        self.forbiddenFlags = forbiddenFlags
        self.minBalance = balanceRange?.lowerBound
        self.maxBalance = balanceRange?.upperBound
    }

    /// Check if requirements can be met with given context
    /// - Note: Prefer using `Requirements.evaluator.canMeet(requirements:...)` instead
    ///   for cleaner separation of data and logic (see ENGINE_ARCHITECTURE.md)
    @available(*, deprecated, message: "Use Requirements.evaluator.canMeet() instead")
    public func canMeet(resources: [String: Int], flags: Set<String>, balance: Int) -> Bool {
        // Check resources
        for (resourceId, minValue) in minResources {
            if (resources[resourceId] ?? 0) < minValue {
                return false
            }
        }

        // Check required flags
        for flag in requiredFlags {
            if !flags.contains(flag) {
                return false
            }
        }

        // Check forbidden flags
        for flag in forbiddenFlags {
            if flags.contains(flag) {
                return false
            }
        }

        // Check balance range
        if let min = minBalance, balance < min {
            return false
        }
        if let max = maxBalance, balance > max {
            return false
        }

        return true
    }
}

// MARK: - Choice Consequences

/// Outcomes that occur when a choice is selected
public struct ChoiceConsequences: Codable, Hashable {
    /// Resource changes (costs and gains)
    public let resourceChanges: [String: Int]

    /// Flags to set
    public let setFlags: [String]

    /// Flags to clear
    public let clearFlags: [String]

    /// Balance change (-100 to +100)
    public let balanceDelta: Int

    /// Region state change (if any)
    public let regionStateChange: RegionStateChange?

    /// Quest progress trigger
    public let questProgress: QuestProgressTrigger?

    /// Follow-up event to trigger (if any)
    public let triggerEventId: String?

    /// Narrative result key (for UI display)
    public let resultKey: String?

    public init(
        resourceChanges: [String: Int] = [:],
        setFlags: [String] = [],
        clearFlags: [String] = [],
        balanceDelta: Int = 0,
        regionStateChange: RegionStateChange? = nil,
        questProgress: QuestProgressTrigger? = nil,
        triggerEventId: String? = nil,
        resultKey: String? = nil
    ) {
        self.resourceChanges = resourceChanges
        self.setFlags = setFlags
        self.clearFlags = clearFlags
        self.balanceDelta = balanceDelta
        self.regionStateChange = regionStateChange
        self.questProgress = questProgress
        self.triggerEventId = triggerEventId
        self.resultKey = resultKey
    }

    /// Empty consequences (no-op choice)
    public static let none = ChoiceConsequences()
}

// MARK: - Supporting Types

/// Region state change triggered by choice
public struct RegionStateChange: Codable, Hashable {
    /// Target region ID (nil = current region)
    public let regionId: String?

    /// New state to set
    public let newState: RegionStateType?

    /// State transition (degrade/restore)
    public let transition: StateTransition?

    public enum StateTransition: String, Codable, Hashable {
        case degrade
        case restore
    }
}

/// Quest progress trigger
public struct QuestProgressTrigger: Codable, Hashable {
    public let questId: String
    public let objectiveId: String?
    public let action: QuestAction

    public enum QuestAction: String, Codable, Hashable {
        case advance      // Move to next objective
        case complete     // Complete specific objective
        case fail         // Fail the quest
        case unlock       // Unlock the quest
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Data/Definitions/GameDefinition.swift
// ==========================================

import Foundation

// MARK: - Base Definition Protocol
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.1
// Reference: Docs/MIGRATION_PLAN.md, Feature A1

/// Base protocol for all game content definitions.
/// Definitions are IMMUTABLE - they contain no runtime state.
/// All runtime data belongs in RuntimeState types.
///
/// **Invariants:**
/// - INV-D01: Definitions have no mutable properties
/// - INV-D02: All IDs are String (not UUID)
/// - INV-D03: All user-facing text uses localization keys (titleKey, bodyKey)
public protocol GameDefinition: Codable, Identifiable, Hashable {
    /// Unique identifier for this definition.
    /// Must be unique within its type (regions, events, quests, etc.)
    var id: String { get }
}

// MARK: - Localization Key Validation

/// Helper to validate localization key format.
/// Keys should follow pattern: "type.id.field" (e.g., "region.forest.title")
public enum LocalizationKeyValidator {
    public static func isValidKey(_ key: String) -> Bool {
        // Key must contain at least one dot and no spaces
        return key.contains(".") && !key.contains(" ")
    }

    public static func validateKeys(_ keys: [String]) -> [String] {
        return keys.filter { !isValidKey($0) }
    }
}

// MARK: - Common Types

/// Availability conditions for content (events, choices, etc.)
/// Reference: Docs/EVENT_MODULE_ARCHITECTURE.md, Section 2.3
public struct Availability: Codable, Hashable {
    /// Required flags that must be set
    let requiredFlags: [String]

    /// Forbidden flags that must NOT be set
    let forbiddenFlags: [String]

    /// Minimum pressure/tension required
    let minPressure: Int?

    /// Maximum pressure/tension allowed
    let maxPressure: Int?

    /// Minimum balance value required
    let minBalance: Int?

    /// Maximum balance value allowed
    let maxBalance: Int?

    /// Specific region states where this is available
    let regionStates: [String]?

    /// Specific region IDs where this is available
    let regionIds: [String]?

    init(
        requiredFlags: [String] = [],
        forbiddenFlags: [String] = [],
        minPressure: Int? = nil,
        maxPressure: Int? = nil,
        minBalance: Int? = nil,
        maxBalance: Int? = nil,
        regionStates: [String]? = nil,
        regionIds: [String]? = nil
    ) {
        self.requiredFlags = requiredFlags
        self.forbiddenFlags = forbiddenFlags
        self.minPressure = minPressure
        self.maxPressure = maxPressure
        self.minBalance = minBalance
        self.maxBalance = maxBalance
        self.regionStates = regionStates
        self.regionIds = regionIds
    }

    /// Default availability (always available)
    public static let always = Availability()
}

// MARK: - Resource Cost/Gain

/// Represents a resource change (cost or gain)
public struct ResourceChange: Codable, Hashable {
    let resourceId: String
    let amount: Int

    /// Positive = gain, negative = cost
    var isGain: Bool { amount > 0 }
    var isCost: Bool { amount < 0 }

    init(resourceId: String, amount: Int) {
        self.resourceId = resourceId
        self.amount = amount
    }
}

/// Collection of resource changes for a transaction
public struct ResourceTransaction: Codable, Hashable {
    let changes: [ResourceChange]

    init(changes: [ResourceChange]) {
        self.changes = changes
    }

    /// Convenience for single resource
    public static func spend(_ resourceId: String, amount: Int) -> ResourceTransaction {
        ResourceTransaction(changes: [ResourceChange(resourceId: resourceId, amount: -abs(amount))])
    }

    public static func gain(_ resourceId: String, amount: Int) -> ResourceTransaction {
        ResourceTransaction(changes: [ResourceChange(resourceId: resourceId, amount: abs(amount))])
    }

    public static let none = ResourceTransaction(changes: [])
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Data/Definitions/LocalizedString.swift
// ==========================================

import Foundation

// MARK: - Localized String
// Reference: Docs/ENGINE_ARCHITECTURE.md
// Supports runtime localization without app rebuild - "Cartridge" approach

/// A string with multiple language variants, loaded from JSON content.
/// This enables adding new content without rebuilding the app.
public struct LocalizedString: Codable, Hashable {
    // MARK: - Supported Languages

    /// English text
    public let en: String

    /// Russian text
    public let ru: String

    // MARK: - Localized Access

    /// Returns the string for the current device locale.
    /// Falls back to English if the current locale is not supported.
    public var localized: String {
        let languageCode = Locale.current.language.languageCode?.identifier ?? "en"
        switch languageCode {
        case "ru": return ru
        default: return en
        }
    }

    /// Returns the string for a specific language code.
    public func localized(for languageCode: String) -> String {
        switch languageCode {
        case "ru": return ru
        default: return en
        }
    }

    // MARK: - Convenience Initializers

    /// Create with the same text for all languages (for testing/development)
    public init(_ text: String) {
        self.en = text
        self.ru = text
    }

    /// Create with specific translations
    public init(en: String, ru: String) {
        self.en = en
        self.ru = ru
    }
}

// MARK: - ExpressibleByStringLiteral

extension LocalizedString: ExpressibleByStringLiteral {
    public init(stringLiteral value: String) {
        self.en = value
        self.ru = value
    }
}

// MARK: - CustomStringConvertible

extension LocalizedString: CustomStringConvertible {
    public var description: String {
        localized
    }
}

// MARK: - LocalizableText Conversion

extension LocalizedString {
    /// Convert to LocalizableText (inline format)
    public var asLocalizableText: LocalizableText {
        .inline(self)
    }
}

// MARK: - Convenience Extensions for LocalizableText

public extension LocalizableText {
    /// Create from a LocalizedString (inline format)
    init(_ localized: LocalizedString) {
        self = .inline(localized)
    }

    /// Create from a LocalizedString with optional (inline format)
    static func from(_ localized: LocalizedString?) -> LocalizableText? {
        guard let localized = localized else { return nil }
        return .inline(localized)
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Data/Definitions/MiniGameChallengeDefinition.swift
// ==========================================

import Foundation

// MARK: - Mini-Game Challenge Definition
// Reference: Docs/EVENT_MODULE_ARCHITECTURE.md, Section 4

/// Immutable definition of a mini-game challenge.
/// Describes what gets dispatched to external mini-game modules.
public struct MiniGameChallengeDefinition: Codable, Hashable, Identifiable {
    // MARK: - Identity

    /// Unique challenge identifier
    public let id: String

    // MARK: - Type

    /// Type of mini-game challenge
    public let challengeKind: MiniGameChallengeKind

    // MARK: - Difficulty

    /// Base difficulty level (1-10)
    public let difficulty: Int

    /// Difficulty scaling based on pressure
    public let pressureScaling: Double

    // MARK: - Content Reference

    /// Enemy ID for combat challenges
    public let enemyId: String?

    /// Puzzle ID for puzzle challenges
    public let puzzleId: String?

    /// Dialogue tree ID for dialogue challenges
    public let dialogueId: String?

    // MARK: - Outcomes

    /// Consequences on victory
    public let victoryConsequences: ChoiceConsequences

    /// Consequences on defeat
    public let defeatConsequences: ChoiceConsequences

    /// Consequences on retreat/escape (if allowed)
    public let retreatConsequences: ChoiceConsequences?

    // MARK: - Options

    /// Whether retreat/escape is allowed
    public let canRetreat: Bool

    /// Time limit in turns (0 = no limit)
    public let turnLimit: Int

    // MARK: - Initialization

    public init(
        id: String,
        challengeKind: MiniGameChallengeKind,
        difficulty: Int = 5,
        pressureScaling: Double = 0.1,
        enemyId: String? = nil,
        puzzleId: String? = nil,
        dialogueId: String? = nil,
        victoryConsequences: ChoiceConsequences = .none,
        defeatConsequences: ChoiceConsequences = .none,
        retreatConsequences: ChoiceConsequences? = nil,
        canRetreat: Bool = true,
        turnLimit: Int = 0
    ) {
        self.id = id
        self.challengeKind = challengeKind
        self.difficulty = difficulty
        self.pressureScaling = pressureScaling
        self.enemyId = enemyId
        self.puzzleId = puzzleId
        self.dialogueId = dialogueId
        self.victoryConsequences = victoryConsequences
        self.defeatConsequences = defeatConsequences
        self.retreatConsequences = retreatConsequences
        self.canRetreat = canRetreat
        self.turnLimit = turnLimit
    }

    /// Calculate effective difficulty based on current pressure
    public func effectiveDifficulty(at pressure: Int) -> Int {
        let scaled = Double(difficulty) + (Double(pressure) * pressureScaling)
        return Int(scaled.rounded())
    }

    // MARK: - Custom Codable

    /// Coding keys for JSON format from events.json
    /// Supports both camelCase (when convertFromSnakeCase is used) and snake_case (explicit)
    private enum CodingKeys: String, CodingKey {
        case id
        // camelCase keys (for when convertFromSnakeCase converts them)
        case challengeKind
        case pressureScaling
        case enemyId
        case puzzleId
        case dialogueId
        case victoryConsequences
        case defeatConsequences
        case retreatConsequences
        case canRetreat
        case turnLimit
        case difficulty
        // Simplified format keys (always used as-is)
        case rewards
        case penalties
    }

    /// Helper to decode a value trying both camelCase and snake_case keys
    private static func decodeOptional<T: Decodable>(
        _ type: T.Type,
        from container: KeyedDecodingContainer<CodingKeys>,
        key: CodingKeys
    ) throws -> T? {
        // With convertFromSnakeCase, keys are already converted, so just use camelCase key
        return try container.decodeIfPresent(type, forKey: key)
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        // Try full format first, then simplified format
        if let id = try container.decodeIfPresent(String.self, forKey: .id) {
            self.id = id
        } else if let enemyIdValue = try container.decodeIfPresent(String.self, forKey: .enemyId) {
            // Generate ID from enemy ID for simplified format
            self.id = "challenge_\(enemyIdValue)"
        } else {
            self.id = "challenge_unknown"
        }

        // Challenge kind - default to combat for simplified format
        self.challengeKind = try container.decodeIfPresent(MiniGameChallengeKind.self, forKey: .challengeKind) ?? .combat

        // Difficulty
        self.difficulty = try container.decodeIfPresent(Int.self, forKey: .difficulty) ?? 5

        // Pressure scaling
        self.pressureScaling = try container.decodeIfPresent(Double.self, forKey: .pressureScaling) ?? 0.1

        // Content references
        self.enemyId = try container.decodeIfPresent(String.self, forKey: .enemyId)
        self.puzzleId = try container.decodeIfPresent(String.self, forKey: .puzzleId)
        self.dialogueId = try container.decodeIfPresent(String.self, forKey: .dialogueId)

        // Consequences - try full format first, then simplified
        if let victory = try container.decodeIfPresent(ChoiceConsequences.self, forKey: .victoryConsequences) {
            self.victoryConsequences = victory
        } else if let rewards = try container.decodeIfPresent(ChoiceConsequences.self, forKey: .rewards) {
            self.victoryConsequences = rewards
        } else {
            self.victoryConsequences = .none
        }

        if let defeat = try container.decodeIfPresent(ChoiceConsequences.self, forKey: .defeatConsequences) {
            self.defeatConsequences = defeat
        } else if let penalties = try container.decodeIfPresent(ChoiceConsequences.self, forKey: .penalties) {
            self.defeatConsequences = penalties
        } else {
            self.defeatConsequences = .none
        }

        self.retreatConsequences = try container.decodeIfPresent(ChoiceConsequences.self, forKey: .retreatConsequences)

        // Options
        self.canRetreat = try container.decodeIfPresent(Bool.self, forKey: .canRetreat) ?? true
        self.turnLimit = try container.decodeIfPresent(Int.self, forKey: .turnLimit) ?? 0
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(id, forKey: .id)
        try container.encode(challengeKind, forKey: .challengeKind)
        try container.encode(difficulty, forKey: .difficulty)
        try container.encode(pressureScaling, forKey: .pressureScaling)
        try container.encodeIfPresent(enemyId, forKey: .enemyId)
        try container.encodeIfPresent(puzzleId, forKey: .puzzleId)
        try container.encodeIfPresent(dialogueId, forKey: .dialogueId)
        try container.encode(victoryConsequences, forKey: .victoryConsequences)
        try container.encode(defeatConsequences, forKey: .defeatConsequences)
        try container.encodeIfPresent(retreatConsequences, forKey: .retreatConsequences)
        try container.encode(canRetreat, forKey: .canRetreat)
        try container.encode(turnLimit, forKey: .turnLimit)
    }
}

// MARK: - Mini-Game Challenge Kind

/// Types of mini-game challenges (Engine-specific, distinct from ChallengeType in EngineProtocols)
public enum MiniGameChallengeKind: String, Codable, Hashable, CaseIterable {
    /// Combat encounter with deck-building mechanics
    case combat

    /// Ritual/prayer challenge (faith-based)
    case ritual

    /// Exploration challenge (resource management)
    case exploration

    /// Dialogue/negotiation challenge
    case dialogue

    /// Puzzle challenge
    case puzzle
}

// MARK: - Mini-Game Result

/// Result returned by a mini-game module
/// Reference: EVENT_MODULE_ARCHITECTURE.md, Section 4.2
public struct MiniGameResult: Codable, Hashable {
    /// Outcome of the mini-game
    public let outcome: MiniGameOutcome

    /// State diff to apply
    public let diff: MiniGameDiff

    /// Additional data from the mini-game
    public let metadata: [String: String]

    public init(
        outcome: MiniGameOutcome,
        diff: MiniGameDiff,
        metadata: [String: String] = [:]
    ) {
        self.outcome = outcome
        self.diff = diff
        self.metadata = metadata
    }
}

/// Possible outcomes of a mini-game
public enum MiniGameOutcome: String, Codable, Hashable {
    case victory
    case defeat
    case retreat
    case timeout
}

/// State changes from a mini-game (diff-only, no direct mutation)
/// Reference: EVENT_MODULE_ARCHITECTURE.md, Invariant #2
public struct MiniGameDiff: Codable, Hashable {
    /// Resource changes
    public let resourceChanges: [String: Int]

    /// Flags to set
    public let flagsToSet: [String: Bool]

    /// Cards to add to deck
    public let cardsToAdd: [String]

    /// Cards to remove from deck
    public let cardsToRemove: [String]

    /// Balance change
    public let balanceDelta: Int

    public init(
        resourceChanges: [String: Int] = [:],
        flagsToSet: [String: Bool] = [:],
        cardsToAdd: [String] = [],
        cardsToRemove: [String] = [],
        balanceDelta: Int = 0
    ) {
        self.resourceChanges = resourceChanges
        self.flagsToSet = flagsToSet
        self.cardsToAdd = cardsToAdd
        self.cardsToRemove = cardsToRemove
        self.balanceDelta = balanceDelta
    }

    /// Empty diff (no changes)
    public static let empty = MiniGameDiff()
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Data/Definitions/QuestDefinition.swift
// ==========================================

import Foundation

// MARK: - Quest Definition
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.1
// Reference: Docs/EXPLORATION_CORE_DESIGN.md, Section 13

/// Immutable definition of a quest.
/// Runtime state (currentStage, completedObjectives) lives in QuestRuntimeState.
public struct QuestDefinition: GameDefinition {
    // MARK: - Identity

    /// Unique quest identifier (e.g., "quest_main_act1")
    public let id: String

    // MARK: - Localized Content

    /// Quest title (supports inline LocalizedString or StringKey)
    public let title: LocalizableText

    /// Quest description (supports inline LocalizedString or StringKey)
    public let description: LocalizableText

    // MARK: - Structure

    /// Ordered list of objectives (stages)
    public let objectives: [ObjectiveDefinition]

    /// Quest kind classification
    public let questKind: QuestKind

    // MARK: - Availability

    /// Conditions for this quest to become available
    public let availability: Availability

    /// If true, quest starts automatically when available
    public let autoStart: Bool

    // MARK: - Rewards

    /// Rewards given on quest completion
    public let completionRewards: QuestCompletionRewards

    /// Penalties on quest failure
    public let failurePenalties: QuestCompletionRewards

    // MARK: - Initialization

    public init(
        id: String,
        title: LocalizableText,
        description: LocalizableText,
        objectives: [ObjectiveDefinition],
        questKind: QuestKind = .side,
        availability: Availability = .always,
        autoStart: Bool = false,
        completionRewards: QuestCompletionRewards = .none,
        failurePenalties: QuestCompletionRewards = .none
    ) {
        self.id = id
        self.title = title
        self.description = description
        self.objectives = objectives
        self.questKind = questKind
        self.availability = availability
        self.autoStart = autoStart
        self.completionRewards = completionRewards
        self.failurePenalties = failurePenalties
    }
}

// MARK: - Quest Kind

/// Quest kind classification (Engine-specific, distinct from legacy QuestType)
public enum QuestKind: String, Codable, Hashable {
    case main           // Main storyline
    case side           // Optional side quest
    case exploration    // Discovery/exploration quest
    case challenge      // Optional challenge quest
}

// MARK: - Objective Definition

/// Immutable definition of a quest objective (stage).
public struct ObjectiveDefinition: Codable, Hashable, Identifiable {
    // MARK: - Identity

    /// Unique objective identifier within the quest
    public let id: String

    // MARK: - Localized Content

    /// Objective description (supports inline LocalizedString or StringKey)
    public let description: LocalizableText

    /// Objective hint (supports inline LocalizedString or StringKey, optional)
    public let hint: LocalizableText?

    // MARK: - Completion Conditions

    /// Condition type for completion
    public let completionCondition: CompletionCondition

    /// Target value for progress-based objectives
    public let targetValue: Int

    // MARK: - Flow Control

    /// If true, this objective is optional
    public let isOptional: Bool

    /// Next objective ID (nil = quest complete)
    public let nextObjectiveId: String?

    /// Alternative objective IDs (for branching)
    public let alternativeNextIds: [String]

    // MARK: - Initialization

    public init(
        id: String,
        description: LocalizableText,
        hint: LocalizableText? = nil,
        completionCondition: CompletionCondition,
        targetValue: Int = 1,
        isOptional: Bool = false,
        nextObjectiveId: String? = nil,
        alternativeNextIds: [String] = []
    ) {
        self.id = id
        self.description = description
        self.hint = hint
        self.completionCondition = completionCondition
        self.targetValue = targetValue
        self.isOptional = isOptional
        self.nextObjectiveId = nextObjectiveId
        self.alternativeNextIds = alternativeNextIds
    }
}

// MARK: - Completion Condition

/// How an objective is completed
public enum CompletionCondition: Codable, Hashable {
    /// Complete when specific flag is set
    case flagSet(String)

    /// Complete when visiting specific region
    case visitRegion(String)

    /// Complete when specific event is resolved
    case eventCompleted(String)

    /// Complete when specific choice is made
    case choiceMade(eventId: String, choiceId: String)

    /// Complete when resource threshold reached
    case resourceThreshold(resourceId: String, minValue: Int)

    /// Complete when defeating specific enemy
    case defeatEnemy(String)

    /// Complete when collecting specific item
    case collectItem(String)

    /// Complete manually (via quest progress trigger)
    case manual

    // MARK: - Custom Codable

    /// Coding keys for JSON format: {"flag_set": "value"} or {"visit_region": "value"}
    private enum CodingKeys: String, CodingKey {
        case flagSet
        case visitRegion
        case eventCompleted
        case choiceMade
        case resourceThreshold
        case defeatEnemy
        case collectItem
        case manual
        // For choiceMade sub-keys
        case eventId
        case choiceId
        // For resourceThreshold sub-keys
        case resourceId
        case minValue
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        // Try each case - JSON format is {"key": "value"} or {"key": {...}}
        if let value = try container.decodeIfPresent(String.self, forKey: .flagSet) {
            self = .flagSet(value)
            return
        }

        if let value = try container.decodeIfPresent(String.self, forKey: .visitRegion) {
            self = .visitRegion(value)
            return
        }

        if let value = try container.decodeIfPresent(String.self, forKey: .eventCompleted) {
            self = .eventCompleted(value)
            return
        }

        if let value = try container.decodeIfPresent(String.self, forKey: .defeatEnemy) {
            self = .defeatEnemy(value)
            return
        }

        if let value = try container.decodeIfPresent(String.self, forKey: .collectItem) {
            self = .collectItem(value)
            return
        }

        if container.contains(.manual) {
            self = .manual
            return
        }

        // Try nested container for choiceMade: {"choice_made": {"event_id": "...", "choice_id": "..."}}
        if container.contains(.choiceMade) {
            let nested = try container.nestedContainer(keyedBy: CodingKeys.self, forKey: .choiceMade)
            let eventId = try nested.decode(String.self, forKey: .eventId)
            let choiceId = try nested.decode(String.self, forKey: .choiceId)
            self = .choiceMade(eventId: eventId, choiceId: choiceId)
            return
        }

        // Try nested container for resourceThreshold: {"resource_threshold": {"resource_id": "...", "min_value": 10}}
        if container.contains(.resourceThreshold) {
            let nested = try container.nestedContainer(keyedBy: CodingKeys.self, forKey: .resourceThreshold)
            let resourceId = try nested.decode(String.self, forKey: .resourceId)
            let minValue = try nested.decode(Int.self, forKey: .minValue)
            self = .resourceThreshold(resourceId: resourceId, minValue: minValue)
            return
        }

        throw DecodingError.dataCorrupted(
            DecodingError.Context(
                codingPath: container.codingPath,
                debugDescription: "Unknown completion condition type"
            )
        )
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        switch self {
        case .flagSet(let value):
            try container.encode(value, forKey: .flagSet)
        case .visitRegion(let value):
            try container.encode(value, forKey: .visitRegion)
        case .eventCompleted(let value):
            try container.encode(value, forKey: .eventCompleted)
        case .choiceMade(let eventId, let choiceId):
            var nested = container.nestedContainer(keyedBy: CodingKeys.self, forKey: .choiceMade)
            try nested.encode(eventId, forKey: .eventId)
            try nested.encode(choiceId, forKey: .choiceId)
        case .resourceThreshold(let resourceId, let minValue):
            var nested = container.nestedContainer(keyedBy: CodingKeys.self, forKey: .resourceThreshold)
            try nested.encode(resourceId, forKey: .resourceId)
            try nested.encode(minValue, forKey: .minValue)
        case .defeatEnemy(let value):
            try container.encode(value, forKey: .defeatEnemy)
        case .collectItem(let value):
            try container.encode(value, forKey: .collectItem)
        case .manual:
            try container.encode(true, forKey: .manual)
        }
    }
}

// MARK: - Quest Completion Rewards

/// Rewards/penalties for quest completion (Engine-specific, distinct from legacy QuestRewards)
public struct QuestCompletionRewards: Codable, Hashable {
    /// Resource changes
    public let resourceChanges: [String: Int]

    /// Flags to set
    public let setFlags: [String]

    /// Cards to add to deck
    public let cardIds: [String]

    /// Balance change
    public let balanceDelta: Int

    public init(
        resourceChanges: [String: Int] = [:],
        setFlags: [String] = [],
        cardIds: [String] = [],
        balanceDelta: Int = 0
    ) {
        self.resourceChanges = resourceChanges
        self.setFlags = setFlags
        self.cardIds = cardIds
        self.balanceDelta = balanceDelta
    }

    /// No rewards
    public static let none = QuestCompletionRewards()
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Data/Definitions/RegionDefinition.swift
// ==========================================

import Foundation

// MARK: - Region Definition
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.1
// Reference: Docs/EXPLORATION_CORE_DESIGN.md, Section 5

/// Immutable definition of a region in the game world.
/// Runtime state (visitCount, currentState, etc.) lives in RegionRuntimeState.
public struct RegionDefinition: GameDefinition {
    // MARK: - Identity

    /// Unique region identifier (e.g., "region_01", "market_square")
    public let id: String

    // MARK: - Localized Content

    /// Region name (supports inline LocalizedString or StringKey)
    public let title: LocalizableText

    /// Region description (supports inline LocalizedString or StringKey)
    public let description: LocalizableText

    // MARK: - Type

    /// Region type string â€” must match a RegionType rawValue
    /// This determines visual representation and gameplay effects
    public let regionType: String

    // MARK: - Connections

    /// IDs of neighboring regions (for travel)
    public let neighborIds: [String]

    /// Whether this region is initially discovered
    public let initiallyDiscovered: Bool

    // MARK: - Content

    /// ID of the anchor in this region (nil if no anchor)
    public let anchorId: String?

    /// Event pool IDs for this region
    public let eventPoolIds: [String]

    // MARK: - Initial State

    /// Initial region state: "stable", "borderland", or "breach"
    public let initialState: RegionStateType

    /// Weight for random degradation selection (higher = more likely to degrade)
    public let degradationWeight: Int

    // MARK: - Initialization

    public init(
        id: String,
        title: LocalizableText,
        description: LocalizableText,
        regionType: String,
        neighborIds: [String],
        initiallyDiscovered: Bool = false,
        anchorId: String? = nil,
        eventPoolIds: [String] = [],
        initialState: RegionStateType = .stable,
        degradationWeight: Int = 1
    ) {
        self.id = id
        self.title = title
        self.description = description
        self.regionType = regionType
        self.neighborIds = neighborIds
        self.initiallyDiscovered = initiallyDiscovered
        self.anchorId = anchorId
        self.eventPoolIds = eventPoolIds
        self.initialState = initialState
        self.degradationWeight = degradationWeight
    }
}

// MARK: - Region State Types

/// Possible states for a region
public enum RegionStateType: String, Codable, Hashable, CaseIterable {
    case stable = "stable"
    case borderland = "borderland"
    case breach = "breach"

    /// Degradation order: stable -> borderland -> breach
    public var degraded: RegionStateType? {
        switch self {
        case .stable: return .borderland
        case .borderland: return .breach
        case .breach: return nil // Cannot degrade further
        }
    }

    /// Restoration order: breach -> borderland -> stable
    public var restored: RegionStateType? {
        switch self {
        case .stable: return nil // Cannot restore further
        case .borderland: return .stable
        case .breach: return .borderland
        }
    }

    /// Weight for random selection during degradation
    public var degradationSelectionWeight: Int {
        switch self {
        case .stable: return 0     // Stable regions not selected
        case .borderland: return 1
        case .breach: return 2     // Breach regions more likely
        }
    }
}



// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Migration/EventDefinitionAdapter.swift
// ==========================================

import Foundation

// MARK: - Event Definition Adapter
// Converts EventDefinition (new data-driven) to GameEvent (legacy UI-compatible)
// This enables using content packs while maintaining compatibility with existing UI

extension EventDefinition {

    /// Convert EventDefinition to legacy GameEvent for UI compatibility
    /// - Parameter regionId: Optional region ID for context-specific conversion
    /// - Returns: GameEvent compatible with existing UI
    public func toGameEvent(forRegion regionId: String? = nil) -> GameEvent {
        // Generate deterministic UUID from string ID for consistency
        let eventUUID = UUID(uuidString: id.md5UUID) ?? UUID()

        // Map event kind to legacy event type
        let eventType = mapEventKind(eventKind)

        // Map region states from availability
        let regionStates = mapRegionStates(availability.regionStates)

        // Map region types (infer from region IDs if needed)
        let regionTypes = mapRegionTypes(availability.regionIds)

        // Convert choices
        let eventChoices = choices.map { $0.toEventChoice() }

        // Create monster card for combat events
        let monsterCard = createMonsterCard(for: miniGameChallenge)

        return GameEvent(
            id: eventUUID,
            definitionId: id,  // Content Pack ID (e.g., "village_elder_request")
            eventType: eventType,
            title: title.localized,
            description: body.localized,
            regionTypes: regionTypes,
            regionStates: regionStates,
            choices: eventChoices,
            questLinks: extractQuestLinks(),
            oneTime: isOneTime,
            completed: false,
            monsterCard: monsterCard,
            instant: isInstant,
            weight: weight,
            minTension: availability.minPressure,
            maxTension: availability.maxPressure,
            requiredFlags: availability.requiredFlags.isEmpty ? nil : availability.requiredFlags,
            forbiddenFlags: availability.forbiddenFlags.isEmpty ? nil : availability.forbiddenFlags
        )
    }

    // MARK: - Private Mapping Helpers

    private func mapEventKind(_ kind: EventKind) -> EventType {
        switch kind {
        case .inline:
            return .narrative
        case .miniGame(let miniGameKind):
            switch miniGameKind {
            case .combat:
                return .combat
            case .ritual:
                return .ritual
            case .exploration:
                return .exploration
            case .dialogue:
                return .narrative
            case .puzzle:
                return .ritual
            }
        }
    }

    private func mapRegionStates(_ stateStrings: [String]?) -> [RegionState] {
        guard let states = stateStrings else {
            return [.stable, .borderland, .breach] // Default: all states
        }

        return states.compactMap { stateString in
            switch stateString.lowercased() {
            case "stable": return .stable
            case "borderland": return .borderland
            case "breach": return .breach
            default: return nil
            }
        }
    }

    private func mapRegionTypes(_ regionIds: [String]?) -> [RegionType] {
        guard let ids = regionIds else {
            return [] // Empty = any region type
        }

        // Look up region types from ContentRegistry (no hardcoded ID mapping)
        var types = Set<RegionType>()
        for regionId in ids {
            if let regionDef = ContentRegistry.shared.getRegion(id: regionId) {
                // Map regionType string from definition to RegionType enum
                let regionType = mapRegionTypeString(regionDef.regionType)
                types.insert(regionType)
            }
        }
        return Array(types)
    }

    private func mapRegionTypeString(_ typeString: String) -> RegionType {
        RegionType(rawValue: typeString.lowercased()) ?? .settlement
    }

    private func extractQuestLinks() -> [String] {
        // Extract quest links from choice consequences
        var links: [String] = []
        for choice in choices {
            if let questProgress = choice.consequences.questProgress {
                links.append(questProgress.questId)
            }
        }
        return links
    }

    private func createMonsterCard(for challenge: MiniGameChallengeDefinition?) -> Card? {
        guard let challenge = challenge,
              let enemyId = challenge.enemyId else { return nil }

        // First, try to get enemy from ContentRegistry
        if let enemy = ContentRegistry.shared.getEnemy(id: enemyId) {
            return enemy.toCard()
        }

        // Fallback: Create from hardcoded stats
        let enemyStats = getEnemyStats(for: enemyId, difficulty: challenge.difficulty)

        return Card(
            id: UUID(),
            definitionId: enemyId,  // Content Pack ID for tracking
            name: enemyId.replacingOccurrences(of: "_", with: " ").capitalized,
            type: .monster,
            rarity: difficultyToRarity(challenge.difficulty),
            description: "Enemy: \(enemyId)",
            power: enemyStats.power,
            defense: enemyStats.defense,
            health: enemyStats.health
        )
    }

    private func getEnemyStats(for enemyId: String, difficulty: Int) -> (health: Int, power: Int, defense: Int) {
        // Try to get stats from ContentRegistry (data-driven)
        if let enemyDef = ContentRegistry.shared.getEnemy(id: enemyId) {
            return (health: enemyDef.health, power: enemyDef.power, defense: enemyDef.defense)
        }

        // Fallback: base stats scaled by difficulty (no game-specific IDs)
        let baseHealth = 5 + (difficulty * 3)
        let basePower = 2 + difficulty
        let baseDefense = 1 + (difficulty / 2)
        return (health: baseHealth, power: basePower, defense: baseDefense)
    }

    private func difficultyToRarity(_ difficulty: Int) -> CardRarity {
        switch difficulty {
        case 1: return .common
        case 2: return .uncommon
        case 3: return .rare
        case 4...5: return .epic
        default: return .legendary
        }
    }
}

// MARK: - Choice Definition to Event Choice

extension ChoiceDefinition {

    /// Convert ChoiceDefinition to legacy EventChoice
    public func toEventChoice() -> EventChoice {
        return EventChoice(
            id: id,
            text: label.localized,
            requirements: requirements?.toEventRequirements(),
            consequences: consequences.toEventConsequences()
        )
    }
}

// MARK: - Choice Requirements Conversion

extension ChoiceRequirements {

    /// Convert to legacy EventRequirements
    public func toEventRequirements() -> EventRequirements {
        var requirements = EventRequirements()

        // Map resource requirements
        if let faith = minResources["faith"] {
            requirements.minimumFaith = faith
        }
        if let health = minResources["health"] {
            requirements.minimumHealth = health
        }

        // Map balance requirements
        if let minBal = minBalance {
            if minBal >= 70 {
                requirements.requiredBalance = .light
            } else if let maxBal = maxBalance, maxBal <= 30 {
                requirements.requiredBalance = .dark
            }
        }

        // Map flag requirements
        if !requiredFlags.isEmpty {
            requirements.requiredFlags = requiredFlags
        }

        return requirements
    }
}

// MARK: - Choice Consequences Conversion

extension ChoiceConsequences {

    /// Convert to legacy EventConsequences
    public func toEventConsequences() -> EventConsequences {
        var consequences = EventConsequences()

        // Map resource changes
        if let faith = resourceChanges["faith"] {
            consequences.faithChange = faith
        }
        if let health = resourceChanges["health"] {
            consequences.healthChange = health
        }

        // Map balance change
        if balanceDelta != 0 {
            consequences.balanceChange = balanceDelta
        }

        // Map flags
        if !setFlags.isEmpty {
            var flagDict: [String: Bool] = [:]
            for flag in setFlags {
                flagDict[flag] = true
            }
            for flag in clearFlags {
                flagDict[flag] = false
            }
            consequences.setFlags = flagDict
        }

        // Map region state change to anchor integrity
        if let stateChange = regionStateChange,
           let transition = stateChange.transition {
            switch transition {
            case .restore:
                consequences.anchorIntegrityChange = 20
            case .degrade:
                consequences.anchorIntegrityChange = -20
            }
        }

        // Result message from result key
        if let resultKey = resultKey {
            consequences.message = resultKey.replacingOccurrences(of: "_", with: " ").capitalized
        }

        return consequences
    }
}

// MARK: - String UUID Extension

private extension String {
    /// Generate a deterministic UUID-like string from this string
    var md5UUID: String {
        // Simple hash-based UUID generation for determinism
        var hash: UInt64 = 5381
        for char in self.utf8 {
            hash = ((hash << 5) &+ hash) &+ UInt64(char)
        }

        // Format as UUID string (simplified)
        let hex = String(format: "%016llX", hash)
        let padded = hex.padding(toLength: 32, withPad: "0", startingAt: 0)

        // Insert dashes: 8-4-4-4-12
        let chars = Array(padded)
        return "\(String(chars[0..<8]))-\(String(chars[8..<12]))-\(String(chars[12..<16]))-\(String(chars[16..<20]))-\(String(chars[20..<32]))"
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Migration/QuestDefinitionAdapter.swift
// ==========================================

import Foundation

// MARK: - Quest Definition Adapter
// Converts QuestDefinition (new data-driven) to Quest (legacy UI-compatible)
// This enables using content packs while maintaining compatibility with existing UI

extension QuestDefinition {

    /// Convert QuestDefinition to legacy Quest for UI compatibility
    /// - Returns: Quest compatible with existing UI
    public func toQuest() -> Quest {
        // Generate deterministic UUID from string ID for consistency
        let questUUID = UUID(uuidString: id.md5UUID) ?? UUID()

        // Map quest kind to legacy quest type
        let questType = mapQuestKind(questKind)

        // Convert objectives
        let legacyObjectives = objectives.map { $0.toQuestObjective() }

        // Convert rewards
        let rewards = completionRewards.toQuestRewards()

        return Quest(
            id: questUUID,
            definitionId: id,  // Content Pack ID for QuestTriggerEngine
            title: title.localized,
            description: description.localized,
            questType: questType,
            stage: 0,
            objectives: legacyObjectives,
            rewards: rewards,
            completed: false
        )
    }

    // MARK: - Private Mapping Helpers

    private func mapQuestKind(_ kind: QuestKind) -> QuestType {
        switch kind {
        case .main:
            return .main
        case .side, .exploration, .challenge:
            return .side
        }
    }
}

// MARK: - Objective Definition to Quest Objective

extension ObjectiveDefinition {

    /// Convert ObjectiveDefinition to legacy QuestObjective
    public func toQuestObjective() -> QuestObjective {
        // Generate deterministic UUID from string ID
        let objectiveUUID = UUID(uuidString: id.md5UUID) ?? UUID()

        // Extract required flags from completion condition
        let requiredFlags = extractRequiredFlags(from: completionCondition)

        return QuestObjective(
            id: objectiveUUID,
            description: description.localized,
            completed: false,
            requiredFlags: requiredFlags
        )
    }

    private func extractRequiredFlags(from condition: CompletionCondition) -> [String]? {
        switch condition {
        case .flagSet(let flag):
            return [flag]
        case .eventCompleted(let eventId):
            return ["\(eventId)_completed"]
        case .choiceMade(let eventId, let choiceId):
            return ["\(eventId)_\(choiceId)_chosen"]
        case .visitRegion(let regionId):
            return ["visited_\(regionId)"]
        case .defeatEnemy(let enemyId):
            return ["defeated_\(enemyId)"]
        case .collectItem(let itemId):
            return ["collected_\(itemId)"]
        case .resourceThreshold, .manual:
            return nil
        }
    }
}

// MARK: - Quest Completion Rewards to Quest Rewards

extension QuestCompletionRewards {

    /// Convert to legacy QuestRewards
    public func toQuestRewards() -> QuestRewards {
        let faith = resourceChanges["faith"]
        let cards = cardIds.isEmpty ? nil : cardIds

        return QuestRewards(
            faith: faith,
            cards: cards,
            artifact: nil,  // Artifacts not supported in new format yet
            experience: nil  // Experience not supported in new format yet
        )
    }
}

// MARK: - String UUID Extension (reuse from EventDefinitionAdapter)

private extension String {
    /// Generate a deterministic UUID-like string from this string
    var md5UUID: String {
        // Simple hash-based UUID generation for determinism
        var hash: UInt64 = 5381
        for char in self.utf8 {
            hash = ((hash << 5) &+ hash) &+ UInt64(char)
        }

        // Format as UUID string (simplified)
        let hex = String(format: "%016llX", hash)
        let padded = hex.padding(toLength: 32, withPad: "0", startingAt: 0)

        // Insert dashes: 8-4-4-4-12
        let chars = Array(padded)
        return "\(String(chars[0..<8]))-\(String(chars[8..<12]))-\(String(chars[12..<16]))-\(String(chars[16..<20]))-\(String(chars[20..<32]))"
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Story/StoryDirector.swift
// ==========================================

import Foundation

// MARK: - Story Director Protocol
// Dynamic event composition and quest management system
// Makes each game session unique and the world feel alive

/// Protocol for story management - selects events, manages quest flow
/// Different campaigns can have different Director implementations
public protocol StoryDirector {

    // MARK: - Event Selection

    /// Select the next event for a region based on current context
    /// Returns nil if no suitable events are available
    func selectEvent(
        forRegion regionId: String,
        context: StoryContext,
        using rng: inout WorldRNG
    ) -> EventDefinition?

    /// Get all events available in current context (for debugging/testing)
    func getAvailableEvents(context: StoryContext) -> [EventDefinition]

    // MARK: - Action Processing

    /// Process a completed action and return story updates
    /// This is called after every game action to update quests, unlock events, etc.
    func processAction(
        _ action: StoryAction,
        context: StoryContext
    ) -> StoryUpdate

    // MARK: - Quest Management

    /// Get currently active quests
    func getActiveQuests(context: StoryContext) -> [QuestDefinition]

    /// Check if victory conditions are met
    func checkVictoryConditions(context: StoryContext) -> VictoryCheck

    /// Check if defeat conditions are met
    func checkDefeatConditions(context: StoryContext) -> DefeatCheck
}

// MARK: - Story Context

/// All context needed for story decisions
public struct StoryContext {
    // World State
    let currentRegionId: String
    let regionStates: [String: RegionStateType]
    let worldTension: Int
    let currentDay: Int

    // Player State
    let playerHealth: Int
    let playerFaith: Int
    let playerBalance: Int

    // Quest State
    let activeQuestIds: Set<String>
    let completedQuestIds: Set<String>
    let questObjectiveStates: [String: Set<String>]  // questId -> completed objective IDs

    // Flags & History
    let worldFlags: [String: Bool]
    let completedEventIds: Set<String>
    let visitedRegionIds: Set<String>

    // Campaign Info
    let campaignId: String
    let actNumber: Int
}

// MARK: - Story Action

/// Actions that affect story progression
public enum StoryAction {
    case visitedRegion(regionId: String)
    case completedEvent(eventId: String, choiceId: String)
    case defeatedEnemy(enemyId: String)
    case dayPassed(newDay: Int)
    case tensionChanged(newTension: Int)
    case flagSet(flagName: String, value: Bool)
    case anchorChanged(regionId: String, newIntegrity: Int)
}

// MARK: - Story Update

/// Result of story processing - what changed
public struct StoryUpdate {
    /// Quest progress updates
    let questUpdates: [QuestProgressUpdate]

    /// Newly unlocked events
    let unlockedEvents: [String]

    /// Events that became unavailable
    let lockedEvents: [String]

    /// World flags to set
    let flagsToSet: [String: Bool]

    /// Narrative messages to display
    let narrativeMessages: [LocalizedString]

    /// If set, game has ended
    let gameEnding: GameEnding?

    public static let none = StoryUpdate(
        questUpdates: [],
        unlockedEvents: [],
        lockedEvents: [],
        flagsToSet: [:],
        narrativeMessages: [],
        gameEnding: nil
    )
}

// MARK: - Game Ending

/// How the game ended
public enum GameEnding {
    case victory(endingId: String, description: LocalizedString)
    case defeat(reason: DefeatReason, description: LocalizedString)
}

public enum DefeatReason {
    case healthZero
    case tensionMax
    case questFailed
    case anchorDestroyed
}

// MARK: - Victory/Defeat Checks

public struct VictoryCheck {
    let isVictory: Bool
    let endingId: String?
    let description: LocalizedString?
}

public struct DefeatCheck {
    let isDefeat: Bool
    let reason: DefeatReason?
    let description: LocalizedString?
}

// MARK: - Event Pool

/// Pool of events for a specific context
public struct EventPool {
    let id: String
    let events: [EventDefinition]
    let selectionStrategy: EventSelectionStrategy
}

public enum EventSelectionStrategy {
    case weighted      // Use event weights
    case sequential    // In order (for story events)
    case random        // Pure random
    case priority      // Highest priority first
}

// MARK: - Default Implementation

/// Base implementation with common logic
public class BaseStoryDirector: StoryDirector {

    let contentRegistry: ContentRegistry
    let questTriggerEngine: QuestTriggerEngine

    init(contentRegistry: ContentRegistry = .shared) {
        self.contentRegistry = contentRegistry
        self.questTriggerEngine = QuestTriggerEngine(contentRegistry: contentRegistry)
    }

    // MARK: - Event Selection

    public func selectEvent(
        forRegion regionId: String,
        context: StoryContext,
        using rng: inout WorldRNG
    ) -> EventDefinition? {
        let available = getAvailableEvents(context: context)
            .filter { event in
                // Filter by region
                if let regionIds = event.availability.regionIds, !regionIds.isEmpty {
                    return regionIds.contains(regionId)
                }
                return true
            }

        guard !available.isEmpty else { return nil }

        // Weighted random selection
        let totalWeight = available.reduce(0) { $0 + $1.weight }
        var roll = rng.nextInt(in: 1...totalWeight)

        for event in available {
            roll -= event.weight
            if roll <= 0 {
                return event
            }
        }

        return available.last
    }

    public func getAvailableEvents(context: StoryContext) -> [EventDefinition] {
        return contentRegistry.getAllEvents().filter { event in
            isEventAvailable(event, context: context)
        }
    }

    /// Check if an event is available in current context
    func isEventAvailable(_ event: EventDefinition, context: StoryContext) -> Bool {
        // Check one-time events
        if event.isOneTime && context.completedEventIds.contains(event.id) {
            return false
        }

        // Check required flags
        for flag in event.availability.requiredFlags {
            if context.worldFlags[flag] != true {
                return false
            }
        }

        // Check forbidden flags
        for flag in event.availability.forbiddenFlags {
            if context.worldFlags[flag] == true {
                return false
            }
        }

        // Check tension range
        if let minPressure = event.availability.minPressure {
            if context.worldTension < minPressure {
                return false
            }
        }
        if let maxPressure = event.availability.maxPressure {
            if context.worldTension > maxPressure {
                return false
            }
        }

        // Check region states
        if let regionStates = event.availability.regionStates, !regionStates.isEmpty {
            let currentState = context.regionStates[context.currentRegionId]?.rawValue ?? "stable"
            if !regionStates.contains(currentState) {
                return false
            }
        }

        return true
    }

    // MARK: - Action Processing

    public func processAction(_ action: StoryAction, context: StoryContext) -> StoryUpdate {
        // Convert to QuestTriggerAction
        let triggerAction = convertToTriggerAction(action)

        // Build trigger context
        let triggerContext = buildTriggerContext(from: context)

        // Process through quest trigger engine
        let questUpdates = questTriggerEngine.processAction(triggerAction, context: triggerContext)

        // Collect flags to set
        var flagsToSet: [String: Bool] = [:]
        for update in questUpdates {
            for flag in update.flagsToSet {
                flagsToSet[flag] = true
            }
        }

        // Check for game ending
        let victoryCheck = checkVictoryConditions(context: context)
        let defeatCheck = checkDefeatConditions(context: context)

        var gameEnding: GameEnding? = nil
        if victoryCheck.isVictory {
            gameEnding = .victory(
                endingId: victoryCheck.endingId ?? "default",
                description: victoryCheck.description ?? LocalizedString(en: "Victory!", ru: "ÐŸÐ¾Ð±ÐµÐ´Ð°!")
            )
        } else if defeatCheck.isDefeat {
            gameEnding = .defeat(
                reason: defeatCheck.reason ?? .healthZero,
                description: defeatCheck.description ?? LocalizedString(en: "Defeat", ru: "ÐŸÐ¾Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ")
            )
        }

        return StoryUpdate(
            questUpdates: questUpdates,
            unlockedEvents: [],
            lockedEvents: [],
            flagsToSet: flagsToSet,
            narrativeMessages: [],
            gameEnding: gameEnding
        )
    }

    // MARK: - Quest Management

    public func getActiveQuests(context: StoryContext) -> [QuestDefinition] {
        return context.activeQuestIds.compactMap { contentRegistry.getQuest(id: $0) }
    }

    public func checkVictoryConditions(context: StoryContext) -> VictoryCheck {
        // Default: check for act completion flag
        let actCompletedFlag = "act\(context.actNumber)_completed"
        if context.worldFlags[actCompletedFlag] == true {
            return VictoryCheck(
                isVictory: true,
                endingId: "act\(context.actNumber)_standard",
                description: LocalizedString(
                    en: "Act \(context.actNumber) completed!",
                    ru: "ÐÐºÑ‚ \(context.actNumber) Ð·Ð°Ð²ÐµÑ€ÑˆÑ‘Ð½!"
                )
            )
        }
        return VictoryCheck(isVictory: false, endingId: nil, description: nil)
    }

    public func checkDefeatConditions(context: StoryContext) -> DefeatCheck {
        // Check health
        if context.playerHealth <= 0 {
            return DefeatCheck(
                isDefeat: true,
                reason: .healthZero,
                description: LocalizedString(en: "You have fallen...", ru: "Ð’Ñ‹ Ð¿Ð°Ð»Ð¸...")
            )
        }

        // Check tension
        if context.worldTension >= 100 {
            return DefeatCheck(
                isDefeat: true,
                reason: .tensionMax,
                description: LocalizedString(
                    en: "The darkness has consumed the world...",
                    ru: "Ð¢ÑŒÐ¼Ð° Ð¿Ð¾Ð³Ð»Ð¾Ñ‚Ð¸Ð»Ð° Ð¼Ð¸Ñ€..."
                )
            )
        }

        return DefeatCheck(isDefeat: false, reason: nil, description: nil)
    }

    // MARK: - Helpers

    private func convertToTriggerAction(_ action: StoryAction) -> QuestTriggerAction {
        switch action {
        case .visitedRegion(let regionId):
            return .visitedRegion(regionId: regionId)
        case .completedEvent(let eventId, let choiceId):
            return .completedEvent(eventId: eventId, choiceId: choiceId)
        case .defeatedEnemy(let enemyId):
            return .defeatedEnemy(enemyId: enemyId)
        case .flagSet(let flagName, _):
            return .flagSet(flagName: flagName)
        case .dayPassed, .tensionChanged, .anchorChanged:
            // These don't directly trigger quest objectives
            return .resourceChanged(resourceId: "day", newValue: 0)
        }
    }

    private func buildTriggerContext(from context: StoryContext) -> QuestTriggerContext {
        let activeQuests = context.activeQuestIds.compactMap { questId -> QuestState? in
            guard let quest = contentRegistry.getQuest(id: questId) else { return nil }
            let completedIds = context.questObjectiveStates[questId] ?? []
            let currentObjectiveId = quest.objectives.first { !completedIds.contains($0.id) }?.id
            return QuestState(
                definitionId: questId,
                currentObjectiveId: currentObjectiveId,
                completedObjectiveIds: completedIds
            )
        }

        return QuestTriggerContext(
            activeQuests: activeQuests,
            completedQuestIds: context.completedQuestIds,
            worldFlags: context.worldFlags,
            resources: [
                "health": context.playerHealth,
                "faith": context.playerFaith,
                "balance": context.playerBalance,
                "tension": context.worldTension
            ],
            currentDay: context.currentDay,
            currentRegionId: context.currentRegionId
        )
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Localization/L10nStub.swift
// ==========================================

import Foundation

// MARK: - L10n Stub
// Provides localized strings for the TwilightEngine package
// This is a stub that returns Russian strings directly
// In production, these would come from the LocalizationManager

/// Localization enum for TwilightEngine package
public enum L10n {
    // MARK: - Region States
    case regionStateStable
    case regionStateBorderland
    case regionStateBreach

    // MARK: - Region Types
    case regionTypeForest
    case regionTypeSwamp
    case regionTypeMountain
    case regionTypeSettlement
    case regionTypeWater
    case regionTypeWasteland
    case regionTypeSacred

    // MARK: - Combat Modifiers
    case combatModifierBorderland
    case combatModifierBreach

    // MARK: - Anchor Types
    case anchorTypeShrine
    case anchorTypeBarrow
    case anchorTypeSacredTree
    case anchorTypeStoneIdol
    case anchorTypeSpring
    case anchorTypeChapel
    case anchorTypeTemple
    case anchorTypeCross

    // MARK: - Event Types
    case eventTypeCombat
    case eventTypeRitual
    case eventTypeNarrative
    case eventTypeExploration
    case eventTypeWorldShift

    // MARK: - Curses (display names)
    case curseWeakness
    case curseFear
    case curseExhaustion
    case curseGreed
    case curseShadowOfNav
    case curseBloodCurse
    case curseSealOfNav

    // MARK: - Curse Names (full)
    case curseWeaknessName
    case curseFearName
    case curseExhaustionName
    case curseGreedName
    case curseShadowOfNavName
    case curseBloodCurseName
    case curseSealOfNavName

    // MARK: - Curse Descriptions
    case curseWeaknessDescription
    case curseFearDescription
    case curseExhaustionDescription
    case curseGreedDescription
    case curseShadowOfNavDescription
    case curseBloodCurseDescription
    case curseSealOfNavDescription

    // MARK: - Combat Calculator
    case calcHit
    case calcMiss
    case calcAttackVsDefense
    case calcStrength
    case calcBonusDice
    case calcBonusDamage
    case calcDamage
    case calcBaseDamage
    case calcHeroAbilityDice
    case calcHeroAbility
    case calcCurseWeakness
    case calcCurseShadowOfNav

    // MARK: - Error Messages
    case errorInvalidAction
    case errorRegionNotAccessible
    case errorRegionNotNeighbor
    case errorActionNotAvailable
    case errorInsufficientResources
    case errorHealthTooLow
    case errorGameNotInProgress
    case errorCombatInProgress
    case errorEventInProgress
    case errorNoActiveEvent
    case errorNoActiveCombat
    case errorEventNotFound
    case errorInvalidChoiceIndex
    case errorChoiceRequirementsNotMet
    case errorCardNotInHand
    case errorNotEnoughActions
    case errorInvalidTarget

    // MARK: - Localized String

    public var localized: String {
        switch self {
        // Region States
        case .regionStateStable: return "Ð¡Ñ‚Ð°Ð±Ð¸Ð»ÑŒÐ½Ñ‹Ð¹"
        case .regionStateBorderland: return "ÐŸÐ¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÑŒÐµ"
        case .regionStateBreach: return "ÐŸÑ€Ð¾Ñ€Ñ‹Ð²"

        // Region Types
        case .regionTypeForest: return "Ð›ÐµÑ"
        case .regionTypeSwamp: return "Ð‘Ð¾Ð»Ð¾Ñ‚Ð¾"
        case .regionTypeMountain: return "Ð“Ð¾Ñ€Ñ‹"
        case .regionTypeSettlement: return "ÐŸÐ¾ÑÐµÐ»ÐµÐ½Ð¸Ðµ"
        case .regionTypeWater: return "Ð’Ð¾Ð´Ð¾Ñ‘Ð¼"
        case .regionTypeWasteland: return "ÐŸÑƒÑÑ‚Ð¾ÑˆÑŒ"
        case .regionTypeSacred: return "Ð¡Ð²ÑÑ‰ÐµÐ½Ð½Ð¾Ðµ Ð¼ÐµÑÑ‚Ð¾"

        // Combat Modifiers
        case .combatModifierBorderland: return "ÐŸÐ¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÑŒÐµ: Ð²Ñ€Ð°Ð³Ð¸ +1 Ðº Ð°Ñ‚Ð°ÐºÐµ"
        case .combatModifierBreach: return "ÐŸÑ€Ð¾Ñ€Ñ‹Ð²: Ð²Ñ€Ð°Ð³Ð¸ +2 Ðº Ð°Ñ‚Ð°ÐºÐµ Ð¸ Ð·Ð°Ñ‰Ð¸Ñ‚Ðµ"

        // Anchor Types
        case .anchorTypeShrine: return "ÐšÐ°Ð¿Ð¸Ñ‰Ðµ"
        case .anchorTypeBarrow: return "ÐšÑƒÑ€Ð³Ð°Ð½"
        case .anchorTypeSacredTree: return "Ð¡Ð²ÑÑ‰ÐµÐ½Ð½Ñ‹Ð¹ Ð´ÑƒÐ±"
        case .anchorTypeStoneIdol: return "ÐšÐ°Ð¼ÐµÐ½Ð½Ð°Ñ Ð±Ð°Ð±Ð°"
        case .anchorTypeSpring: return "Ð Ð¾Ð´Ð½Ð¸Ðº"
        case .anchorTypeChapel: return "Ð§Ð°ÑÐ¾Ð²Ð½Ñ"
        case .anchorTypeTemple: return "Ð¥Ñ€Ð°Ð¼"
        case .anchorTypeCross: return "ÐžÐ±ÐµÑ‚Ð½Ñ‹Ð¹ ÐºÑ€ÐµÑÑ‚"

        // Event Types
        case .eventTypeCombat: return "Ð‘Ð¾Ð¹"
        case .eventTypeRitual: return "Ð Ð¸Ñ‚ÑƒÐ°Ð»"
        case .eventTypeNarrative: return "Ð¡Ð¾Ð±Ñ‹Ñ‚Ð¸Ðµ"
        case .eventTypeExploration: return "Ð˜ÑÑÐ»ÐµÐ´Ð¾Ð²Ð°Ð½Ð¸Ðµ"
        case .eventTypeWorldShift: return "Ð¡Ð´Ð²Ð¸Ð³ Ð¼Ð¸Ñ€Ð°"

        // Curses (short names)
        case .curseWeakness: return "Ð¡Ð»Ð°Ð±Ð¾ÑÑ‚ÑŒ"
        case .curseFear: return "Ð¡Ñ‚Ñ€Ð°Ñ…"
        case .curseExhaustion: return "Ð˜ÑÑ‚Ð¾Ñ‰ÐµÐ½Ð¸Ðµ"
        case .curseGreed: return "Ð–Ð°Ð´Ð½Ð¾ÑÑ‚ÑŒ"
        case .curseShadowOfNav: return "Ð¢ÐµÐ½ÑŒ ÐÐ°Ð²Ð¸"
        case .curseBloodCurse: return "ÐŸÑ€Ð¾ÐºÐ»ÑÑ‚Ð¸Ðµ ÐºÑ€Ð¾Ð²Ð¸"
        case .curseSealOfNav: return "ÐŸÐµÑ‡Ð°Ñ‚ÑŒ ÐÐ°Ð²Ð¸"

        // Curse Names (full)
        case .curseWeaknessName: return "Ð¡Ð»Ð°Ð±Ð¾ÑÑ‚ÑŒ"
        case .curseFearName: return "Ð¡Ñ‚Ñ€Ð°Ñ…"
        case .curseExhaustionName: return "Ð˜ÑÑ‚Ð¾Ñ‰ÐµÐ½Ð¸Ðµ"
        case .curseGreedName: return "Ð–Ð°Ð´Ð½Ð¾ÑÑ‚ÑŒ"
        case .curseShadowOfNavName: return "Ð¢ÐµÐ½ÑŒ ÐÐ°Ð²Ð¸"
        case .curseBloodCurseName: return "ÐŸÑ€Ð¾ÐºÐ»ÑÑ‚Ð¸Ðµ ÐºÑ€Ð¾Ð²Ð¸"
        case .curseSealOfNavName: return "ÐŸÐµÑ‡Ð°Ñ‚ÑŒ ÐÐ°Ð²Ð¸"

        // Curse Descriptions
        case .curseWeaknessDescription: return "-1 Ðº ÑƒÑ€Ð¾Ð½Ñƒ Ð´Ð¾ ÐºÐ¾Ð½Ñ†Ð° Ð±Ð¾Ñ"
        case .curseFearDescription: return "-1 Ðº Ð·Ð°Ñ‰Ð¸Ñ‚Ðµ Ð´Ð¾ ÐºÐ¾Ð½Ñ†Ð° Ð±Ð¾Ñ"
        case .curseExhaustionDescription: return "-1 Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ Ð² ÑÑ‚Ð¾Ð¼ Ñ…Ð¾Ð´Ñƒ"
        case .curseGreedDescription: return "+2 Ð²ÐµÑ€Ñ‹, Ð½Ð¾ WorldTension +1"
        case .curseShadowOfNavDescription: return "+3 ÑƒÑ€Ð¾Ð½Ð°, Ð½Ð¾ -2 HP"
        case .curseBloodCurseDescription: return "ÐŸÑ€Ð¸ ÑƒÐ±Ð¸Ð¹ÑÑ‚Ð²Ðµ +2 HP, Ð±Ð°Ð»Ð°Ð½Ñ Ðº Ñ‚ÑŒÐ¼Ðµ"
        case .curseSealOfNavDescription: return "ÐÐµÐ»ÑŒÐ·Ñ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Sustain ÐºÐ°Ñ€Ñ‚Ñ‹"

        // Combat Calculator
        case .calcHit: return "ÐŸÐ¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ðµ!"
        case .calcMiss: return "ÐŸÑ€Ð¾Ð¼Ð°Ñ…!"
        case .calcAttackVsDefense: return "ÐÑ‚Ð°ÐºÐ° vs Ð—Ð°Ñ‰Ð¸Ñ‚Ð°"
        case .calcStrength: return "Ð¡Ð¸Ð»Ð°"
        case .calcBonusDice: return "Ð‘Ð¾Ð½ÑƒÑÐ½Ñ‹Ðµ ÐºÑƒÐ±Ð¸ÐºÐ¸"
        case .calcBonusDamage: return "Ð‘Ð¾Ð½ÑƒÑÐ½Ñ‹Ð¹ ÑƒÑ€Ð¾Ð½"
        case .calcDamage: return "Ð£Ñ€Ð¾Ð½"
        case .calcBaseDamage: return "Ð‘Ð°Ð·Ð¾Ð²Ñ‹Ð¹ ÑƒÑ€Ð¾Ð½"
        case .calcHeroAbilityDice: return "Ð¡Ð¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚ÑŒ Ð³ÐµÑ€Ð¾Ñ (ÐºÑƒÐ±Ð¸ÐºÐ¸)"
        case .calcHeroAbility: return "Ð¡Ð¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚ÑŒ Ð³ÐµÑ€Ð¾Ñ"
        case .calcCurseWeakness: return "ÐŸÑ€Ð¾ÐºÐ»ÑÑ‚Ð¸Ðµ: Ð¡Ð»Ð°Ð±Ð¾ÑÑ‚ÑŒ"
        case .calcCurseShadowOfNav: return "ÐŸÑ€Ð¾ÐºÐ»ÑÑ‚Ð¸Ðµ: Ð¢ÐµÐ½ÑŒ ÐÐ°Ð²Ð¸"

        // Error Messages
        case .errorInvalidAction: return "ÐÐµÐ´Ð¾Ð¿ÑƒÑÑ‚Ð¸Ð¼Ð¾Ðµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ"
        case .errorRegionNotAccessible: return "Ð ÐµÐ³Ð¸Ð¾Ð½ Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½"
        case .errorRegionNotNeighbor: return "Ð ÐµÐ³Ð¸Ð¾Ð½ Ð½Ðµ ÑÐ²Ð»ÑÐµÑ‚ÑÑ ÑÐ¾ÑÐµÐ´Ð½Ð¸Ð¼"
        case .errorActionNotAvailable: return "Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾ Ð² ÑÑ‚Ð¾Ð¼ Ñ€ÐµÐ³Ð¸Ð¾Ð½Ðµ"
        case .errorInsufficientResources: return "ÐÐµÐ´Ð¾ÑÑ‚Ð°Ñ‚Ð¾Ñ‡Ð½Ð¾ Ñ€ÐµÑÑƒÑ€ÑÐ¾Ð²"
        case .errorHealthTooLow: return "Ð¡Ð»Ð¸ÑˆÐºÐ¾Ð¼ Ð¼Ð°Ð»Ð¾ Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÑ"
        case .errorGameNotInProgress: return "Ð˜Ð³Ñ€Ð° Ð½Ðµ Ð·Ð°Ð¿ÑƒÑ‰ÐµÐ½Ð°"
        case .errorCombatInProgress: return "Ð˜Ð´Ñ‘Ñ‚ Ð±Ð¾Ð¹"
        case .errorEventInProgress: return "Ð¡Ð¾Ð±Ñ‹Ñ‚Ð¸Ðµ Ð² Ð¿Ñ€Ð¾Ñ†ÐµÑÑÐµ"
        case .errorNoActiveEvent: return "ÐÐµÑ‚ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð¾Ð³Ð¾ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ñ"
        case .errorNoActiveCombat: return "ÐÐµÑ‚ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð¾Ð³Ð¾ Ð±Ð¾Ñ"
        case .errorEventNotFound: return "Ð¡Ð¾Ð±Ñ‹Ñ‚Ð¸Ðµ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾"
        case .errorInvalidChoiceIndex: return "ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð¸Ð½Ð´ÐµÐºÑ Ð²Ñ‹Ð±Ð¾Ñ€Ð°"
        case .errorChoiceRequirementsNotMet: return "Ð¢Ñ€ÐµÐ±Ð¾Ð²Ð°Ð½Ð¸Ñ Ð²Ñ‹Ð±Ð¾Ñ€Ð° Ð½Ðµ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ñ‹"
        case .errorCardNotInHand: return "ÐšÐ°Ñ€Ñ‚Ð° Ð½Ðµ Ð² Ñ€ÑƒÐºÐµ"
        case .errorNotEnoughActions: return "ÐÐµÐ´Ð¾ÑÑ‚Ð°Ñ‚Ð¾Ñ‡Ð½Ð¾ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ð¹"
        case .errorInvalidTarget: return "ÐÐµÐ²ÐµÑ€Ð½Ð°Ñ Ñ†ÐµÐ»ÑŒ"
        }
    }

    // MARK: - Localized with Arguments

    public func localized(with args: CVarArg...) -> String {
        let format = self.localized
        return String(format: format, arguments: args)
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Localization/LocalizableText.swift
// ==========================================

import Foundation

// MARK: - Localizable Text
// Reference: Docs/ENGINE_ARCHITECTURE.md
// Supports both legacy inline LocalizedString and new StringKey approaches

/// Represents text that can be localized in two ways:
/// 1. Legacy inline LocalizedString: { "en": "...", "ru": "..." }
/// 2. New StringKey: "card.strike.name" (references external string tables)
///
/// This enum enables gradual migration from inline translations to string tables
/// while maintaining full backward compatibility with existing content packs.
public enum LocalizableText: Hashable {
    /// Legacy: embedded translations in the JSON content
    case inline(LocalizedString)

    /// New: reference to external string table entry
    case key(StringKey)

    // MARK: - Resolution

    /// Resolve to actual text using shared LocalizationManager
    public var resolved: String {
        switch self {
        case .inline(let localized):
            // Use LocalizationManager's current locale for consistency
            return localized.localized(for: LocalizationManager.shared.currentLocale)
        case .key(let stringKey):
            if let resolved = LocalizationManager.shared.resolve(stringKey) {
                return resolved
            }
            // Fallback: show key in brackets for debugging
            return "[\(stringKey.rawValue)]"
        }
    }

    /// Resolve for a specific locale
    public func resolved(for locale: String) -> String {
        switch self {
        case .inline(let localized):
            return localized.localized(for: locale)
        case .key(let stringKey):
            if let resolved = LocalizationManager.shared.resolve(stringKey, locale: locale) {
                return resolved
            }
            return "[\(stringKey.rawValue)]"
        }
    }

    /// Resolve with pack context for proper fallback chain
    public func resolved(packContext: String?) -> String {
        switch self {
        case .inline(let localized):
            return localized.localized(for: LocalizationManager.shared.currentLocale)
        case .key(let stringKey):
            if let resolved = LocalizationManager.shared.resolve(stringKey, packContext: packContext) {
                return resolved
            }
            return "[\(stringKey.rawValue)]"
        }
    }

    // MARK: - Convenience Properties

    /// Returns the StringKey if this is a key-based text, nil otherwise
    public var stringKey: StringKey? {
        if case .key(let key) = self {
            return key
        }
        return nil
    }

    /// Returns the LocalizedString if this is inline text, nil otherwise
    public var inlineString: LocalizedString? {
        if case .inline(let localized) = self {
            return localized
        }
        return nil
    }

    /// Whether this uses the new key-based localization
    public var usesStringKey: Bool {
        if case .key = self { return true }
        return false
    }

    /// English text for validation purposes
    /// For inline strings, returns the `en` value directly
    /// For key-based strings, returns the key itself (validation should check separately)
    public var en: String {
        switch self {
        case .inline(let localized):
            return localized.en
        case .key(let stringKey):
            // For validation, return the key - validators should check key validity separately
            return stringKey.rawValue
        }
    }

    /// Russian text for validation purposes
    /// For inline strings, returns the `ru` value directly
    /// For key-based strings, returns the key itself (validation should check separately)
    public var ru: String {
        switch self {
        case .inline(let localized):
            return localized.ru
        case .key(let stringKey):
            // For validation, return the key - validators should check key validity separately
            return stringKey.rawValue
        }
    }

    /// Check if the text is effectively empty
    /// For inline strings, checks if English text is empty
    /// For key-based strings, always returns false (key presence = not empty)
    public var isEmpty: Bool {
        switch self {
        case .inline(let localized):
            return localized.en.isEmpty
        case .key(let stringKey):
            // A valid key reference is never "empty"
            return stringKey.rawValue.isEmpty
        }
    }

    /// Alias for `resolved` - compatibility with LocalizedString interface
    /// Returns the string for the current device locale
    public var localized: String {
        resolved
    }
}

// MARK: - Codable

extension LocalizableText: Codable {
    public init(from decoder: Decoder) throws {
        // Try to decode as object (LocalizedString) first
        if let localized = try? LocalizedString(from: decoder) {
            self = .inline(localized)
            return
        }

        // Try to decode as string
        let container = try decoder.singleValueContainer()
        let keyString = try container.decode(String.self)

        // Check if string looks like a valid StringKey (lowercase.dot.separated, no spaces)
        // StringKeys must: start with lowercase, contain dots, no spaces, only alphanumeric/underscore/dot
        let looksLikeStringKey = keyString.first?.isLowercase == true
            && keyString.contains(".")
            && !keyString.contains(" ")
            && keyString.range(of: "^[a-z][a-z0-9_]*(\\.[a-z][a-z0-9_]*)+$", options: .regularExpression) != nil

        if looksLikeStringKey {
            // Valid StringKey format (e.g., "card.strike.name")
            self = .key(StringKey(keyString))
        } else {
            // Plain text string - treat as single-language inline text
            // This handles legacy JSON with raw strings like "Ð£Ð´Ð°Ñ€ ÐœÐµÑ‡Ð¾Ð¼"
            self = .inline(LocalizedString(keyString))
        }
    }

    public func encode(to encoder: Encoder) throws {
        switch self {
        case .inline(let localized):
            try localized.encode(to: encoder)
        case .key(let stringKey):
            var container = encoder.singleValueContainer()
            try container.encode(stringKey.rawValue)
        }
    }
}

// MARK: - ExpressibleByStringLiteral

extension LocalizableText: ExpressibleByStringLiteral {
    /// Create from string literal - interpreted as StringKey
    public init(stringLiteral value: String) {
        self = .key(StringKey(value))
    }
}

// MARK: - CustomStringConvertible

extension LocalizableText: CustomStringConvertible {
    public var description: String {
        resolved
    }
}

// MARK: - Convenience Initializers

public extension LocalizableText {
    /// Create inline text with same value for all locales (for testing/development)
    static func text(_ value: String) -> LocalizableText {
        .inline(LocalizedString(value))
    }

    /// Create inline text with specific translations
    static func localized(en: String, ru: String) -> LocalizableText {
        .inline(LocalizedString(en: en, ru: ru))
    }

    /// Create key-based text
    static func key(_ value: String) -> LocalizableText {
        .key(StringKey(value))
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Localization/LocalizationManager.swift
// ==========================================

import Foundation
import Combine
import os.log

// MARK: - String Resolver Protocol

/// Protocol for resolving string keys to localized strings
public protocol StringResolver {
    func resolve(_ key: StringKey) -> String?
    func resolve(_ key: StringKey, locale: String) -> String?
    func resolve(_ key: StringKey, packContext: String?) -> String?
}

// MARK: - Localization Manager

/// Manages string tables for all loaded content packs.
/// Supports runtime locale switching and fallback resolution.
///
/// Resolution order (pack context â†’ core fallback):
/// 1. Pack string table, current locale
/// 2. Pack string table, fallback locale (en)
/// 3. Core pack string table, current locale
/// 4. Core pack string table, fallback locale (en)
/// 5. Return nil (caller shows warning + bracketed key)
public final class LocalizationManager: ObservableObject, StringResolver {
    // MARK: - Singleton

    public static let shared = LocalizationManager()

    // MARK: - Constants

    private static let corePackId = "core"
    private static let fallbackLocale = "en"

    // MARK: - Published Properties

    /// Current locale code (e.g., "en", "ru")
    @Published private(set) var currentLocale: String

    // MARK: - Private Properties

    /// String tables indexed by [packId: [locale: [key: value]]]
    private var stringTables: [String: [String: [String: String]]] = [:]

    /// Order in which packs were loaded (for fallback priority)
    private var packLoadOrder: [String] = []

    /// Logger for missing key warnings
    private let logger = Logger(subsystem: "com.cardsamplegame", category: "Localization")

    /// Track warned keys to avoid spam
    private var warnedKeys: Set<String> = []

    // MARK: - Initialization

    private init() {
        // Initialize with device locale or fallback
        let deviceLocale = Locale.current.language.languageCode?.identifier ?? Self.fallbackLocale
        self.currentLocale = deviceLocale
    }

    // MARK: - Loading

    /// Load string tables for a pack from the localization directory
    /// - Parameters:
    ///   - packId: Unique identifier of the pack
    ///   - url: URL to the localization directory (contains en.json, ru.json, etc.)
    ///   - locales: List of supported locale codes
    /// - Throws: If string tables cannot be loaded
    func loadStringTables(for packId: String, from url: URL, locales: [String]) throws {
        var packTables: [String: [String: String]] = [:]

        for locale in locales {
            let localeURL = url.appendingPathComponent("\(locale).json")

            guard FileManager.default.fileExists(atPath: localeURL.path) else {
                logger.warning("Missing string table for locale '\(locale)' in pack '\(packId)'")
                continue
            }

            let data = try Data(contentsOf: localeURL)
            let table = try JSONDecoder().decode([String: String].self, from: data)
            packTables[locale] = table

            logger.info("Loaded \(table.count) strings for locale '\(locale)' in pack '\(packId)'")
        }

        stringTables[packId] = packTables

        // Add to load order if not already present
        if !packLoadOrder.contains(packId) {
            // Core pack should always be first in fallback order
            if packId == Self.corePackId {
                packLoadOrder.insert(packId, at: 0)
            } else {
                packLoadOrder.append(packId)
            }
        }
    }

    /// Load string tables from raw dictionaries (for testing)
    func loadStringTables(for packId: String, tables: [String: [String: String]]) {
        stringTables[packId] = tables

        if !packLoadOrder.contains(packId) {
            if packId == Self.corePackId {
                packLoadOrder.insert(packId, at: 0)
            } else {
                packLoadOrder.append(packId)
            }
        }
    }

    /// Unload string tables for a pack
    func unloadStringTables(for packId: String) {
        stringTables.removeValue(forKey: packId)
        packLoadOrder.removeAll { $0 == packId }
        logger.info("Unloaded string tables for pack '\(packId)'")
    }

    /// Clear all loaded string tables
    public func clearAll() {
        stringTables.removeAll()
        packLoadOrder.removeAll()
        warnedKeys.removeAll()
    }

    // MARK: - Resolution

    /// Resolve a key using current locale with full fallback chain
    public func resolve(_ key: StringKey) -> String? {
        resolve(key, packContext: nil)
    }

    /// Resolve a key for a specific locale
    public func resolve(_ key: StringKey, locale: String) -> String? {
        resolve(key, locale: locale, packContext: nil)
    }

    /// Resolve a key with pack context for proper fallback
    public func resolve(_ key: StringKey, packContext: String?) -> String? {
        resolve(key, locale: currentLocale, packContext: packContext)
    }

    /// Full resolution with all parameters
    func resolve(_ key: StringKey, locale: String, packContext: String?) -> String? {
        // Build search order: context pack first, then others in reverse load order (newest first)
        var searchOrder: [String] = []

        if let context = packContext {
            searchOrder.append(context)
        }

        // Add other packs in reverse load order (excluding context pack)
        for packId in packLoadOrder.reversed() where packId != packContext {
            searchOrder.append(packId)
        }

        // Ensure core is always included at the end if not already
        if !searchOrder.contains(Self.corePackId) {
            searchOrder.append(Self.corePackId)
        }

        // Try each pack in order
        for packId in searchOrder {
            // Try requested locale first
            if let value = stringTables[packId]?[locale]?[key.rawValue] {
                return value
            }

            // Fallback to English if not the requested locale
            if locale != Self.fallbackLocale {
                if let value = stringTables[packId]?[Self.fallbackLocale]?[key.rawValue] {
                    return value
                }
            }
        }

        // Key not found - log warning once
        logMissingKey(key, packContext: packContext)
        return nil
    }

    // MARK: - Locale Switching

    /// Switch to a different locale at runtime
    /// Views observing LocalizationManager will update automatically
    func setLocale(_ locale: String) {
        guard currentLocale != locale else { return }
        currentLocale = locale
        logger.info("Locale switched to '\(locale)'")
    }

    // MARK: - Validation Support

    /// Get all keys defined in a pack across all locales
    func getAllKeys(for packId: String) -> Set<String> {
        guard let packTables = stringTables[packId] else { return [] }

        var allKeys = Set<String>()
        for (_, table) in packTables {
            allKeys.formUnion(table.keys)
        }
        return allKeys
    }

    /// Get keys that exist in reference set but are missing from a specific locale
    func getMissingKeys(for packId: String, locale: String, referencing keys: Set<String>) -> Set<String> {
        guard let table = stringTables[packId]?[locale] else {
            return keys // All keys are missing if no table exists
        }
        return keys.subtracting(table.keys)
    }

    /// Check if a key exists in any loaded pack
    func keyExists(_ key: StringKey) -> Bool {
        for (_, packTables) in stringTables {
            for (_, table) in packTables {
                if table[key.rawValue] != nil {
                    return true
                }
            }
        }
        return false
    }

    /// Get list of loaded pack IDs
    var loadedPackIds: [String] {
        packLoadOrder
    }

    /// Get string tables for caching
    func getStringTables(for packId: String) -> [String: [String: String]] {
        stringTables[packId] ?? [:]
    }

    /// Restore string tables from cache
    func restoreFromCache(packId: String, tables: [String: [String: String]]) {
        loadStringTables(for: packId, tables: tables)
    }

    // MARK: - Private Methods

    private func logMissingKey(_ key: StringKey, packContext: String?) {
        let cacheKey = "\(packContext ?? "global"):\(key.rawValue)"
        guard !warnedKeys.contains(cacheKey) else { return }

        warnedKeys.insert(cacheKey)
        let context = packContext ?? "global"
        logger.warning("Missing localization key '\(key.rawValue)' in context '\(context)'")
    }
}

// MARK: - Testing Support

#if DEBUG
extension LocalizationManager {
    /// Reset manager state for testing
    func resetForTesting() {
        stringTables.removeAll()
        packLoadOrder.removeAll()
        warnedKeys.removeAll()
        currentLocale = Self.fallbackLocale
    }

    /// Create a fresh instance for testing (bypasses singleton)
    public static func createForTesting() -> LocalizationManager {
        let manager = LocalizationManager()
        manager.resetForTesting()
        return manager
    }
}
#endif


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Localization/LocalizationValidator.swift
// ==========================================

import Foundation

// MARK: - Localization Validator

/// Validates localization schema consistency across content packs.
/// Enforces the canonical localization approach (inline LocalizedString).
///
/// Canonical approach (REQUIRED):
///   - Inline LocalizedString: { "en": "Strike", "ru": "Ð£Ð´Ð°Ñ€" }
///
/// Deprecated approach (NOT allowed in new content):
///   - StringKey references: "card.strike.name" â†’ string tables
///
/// Reference: Audit B1 requirement - prevent hybrid localization schemes.
public final class LocalizationValidator {

    // MARK: - Configuration

    /// Canonical localization scheme for this project
    public enum LocalizationScheme {
        /// Inline translations in JSON: { "en": "...", "ru": "..." }
        case inlineOnly

        /// String key references to external tables: "card.strike.name"
        case stringKeyOnly

        /// Mixed (deprecated - should not be used)
        case mixed
    }

    /// The canonical scheme enforced by this validator
    public static let canonicalScheme: LocalizationScheme = .inlineOnly

    // MARK: - Validation Results

    public struct ValidationResult {
        public let isValid: Bool
        public let scheme: LocalizationScheme
        public let inlineCount: Int
        public let keyCount: Int
        public let mixedEntities: [String]  // Entity IDs that mix schemes

        public static let valid = ValidationResult(
            isValid: true,
            scheme: .inlineOnly,
            inlineCount: 0,
            keyCount: 0,
            mixedEntities: []
        )
    }

    // MARK: - Validation

    /// Validate localization scheme consistency in a loaded pack
    public static func validate(pack: LoadedPack) -> ValidationResult {
        var inlineCount = 0
        var keyCount = 0
        var mixedEntities: [String] = []

        // Check events
        for (id, event) in pack.events {
            let titleIsInline = event.title.inlineString != nil
            let bodyIsInline = event.body.inlineString != nil

            if titleIsInline { inlineCount += 1 } else { keyCount += 1 }
            if bodyIsInline { inlineCount += 1 } else { keyCount += 1 }

            // Check if entity mixes schemes
            if titleIsInline != bodyIsInline {
                mixedEntities.append("event:\(id)")
            }
        }

        // Check heroes
        for (id, hero) in pack.heroes {
            let nameIsInline = hero.name.inlineString != nil
            let descIsInline = hero.description.inlineString != nil

            if nameIsInline { inlineCount += 1 } else { keyCount += 1 }
            if descIsInline { inlineCount += 1 } else { keyCount += 1 }

            if nameIsInline != descIsInline {
                mixedEntities.append("hero:\(id)")
            }
        }

        // Check cards
        for (id, card) in pack.cards {
            let nameIsInline = card.name.inlineString != nil
            let descIsInline = card.description.inlineString != nil

            if nameIsInline { inlineCount += 1 } else { keyCount += 1 }
            if descIsInline { inlineCount += 1 } else { keyCount += 1 }

            if nameIsInline != descIsInline {
                mixedEntities.append("card:\(id)")
            }
        }

        // Check regions
        for (id, region) in pack.regions {
            let titleIsInline = region.title.inlineString != nil
            let descIsInline = region.description.inlineString != nil

            if titleIsInline { inlineCount += 1 } else { keyCount += 1 }
            if descIsInline { inlineCount += 1 } else { keyCount += 1 }

            if titleIsInline != descIsInline {
                mixedEntities.append("region:\(id)")
            }
        }

        // Check quests
        for (id, quest) in pack.quests {
            let titleIsInline = quest.title.inlineString != nil
            let descIsInline = quest.description.inlineString != nil

            if titleIsInline { inlineCount += 1 } else { keyCount += 1 }
            if descIsInline { inlineCount += 1 } else { keyCount += 1 }

            if titleIsInline != descIsInline {
                mixedEntities.append("quest:\(id)")
            }
        }

        // Determine scheme
        let scheme: LocalizationScheme
        if inlineCount > 0 && keyCount > 0 {
            scheme = .mixed
        } else if keyCount > 0 {
            scheme = .stringKeyOnly
        } else {
            scheme = .inlineOnly
        }

        // Validate against canonical scheme
        let isValid = scheme == canonicalScheme && mixedEntities.isEmpty

        return ValidationResult(
            isValid: isValid,
            scheme: scheme,
            inlineCount: inlineCount,
            keyCount: keyCount,
            mixedEntities: mixedEntities
        )
    }

    /// Check if a single LocalizableText uses the canonical scheme
    public static func isCanonical(_ text: LocalizableText) -> Bool {
        switch canonicalScheme {
        case .inlineOnly:
            return text.inlineString != nil
        case .stringKeyOnly:
            return text.stringKey != nil
        case .mixed:
            return true  // Mixed allows both
        }
    }

    /// Get a description of why the pack failed validation
    public static func failureReason(result: ValidationResult) -> String {
        var reasons: [String] = []

        if result.scheme != canonicalScheme {
            reasons.append("Pack uses \(result.scheme) scheme, but canonical is \(canonicalScheme)")
            reasons.append("  - Inline strings: \(result.inlineCount)")
            reasons.append("  - String keys: \(result.keyCount)")
        }

        if !result.mixedEntities.isEmpty {
            reasons.append("Mixed localization within entities:")
            for entity in result.mixedEntities.prefix(5) {
                reasons.append("  - \(entity)")
            }
            if result.mixedEntities.count > 5 {
                reasons.append("  - ... and \(result.mixedEntities.count - 5) more")
            }
        }

        return reasons.joined(separator: "\n")
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/TwilightEngine/Localization/StringKey.swift
// ==========================================

import Foundation

// MARK: - String Key
// Reference: Docs/ENGINE_ARCHITECTURE.md
// Keys reference strings in pack string tables

/// A key that references a localized string in the pack's string tables.
/// Format: "namespace.entity.field" (e.g., "card.strike.name", "hero.ragnar.description")
public struct StringKey: Hashable {
    // MARK: - Properties

    /// The raw string value of the key
    public let rawValue: String

    // MARK: - Initialization

    public init(_ value: String) {
        self.rawValue = value
    }

    // MARK: - Validation

    /// Validates key format: lowercase alphanumeric with dots and underscores
    /// Examples:
    ///   Valid: "card.strike.name", "hero.ragnar_the_brave.description", "region.dark_forest.title"
    ///   Invalid: "Card.Strike" (uppercase), "card strike" (space), "" (empty)
    public var isValid: Bool {
        guard !rawValue.isEmpty else { return false }
        let pattern = "^[a-z][a-z0-9_]*(\\.[a-z][a-z0-9_]*)*$"
        return rawValue.range(of: pattern, options: .regularExpression) != nil
    }

    /// Returns validation error message if invalid, nil if valid
    public var validationError: String? {
        guard !rawValue.isEmpty else {
            return "StringKey cannot be empty"
        }

        if rawValue.contains(" ") {
            return "StringKey cannot contain spaces: '\(rawValue)'"
        }

        if rawValue.first?.isUppercase == true {
            return "StringKey must start with lowercase letter: '\(rawValue)'"
        }

        if !isValid {
            return "StringKey has invalid format: '\(rawValue)'. Expected: lowercase.dot.separated.keys"
        }

        return nil
    }
}

// MARK: - Codable

extension StringKey: Codable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        self.rawValue = try container.decode(String.self)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(rawValue)
    }
}

// MARK: - ExpressibleByStringLiteral

extension StringKey: ExpressibleByStringLiteral {
    public init(stringLiteral value: String) {
        self.rawValue = value
    }
}

// MARK: - CustomStringConvertible

extension StringKey: CustomStringConvertible {
    public var description: String {
        rawValue
    }
}

// MARK: - Key Generation Helpers

public extension StringKey {
    /// Generate a key for a card field
    static func card(_ cardId: String, _ field: String) -> StringKey {
        StringKey("card.\(cardId).\(field)")
    }

    /// Generate a key for a hero field
    static func hero(_ heroId: String, _ field: String) -> StringKey {
        StringKey("hero.\(heroId).\(field)")
    }

    /// Generate a key for a region field
    static func region(_ regionId: String, _ field: String) -> StringKey {
        StringKey("region.\(regionId).\(field)")
    }

    /// Generate a key for an event field
    static func event(_ eventId: String, _ field: String) -> StringKey {
        StringKey("event.\(eventId).\(field)")
    }

    /// Generate a key for an enemy field
    static func enemy(_ enemyId: String, _ field: String) -> StringKey {
        StringKey("enemy.\(enemyId).\(field)")
    }

    /// Generate a key for an ability field
    static func ability(_ abilityId: String, _ field: String) -> StringKey {
        StringKey("ability.\(abilityId).\(field)")
    }

    /// Generate a key for an event choice field
    static func choice(_ eventId: String, _ choiceId: String, _ field: String) -> StringKey {
        StringKey("event.\(eventId).choice.\(choiceId).\(field)")
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Sources/PackCompilerTool/main.swift
// ==========================================

import Foundation
import TwilightEngine

// MARK: - Pack Compiler CLI Tool
// Compiles JSON content packs to binary .pack format

/// Print usage information
func printUsage() {
    let programName = CommandLine.arguments[0].components(separatedBy: "/").last ?? "pack-compiler"
    print("""
    Usage: \(programName) <command> [options]

    Commands:
        compile <source-dir> <output-file>
            Compile a JSON pack directory to .pack binary file

        validate <source-dir>
            Validate a JSON pack without compiling

        info <pack-file>
            Show information about a compiled .pack file

        compile-all <packs-dir> [--output-dir <dir>]
            Compile all packs in a directory

    Examples:
        \(programName) compile ./CoreHeroes ./CoreHeroes.pack
        \(programName) validate ./TwilightMarchesActI
        \(programName) info ./CoreHeroes.pack
    """)
}

/// Compile a single pack
func compilePack(source: String, output: String) {
    let sourceURL = URL(fileURLWithPath: source)
    let outputURL = URL(fileURLWithPath: output)

    print("Compiling: \(sourceURL.lastPathComponent) -> \(outputURL.lastPathComponent)")

    do {
        let result = try PackCompiler.compile(from: sourceURL, to: outputURL)
        print(result.summary)
        print("âœ… Compilation successful!")
    } catch {
        print("âŒ Compilation failed: \(error)")
        exit(1)
    }
}

/// Validate a pack
func validatePack(source: String) {
    let sourceURL = URL(fileURLWithPath: source)

    print("Validating: \(sourceURL.lastPathComponent)")

    do {
        let result = try PackCompiler.validate(at: sourceURL)
        print(result.summary)
        exit(result.isValid ? 0 : 1)
    } catch {
        print("âŒ Validation failed: \(error)")
        exit(1)
    }
}

/// Show pack info
func showPackInfo(packFile: String) {
    let packURL = URL(fileURLWithPath: packFile)

    print("Reading: \(packURL.lastPathComponent)")

    do {
        let content = try BinaryPackReader.loadContent(from: packURL)
        let manifest = content.manifest

        print("""

        Pack Information:
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ID: \(manifest.packId)
        Version: \(manifest.version)
        Type: \(manifest.packType.rawValue)
        Core Version: \(manifest.coreVersionMin)+

        Content:
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        Regions: \(content.regions.count)
        Events: \(content.events.count)
        Quests: \(content.quests.count)
        Anchors: \(content.anchors.count)
        Heroes: \(content.heroes.count)
        Cards: \(content.cards.count)
        Enemies: \(content.enemies.count)
        Abilities: \(content.abilities.count)
        """)

        // File size
        let attributes = try FileManager.default.attributesOfItem(atPath: packFile)
        if let fileSize = attributes[.size] as? Int64 {
            let sizeKB = Double(fileSize) / 1024
            print("File Size: \(String(format: "%.1f", sizeKB)) KB")
        }

    } catch {
        print("âŒ Failed to read pack: \(error)")
        exit(1)
    }
}

/// Compile all packs in directory
func compileAllPacks(packsDir: String, outputDir: String?) {
    let packsDirURL = URL(fileURLWithPath: packsDir)
    let outputDirURL = outputDir.map { URL(fileURLWithPath: $0) } ?? packsDirURL

    do {
        let contents = try FileManager.default.contentsOfDirectory(
            at: packsDirURL,
            includingPropertiesForKeys: [.isDirectoryKey]
        )

        var compiledCount = 0
        var failedCount = 0

        for item in contents {
            let resourceValues = try item.resourceValues(forKeys: [.isDirectoryKey])
            guard resourceValues.isDirectory == true else { continue }

            // Check if directory has manifest.json
            let manifestURL = item.appendingPathComponent("manifest.json")
            guard FileManager.default.fileExists(atPath: manifestURL.path) else { continue }

            let packName = item.lastPathComponent
            let outputURL = outputDirURL.appendingPathComponent("\(packName).pack")

            print("\nCompiling: \(packName)")

            do {
                let result = try PackCompiler.compile(from: item, to: outputURL)
                print("  âœ… \(result.contentStats.summary)")
                compiledCount += 1
            } catch {
                print("  âŒ Failed: \(error)")
                failedCount += 1
            }
        }

        print("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        print("Compiled: \(compiledCount) packs")
        if failedCount > 0 {
            print("Failed: \(failedCount) packs")
            exit(1)
        }

    } catch {
        print("âŒ Failed to scan directory: \(error)")
        exit(1)
    }
}

// MARK: - Main

let args = CommandLine.arguments

guard args.count >= 2 else {
    printUsage()
    exit(0)
}

let command = args[1]

switch command {
case "compile":
    guard args.count >= 4 else {
        print("Error: compile requires <source-dir> and <output-file>")
        exit(1)
    }
    compilePack(source: args[2], output: args[3])

case "validate":
    guard args.count >= 3 else {
        print("Error: validate requires <source-dir>")
        exit(1)
    }
    validatePack(source: args[2])

case "info":
    guard args.count >= 3 else {
        print("Error: info requires <pack-file>")
        exit(1)
    }
    showPackInfo(packFile: args[2])

case "compile-all":
    guard args.count >= 3 else {
        print("Error: compile-all requires <packs-dir>")
        exit(1)
    }
    var outputDir: String? = nil
    if args.count >= 5 && args[3] == "--output-dir" {
        outputDir = args[4]
    }
    compileAllPacks(packsDir: args[2], outputDir: outputDir)

case "-h", "--help", "help":
    printUsage()

default:
    print("Unknown command: \(command)")
    printUsage()
    exit(1)
}


// ==========================================
// FILE: Packages/StoryPacks/Season1/TwilightMarchesActI/Package.swift
// ==========================================

// swift-tools-version: 5.9
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: "TwilightMarchesActI",
    defaultLocalization: "en",
    platforms: [
        .iOS(.v16),
        .macOS(.v13)
    ],
    products: [
        .library(
            name: "TwilightMarchesActIContent",
            targets: ["TwilightMarchesActIContent"]
        ),
    ],
    targets: [
        .target(
            name: "TwilightMarchesActIContent",
            resources: [
                // Compiled binary pack (fast loading, compressed) - used at runtime
                .copy("Resources/TwilightMarchesActI.pack"),
                // JSON source directory - for PackLoader tests and content authoring
                .copy("Resources/TwilightMarchesActI")
            ]
        ),
    ]
)


// ==========================================
// FILE: Packages/StoryPacks/Season1/TwilightMarchesActI/Sources/TwilightMarchesActIContent/TwilightMarchesActIContent.swift
// ==========================================

import Foundation

/// TwilightMarchesActI story pack
/// Provides Act I campaign content: regions, events, quests, anchors, enemies
public enum TwilightMarchesActIContent {
    /// URL to the TwilightMarchesActI.pack binary file
    public static var packURL: URL? {
        Bundle.module.url(forResource: "TwilightMarchesActI", withExtension: "pack")
    }

    /// Pack identifier
    public static let packId = "twilight-marches-act1"
}


// ==========================================
// FILE: Views/CardView.swift
// ==========================================

import SwiftUI
import TwilightEngine

struct CardView: View {
    let card: Card
    var isSelected: Bool = false
    var onTap: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Card header with name and type
            VStack(alignment: .leading, spacing: Spacing.xxs) {
                HStack {
                    Text(card.name)
                        .font(.headline)
                        .fontWeight(.bold)
                        .foregroundColor(.white)
                    Spacer()
                    if let cost = card.cost {
                        Text("\(cost)")
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(AppColors.faith)
                            .padding(Spacing.xs)
                            .background(Circle().fill(Color.black.opacity(Opacity.mediumHigh)))
                    }
                }

                Text(localizedCardType)
                    .font(.caption)
                    .foregroundColor(.white.opacity(Opacity.high))
            }
            .padding(Spacing.md)
            .background(headerColor)

            // Card image area
            ZStack {
                Rectangle()
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [cardColor.opacity(Opacity.light), cardColor]),
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    )

                VStack {
                    Image(systemName: cardIcon)
                        .font(.system(size: Sizes.iconRegion))
                        .foregroundColor(.white.opacity(Opacity.almostOpaque))
                }
            }
            .frame(height: Sizes.cardHeightSmall + Spacing.xl)

            // Stats section
            if hasStats {
                HStack(spacing: Spacing.lg) {
                    if let power = card.power {
                        CardStatBadge(icon: "bolt.fill", value: power, color: AppColors.power)
                    }
                    if let defense = card.defense {
                        CardStatBadge(icon: "shield.fill", value: defense, color: AppColors.defense)
                    }
                    if let health = card.health {
                        CardStatBadge(icon: "heart.fill", value: health, color: AppColors.health)
                    }
                    Spacer()
                }
                .padding(.horizontal, Spacing.md)
                .padding(.vertical, Spacing.sm)
                .background(Color.black.opacity(Opacity.faint))
            }

            // Description
            ScrollView {
                VStack(alignment: .leading, spacing: Spacing.sm) {
                    Text(card.description)
                        .font(.caption)
                        .foregroundColor(.primary)
                        .fixedSize(horizontal: false, vertical: true)

                    // Abilities
                    ForEach(card.abilities) { ability in
                        VStack(alignment: .leading, spacing: Spacing.xxxs) {
                            Text(ability.name)
                                .font(.caption)
                                .fontWeight(.bold)
                                .foregroundColor(AppColors.power)
                            Text(ability.description)
                                .font(.caption2)
                                .foregroundColor(AppColors.muted)
                                .fixedSize(horizontal: false, vertical: true)
                        }
                        .padding(.top, Spacing.xxs)
                    }

                    // Traits
                    if !card.traits.isEmpty {
                        HStack {
                            ForEach(card.traits, id: \.self) { trait in
                                Text(trait.localized)
                                    .font(.caption2)
                                    .padding(.horizontal, Spacing.xs)
                                    .padding(.vertical, Spacing.xxxs)
                                    .background(Capsule().fill(AppColors.secondary.opacity(Opacity.light)))
                            }
                        }
                        .padding(.top, Spacing.xxs)
                    }
                }
                .padding(Spacing.md)
            }

            // Rarity indicator
            HStack {
                Spacer()
                Circle()
                    .fill(rarityColor)
                    .frame(width: Spacing.sm, height: Spacing.sm)
                Text(localizedRarity)
                    .font(.caption2)
                    .foregroundColor(AppColors.muted)
            }
            .padding(Spacing.sm)
        }
        .frame(height: Sizes.cardHeightLarge + Sizes.cardHeightMedium)
        .background(AppColors.cardBackground)
        .cornerRadius(CornerRadius.lg)
        .shadow(color: isSelected ? AppColors.primary.opacity(Opacity.medium) : Color.black.opacity(Opacity.faint), radius: isSelected ? 8 : 4)
        .overlay(
            RoundedRectangle(cornerRadius: CornerRadius.lg)
                .stroke(isSelected ? AppColors.primary : .clear, lineWidth: 3)
        )
        .onTapGesture {
            onTap?()
        }
    }

    var hasStats: Bool {
        card.power != nil || card.defense != nil || card.health != nil
    }

    var localizedCardType: String {
        switch card.type {
        case .character: return L10n.cardTypeCharacter.localized
        case .weapon: return L10n.cardTypeWeapon.localized
        case .spell: return L10n.cardTypeSpell.localized
        case .armor: return L10n.cardTypeArmor.localized
        case .item: return L10n.cardTypeItem.localized
        case .ally: return L10n.cardTypeAlly.localized
        case .blessing: return L10n.cardTypeBlessing.localized
        case .monster: return L10n.cardTypeMonster.localized
        case .location: return L10n.cardTypeLocation.localized
        case .scenario: return card.type.rawValue.capitalized
        case .curse: return L10n.tmCardTypeCurse.localized
        case .spirit: return L10n.tmCardTypeSpirit.localized
        case .artifact: return L10n.tmCardTypeArtifact.localized
        case .ritual: return L10n.tmCardTypeRitual.localized
        case .resource: return L10n.cardTypeResource.localized
        case .attack: return L10n.cardTypeAttack.localized
        case .defense: return L10n.cardTypeDefense.localized
        case .special: return L10n.cardTypeSpecial.localized
        }
    }

    var localizedRarity: String {
        switch card.rarity {
        case .common: return L10n.rarityCommon.localized
        case .uncommon: return L10n.rarityUncommon.localized
        case .rare: return L10n.rarityRare.localized
        case .epic: return L10n.rarityEpic.localized
        case .legendary: return L10n.rarityLegendary.localized
        }
    }

    var headerColor: Color {
        switch card.type {
        case .character: return AppColors.dark
        case .weapon: return AppColors.danger
        case .spell: return AppColors.primary
        case .armor: return AppColors.secondary
        case .item: return Color.brown
        case .ally: return AppColors.success
        case .blessing: return AppColors.light
        case .monster: return AppColors.danger.opacity(Opacity.high)
        case .location: return Color.teal
        case .scenario: return Color.indigo
        case .curse: return Color.black
        case .spirit: return Color.cyan
        case .artifact: return AppColors.power
        case .ritual: return Color.indigo
        case .resource: return AppColors.success
        case .attack: return AppColors.danger
        case .defense: return AppColors.defense
        case .special: return AppColors.dark
        }
    }

    var cardColor: Color {
        headerColor.opacity(Opacity.mediumHigh)
    }

    var cardIcon: String {
        switch card.type {
        case .character: return "person.fill"
        case .weapon: return "bolt.fill"
        case .spell: return "sparkles"
        case .armor: return "shield.fill"
        case .item: return "bag.fill"
        case .ally: return "person.2.fill"
        case .blessing: return "star.fill"
        case .monster: return "flame.fill"
        case .location: return "mappin.and.ellipse"
        case .scenario: return "book.fill"
        case .curse: return "cloud.bolt.fill"
        case .spirit: return "cloud.moon.fill"
        case .artifact: return "crown.fill"
        case .ritual: return "book.closed.fill"
        case .resource: return "leaf.fill"
        case .attack: return "bolt.fill"
        case .defense: return "shield.fill"
        case .special: return "star.circle.fill"
        }
    }

    var rarityColor: Color {
        switch card.rarity {
        case .common: return AppColors.rarityCommon
        case .uncommon: return AppColors.rarityUncommon
        case .rare: return AppColors.rarityRare
        case .epic: return AppColors.rarityEpic
        case .legendary: return AppColors.rarityLegendary
        }
    }
}

struct CardStatBadge: View {
    let icon: String
    let value: Int
    let color: Color

    var body: some View {
        HStack(spacing: Spacing.xxs) {
            Image(systemName: icon)
                .font(.caption)
            Text("\(value)")
                .font(.caption)
                .fontWeight(.bold)
        }
        .foregroundColor(color)
    }
}

// Compact card view for character selection
struct CompactCardView: View {
    let card: Card
    var isSelected: Bool = false
    var onTap: (() -> Void)?

    var body: some View {
        VStack(spacing: 0) {
            // Card header
            Text(card.name)
                .font(.title3)
                .fontWeight(.bold)
                .foregroundColor(.white)
                .frame(maxWidth: .infinity)
                .padding(.vertical, Spacing.md)
                .background(headerColor)

            // Card image area
            ZStack {
                Rectangle()
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [headerColor.opacity(Opacity.light), headerColor.opacity(Opacity.mediumHigh)]),
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    )

                Image(systemName: cardIcon)
                    .font(.system(size: Sizes.iconRegion + Spacing.smd))
                    .foregroundColor(.white.opacity(Opacity.almostOpaque))
            }
            .frame(height: Sizes.cardHeightMedium)

            // Stats
            VStack(spacing: Spacing.sm) {
                Text(localizedCardType)
                    .font(.caption)
                    .foregroundColor(AppColors.muted)

                HStack(spacing: Spacing.xl) {
                    if let health = card.health {
                        VStack(spacing: Spacing.xxxs) {
                            Image(systemName: "heart.fill")
                                .font(.title3)
                                .foregroundColor(AppColors.health)
                            Text("\(health)")
                                .font(.headline)
                                .fontWeight(.bold)
                            Text(L10n.cardStatHealth.localized)
                                .font(.system(size: 9))
                                .foregroundColor(AppColors.muted)
                        }
                    }
                    if let power = card.power {
                        VStack(spacing: Spacing.xxxs) {
                            Image(systemName: "bolt.fill")
                                .font(.title3)
                                .foregroundColor(AppColors.power)
                            Text("\(power)")
                                .font(.headline)
                                .fontWeight(.bold)
                            Text(L10n.cardStatStrength.localized)
                                .font(.system(size: 9))
                                .foregroundColor(AppColors.muted)
                        }
                    }
                    if let defense = card.defense {
                        VStack(spacing: Spacing.xxxs) {
                            Image(systemName: "shield.fill")
                                .font(.title3)
                                .foregroundColor(AppColors.defense)
                            Text("\(defense)")
                                .font(.headline)
                                .fontWeight(.bold)
                            Text(L10n.cardStatDefense.localized)
                                .font(.system(size: 9))
                                .foregroundColor(AppColors.muted)
                        }
                    }
                }

                Circle()
                    .fill(rarityColor)
                    .frame(width: Spacing.xs, height: Spacing.xs)
            }
            .padding(.vertical, Spacing.smd)
            .frame(maxWidth: .infinity)
            .background(AppColors.cardBackground)
        }
        .frame(height: Sizes.cardHeightMedium + Sizes.cardHeightMedium)
        .background(Color(UIColor.systemBackground))
        .cornerRadius(CornerRadius.xl)
        .shadow(color: isSelected ? headerColor.opacity(Opacity.medium) : .black.opacity(Opacity.faint), radius: isSelected ? 10 : 5)
        .overlay(
            RoundedRectangle(cornerRadius: CornerRadius.xl)
                .stroke(isSelected ? headerColor : Color.clear, lineWidth: 3)
        )
        .scaleEffect(isSelected ? 1.05 : 1.0)
        .animation(.spring(response: AnimationDuration.slow, dampingFraction: 0.7), value: isSelected)
        .onTapGesture {
            onTap?()
        }
    }

    var headerColor: Color {
        switch card.type {
        case .character: return AppColors.dark
        case .weapon: return AppColors.danger
        case .spell: return AppColors.primary
        case .armor: return AppColors.secondary
        case .item: return Color.brown
        case .ally: return AppColors.success
        case .blessing: return AppColors.light
        case .monster: return AppColors.danger.opacity(Opacity.high)
        case .location: return Color.teal
        case .scenario: return Color.indigo
        case .curse: return Color.black
        case .spirit: return Color.cyan
        case .artifact: return AppColors.power
        case .ritual: return Color.indigo
        case .resource: return AppColors.success
        case .attack: return AppColors.danger
        case .defense: return AppColors.defense
        case .special: return AppColors.dark
        }
    }

    var cardIcon: String {
        switch card.type {
        case .character: return "person.fill"
        case .weapon: return "bolt.fill"
        case .spell: return "sparkles"
        case .armor: return "shield.fill"
        case .item: return "bag.fill"
        case .ally: return "person.2.fill"
        case .blessing: return "star.fill"
        case .monster: return "flame.fill"
        case .location: return "mappin.and.ellipse"
        case .scenario: return "book.fill"
        case .curse: return "cloud.bolt.fill"
        case .spirit: return "cloud.moon.fill"
        case .artifact: return "crown.fill"
        case .ritual: return "book.closed.fill"
        case .resource: return "leaf.fill"
        case .attack: return "bolt.fill"
        case .defense: return "shield.fill"
        case .special: return "star.circle.fill"
        }
    }

    var localizedCardType: String {
        switch card.type {
        case .character: return L10n.cardTypeCharacter.localized
        case .weapon: return L10n.cardTypeWeapon.localized
        case .spell: return L10n.cardTypeSpell.localized
        case .armor: return L10n.cardTypeArmor.localized
        case .item: return L10n.cardTypeItem.localized
        case .ally: return L10n.cardTypeAlly.localized
        case .blessing: return L10n.cardTypeBlessing.localized
        case .monster: return L10n.cardTypeMonster.localized
        case .location: return L10n.cardTypeLocation.localized
        case .scenario: return card.type.rawValue.capitalized
        case .curse: return L10n.tmCardTypeCurse.localized
        case .spirit: return L10n.tmCardTypeSpirit.localized
        case .artifact: return L10n.tmCardTypeArtifact.localized
        case .ritual: return L10n.tmCardTypeRitual.localized
        case .resource: return L10n.cardTypeResource.localized
        case .attack: return L10n.cardTypeAttack.localized
        case .defense: return L10n.cardTypeDefense.localized
        case .special: return L10n.cardTypeSpecial.localized
        }
    }

    var rarityColor: Color {
        switch card.rarity {
        case .common: return AppColors.rarityCommon
        case .uncommon: return AppColors.rarityUncommon
        case .rare: return AppColors.rarityRare
        case .epic: return AppColors.rarityEpic
        case .legendary: return AppColors.rarityLegendary
        }
    }
}

// Very compact card view for player hand
struct HandCardView: View {
    let card: Card
    var isSelected: Bool = false
    var onTap: (() -> Void)?

    var body: some View {
        VStack(spacing: 0) {
            // Card name
            Text(card.name)
                .font(.system(size: Spacing.smd))
                .fontWeight(.bold)
                .foregroundColor(.white)
                .lineLimit(1)
                .minimumScaleFactor(0.7)
                .frame(maxWidth: .infinity)
                .padding(.vertical, Spacing.xxxs)
                .padding(.horizontal, Spacing.xxxs)
                .background(headerColor)

            // Card icon
            ZStack {
                Rectangle()
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [headerColor.opacity(Opacity.light), headerColor.opacity(Opacity.mediumHigh)]),
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    )

                Image(systemName: cardIcon)
                    .font(.system(size: Sizes.iconLarge))
                    .foregroundColor(.white.opacity(Opacity.almostOpaque))
            }
            .frame(height: Sizes.iconHero + 5)

            // Stats in vertical column
            VStack(spacing: Spacing.xxxs) {
                if let cost = card.cost {
                    HStack(spacing: Spacing.xxxs) {
                        Image(systemName: "star.fill")
                            .font(.system(size: Spacing.sm))
                            .foregroundColor(AppColors.faith)
                        Text("\(cost)")
                            .font(.system(size: 9))
                            .fontWeight(.bold)
                    }
                }
                if let power = card.power {
                    HStack(spacing: Spacing.xxxs) {
                        Image(systemName: "bolt.fill")
                            .font(.system(size: Spacing.sm))
                            .foregroundColor(AppColors.health)
                        Text("\(power)")
                            .font(.system(size: 9))
                            .fontWeight(.bold)
                    }
                }
                if let defense = card.defense {
                    HStack(spacing: Spacing.xxxs) {
                        Image(systemName: "shield.fill")
                            .font(.system(size: Spacing.sm))
                            .foregroundColor(AppColors.defense)
                        Text("\(defense)")
                            .font(.system(size: 9))
                            .fontWeight(.bold)
                    }
                }
            }
            .padding(.vertical, Spacing.xxxs)
            .frame(maxWidth: .infinity)
            .background(AppColors.cardBackground)
        }
        .frame(width: Sizes.cardWidthSmall + 5, height: Sizes.cardHeightSmall + Spacing.lg - 1)
        .background(Color(UIColor.systemBackground))
        .cornerRadius(CornerRadius.md)
        .shadow(color: isSelected ? headerColor.opacity(Opacity.mediumHigh) : .black.opacity(Opacity.faint), radius: isSelected ? 6 : 3)
        .overlay(
            RoundedRectangle(cornerRadius: CornerRadius.md)
                .stroke(isSelected ? headerColor : Color.clear, lineWidth: 2)
        )
        .scaleEffect(isSelected ? 1.1 : 1.0)
        .animation(.spring(response: AnimationDuration.fast + 0.05, dampingFraction: 0.7), value: isSelected)
        .onTapGesture {
            onTap?()
        }
    }

    var headerColor: Color {
        switch card.type {
        case .character: return AppColors.dark
        case .weapon: return AppColors.danger
        case .spell: return AppColors.primary
        case .armor: return AppColors.secondary
        case .item: return Color.brown
        case .ally: return AppColors.success
        case .blessing: return AppColors.light
        case .monster: return AppColors.danger.opacity(Opacity.high)
        case .location: return Color.teal
        case .scenario: return Color.indigo
        case .curse: return Color.black
        case .spirit: return Color.cyan
        case .artifact: return AppColors.power
        case .ritual: return Color.indigo
        case .resource: return AppColors.success
        case .attack: return AppColors.danger
        case .defense: return AppColors.defense
        case .special: return AppColors.dark
        }
    }

    var cardIcon: String {
        switch card.type {
        case .character: return "person.fill"
        case .weapon: return "bolt.fill"
        case .spell: return "sparkles"
        case .armor: return "shield.fill"
        case .item: return "bag.fill"
        case .ally: return "person.2.fill"
        case .blessing: return "star.fill"
        case .monster: return "flame.fill"
        case .location: return "mappin.and.ellipse"
        case .scenario: return "book.fill"
        case .curse: return "cloud.bolt.fill"
        case .spirit: return "cloud.moon.fill"
        case .artifact: return "crown.fill"
        case .ritual: return "book.closed.fill"
        case .resource: return "leaf.fill"
        case .attack: return "bolt.fill"
        case .defense: return "shield.fill"
        case .special: return "star.circle.fill"
        }
    }
}


// ==========================================
// FILE: Views/CombatView.swift
// ==========================================

import SwiftUI
import TwilightEngine

/// Ð‘Ð¾ÐµÐ²Ð¾Ð¹ ÑÐºÑ€Ð°Ð½ - Ñ€ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð¿Ð¾ Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ð°Ñ†Ð¸Ð¸ GAME_DESIGN_DOCUMENT.md
/// Ð¦Ð¸ÐºÐ»: PlayerTurn â†’ EnemyTurn â†’ EndTurn (Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€ Ð´Ð¾ Ð¿Ð¾Ð±ÐµÐ´Ñ‹/Ð¿Ð¾Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ)
/// Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ: 3 Ð·Ð° Ñ…Ð¾Ð´. Ð˜Ð³Ñ€Ð°Ñ‚ÑŒ ÐºÐ°Ñ€Ñ‚Ñƒ = 1 Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ, ÐÑ‚Ð°ÐºÐ¾Ð²Ð°Ñ‚ÑŒ = 1 Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ
///
/// Engine-First Architecture:
/// - All player mutations go through engine.performAction()
/// - UI reads state from engine properties
struct CombatView: View {
    // MARK: - Engine-First Architecture
    @ObservedObject var engine: TwilightGameEngine
    let onCombatEnd: (CombatOutcome) -> Void

    enum CombatOutcome: Equatable {
        case victory(stats: CombatStats)
        case defeat(stats: CombatStats)
        case fled

        var isVictory: Bool {
            if case .victory = self { return true }
            return false
        }
    }

    struct CombatStats: Equatable {
        let turnsPlayed: Int
        let totalDamageDealt: Int
        let totalDamageTaken: Int
        let cardsPlayed: Int

        var summary: String {
            L10n.combatTurnsStats.localized(with: turnsPlayed, totalDamageDealt, totalDamageTaken)
        }
    }

    enum CombatPhase {
        case playerTurn
        case enemyTurn
        case endTurn
        case combatOver
    }

    @State private var phase: CombatPhase = .playerTurn
    @State private var turnNumber: Int = 1
    @State private var actionsRemaining: Int = 3
    @State private var combatLog: [String] = []
    @State private var lastMessage: String = ""
    @State private var showingMessage = false

    // Ð‘Ð¾ÐµÐ²Ñ‹Ðµ Ð±Ð¾Ð½ÑƒÑÑ‹ (ÑÐ±Ñ€Ð°ÑÑ‹Ð²Ð°ÑŽÑ‚ÑÑ Ð² ÐºÐ¾Ð½Ñ†Ðµ Ñ…Ð¾Ð´Ð°/Ð¿Ð¾ÑÐ»Ðµ Ð°Ñ‚Ð°ÐºÐ¸)
    @State private var bonusDice: Int = 0          // Ð”Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ ÐºÑƒÐ±Ð¸ÐºÐ¸ Ð¾Ñ‚ ÐºÐ°Ñ€Ñ‚
    @State private var bonusDamage: Int = 0        // Ð‘Ð¾Ð½ÑƒÑÐ½Ñ‹Ð¹ ÑƒÑ€Ð¾Ð½
    @State private var canReroll: Bool = false     // Ð’Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ÑÑ‚ÑŒ Ð¿ÐµÑ€ÐµÐ±Ñ€Ð¾ÑÐ¸Ñ‚ÑŒ ÐºÑƒÐ±Ð¸Ðº
    @State private var summonedSpirits: [(power: Int, realm: Realm)] = []  // ÐŸÑ€Ð¸Ð·Ð²Ð°Ð½Ð½Ñ‹Ðµ Ð´ÑƒÑ…Ð¸
    @State private var isFirstAttackThisCombat: Bool = true  // Ð”Ð»Ñ ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚Ð¸ Ð¡Ð»ÐµÐ´Ð¾Ð¿Ñ‹Ñ‚Ð°
    @State private var lastCombatResult: CombatResult? = nil  // ÐŸÐ¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð°Ñ‚Ð°ÐºÐ¸

    // NEW: Temporary Shield (Ð·Ð°Ñ‰Ð¸Ñ‚Ð° Ð¾Ñ‚ ÐºÐ°Ñ€Ñ‚, Ð¿Ð¾Ð³Ð»Ð¾Ñ‰Ð°ÐµÑ‚ ÑƒÑ€Ð¾Ð½, ÑÐ±Ñ€Ð°ÑÑ‹Ð²Ð°ÐµÑ‚ÑÑ Ð² ÐºÐ¾Ð½Ñ†Ðµ Ñ€Ð°ÑƒÐ½Ð´Ð°)
    @State private var temporaryShield: Int = 0

    // Combat statistics tracking
    @State private var totalDamageDealt: Int = 0
    @State private var totalDamageTaken: Int = 0
    @State private var cardsPlayedCount: Int = 0

    // Combat end state (for victory/defeat screen)
    @State private var finalCombatStats: CombatStats? = nil
    @State private var isVictory: Bool = false
    @State private var defeatedMonsterName: String = ""  // Saved before combat ends for UI
    @State private var savedMonsterCard: Card? = nil     // Saved monster for display after combat ends

    // Dice roll animation state
    @State private var showDiceRollOverlay: Bool = false
    @State private var animatingDiceValues: [Int] = []
    @State private var diceAnimationPhase: Int = 0
    @State private var pendingDamageApplication: (() -> Void)? = nil  // Deferred damage application

    // MARK: - Computed Properties (Engine-First)

    /// Monster from engine combat state
    /// Uses savedMonsterCard when combat is over to avoid "Unknown" display
    private var monster: Card {
        get {
            // After combat ends, use saved monster card to display correct info
            if phase == .combatOver, let saved = savedMonsterCard {
                return saved
            }
            return engine.combatState?.enemy ?? savedMonsterCard ?? Card(
                name: "Unknown",
                type: .monster,
                description: "Unknown enemy"
            )
        }
    }

    /// Monster health from engine (reads @Published property directly for SwiftUI reactivity)
    private var monsterHealth: Int {
        // After combat ends with victory, show 0 HP
        if phase == .combatOver {
            // Check if it was a victory (enemy defeated)
            if engine.combatEnemyHealth <= 0 {
                return 0
            }
            // Otherwise return last known value or monster's base health
            return engine.combatEnemyHealth > 0 ? engine.combatEnemyHealth : (monster.health ?? 10)
        }
        // During active combat, use engine value directly
        if engine.isInCombat {
            return engine.combatEnemyHealth
        }
        // Fallback for when combat hasn't started yet
        return monster.health ?? 10
    }

    // MARK: - Initialization (Engine-First only)

    init(engine: TwilightGameEngine, onCombatEnd: @escaping (CombatOutcome) -> Void) {
        self.engine = engine
        self.onCombatEnd = onCombatEnd
    }

    var body: some View {
        VStack(spacing: 0) {
            // Hero Panel (persistent, consistent design)
            HeroPanel(engine: engine, compact: true, showAvatar: true)
                .padding(.horizontal, Spacing.sm)
                .padding(.top, Spacing.xxs)

            // Ð’ÐµÑ€Ñ…Ð½ÑÑ Ð¿Ð°Ð½ÐµÐ»ÑŒ
            combatHeader

            // ÐžÑÐ½Ð¾Ð²Ð½Ð°Ñ Ð¾Ð±Ð»Ð°ÑÑ‚ÑŒ Ð±Ð¾Ñ
            ScrollView {
                VStack(spacing: Spacing.lg) {
                    // ÐœÐ¾Ð½ÑÑ‚Ñ€
                    monsterCard

                    // VS Ñ€Ð°Ð·Ð´ÐµÐ»Ð¸Ñ‚ÐµÐ»ÑŒ
                    vsIndicator

                    // Ð˜Ð³Ñ€Ð¾Ðº
                    playerStats

                    // Ð˜Ð½ÑÑ‚Ñ€ÑƒÐºÑ†Ð¸Ð¸ Ð¸ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ
                    if phase == .playerTurn {
                        playerTurnControls
                    } else if phase == .enemyTurn {
                        enemyTurnView
                    } else if phase == .endTurn {
                        endTurnView
                    } else if phase == .combatOver {
                        combatOverView
                    }

                    // Ð›Ð¾Ð³ Ð±Ð¾Ñ
                    combatLogView
                }
                .padding()
            }

            Divider()

            // Ð ÑƒÐºÐ° Ð¸Ð³Ñ€Ð¾ÐºÐ°
            playerHandView
        }
        .background(Color(UIColor.systemBackground))
        .accessibilityIdentifier(AccessibilityIdentifiers.Combat.view)
        .overlay {
            // Dice roll animation overlay
            if showDiceRollOverlay {
                diceRollOverlay
            }
        }
        .alert(L10n.combatTitle.localized, isPresented: $showingMessage) {
            Button(L10n.buttonOk.localized) { }
        } message: {
            Text(lastMessage)
        }
        .onAppear {
            startCombat()
        }
    }

    // MARK: - Header

    var combatHeader: some View {
        HStack {
            // Ð¥Ð¾Ð´ Ð¸ Ñ„Ð°Ð·Ð°
            VStack(alignment: .leading, spacing: Spacing.xxxs) {
                Text(L10n.combatTurnNumber.localized(with: turnNumber))
                    .font(.headline)
                Text(phaseText)
                    .font(.subheadline)
                    .foregroundColor(phaseColor)
            }

            Spacer()

            // Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ (Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð² Ñ…Ð¾Ð´ Ð¸Ð³Ñ€Ð¾ÐºÐ°)
            if phase == .playerTurn {
                HStack(spacing: Spacing.xs) {
                    ForEach(0..<3, id: \.self) { i in
                        Circle()
                            .fill(i < actionsRemaining ? AppColors.power : AppColors.secondary.opacity(Opacity.light))
                            .frame(width: Sizes.iconTiny, height: Sizes.iconTiny)
                    }
                }

                Text("\(actionsRemaining)/3")
                    .font(.headline)
                    .foregroundColor(AppColors.power)
                    .padding(.leading, Spacing.xxs)
            }

            Spacer()

            // ÐšÐ½Ð¾Ð¿ÐºÐ° Ð¿Ð¾Ð±ÐµÐ³Ð°
            Button(action: flee) {
                HStack(spacing: Spacing.xxs) {
                    Image(systemName: "figure.run")
                    Text(L10n.combatFleeButton.localized)
                        .font(.caption)
                }
                .foregroundColor(AppColors.secondary)
                .padding(.horizontal, Spacing.md)
                .padding(.vertical, Spacing.xs)
                .background(AppColors.secondary.opacity(Opacity.faint))
                .cornerRadius(CornerRadius.md)
            }
            .disabled(phase != .playerTurn)
        }
        .padding()
        .background(AppColors.cardBackground)
    }

    // MARK: - Monster Card

    var monsterCard: some View {
        VStack(spacing: Spacing.sm) {
            Text(monster.name)
                .font(.title2)
                .fontWeight(.bold)
                .foregroundColor(AppColors.danger)

            HStack(spacing: Spacing.xxxl) {
                // HP Ð¼Ð¾Ð½ÑÑ‚Ñ€Ð° (Engine-First: read from engine.combatState)
                VStack {
                    Image(systemName: "heart.fill")
                        .font(.title)
                        .foregroundColor(AppColors.health)
                    Text("\(monsterHealth)")
                        .font(.title)
                        .fontWeight(.bold)
                    Text(L10n.combatHP.localized)
                        .font(.caption)
                        .foregroundColor(AppColors.muted)
                }

                // ÐÑ‚Ð°ÐºÐ° Ð¼Ð¾Ð½ÑÑ‚Ñ€Ð°
                VStack {
                    Image(systemName: "burst.fill")
                        .font(.title)
                        .foregroundColor(AppColors.power)
                    Text("\(monster.power ?? 3)")
                        .font(.title)
                        .fontWeight(.bold)
                    Text(L10n.combatAttack.localized)
                        .font(.caption)
                        .foregroundColor(AppColors.muted)
                }

                // Ð—Ð°Ñ‰Ð¸Ñ‚Ð° Ð¼Ð¾Ð½ÑÑ‚Ñ€Ð°
                VStack {
                    Image(systemName: "shield.fill")
                        .font(.title)
                        .foregroundColor(AppColors.defense)
                    Text("\(monster.defense ?? 10)")
                        .font(.title)
                        .fontWeight(.bold)
                    Text(L10n.combatDefense.localized)
                        .font(.caption)
                        .foregroundColor(AppColors.muted)
                }
            }
        }
        .padding()
        .frame(maxWidth: .infinity)
        .background(
            RoundedRectangle(cornerRadius: CornerRadius.lg)
                .fill(AppColors.danger.opacity(0.1))
                .overlay(
                    RoundedRectangle(cornerRadius: CornerRadius.lg)
                        .stroke(AppColors.danger, lineWidth: 2)
                )
        )
    }

    var vsIndicator: some View {
        HStack {
            Rectangle().fill(AppColors.danger.opacity(Opacity.medium)).frame(height: Spacing.xxxs)
            Text("âš”ï¸ VS âš”ï¸")
                .font(.headline)
                .padding(.horizontal, Spacing.sm)
            Rectangle().fill(AppColors.danger.opacity(Opacity.medium)).frame(height: Spacing.xxxs)
        }
    }

    // MARK: - Player Stats (Engine-First: reads from engine.player*)

    var playerStats: some View {
        VStack(spacing: Spacing.sm) {
            // Main stats row
            HStack(spacing: Spacing.xl) {
                VStack {
                    Image(systemName: "heart.fill")
                        .foregroundColor(AppColors.health)
                    Text("\(engine.playerHealth)/\(engine.playerMaxHealth)")
                        .fontWeight(.bold)
                    Text(L10n.combatHP.localized)
                        .font(.caption)
                        .foregroundColor(AppColors.muted)
                }

                VStack {
                    Image(systemName: "hand.raised.fill")
                        .foregroundColor(AppColors.power)
                    Text("\(engine.playerStrength)")
                        .fontWeight(.bold)
                    Text(L10n.combatStrength.localized)
                        .font(.caption)
                        .foregroundColor(AppColors.muted)
                }

                VStack {
                    Image(systemName: "sparkles")
                        .foregroundColor(AppColors.faith)
                    Text("\(engine.playerFaith)")
                        .fontWeight(.bold)
                    Text(L10n.tmResourceFaith.localized)
                        .font(.caption)
                        .foregroundColor(AppColors.muted)
                }

                // NEW: Shield display
                if temporaryShield > 0 {
                    VStack {
                        Image(systemName: "shield.fill")
                            .foregroundColor(.cyan)
                        Text("\(temporaryShield)")
                            .fontWeight(.bold)
                        Text(L10n.combatShield.localized)
                            .font(.caption)
                            .foregroundColor(AppColors.muted)
                    }
                }
            }

            // Combat bonuses indicator (if any)
            if bonusDice > 0 || bonusDamage > 0 {
                HStack(spacing: Spacing.md) {
                    if bonusDice > 0 {
                        HStack(spacing: Spacing.xxs) {
                            Image(systemName: "dice.fill")
                                .foregroundColor(AppColors.dark)
                            Text("+\(bonusDice)")
                                .font(.caption)
                                .fontWeight(.bold)
                                .foregroundColor(AppColors.dark)
                        }
                    }
                    if bonusDamage > 0 {
                        HStack(spacing: Spacing.xxs) {
                            Image(systemName: "flame.fill")
                                .foregroundColor(AppColors.power)
                            Text("+\(bonusDamage)")
                                .font(.caption)
                                .fontWeight(.bold)
                                .foregroundColor(AppColors.power)
                        }
                    }
                }
                .padding(.horizontal, Spacing.sm)
                .padding(.vertical, Spacing.xxs)
                .background(AppColors.dark.opacity(0.1))
                .cornerRadius(CornerRadius.md)
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: CornerRadius.lg)
                .fill(AppColors.defense.opacity(0.1))
        )
    }

    // MARK: - Player Turn Controls

    var playerTurnControls: some View {
        VStack(spacing: Spacing.lg) {
            // Ð˜Ð½ÑÑ‚Ñ€ÑƒÐºÑ†Ð¸Ñ
            VStack(spacing: Spacing.xxs) {
                Text(L10n.combatPlayerTurn.localized)
                    .font(.headline)
                    .foregroundColor(AppColors.success)

                if actionsRemaining > 0 {
                    Text(L10n.combatActionsRemaining.localized(with: actionsRemaining))
                        .font(.subheadline)
                    Text(L10n.combatTapToPlay.localized)
                        .font(.caption)
                        .foregroundColor(AppColors.muted)
                } else {
                    Text(L10n.combatActionsRemaining.localized(with: 0))
                        .font(.subheadline)
                        .foregroundColor(AppColors.power)
                    Text(L10n.combatEndTurnButton.localized)
                        .font(.caption)
                        .foregroundColor(AppColors.muted)
                }
            }
            .padding()
            .frame(maxWidth: .infinity)
            .background(AppColors.success.opacity(0.1))
            .cornerRadius(CornerRadius.lg)

            // ÐšÐ½Ð¾Ð¿ÐºÐ¸ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ð¹ (ÐºÐ°Ð¶Ð´Ð¾Ðµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ Ñ‚Ñ€Ð°Ñ‚Ð¸Ñ‚ 1 Ð¸Ð· 3)
            HStack(spacing: Spacing.sm) {
                // Ð‘Ð°Ð·Ð¾Ð²Ð°Ñ Ð°Ñ‚Ð°ÐºÐ°
                Button(action: performBasicAttack) {
                    VStack(spacing: Spacing.xxs) {
                        Image(systemName: "hand.raised.fill")
                            .font(.title2)
                        Text(L10n.combatAttackButton.localized)
                            .font(.caption)
                            .fontWeight(.semibold)
                        // Show accumulated bonuses
                        if bonusDamage > 0 || bonusDice > 0 {
                            Text("+\(bonusDamage)ðŸ’¥ +\(bonusDice)ðŸŽ²")
                                .font(.system(size: 9))
                                .foregroundColor(AppColors.faith)
                        } else {
                            Text(L10n.combatActionCost.localized)
                                .font(.system(size: 9))
                                .foregroundColor(.white.opacity(Opacity.high))
                        }
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(actionsRemaining > 0 ? AppColors.power : AppColors.secondary)
                    .foregroundColor(.white)
                    .cornerRadius(CornerRadius.lg)
                }
                .disabled(actionsRemaining <= 0)
                .accessibilityIdentifier(AccessibilityIdentifiers.Combat.attackButton)

                // NEW: Ð£ÐºÑ€Ñ‹Ñ‚Ð¸Ðµ (Defend/Take Cover)
                Button(action: performDefend) {
                    VStack(spacing: Spacing.xxs) {
                        Image(systemName: "shield.fill")
                            .font(.title2)
                        Text(L10n.combatDefend.localized)
                            .font(.caption)
                            .fontWeight(.semibold)
                        Text("+3ðŸ›¡ï¸ (-1)")
                            .font(.system(size: 9))
                            .foregroundColor(.white.opacity(Opacity.high))
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(actionsRemaining > 0 ? Color.cyan : AppColors.secondary)
                    .foregroundColor(.white)
                    .cornerRadius(CornerRadius.lg)
                }
                .disabled(actionsRemaining <= 0)

                // Ð—Ð°Ð²ÐµÑ€ÑˆÐ¸Ñ‚ÑŒ Ñ…Ð¾Ð´
                Button(action: endPlayerTurn) {
                    VStack(spacing: Spacing.xxs) {
                        Image(systemName: "arrow.right.circle.fill")
                            .font(.title2)
                        Text(L10n.combatEndTurnButton.localized)
                            .font(.caption)
                            .fontWeight(.semibold)
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(AppColors.dark)
                    .foregroundColor(.white)
                    .cornerRadius(CornerRadius.lg)
                }
                .accessibilityIdentifier(AccessibilityIdentifiers.Combat.endTurnButton)
            }
            .accessibilityIdentifier(AccessibilityIdentifiers.Combat.actionBar)
        }
    }

    // MARK: - Enemy Turn View

    var enemyTurnView: some View {
        VStack(spacing: Spacing.md) {
            Text(L10n.combatEnemyTurn.localized)
                .font(.headline)
                .foregroundColor(AppColors.danger)

            HStack {
                Image(systemName: "burst.fill")
                    .foregroundColor(AppColors.danger)
                Text(L10n.combatLogEnemyAttacks.localized(with: monster.name))
            }

            ProgressView()
                .progressViewStyle(CircularProgressViewStyle(tint: AppColors.danger))
        }
        .padding()
        .frame(maxWidth: .infinity)
        .background(AppColors.danger.opacity(0.1))
        .cornerRadius(CornerRadius.lg)
        .onAppear {
            performEnemyAttack()
        }
    }

    // MARK: - End Turn View

    var endTurnView: some View {
        VStack(spacing: Spacing.md) {
            Text(L10n.combatEndTurn.localized)
                .font(.headline)
                .foregroundColor(AppColors.dark)

            ProgressView()
                .progressViewStyle(CircularProgressViewStyle(tint: AppColors.dark))
        }
        .padding()
        .frame(maxWidth: .infinity)
        .background(AppColors.dark.opacity(0.1))
        .cornerRadius(CornerRadius.lg)
        .onAppear {
            performEndTurn()
        }
    }

    // MARK: - Combat Over View (Full-screen victory/defeat display)
    // Player must tap "Continue" to dismiss - no auto-dismiss

    var combatOverView: some View {
        VStack(spacing: Spacing.xxl) {
            Spacer()

            // Victory/Defeat Icon and Title
            if isVictory {
                VStack(spacing: Spacing.md) {
                    Text("ðŸŽ‰")
                        .font(.system(size: Sizes.iconRegion + Spacing.md))

                    Text(L10n.combatVictory.localized)
                        .font(.largeTitle)
                        .fontWeight(.bold)
                        .foregroundColor(AppColors.success)

                    Text(L10n.combatMonsterDefeated.localized(with: defeatedMonsterName))
                        .font(.title3)
                        .foregroundColor(AppColors.muted)
                }
            } else {
                VStack(spacing: Spacing.md) {
                    Text("ðŸ’€")
                        .font(.system(size: Sizes.iconRegion + Spacing.md))

                    Text(L10n.combatDefeat.localized)
                        .font(.largeTitle)
                        .fontWeight(.bold)
                        .foregroundColor(AppColors.danger)

                    Text(L10n.combatFallen.localized)
                        .font(.title3)
                        .foregroundColor(AppColors.muted)
                }
            }

            // Combat Statistics
            if let stats = finalCombatStats {
                VStack(spacing: Spacing.lg) {
                    Text("ðŸ“Š " + L10n.combatLogTitle.localized)
                        .font(.headline)
                        .foregroundColor(.primary)

                    HStack(spacing: Spacing.xxxl) {
                        // Turns
                        VStack {
                            Text("\(stats.turnsPlayed)")
                                .font(.title)
                                .fontWeight(.bold)
                                .foregroundColor(AppColors.defense)
                            Text(L10n.combatStatsTurns.localized)
                                .font(.caption)
                                .foregroundColor(AppColors.muted)
                        }

                        // Damage dealt
                        VStack {
                            Text("\(stats.totalDamageDealt)")
                                .font(.title)
                                .fontWeight(.bold)
                                .foregroundColor(AppColors.power)
                            Text(L10n.combatStatsDamageDealt.localized)
                                .font(.caption)
                                .foregroundColor(AppColors.muted)
                        }

                        // Damage taken
                        VStack {
                            Text("\(stats.totalDamageTaken)")
                                .font(.title)
                                .fontWeight(.bold)
                                .foregroundColor(AppColors.danger)
                            Text(L10n.combatStatsDamageTaken.localized)
                                .font(.caption)
                                .foregroundColor(AppColors.muted)
                        }

                        // Cards played
                        VStack {
                            Text("\(stats.cardsPlayed)")
                                .font(.title)
                                .fontWeight(.bold)
                                .foregroundColor(AppColors.dark)
                            Text(L10n.combatStatsCardsPlayed.localized)
                                .font(.caption)
                                .foregroundColor(AppColors.muted)
                        }
                    }
                }
                .padding()
                .background(AppColors.cardBackground)
                .cornerRadius(CornerRadius.lg)
            }

            Spacer()

            // Continue Button - player controls when to dismiss
            Button(action: {
                let stats = finalCombatStats ?? CombatStats(
                    turnsPlayed: turnNumber,
                    totalDamageDealt: totalDamageDealt,
                    totalDamageTaken: totalDamageTaken,
                    cardsPlayed: cardsPlayedCount
                )
                let outcome: CombatOutcome = isVictory ? .victory(stats: stats) : .defeat(stats: stats)
                onCombatEnd(outcome)
            }) {
                HStack {
                    Image(systemName: isVictory ? "arrow.right.circle.fill" : "arrow.counterclockwise.circle.fill")
                    Text(isVictory ? L10n.combatContinue.localized : L10n.combatReturn.localized)
                }
                .font(.title2)
                .fontWeight(.semibold)
                .foregroundColor(.white)
                .frame(maxWidth: .infinity)
                .padding()
                .background(isVictory ? AppColors.success : AppColors.defense)
                .cornerRadius(CornerRadius.lg)
            }
            .padding(.horizontal)
            .padding(.bottom, Spacing.xxxl)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(
            LinearGradient(
                gradient: Gradient(colors: isVictory
                    ? [AppColors.success.opacity(0.1), Color.black.opacity(Opacity.light)]
                    : [AppColors.danger.opacity(0.1), Color.black.opacity(Opacity.light)]),
                startPoint: .top,
                endPoint: .bottom
            )
        )
    }

    // MARK: - Combat Log

    var combatLogView: some View {
        VStack(alignment: .leading, spacing: Spacing.sm) {
            // Ð”ÐµÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÐµÐ¹ Ð°Ñ‚Ð°ÐºÐ¸
            if let result = lastCombatResult {
                combatResultDetailView(result)
            }

            // Ð–ÑƒÑ€Ð½Ð°Ð» Ð±Ð¾Ñ
            VStack(alignment: .leading, spacing: Spacing.xxs) {
                Text("ðŸ“œ " + L10n.combatLogTitle.localized)
                    .font(.caption)
                    .fontWeight(.bold)
                    .foregroundColor(AppColors.muted)

                ForEach(Array(combatLog.suffix(5).enumerated()), id: \.offset) { index, entry in
                    Text("â€¢ \(entry)")
                        .font(.caption2)
                        .foregroundColor(AppColors.muted)
                }
            }
            .frame(maxWidth: .infinity, alignment: .leading)
            .padding()
            .background(Color(UIColor.tertiarySystemBackground))
            .cornerRadius(CornerRadius.md)
        }
    }

    /// Ð”ÐµÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð²Ð¸Ð´ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð° Ð°Ñ‚Ð°ÐºÐ¸
    func combatResultDetailView(_ result: CombatResult) -> some View {
        VStack(alignment: .leading, spacing: Spacing.xs) {
            // Ð—Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ðµ/Ð¿Ñ€Ð¾Ð¼Ð°Ñ…
            HStack {
                Text(result.isHit ? L10n.combatHitResult.localized : L10n.combatMissResult.localized)
                    .font(.headline)
                    .fontWeight(.bold)
                    .foregroundColor(result.isHit ? AppColors.success : AppColors.danger)

                Spacer()

                // ÐžÐ±Ñ‰Ð¸Ð¹ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚
                Text(L10n.combatAttackVsDefense.localized(with: result.attackRoll.total, result.defenseValue))
                    .font(.caption)
                    .foregroundColor(AppColors.muted)
            }

            Divider()

            // Ð Ð°Ð·Ð±Ð¸Ð²ÐºÐ° Ð±Ñ€Ð¾ÑÐºÐ° Ð°Ñ‚Ð°ÐºÐ¸
            VStack(alignment: .leading, spacing: Spacing.xxxs) {
                Text(L10n.combatAttackRollTitle.localized)
                    .font(.caption)
                    .fontWeight(.semibold)

                HStack(spacing: Spacing.xxs) {
                    Text("ðŸ’ª \(result.attackRoll.baseStrength)")
                        .font(.caption2)

                    Text("+")
                        .font(.caption2)
                        .foregroundColor(AppColors.muted)

                    // ÐšÑƒÐ±Ð¸ÐºÐ¸
                    ForEach(result.attackRoll.diceRolls.indices, id: \.self) { index in
                        diceView(result.attackRoll.diceRolls[index])
                    }

                    if result.attackRoll.bonusDamage > 0 {
                        Text("+ \(result.attackRoll.bonusDamage)")
                            .font(.caption2)
                            .foregroundColor(AppColors.power)
                    }

                    Text("= \(result.attackRoll.total)")
                        .font(.caption)
                        .fontWeight(.bold)
                }

                // ÐœÐ¾Ð´Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð¾Ñ€Ñ‹ Ð°Ñ‚Ð°ÐºÐ¸
                ForEach(result.attackRoll.modifiers.indices, id: \.self) { index in
                    let modifier = result.attackRoll.modifiers[index]
                    Text("\(modifier.icon) \(modifier.description)")
                        .font(.caption2)
                        .foregroundColor(AppColors.defense)
                }
            }

            // Ð Ð°ÑÑ‡Ñ‘Ñ‚ ÑƒÑ€Ð¾Ð½Ð° (ÐµÑÐ»Ð¸ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ðµ)
            if result.isHit, let damage = result.damageCalculation {
                Divider()

                VStack(alignment: .leading, spacing: Spacing.xxxs) {
                    Text(L10n.combatDamageCalcTitle.localized)
                        .font(.caption)
                        .fontWeight(.semibold)

                    HStack {
                        Text(L10n.combatBaseValue.localized(with: damage.base))
                            .font(.caption2)

                        ForEach(damage.modifiers.indices, id: \.self) { index in
                            let mod = damage.modifiers[index]
                            Text("\(mod.value > 0 ? "+" : "")\(mod.value)")
                                .font(.caption2)
                                .foregroundColor(mod.value > 0 ? AppColors.success : AppColors.danger)
                        }

                        Text("= \(damage.total) ðŸ’¥")
                            .font(.caption)
                            .fontWeight(.bold)
                            .foregroundColor(AppColors.danger)
                    }

                    // Ð”ÐµÑ‚Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð¼Ð¾Ð´Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð¾Ñ€Ð¾Ð² ÑƒÑ€Ð¾Ð½Ð°
                    ForEach(damage.modifiers.indices, id: \.self) { index in
                        let modifier = damage.modifiers[index]
                        HStack(spacing: Spacing.xxs) {
                            Text(modifier.icon)
                            Text(modifier.description)
                            Text("\(modifier.value > 0 ? "+" : "")\(modifier.value)")
                                .foregroundColor(modifier.value > 0 ? AppColors.success : AppColors.danger)
                        }
                        .font(.caption2)
                    }
                }
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: CornerRadius.md)
                .fill(result.isHit ? AppColors.success.opacity(0.1) : AppColors.danger.opacity(0.1))
                .overlay(
                    RoundedRectangle(cornerRadius: CornerRadius.md)
                        .stroke(result.isHit ? AppColors.success : AppColors.danger, lineWidth: 1)
                )
        )
    }

    /// Ð’Ð¸Ð´ ÐºÑƒÐ±Ð¸ÐºÐ°
    func diceView(_ value: Int) -> some View {
        ZStack {
            RoundedRectangle(cornerRadius: CornerRadius.sm)
                .fill(Color.white)
                .frame(width: Spacing.xxl, height: Spacing.xxl)
                .shadow(radius: 1)

            Text("\(value)")
                .font(.caption)
                .fontWeight(.bold)
                .foregroundColor(value >= 5 ? AppColors.success : value <= 2 ? AppColors.danger : .black)
        }
    }

    // MARK: - Dice Roll Overlay

    /// Prominent dice roll animation overlay
    var diceRollOverlay: some View {
        ZStack {
            // Semi-transparent background
            Color.black.opacity(Opacity.mediumHigh)
                .ignoresSafeArea()

            VStack(spacing: Spacing.xl) {
                // Title
                Text(L10n.combatDiceRoll.localized)
                    .font(.title2)
                    .fontWeight(.bold)
                    .foregroundColor(.white)

                // Animated dice
                HStack(spacing: Spacing.lg) {
                    ForEach(animatingDiceValues.indices, id: \.self) { index in
                        animatedDiceView(value: animatingDiceValues[index], index: index)
                    }
                }
                .padding()

                // Result display (after animation completes)
                if let result = lastCombatResult, diceAnimationPhase >= 3 {
                    VStack(spacing: Spacing.md) {
                        // Attack total
                        HStack(spacing: Spacing.sm) {
                            Text("ðŸ’ª \(result.attackRoll.baseStrength)")
                                .foregroundColor(.cyan)
                            Text("+")
                                .foregroundColor(.white)
                            Text("ðŸŽ² \(result.attackRoll.diceTotal)")
                                .foregroundColor(AppColors.faith)
                            if result.attackRoll.bonusDamage > 0 {
                                Text("+")
                                    .foregroundColor(.white)
                                Text("âš”ï¸ \(result.attackRoll.bonusDamage)")
                                    .foregroundColor(AppColors.power)
                            }
                            Text("=")
                                .foregroundColor(.white)
                            Text("\(result.attackRoll.total)")
                                .font(.title)
                                .fontWeight(.bold)
                                .foregroundColor(.white)
                        }
                        .font(.headline)

                        // VS Defense
                        HStack(spacing: Spacing.sm) {
                            Text("vs")
                                .foregroundColor(AppColors.secondary)
                            Text(L10n.combatDefenseValue.localized(with: result.defenseValue))
                                .foregroundColor(AppColors.defense)
                        }
                        .font(.subheadline)

                        // Hit/Miss result
                        if result.isHit {
                            VStack(spacing: Spacing.xxs) {
                                Text(L10n.combatHitResult.localized)
                                    .font(.title)
                                    .fontWeight(.bold)
                                    .foregroundColor(AppColors.success)

                                if let damage = result.damageCalculation {
                                    Text(L10n.combatDamageValue.localized(with: damage.total))
                                        .font(.headline)
                                        .foregroundColor(AppColors.danger)
                                }
                            }
                        } else {
                            Text(L10n.combatMissResult.localized)
                                .font(.title)
                                .fontWeight(.bold)
                                .foregroundColor(AppColors.danger)
                        }
                    }
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: CornerRadius.lg)
                            .fill(Color.black.opacity(Opacity.high))
                    )
                    .transition(.scale.combined(with: .opacity))

                    // Confirmation button - applies damage and closes overlay
                    Button(action: confirmAttackResult) {
                        Text(L10n.buttonOk.localized)
                            .font(.headline)
                            .fontWeight(.bold)
                            .foregroundColor(.white)
                            .frame(width: Sizes.buttonMinWidth, height: Sizes.touchTarget)
                            .background(result.isHit ? AppColors.success : AppColors.danger)
                            .cornerRadius(CornerRadius.lg)
                    }
                    .padding(.top, Spacing.lg)
                }
            }
        }
    }

    /// Confirm attack result - applies pending damage and closes overlay
    func confirmAttackResult() {
        // Apply the pending damage
        pendingDamageApplication?()
        pendingDamageApplication = nil

        // Close overlay
        withAnimation(.easeOut(duration: 0.2)) {
            showDiceRollOverlay = false
        }
    }

    /// Single animated dice
    func animatedDiceView(value: Int, index: Int) -> some View {
        ZStack {
            // Dice background
            RoundedRectangle(cornerRadius: CornerRadius.md)
                .fill(Color.white)
                .frame(width: Sizes.iconRegion, height: Sizes.iconRegion)
                .shadow(color: .black.opacity(Opacity.light), radius: 4, x: 2, y: 2)

            // Dice value
            Text("\(value)")
                .font(.system(size: Sizes.iconLarge, weight: .bold, design: .rounded))
                .foregroundColor(value >= 5 ? AppColors.success : value <= 2 ? AppColors.danger : .black)
        }
        .scaleEffect(diceAnimationPhase >= 2 ? 1.0 : 1.2)
        .rotationEffect(.degrees(diceAnimationPhase >= 2 ? 0 : Double(index * 30)))
        .animation(
            .spring(response: AnimationDuration.slow, dampingFraction: 0.6),
            value: diceAnimationPhase
        )
    }

    /// Trigger dice roll animation
    func showDiceAnimation(diceRolls: [Int]) {
        // Start with random values
        animatingDiceValues = diceRolls.map { _ in Int.random(in: 1...6) }
        diceAnimationPhase = 0

        withAnimation(.easeIn(duration: 0.1)) {
            showDiceRollOverlay = true
        }

        // Animation sequence: roll several times then show final result
        let rollDuration = 0.1

        // Roll 1
        DispatchQueue.main.asyncAfter(deadline: .now() + rollDuration) {
            animatingDiceValues = diceRolls.map { _ in Int.random(in: 1...6) }
            diceAnimationPhase = 1
        }

        // Roll 2
        DispatchQueue.main.asyncAfter(deadline: .now() + rollDuration * 2) {
            animatingDiceValues = diceRolls.map { _ in Int.random(in: 1...6) }
        }

        // Roll 3
        DispatchQueue.main.asyncAfter(deadline: .now() + rollDuration * 3) {
            animatingDiceValues = diceRolls.map { _ in Int.random(in: 1...6) }
        }

        // Final result
        DispatchQueue.main.asyncAfter(deadline: .now() + rollDuration * 4) {
            withAnimation(.spring(response: 0.4, dampingFraction: 0.7)) {
                animatingDiceValues = diceRolls
                diceAnimationPhase = 2
            }
        }

        // Show hit/miss result and OK button
        DispatchQueue.main.asyncAfter(deadline: .now() + rollDuration * 4 + 0.3) {
            withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                diceAnimationPhase = 3
            }
        }
        // No auto-dismiss - player must tap OK button to confirm and apply damage
    }

    // MARK: - Player Hand (Engine-First)

    /// Player's hand cards from engine
    private var playerHand: [Card] {
        engine.playerHand
    }

    var playerHandView: some View {
        VStack(spacing: Spacing.xxs) {
            HStack {
                Text("ðŸƒ " + L10n.combatYourHand.localized + " (\(playerHand.count))")
                    .font(.caption)
                    .foregroundColor(AppColors.muted)

                Spacer()

                if phase == .playerTurn && actionsRemaining > 0 {
                    Text(L10n.combatTapToPlay.localized)
                        .font(.system(size: Spacing.smd))
                        .foregroundColor(AppColors.success)
                }
            }
            .padding(.horizontal)

            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: Spacing.sm) {
                    ForEach(playerHand) { card in
                        CombatCardView(
                            card: card,
                            canPlay: actionsRemaining > 0 && phase == .playerTurn
                        ) {
                            playCard(card)
                        }
                    }
                }
                .padding(.horizontal)
            }
        }
        .frame(height: Sizes.cardHeightMedium + Spacing.smd)
        .background(AppColors.cardBackground)
    }

    // MARK: - Combat Logic (Engine-First: uses engine.performAction())

    func startCombat() {
        // Save monster card for display after combat ends
        savedMonsterCard = engine.combatState?.enemy

        combatLog.append(L10n.combatLogBattleStartEnemy.localized(with: monster.name))
        combatLog.append(L10n.combatLogActionsInfo.localized(with: 3))

        // Engine-First: Initialize combat through engine
        // This handles: shuffle deck, draw initial hand
        engine.performAction(.combatInitialize)

        actionsRemaining = 3
        phase = .playerTurn
    }

    func performBasicAttack() {
        guard actionsRemaining > 0 else { return }

        actionsRemaining -= 1

        let monsterDef = monster.defense ?? 10
        let monsterCurrentHP = monsterHealth
        let monsterMaxHP = monster.health ?? 10

        // Engine-First: Use Engine-based calculator (no Player dependency)
        let result = CombatCalculator.calculateAttackEngineFirst(
            engine: engine,
            monsterDefense: monsterDef,
            monsterCurrentHP: monsterCurrentHP,
            monsterMaxHP: monsterMaxHP,
            bonusDice: bonusDice,
            bonusDamage: bonusDamage,
            isFirstAttack: isFirstAttackThisCombat
        )

        // Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð´Ð»Ñ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ
        lastCombatResult = result

        // Store damage application to be called when player confirms
        pendingDamageApplication = { [self] in
            if result.isHit, let damageCalc = result.damageCalculation {
                let damage = damageCalc.total

                // Track damage for statistics
                totalDamageDealt += damage

                // Engine-First: Apply damage through engine action
                engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: damage)))

                combatLog.append(L10n.combatLogHit.localized(with: result.attackRoll.total, monsterDef, damage, monsterHealth))

                if monsterHealth <= 0 {
                    finishCombat(victory: true)
                }
            } else {
                combatLog.append(L10n.combatLogMissed.localized(with: result.attackRoll.total, monsterDef))
            }
        }

        // Show dice roll animation (player will confirm to apply damage)
        showDiceAnimation(diceRolls: result.attackRoll.diceRolls)

        // Ð¡Ð±Ñ€Ð¾ÑÐ¸Ñ‚ÑŒ Ð±Ð¾Ð½ÑƒÑÑ‹ Ð¿Ð¾ÑÐ»Ðµ Ð°Ñ‚Ð°ÐºÐ¸
        bonusDice = 0
        bonusDamage = 0
        isFirstAttackThisCombat = false
    }

    /// Take Cover / Defend action - adds shield to absorb damage
    func performDefend() {
        guard actionsRemaining > 0 else { return }

        actionsRemaining -= 1

        // Base defend gives +3 shield
        let baseShield = 3

        // Engine-First: use engine strength (no Player dependency)
        let strengthBonus = engine.playerStrength / 2  // Half strength as shield bonus

        let totalShield = baseShield + strengthBonus
        temporaryShield += totalShield

        combatLog.append(L10n.combatLogCover.localized(with: totalShield, temporaryShield))

        // Log breakdown
        if strengthBonus > 0 {
            combatLog.append(L10n.combatLogStrengthBonus.localized(with: strengthBonus))
        }
    }

    /// Play a card as a modifier (does NOT consume actions)
    /// Cards enhance the next action (attack) or add to shield (defense)
    func playCard(_ card: Card) {
        guard phase == .playerTurn else { return }

        // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ ÑÑ‚Ð¾Ð¸Ð¼Ð¾ÑÑ‚ÑŒ Ð²ÐµÑ€Ñ‹ (Engine-First: check via engine)
        // Cards cost Faith to play - this limits infinite card usage
        let faithCost = card.cost ?? 0
        if faithCost > 0 {
            guard engine.playerFaith >= faithCost else {
                combatLog.append(L10n.combatLogInsufficientFaith.localized(with: card.name, faithCost, engine.playerFaith))
                return
            }
            // Engine-First: Spend faith through engine action
            engine.performAction(.combatApplyEffect(effect: .spendFaith(amount: faithCost)))
            combatLog.append(L10n.combatLogFaithSpent.localized(with: faithCost))
        }

        // Track cards played for statistics
        cardsPlayedCount += 1

        // Engine-First: Use engine action to play card (moves from hand to discard)
        engine.performAction(.playCard(cardId: card.id, targetId: nil))

        // NEW: Cards are modifiers, not actions
        // Defense cards add to temporary shield
        // Attack cards add to bonus damage/dice
        switch card.type {
        case .defense, .armor:
            // Defense cards add to temporary shield
            let shieldValue = card.defense ?? card.power ?? 2
            temporaryShield += shieldValue
            combatLog.append(L10n.combatLogShieldCard.localized(with: card.name, shieldValue, temporaryShield))

        case .attack, .weapon:
            // Attack cards add bonus damage
            let attackBonus = card.power ?? 2
            bonusDamage += attackBonus
            combatLog.append(L10n.combatLogAttackBonus.localized(with: card.name, attackBonus))

        case .spell, .ritual:
            // Spells apply their effects
            combatLog.append(L10n.combatLogSpellCast.localized(with: card.name))
            applyCardEffects(card)

        default:
            // Other cards (items, etc.) apply their effects
            combatLog.append(L10n.combatLogCardPlayed.localized(with: card.name))
            applyCardEffects(card)
        }

        // Apply card abilities (on top of type-based effects)
        if card.type != .spell && card.type != .ritual {
            applyCardEffects(card)
        }

        // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð¿Ð¾Ð±ÐµÐ´Ñƒ (Engine-First: read from engine)
        if monsterHealth <= 0 {
            finishCombat(victory: true)
        }
    }

    func applyCardEffects(_ card: Card) {
        for ability in card.abilities {
            switch ability.effect {
            case .heal(let amount):
                // Engine-First: Heal through engine action
                engine.performAction(.combatApplyEffect(effect: .heal(amount: amount)))
                combatLog.append(L10n.combatLogHealEffect.localized(with: amount))

            case .damage(let amount, _):
                // Engine-First: Use engine's calculateDamageDealt (no Player dependency)
                let actualDamage = engine.calculateDamageDealt(amount)
                // Engine-First: Damage enemy through engine action
                engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: actualDamage)))
                // Monster health updated via engine.performAction() - no legacy sync needed
                combatLog.append(L10n.combatLogDamageEffect.localized(with: actualDamage, monsterHealth))

            case .drawCards(let count):
                // Engine-First: Draw cards through engine action (handles deck recycling)
                engine.performAction(.combatApplyEffect(effect: .drawCards(count: count)))
                combatLog.append(L10n.combatLogDrawCards.localized(with: count))

            case .gainFaith(let amount):
                // Engine-First: Gain faith through engine action
                engine.performAction(.combatApplyEffect(effect: .gainFaith(amount: amount)))
                combatLog.append(L10n.combatLogFaithGained.localized(with: amount))

            case .removeCurse(let type):
                // Engine-First: Remove curse through engine action (convert CurseType to String)
                engine.performAction(.combatApplyEffect(effect: .removeCurse(type: type?.rawValue)))
                combatLog.append(L10n.combatLogCurseRemoved.localized)

            case .addDice(let count):
                // Engine-First: Add bonus dice through engine action
                engine.performAction(.combatApplyEffect(effect: .addBonusDice(count: count)))
                bonusDice += count  // Local tracking for UI
                combatLog.append(L10n.combatLogBonusDice.localized(with: count))

            case .reroll:
                // Reroll Ð´Ð°Ñ‘Ñ‚ +1 ÐºÑƒÐ±Ð¸Ðº (Ð²Ñ‹Ð±Ð¸Ñ€Ð°ÐµÑ‚ÑÑ Ð»ÑƒÑ‡ÑˆÐ¸Ð¹ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚)
                engine.performAction(.combatApplyEffect(effect: .addBonusDice(count: 1)))
                bonusDice += 1
                combatLog.append(L10n.combatLogReroll.localized)

            case .shiftBalance(let towards, let amount):
                // Engine-First: Shift balance through engine action
                let directionString = towards == .light ? "light" : towards == .dark ? "dark" : "equilibrium"
                engine.performAction(.combatApplyEffect(effect: .shiftBalance(towards: directionString, amount: amount)))
                let directionText = towards == .light ? L10n.balanceLight.localized : towards == .dark ? L10n.balanceDark.localized : L10n.balanceNeutral.localized
                combatLog.append(L10n.combatLogBalanceShift.localized(with: directionText, amount))

            case .applyCurse(let curseType, let duration):
                // Ð’ Ð±Ð¾ÑŽ Ð¿Ñ€Ð¾ÐºÐ»ÑÑ‚Ð¸Ðµ Ð½Ð°Ð½Ð¾ÑÐ¸Ñ‚ ÑƒÑ€Ð¾Ð½ Ð¼Ð¾Ð½ÑÑ‚Ñ€Ñƒ (Ñ‚Ñ‘Ð¼Ð½Ð°Ñ Ð¼Ð°Ð³Ð¸Ñ)
                let curseDamage = duration * 2
                // Engine-First: Damage enemy through engine action
                engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: curseDamage)))
                // Monster health updated via engine.performAction() - no legacy sync needed
                combatLog.append(L10n.combatLogCurseDamage.localized(with: curseType.rawValue, curseDamage))

            case .summonSpirit(let power, let realm):
                summonedSpirits.append((power: power, realm: realm))
                let realmName = realm == .yav ? L10n.realmYav.localized : realm == .nav ? L10n.realmNav.localized : L10n.realmPrav.localized
                let realmString = realm == .yav ? "yav" : realm == .nav ? "nav" : "prav"
                combatLog.append(L10n.combatLogSpiritSummoned.localized(with: realmName, power))
                // Engine-First: Spirit attacks enemy immediately through engine action
                engine.performAction(.combatApplyEffect(effect: .summonSpirit(power: power, realm: realmString)))
                // Monster health updated via engine.performAction() - no legacy sync needed
                combatLog.append(L10n.combatLogSpiritAttack.localized(with: power))

            case .sacrifice(let cost, let benefit):
                // Engine-First: Take damage through engine action
                engine.performAction(.combatApplyEffect(effect: .takeDamage(amount: cost)))
                combatLog.append("   ðŸ©¸ Ð–ÐµÑ€Ñ‚Ð²Ð°: -\(cost) HP")
                // ÐŸÐ°Ñ€ÑÐ¸Ð¼ benefit Ð´Ð»Ñ ÑÑ„Ñ„ÐµÐºÑ‚Ð°
                if benefit.lowercased().contains("ÑƒÑ€Ð¾Ð½") || benefit.lowercased().contains("damage") {
                    engine.performAction(.combatApplyEffect(effect: .addBonusDamage(amount: cost * 2)))
                    bonusDamage += cost * 2
                    combatLog.append("   ðŸ”¥ +\(cost * 2) Ðº ÑƒÑ€Ð¾Ð½Ñƒ ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐ¹ Ð°Ñ‚Ð°ÐºÐ¸")
                } else if benefit.lowercased().contains("ÐºÐ°Ñ€Ñ‚") || benefit.lowercased().contains("draw") {
                    // Engine-First: Draw cards through engine action
                    engine.performAction(.combatApplyEffect(effect: .drawCards(count: cost)))
                    combatLog.append("   ðŸƒ Ð’Ð·ÑÑ‚Ð¾ ÐºÐ°Ñ€Ñ‚: \(cost)")
                } else {
                    // ÐžÐ±Ñ‰Ð¸Ð¹ Ð±Ð¾Ð½ÑƒÑ - Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ ÑƒÑ€Ð¾Ð½
                    engine.performAction(.combatApplyEffect(effect: .addBonusDamage(amount: cost)))
                    bonusDamage += cost
                    combatLog.append("   ðŸ”¥ +\(cost) Ðº ÑƒÑ€Ð¾Ð½Ñƒ (\(benefit))")
                }

            case .explore:
                // Ð˜ÑÑÐ»ÐµÐ´Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð½Ðµ Ð¿Ñ€Ð¸Ð¼ÐµÐ½Ð¸Ð¼Ð¾ Ð² Ð±Ð¾ÑŽ
                combatLog.append("   ðŸ” Ð˜ÑÑÐ»ÐµÐ´Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾ Ð² Ð±Ð¾ÑŽ")

            case .travelRealm:
                // ÐŸÑƒÑ‚ÐµÑˆÐµÑÑ‚Ð²Ð¸Ðµ Ð¼ÐµÐ¶Ð´Ñƒ Ð¼Ð¸Ñ€Ð°Ð¼Ð¸ Ð½Ðµ Ð¿Ñ€Ð¸Ð¼ÐµÐ½Ð¸Ð¼Ð¾ Ð² Ð±Ð¾ÑŽ
                combatLog.append("   ðŸŒ€ ÐŸÑƒÑ‚ÐµÑˆÐµÑÑ‚Ð²Ð¸Ðµ Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾ Ð² Ð±Ð¾ÑŽ")

            case .permanentStat(let stat, let amount):
                // ÐŸÐ¾ÑÑ‚Ð¾ÑÐ½Ð½Ñ‹Ð¹ Ð±Ð¾Ð½ÑƒÑ Ðº Ñ…Ð°Ñ€Ð°ÐºÑ‚ÐµÑ€Ð¸ÑÑ‚Ð¸ÐºÐµ
                combatLog.append("   â¬†ï¸ ÐŸÐ¾ÑÑ‚Ð¾ÑÐ½Ð½Ñ‹Ð¹ Ð±Ð¾Ð½ÑƒÑ: +\(amount) Ðº \(stat)")

            case .temporaryStat(let stat, let amount, let duration):
                // Ð’Ñ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ð¹ Ð±Ð¾Ð½ÑƒÑ Ðº Ñ…Ð°Ñ€Ð°ÐºÑ‚ÐµÑ€Ð¸ÑÑ‚Ð¸ÐºÐµ
                if stat == "defense" {
                    temporaryShield += amount
                    combatLog.append("   ðŸ›¡ï¸ +\(amount) Ðº Ð·Ð°Ñ‰Ð¸Ñ‚Ðµ Ð½Ð° \(duration) Ñ…Ð¾Ð´(Ð°)")
                } else {
                    bonusDamage += amount
                    combatLog.append("   â¬†ï¸ +\(amount) Ðº \(stat) Ð½Ð° \(duration) Ñ…Ð¾Ð´(Ð°)")
                }

            case .custom(let description):
                combatLog.append("   ðŸ“œ \(description)")
            }
        }
    }

    func endPlayerTurn() {
        phase = .enemyTurn
    }

    func performEnemyAttack() {
        // Capture engine weakly to prevent retain cycles (engine is a class)
        let engineRef = engine
        let monsterName = monster.name
        let monsterPowerVal = monster.power ?? 3
        let currentShield = temporaryShield

        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) { [weak engineRef] in
            guard let engine = engineRef else { return }
            guard engine.combatState?.enemyHealth ?? 0 > 0 else {
                phase = .endTurn
                return
            }

            var rawDamage = monsterPowerVal
            var shieldAbsorbed = 0
            var actualDamage = 0

            // Shield absorbs damage first
            if currentShield > 0 {
                shieldAbsorbed = min(currentShield, rawDamage)
                rawDamage -= shieldAbsorbed
                temporaryShield -= shieldAbsorbed
            }

            // Remaining damage goes to HP (Engine-First: uses takeDamageWithModifiers)
            if rawDamage > 0 {
                let healthBefore = engine.playerHealth
                // Engine handles curse modifiers and hero damage reduction
                engine.takeDamageWithModifiers(rawDamage, fromDarkSource: true)
                actualDamage = healthBefore - engine.playerHealth
            }

            // Track damage taken for statistics (only HP damage, not shield)
            totalDamageTaken += actualDamage

            // Build detailed combat log message
            var logMessage = "ðŸ‘¹ \(monsterName) Ð°Ñ‚Ð°ÐºÑƒÐµÑ‚! Ð¡Ð¸Ð»Ð°: \(monsterPowerVal)"
            if shieldAbsorbed > 0 {
                logMessage += " | ðŸ›¡ï¸ Ð©Ð¸Ñ‚ Ð¿Ð¾Ð³Ð»Ð¾Ñ‚Ð¸Ð»: \(shieldAbsorbed)"
            }
            if actualDamage > 0 {
                logMessage += " | ðŸ’” Ð£Ñ€Ð¾Ð½ HP: \(actualDamage)"
            } else if shieldAbsorbed == monsterPowerVal {
                logMessage += " | âœ¨ ÐŸÐ¾Ð»Ð½Ð¾ÑÑ‚ÑŒÑŽ Ð·Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¾!"
            }
            logMessage += " (HP: \(engine.playerHealth)/\(engine.playerMaxHealth), Ð©Ð¸Ñ‚: \(temporaryShield))"
            combatLog.append(logMessage)

            if engine.playerHealth <= 0 {
                finishCombat(victory: false)
            } else {
                phase = .endTurn
            }
        }
    }

    func performEndTurn() {
        // Capture engine weakly to prevent retain cycles
        let engineRef = engine
        let currentSpirits = summonedSpirits

        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) { [weak engineRef] in
            guard let engine = engineRef else { return }

            // Ð”ÑƒÑ…Ð¸ Ð°Ñ‚Ð°ÐºÑƒÑŽÑ‚ Ð² ÐºÐ¾Ð½Ñ†Ðµ Ñ…Ð¾Ð´Ð° (ÐµÑÐ»Ð¸ ÐµÑ‰Ñ‘ Ð¶Ð¸Ð²Ñ‹)
            if !currentSpirits.isEmpty {
                for spirit in currentSpirits {
                    let spiritDamage = spirit.power
                    // Engine-First: Spirit damage through engine action
                    engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: spiritDamage)))
                    let realmName = spirit.realm == .yav ? "Ð¯Ð²ÑŒ" : spirit.realm == .nav ? "ÐÐ°Ð²ÑŒ" : "ÐŸÑ€Ð°Ð²ÑŒ"
                    combatLog.append("ðŸ‘» Ð”ÑƒÑ… \(realmName) Ð°Ñ‚Ð°ÐºÑƒÐµÑ‚: \(spiritDamage) ÑƒÑ€Ð¾Ð½Ð°")
                }
                // Ð”ÑƒÑ…Ð¸ Ð¸ÑÑ‡ÐµÐ·Ð°ÑŽÑ‚ Ð¿Ð¾ÑÐ»Ðµ Ð°Ñ‚Ð°ÐºÐ¸
                summonedSpirits.removeAll()
            }

            // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð¿Ð¾Ð±ÐµÐ´Ñƒ Ð¿Ð¾ÑÐ»Ðµ Ð°Ñ‚Ð°Ðº Ð´ÑƒÑ…Ð¾Ð² (Engine-First: read from engine)
            if engine.combatState?.enemyHealth ?? 0 <= 0 {
                finishCombat(victory: true)
                return
            }

            // Ð¡Ð±Ñ€Ð°ÑÑ‹Ð²Ð°ÐµÐ¼ Ð±Ð¾Ð½ÑƒÑÑ‹ Ð¸ Ñ‰Ð¸Ñ‚ Ð½Ð° ÐºÐ¾Ð½ÐµÑ† Ñ€Ð°ÑƒÐ½Ð´Ð°
            if temporaryShield > 0 {
                combatLog.append("ðŸ›¡ï¸ Ð’Ñ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ð¹ Ñ‰Ð¸Ñ‚ Ñ€Ð°ÑÑÐµÑÐ»ÑÑ (\(temporaryShield) â†’ 0)")
            }
            bonusDice = 0
            bonusDamage = 0
            temporaryShield = 0  // Shield resets at end of round
            canReroll = false

            // Engine-First: End turn phase through engine action (discard, draw, faith restore)
            // This handles: discard hand, recycle deck, draw new hand, restore faith
            engine.performAction(.combatEndTurnPhase)

            // Ð¡Ð¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚ÑŒ ÐœÐ°Ð³Ð°: +1 Ð²ÐµÑ€Ð° Ð² ÐºÐ¾Ð½Ñ†Ðµ Ñ…Ð¾Ð´Ð° (ÐœÐµÐ´Ð¸Ñ‚Ð°Ñ†Ð¸Ñ) - now handled by Engine
            if engine.shouldGainFaithEndOfTurn {
                combatLog.append("ðŸ”® ÐœÐµÐ´Ð¸Ñ‚Ð°Ñ†Ð¸Ñ: +1 Ð²ÐµÑ€Ð°")
            }

            // ÐÐ¾Ð²Ñ‹Ð¹ Ñ…Ð¾Ð´
            turnNumber += 1
            actionsRemaining = 3

            combatLog.append("â”â”â” Ð¥Ð¾Ð´ \(turnNumber) â”â”â”")

            phase = .playerTurn
        }
    }

    func finishCombat(victory: Bool) {
        phase = .combatOver

        // Save monster name BEFORE engine clears combatEnemy
        defeatedMonsterName = monster.name

        // Engine-First: Finish combat through engine action
        engine.performAction(.combatFinish(victory: victory))

        // Create combat statistics
        let stats = CombatStats(
            turnsPlayed: turnNumber,
            totalDamageDealt: totalDamageDealt,
            totalDamageTaken: totalDamageTaken,
            cardsPlayed: cardsPlayedCount
        )

        // Store stats for display in victory/defeat screen
        finalCombatStats = stats
        isVictory = victory

        if victory {
            combatLog.append("ðŸŽ‰ ÐŸÐ¾Ð±ÐµÐ´Ð°! \(defeatedMonsterName) Ð¿Ð¾Ð²ÐµÑ€Ð¶ÐµÐ½!")
            combatLog.append("ðŸ“Š \(stats.summary)")
        } else {
            combatLog.append("ðŸ’€ ÐŸÐ¾Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ...")
            combatLog.append("ðŸ“Š \(stats.summary)")
        }

        // NOTE: No auto-dismiss! Player taps "Continue" button in combatOverView
        // This lets the player enjoy the victory moment and review stats
    }

    func flee() {
        // Engine-First: Flee combat through engine action
        engine.performAction(.combatFlee)

        combatLog.append("ðŸƒ Ð’Ñ‹ ÑÐ±ÐµÐ¶Ð°Ð»Ð¸ Ð¸Ð· Ð±Ð¾Ñ!")
        onCombatEnd(.fled)
    }

    // MARK: - Helpers

    var phaseText: String {
        switch phase {
        case .playerTurn: return L10n.combatPlayerTurn.localized
        case .enemyTurn: return L10n.combatEnemyTurn.localized
        case .endTurn: return L10n.combatEndTurn.localized
        case .combatOver: return L10n.combatOver.localized
        }
    }

    var phaseColor: Color {
        switch phase {
        case .playerTurn: return .green
        case .enemyTurn: return .red
        case .endTurn: return .purple
        case .combatOver: return .gray
        }
    }
}

// MARK: - Combat Card View

struct CombatCardView: View {
    let card: Card
    let canPlay: Bool
    let onPlay: () -> Void

    var body: some View {
        VStack(spacing: Spacing.xxs) {
            // ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ ÐºÐ°Ñ€Ñ‚Ñ‹
            Text(card.name)
                .font(.caption)
                .fontWeight(.semibold)
                .lineLimit(2)
                .multilineTextAlignment(.center)

            // Ð¡Ñ‚Ð¾Ð¸Ð¼Ð¾ÑÑ‚ÑŒ Ð²ÐµÑ€Ñ‹ (ÐµÑÐ»Ð¸ ÐµÑÑ‚ÑŒ)
            if let cost = card.cost, cost > 0 {
                HStack(spacing: Spacing.xxxs) {
                    Image(systemName: "sparkles")
                        .font(.system(size: Spacing.smd))
                    Text("\(cost)")
                        .font(.caption2)
                }
                .foregroundColor(AppColors.faith)
            }

            // Ð¢Ð¸Ð¿ ÐºÐ°Ñ€Ñ‚Ñ‹
            Text(cardTypeText)
                .font(.system(size: 9))
                .foregroundColor(cardTypeColor)
                .fontWeight(.medium)

            // ÐžÑÐ½Ð¾Ð²Ð½Ð¾Ð¹ ÑÑ„Ñ„ÐµÐºÑ‚
            if let ability = card.abilities.first {
                Text(abilityText(ability))
                    .font(.system(size: Spacing.smd))
                    .foregroundColor(AppColors.muted)
                    .lineLimit(2)
            }
        }
        .frame(width: Sizes.cardWidthSmall + 5, height: Sizes.cardHeightSmall + Spacing.smd)
        .padding(Spacing.xs)
        .background(
            RoundedRectangle(cornerRadius: CornerRadius.md)
                .fill(cardBackground)
                .overlay(
                    RoundedRectangle(cornerRadius: CornerRadius.md)
                        .stroke(canPlay ? cardBorder : AppColors.secondary, lineWidth: canPlay ? 2 : 1)
                )
        )
        .opacity(canPlay ? Opacity.opaque : Opacity.medium)
        .scaleEffect(canPlay ? 1.0 : 0.95)
        .onTapGesture {
            if canPlay {
                onPlay()
            }
        }
    }

    var cardTypeText: String {
        switch card.type {
        case .attack: return "âš”ï¸ ÐÑ‚Ð°ÐºÐ°"
        case .defense: return "ðŸ›¡ Ð—Ð°Ñ‰Ð¸Ñ‚Ð°"
        case .spell: return "âœ¨ Ð—Ð°ÐºÐ»Ð¸Ð½Ð°Ð½Ð¸Ðµ"
        case .resource: return "ðŸ’° Ð ÐµÑÑƒÑ€Ñ"
        default: return "ðŸ“œ ÐšÐ°Ñ€Ñ‚Ð°"
        }
    }

    var cardTypeColor: Color {
        switch card.type {
        case .attack: return AppColors.danger
        case .defense: return AppColors.defense
        case .spell: return AppColors.dark
        case .resource: return AppColors.faith
        default: return AppColors.secondary
        }
    }

    var cardBackground: Color {
        switch card.type {
        case .attack: return AppColors.danger.opacity(0.15)
        case .defense: return AppColors.defense.opacity(0.15)
        case .spell: return AppColors.dark.opacity(0.15)
        case .resource: return AppColors.faith.opacity(0.15)
        default: return AppColors.secondary.opacity(0.15)
        }
    }

    var cardBorder: Color {
        switch card.type {
        case .attack: return AppColors.danger
        case .defense: return AppColors.defense
        case .spell: return AppColors.dark
        case .resource: return AppColors.faith
        default: return AppColors.secondary
        }
    }

    func abilityText(_ ability: CardAbility) -> String {
        switch ability.effect {
        case .damage(let amount, _): return "Ð£Ñ€Ð¾Ð½: \(amount)"
        case .heal(let amount): return "Ð›ÐµÑ‡ÐµÐ½Ð¸Ðµ: +\(amount)"
        case .drawCards(let count): return "ÐšÐ°Ñ€Ñ‚Ñ‹: +\(count)"
        case .gainFaith(let amount): return "Ð’ÐµÑ€Ð°: +\(amount)"
        case .addDice(let count): return "+\(count) ðŸŽ²"
        case .reroll: return "ÐŸÐµÑ€ÐµÐ±Ñ€Ð¾ÑÐ¾Ðº"
        case .shiftBalance(let towards, let amount):
            let dir = towards == .light ? "â˜€ï¸" : towards == .dark ? "ðŸŒ™" : "âš–ï¸"
            return "\(dir) +\(amount)"
        case .applyCurse(let type, _): return "ÐŸÑ€Ð¾ÐºÐ»ÑÑ‚Ð¸Ðµ: \(type)"
        case .removeCurse: return "Ð¡Ð½ÑÑ‚ÑŒ Ð¿Ñ€Ð¾ÐºÐ»ÑÑ‚Ð¸Ðµ"
        case .summonSpirit(let power, let realm):
            let realmIcon = realm == .yav ? "ðŸŒ³" : realm == .nav ? "ðŸ’€" : "â­"
            return "\(realmIcon) Ð”ÑƒÑ… (\(power))"
        case .sacrifice(let cost, _): return "Ð–ÐµÑ€Ñ‚Ð²Ð°: \(cost) HP"
        case .explore: return "Ð˜ÑÑÐ»ÐµÐ´Ð¾Ð²Ð°Ñ‚ÑŒ"
        case .travelRealm(let realm):
            let realmName = realm == .yav ? "Ð¯Ð²ÑŒ" : realm == .nav ? "ÐÐ°Ð²ÑŒ" : "ÐŸÑ€Ð°Ð²ÑŒ"
            return "â†’ \(realmName)"
        case .permanentStat(let stat, let amount): return "+\(amount) \(stat)"
        case .temporaryStat(let stat, let amount, let duration): return "+\(amount) \(stat) (\(duration))"
        case .custom: return ability.description
        }
    }
}


// ==========================================
// FILE: Views/ContentManagerView.swift
// ==========================================

import SwiftUI
import TwilightEngine

/// Content Manager View - shows all packs with status and reload options
struct ContentManagerView: View {
    @StateObject private var viewModel = ContentManagerVM()
    @State private var showingPackDetail = false
    @Environment(\.dismiss) private var dismiss

    /// Bundled pack URLs (passed from app)
    let bundledPackURLs: [URL]

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: Spacing.xl) {
                    // Error banner
                    if let error = viewModel.lastError {
                        errorBanner(error)
                    }

                    // Loaded packs section
                    packSection(
                        title: L10n.contentManagerLoadedPacks.localized,
                        count: viewModel.loadedCount,
                        packs: viewModel.loadedPacks,
                        showReloadAll: false
                    )

                    // Bundled packs section
                    if !viewModel.bundledPacks.isEmpty {
                        packSection(
                            title: L10n.contentManagerBundledPacks.localized,
                            count: viewModel.bundledPacks.count,
                            packs: viewModel.bundledPacks.filter { $0.state != .loaded },
                            showReloadAll: false
                        )
                    }

                    // External packs section
                    externalPacksSection

                    // Instructions
                    instructionsCard
                }
                .padding()
            }
            .navigationTitle(L10n.contentManagerTitle.localized)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button(L10n.back.localized) {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button {
                        Task { await viewModel.refresh() }
                    } label: {
                        Image(systemName: "arrow.clockwise")
                    }
                    .disabled(viewModel.isScanning)
                }
            }
            .sheet(isPresented: $showingPackDetail) {
                if let pack = viewModel.selectedPack {
                    PackDetailView(pack: pack, viewModel: viewModel)
                }
            }
            .task {
                viewModel.setBundledPackURLs(bundledPackURLs)
                await viewModel.refresh()
            }
        }
    }

    // MARK: - Pack Section

    private func packSection(title: String, count: Int, packs: [ManagedPack], showReloadAll: Bool) -> some View {
        Group {
            if !packs.isEmpty {
                VStack(alignment: .leading, spacing: Spacing.md) {
                    HStack {
                        Text("\(title) (\(count))")
                            .font(.headline)
                            .foregroundColor(AppColors.muted)
                        Spacer()
                        if showReloadAll {
                            Button(L10n.contentManagerReloadAll.localized) {
                                Task { await viewModel.reloadAllExternal() }
                            }
                            .font(.caption)
                        }
                    }

                    ForEach(packs) { pack in
                        PackRowView(pack: pack, viewModel: viewModel) {
                            viewModel.selectPack(pack.id)
                            showingPackDetail = true
                        }
                    }
                }
            }
        }
    }

    // MARK: - External Packs Section

    private var externalPacksSection: some View {
        VStack(alignment: .leading, spacing: Spacing.md) {
            HStack {
                Text(L10n.contentManagerExternalPacks.localized)
                    .font(.headline)
                    .foregroundColor(AppColors.muted)
                Spacer()
                if !viewModel.externalPacks.isEmpty {
                    Button(L10n.contentManagerReloadAll.localized) {
                        Task { await viewModel.reloadAllExternal() }
                    }
                    .font(.caption)
                }
            }

            if viewModel.externalPacks.isEmpty {
                Text(L10n.contentManagerNoExternal.localized)
                    .font(.subheadline)
                    .foregroundColor(AppColors.muted)
                    .frame(maxWidth: .infinity, alignment: .center)
                    .padding()
            } else {
                ForEach(viewModel.externalPacks) { pack in
                    PackRowView(pack: pack, viewModel: viewModel) {
                        viewModel.selectPack(pack.id)
                        showingPackDetail = true
                    }
                }
            }
        }
    }

    // MARK: - Instructions Card

    private var instructionsCard: some View {
        VStack(alignment: .leading, spacing: Spacing.sm) {
            HStack {
                Image(systemName: "lightbulb")
                    .foregroundColor(AppColors.warning)
                Text(L10n.contentManagerHowToAdd.localized)
                    .font(.headline)
            }

            Text(L10n.contentManagerPlaceFiles.localized)
                .font(.subheadline)
                .foregroundColor(AppColors.muted)

            HStack {
                Text(viewModel.externalPacksPath)
                    .font(.caption)
                    .foregroundColor(AppColors.muted)
                    .lineLimit(1)
                    .truncationMode(.middle)

                Spacer()

                Button {
                    viewModel.copyPathToClipboard()
                } label: {
                    Image(systemName: "doc.on.doc")
                        .font(.caption)
                }

                #if os(iOS)
                Button {
                    viewModel.openExternalPacksFolder()
                } label: {
                    Text(L10n.contentManagerOpen.localized)
                        .font(.caption)
                }
                #endif
            }
        }
        .padding()
        .background(Color(.systemGray6))
        .cornerRadius(CornerRadius.lg)
    }

    // MARK: - Error Banner

    private func errorBanner(_ message: String) -> some View {
        HStack {
            Image(systemName: "exclamationmark.triangle.fill")
                .foregroundColor(AppColors.danger)
            Text(message)
                .font(.caption)
                .foregroundColor(AppColors.danger)
            Spacer()
            Button {
                viewModel.lastError = nil
            } label: {
                Image(systemName: "xmark")
                    .font(.caption)
            }
        }
        .padding()
        .background(AppColors.danger.opacity(0.1))
        .cornerRadius(CornerRadius.md)
    }
}

// MARK: - Pack Row View

struct PackRowView: View {
    let pack: ManagedPack
    @ObservedObject var viewModel: ContentManagerVM
    let onTap: () -> Void

    var body: some View {
        Button(action: onTap) {
            HStack(spacing: Spacing.md) {
                // Status icon
                statusIcon
                    .frame(width: Sizes.iconSmall)

                // Pack info
                VStack(alignment: .leading, spacing: Spacing.xxs) {
                    HStack {
                        Text(pack.displayName)
                            .font(.headline)
                            .foregroundColor(.primary)
                        Text("v\(pack.versionString)")
                            .font(.caption)
                            .foregroundColor(AppColors.muted)
                    }

                    Text(pack.contentSummary)
                        .font(.caption)
                        .foregroundColor(AppColors.muted)

                    HStack(spacing: Spacing.sm) {
                        Text(pack.localizedSourceName)
                            .font(.caption2)
                            .foregroundColor(AppColors.muted)

                        if let loadedAt = pack.formattedLoadedAt {
                            Text(String(format: L10n.contentManagerLoadedTime.localized, loadedAt))
                                .font(.caption2)
                                .foregroundColor(AppColors.muted)
                        } else {
                            Text(pack.formattedFileSize)
                                .font(.caption2)
                                .foregroundColor(AppColors.muted)
                        }
                    }
                }

                Spacer()

                // Action buttons
                actionButtons
            }
            .padding()
            .background(Color(.secondarySystemBackground))
            .cornerRadius(CornerRadius.lg)
        }
        .buttonStyle(.plain)
    }

    @ViewBuilder
    private var statusIcon: some View {
        switch pack.state {
        case .discovered:
            Image(systemName: "circle")
                .foregroundColor(AppColors.secondary)
        case .validating, .loading:
            ProgressView()
                .scaleEffect(0.7)
        case .validated(let summary):
            if summary.errorCount > 0 {
                Image(systemName: "xmark.circle.fill")
                    .foregroundColor(AppColors.danger)
            } else if summary.warningCount > 0 {
                Image(systemName: "exclamationmark.triangle.fill")
                    .foregroundColor(AppColors.warning)
            } else {
                Image(systemName: "checkmark.circle.fill")
                    .foregroundColor(AppColors.success)
            }
        case .loaded:
            Image(systemName: "checkmark.circle.fill")
                .foregroundColor(AppColors.success)
        case .failed:
            Image(systemName: "xmark.circle.fill")
                .foregroundColor(AppColors.danger)
        }
    }

    @ViewBuilder
    private var actionButtons: some View {
        HStack(spacing: Spacing.sm) {
            // Validate button (for discovered packs)
            if pack.canValidate && pack.state == .discovered {
                Button(L10n.contentManagerValidate.localized) {
                    Task { await viewModel.validatePack(pack.id) }
                }
                .font(.caption)
                .buttonStyle(.bordered)
            }

            // Load button (for validated packs)
            if pack.canLoad {
                Button(L10n.contentManagerLoad.localized) {
                    Task { await viewModel.loadPack(pack.id) }
                }
                .font(.caption)
                .buttonStyle(.borderedProminent)
            }

            // Reload button (for loaded external packs)
            if pack.canReload && pack.state == .loaded {
                Button(L10n.contentManagerReload.localized) {
                    Task { await viewModel.reloadPack(pack.id) }
                }
                .font(.caption)
                .buttonStyle(.bordered)
            }
        }
    }
}

// MARK: - Pack Detail View

struct PackDetailView: View {
    let pack: ManagedPack
    @ObservedObject var viewModel: ContentManagerVM
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: Spacing.xl) {
                    // Header
                    headerSection

                    // Status
                    statusSection

                    // Content counts
                    if pack.state == .loaded {
                        contentSection
                    }

                    // Validation details
                    if let validation = pack.lastValidation {
                        validationSection(validation)
                    }

                    // Actions
                    actionsSection
                }
                .padding()
            }
            .navigationTitle(pack.displayName)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(L10n.contentManagerDone.localized) {
                        dismiss()
                    }
                }
            }
        }
    }

    private var headerSection: some View {
        VStack(spacing: Spacing.sm) {
            Text(pack.displayName)
                .font(.title)
                .fontWeight(.bold)
            Text("v\(pack.versionString)")
                .font(.subheadline)
                .foregroundColor(AppColors.muted)
            Text(pack.localizedPackType)
                .font(.caption)
                .padding(.horizontal, Spacing.sm)
                .padding(.vertical, Spacing.xxs)
                .background(AppColors.primary.opacity(Opacity.faint))
                .foregroundColor(AppColors.primary)
                .cornerRadius(CornerRadius.sm)
        }
    }

    private var statusSection: some View {
        VStack(alignment: .leading, spacing: Spacing.sm) {
            Text(L10n.contentManagerStatus.localized)
                .font(.headline)

            HStack {
                Image(systemName: pack.state.statusIcon)
                    .foregroundColor(statusColor)
                Text(localizedStatusText)
                    .foregroundColor(statusColor)
                Spacer()
            }

            HStack {
                Label(pack.localizedSourceName, systemImage: pack.source.isReloadable ? "arrow.triangle.2.circlepath" : "lock.fill")
                    .font(.caption)
                    .foregroundColor(AppColors.muted)
                Spacer()
                Text(pack.formattedFileSize)
                    .font(.caption)
                    .foregroundColor(AppColors.muted)
            }

            if let loadedAt = pack.formattedLoadedAt {
                Text(String(format: L10n.contentManagerLoadedAt.localized, loadedAt))
                    .font(.caption)
                    .foregroundColor(AppColors.muted)
            }
        }
        .padding()
        .background(Color(.secondarySystemBackground))
        .cornerRadius(CornerRadius.lg)
    }

    private var statusColor: Color {
        switch pack.state {
        case .loaded: return AppColors.success
        case .failed: return AppColors.danger
        case .validated(let s) where s.errorCount > 0: return AppColors.danger
        case .validated(let s) where s.warningCount > 0: return AppColors.warning
        case .validated: return AppColors.success
        default: return AppColors.muted
        }
    }

    private var localizedStatusText: String {
        switch pack.state {
        case .discovered: return L10n.contentManagerStatusDiscovered.localized
        case .validating: return L10n.contentManagerStatusValidating.localized
        case .validated(let s):
            if s.errorCount > 0 { return String(format: L10n.contentManagerStatusErrors.localized, s.errorCount) }
            if s.warningCount > 0 { return String(format: L10n.contentManagerStatusWarnings.localized, s.warningCount) }
            return L10n.contentManagerStatusValid.localized
        case .loading: return L10n.contentManagerStatusLoading.localized
        case .loaded: return L10n.contentManagerStatusLoaded.localized
        case .failed(let e): return String(format: L10n.contentManagerStatusFailed.localized, e)
        }
    }

    private var contentSection: some View {
        VStack(alignment: .leading, spacing: Spacing.sm) {
            Text(L10n.contentManagerContent.localized)
                .font(.headline)

            if let loadedPack = ContentRegistry.shared.loadedPacks[pack.id] {
                LazyVGrid(columns: [
                    GridItem(.flexible()),
                    GridItem(.flexible())
                ], spacing: Spacing.sm) {
                    contentItem(L10n.contentManagerRegions.localized, count: loadedPack.regions.count, icon: "map")
                    contentItem(L10n.contentManagerEvents.localized, count: loadedPack.events.count, icon: "sparkles")
                    contentItem(L10n.contentManagerQuests.localized, count: loadedPack.quests.count, icon: "scroll")
                    contentItem(L10n.contentManagerHeroes.localized, count: loadedPack.heroes.count, icon: "person.fill")
                    contentItem(L10n.contentManagerCards.localized, count: loadedPack.cards.count, icon: "rectangle.portrait.on.rectangle.portrait")
                    contentItem(L10n.contentManagerEnemies.localized, count: loadedPack.enemies.count, icon: "flame")
                }
            }
        }
        .padding()
        .background(Color(.secondarySystemBackground))
        .cornerRadius(CornerRadius.lg)
    }

    private func contentItem(_ title: String, count: Int, icon: String) -> some View {
        HStack {
            Image(systemName: icon)
                .foregroundColor(AppColors.muted)
                .frame(width: Sizes.iconSmall)
            Text(title)
                .font(.caption)
            Spacer()
            Text("\(count)")
                .font(.caption)
                .fontWeight(.semibold)
        }
        .padding(.vertical, Spacing.xs)
    }

    private func validationSection(_ validation: ValidationSummary) -> some View {
        VStack(alignment: .leading, spacing: Spacing.sm) {
            HStack {
                Text(L10n.contentManagerValidation.localized)
                    .font(.headline)
                Spacer()
                Text(String(format: "%.2fs", validation.duration))
                    .font(.caption)
                    .foregroundColor(AppColors.muted)
            }

            HStack(spacing: Spacing.md) {
                Label("\(validation.errorCount)", systemImage: "xmark.circle.fill")
                    .foregroundColor(validation.errorCount > 0 ? AppColors.danger : AppColors.secondary)
                Label("\(validation.warningCount)", systemImage: "exclamationmark.triangle.fill")
                    .foregroundColor(validation.warningCount > 0 ? AppColors.warning : AppColors.secondary)
                Label("\(validation.infoCount)", systemImage: "info.circle.fill")
                    .foregroundColor(AppColors.muted)
            }
            .font(.caption)

            if !validation.errors.isEmpty {
                VStack(alignment: .leading, spacing: Spacing.xs) {
                    Text(L10n.contentManagerValidationErrors.localized)
                        .font(.caption)
                        .fontWeight(.semibold)
                        .foregroundColor(AppColors.danger)
                    ForEach(validation.errors, id: \.self) { error in
                        Text("â€¢ \(error)")
                            .font(.caption2)
                            .foregroundColor(AppColors.danger)
                    }
                }
            }

            if !validation.warnings.isEmpty {
                VStack(alignment: .leading, spacing: Spacing.xs) {
                    Text(L10n.contentManagerValidationWarnings.localized)
                        .font(.caption)
                        .fontWeight(.semibold)
                        .foregroundColor(AppColors.warning)
                    ForEach(validation.warnings, id: \.self) { warning in
                        Text("â€¢ \(warning)")
                            .font(.caption2)
                            .foregroundColor(AppColors.warning)
                    }
                }
            }
        }
        .padding()
        .background(Color(.secondarySystemBackground))
        .cornerRadius(CornerRadius.lg)
    }

    private var actionsSection: some View {
        HStack(spacing: Spacing.md) {
            if pack.canValidate {
                Button {
                    Task { await viewModel.validatePack(pack.id) }
                } label: {
                    Label(L10n.contentManagerValidate.localized, systemImage: "checkmark.shield")
                }
                .buttonStyle(.bordered)
            }

            if pack.canLoad {
                Button {
                    Task { await viewModel.loadPack(pack.id) }
                } label: {
                    Label(L10n.contentManagerLoad.localized, systemImage: "arrow.down.circle")
                }
                .buttonStyle(.borderedProminent)
            }

            if pack.canReload {
                Button {
                    Task { await viewModel.reloadPack(pack.id) }
                } label: {
                    Label(L10n.contentManagerReload.localized, systemImage: "arrow.triangle.2.circlepath")
                }
                .buttonStyle(.bordered)
            }
        }
    }
}

// MARK: - Localization Keys

extension L10n {
    static let contentManagerTitle = "content.manager.title"
    static let contentManagerLoadedPacks = "content.manager.loaded.packs"
    static let contentManagerBundledPacks = "content.manager.bundled.packs"
    static let contentManagerExternalPacks = "content.manager.external.packs"
    static let contentManagerNoExternal = "content.manager.no.external"
    static let contentManagerHowToAdd = "content.manager.how.to.add"
    static let contentManagerPlaceFiles = "content.manager.place.files"
    static let contentManagerOpen = "content.manager.open"
    static let contentManagerReloadAll = "content.manager.reload.all"
    static let contentManagerValidate = "content.manager.validate"
    static let contentManagerLoad = "content.manager.load"
    static let contentManagerReload = "content.manager.reload"
    static let contentManagerDone = "content.manager.done"

    // Status
    static let contentManagerStatus = "content.manager.status"
    static let contentManagerStatusDiscovered = "content.manager.status.discovered"
    static let contentManagerStatusValidating = "content.manager.status.validating"
    static let contentManagerStatusValid = "content.manager.status.valid"
    static let contentManagerStatusErrors = "content.manager.status.errors"
    static let contentManagerStatusWarnings = "content.manager.status.warnings"
    static let contentManagerStatusLoading = "content.manager.status.loading"
    static let contentManagerStatusLoaded = "content.manager.status.loaded"
    static let contentManagerStatusFailed = "content.manager.status.failed"
    static let contentManagerLoadedAt = "content.manager.loaded.at"
    static let contentManagerLoadedTime = "content.manager.loaded.time"

    // Pack details
    static let contentManagerContent = "content.manager.content"
    static let contentManagerRegions = "content.manager.regions"
    static let contentManagerEvents = "content.manager.events"
    static let contentManagerQuests = "content.manager.quests"
    static let contentManagerHeroes = "content.manager.heroes"
    static let contentManagerCards = "content.manager.cards"
    static let contentManagerEnemies = "content.manager.enemies"

    // Validation
    static let contentManagerValidation = "content.manager.validation"
    static let contentManagerValidationErrors = "content.manager.validation.errors"
    static let contentManagerValidationWarnings = "content.manager.validation.warnings"

    // Source
    static let contentManagerSourceBundled = "content.manager.source.bundled"
    static let contentManagerSourceExternal = "content.manager.source.external"

    // Pack types
    static let contentManagerPackTypeCharacter = "content.manager.pack.type.character"
    static let contentManagerPackTypeCampaign = "content.manager.pack.type.campaign"
    static let contentManagerPackTypeBalance = "content.manager.pack.type.balance"
    static let contentManagerPackTypeRulesExtension = "content.manager.pack.type.rules.extension"
    static let contentManagerPackTypeFull = "content.manager.pack.type.full"
    static let contentManagerPackTypeUnknown = "content.manager.pack.type.unknown"

    static let back = "back"
}

// MARK: - ManagedPack Localization Extension

extension ManagedPack {
    /// Localized source name (Bundled/External)
    var localizedSourceName: String {
        switch source {
        case .bundled:
            return L10n.contentManagerSourceBundled.localized
        case .external:
            return L10n.contentManagerSourceExternal.localized
        }
    }

    /// Localized pack type display
    var localizedPackType: String {
        guard let manifest = manifest else {
            return L10n.contentManagerPackTypeUnknown.localized
        }
        switch manifest.packType {
        case .character:
            return L10n.contentManagerPackTypeCharacter.localized
        case .campaign:
            return L10n.contentManagerPackTypeCampaign.localized
        case .balance:
            return L10n.contentManagerPackTypeBalance.localized
        case .rulesExtension:
            return L10n.contentManagerPackTypeRulesExtension.localized
        case .full:
            return L10n.contentManagerPackTypeFull.localized
        }
    }
}


// ==========================================
// FILE: Views/EventView.swift
// ==========================================

import SwiftUI
import TwilightEngine

/// Event view with Engine-First Architecture
/// - All state mutations go through engine.performAction()
/// - UI reads state from engine properties
struct EventView: View {
    // MARK: - Engine-First Architecture
    @ObservedObject var engine: TwilightGameEngine

    let event: GameEvent
    let regionId: UUID
    let onChoiceSelected: (EventChoice) -> Void
    let onDismiss: () -> Void

    @State private var selectedChoice: EventChoice?
    @State private var showingResult = false
    @State private var resultMessage: String = ""
    @State private var combatMonster: Card?
    @State private var combatVictory: Bool?

    // MARK: - Initialization (Engine-First only)

    init(
        engine: TwilightGameEngine,
        event: GameEvent,
        regionId: UUID,
        onChoiceSelected: @escaping (EventChoice) -> Void,
        onDismiss: @escaping () -> Void
    ) {
        self.engine = engine
        self.event = event
        self.regionId = regionId
        self.onChoiceSelected = onChoiceSelected
        self.onDismiss = onDismiss
    }

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: Spacing.xl) {
                    // Hero Panel (consistent design across all screens)
                    HeroPanel(engine: engine, compact: true)
                        .padding(.horizontal)

                    // Event header
                    eventHeader

                    Divider()

                    // Event description
                    Text(event.description)
                        .font(.body)
                        .foregroundColor(AppColors.muted)
                        .padding(.horizontal)

                    Divider()

                    // Choices
                    VStack(spacing: Spacing.md) {
                        Text(L10n.eventChooseAction.localized)
                            .font(.headline)
                            .padding(.horizontal)

                        ForEach(event.choices) { choice in
                            choiceButton(choice)
                        }
                    }
                    .padding(.horizontal)
                }
                .padding(.vertical)
            }
            .navigationTitle(event.title)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(L10n.uiClose.localized) {
                        onDismiss()
                    }
                }
            }
            .alert(L10n.uiResult.localized, isPresented: $showingResult) {
                Button(L10n.buttonOk.localized) {
                    // Note: onChoiceSelected is already called in handleCombatEnd for combat victories
                    // or in handleNonCombatChoice for non-combat choices
                    onDismiss()
                }
            } message: {
                Text(resultMessage)
            }
            .fullScreenCover(item: $combatMonster) { _ in
                // Combat already set up in initiateCombat via engine.setupCombatEnemy
                CombatView(
                    engine: engine,
                    onCombatEnd: { outcome in
                        handleCombatEnd(outcome: outcome)
                    }
                )
            }
        }
    }

    // MARK: - Event Header

    var eventHeader: some View {
        HStack(spacing: Spacing.md) {
            // Event type icon
            ZStack {
                Circle()
                    .fill(eventTypeColor.opacity(Opacity.faint))
                    .frame(width: Sizes.iconRegion, height: Sizes.iconRegion)

                Image(systemName: event.eventType.icon)
                    .font(.title2)
                    .foregroundColor(eventTypeColor)
            }

            VStack(alignment: .leading, spacing: Spacing.xxs) {
                Text(event.eventType.displayName)
                    .font(.caption)
                    .foregroundColor(AppColors.muted)

                Text(event.title)
                    .font(.title3)
                    .fontWeight(.bold)
            }

            Spacer()
        }
        .padding(.horizontal)
    }

    // MARK: - Hero Stats (now uses HeroPanel component)
    // Old heroStatsBar removed - using unified HeroPanel component instead

    var eventTypeColor: Color {
        switch event.eventType {
        case .combat: return AppColors.danger
        case .ritual: return AppColors.dark
        case .narrative: return AppColors.primary
        case .exploration: return Color.cyan
        case .worldShift: return AppColors.power
        }
    }

    // MARK: - Choice Button

    func choiceButton(_ choice: EventChoice) -> some View {
        let canChoose = canMeetRequirementsEngine(choice)
        let isCombatChoice = event.eventType == .combat &&
                             choice.id == event.choices.first?.id &&
                             event.monsterCard != nil

        return Button {
            guard canChoose else { return }

            // Defer all state changes to avoid "Publishing changes from within view updates"
            DispatchQueue.main.async {
                selectedChoice = choice

                // Check if this is a combat choice
                if isCombatChoice {
                    initiateCombat(choice: choice)
                } else {
                    onChoiceSelected(choice)
                    onDismiss()
                }
            }
        } label: {
            VStack(alignment: .leading, spacing: Spacing.sm) {
                Text(choice.text)
                    .font(.body)
                    .fontWeight(.medium)
                    .foregroundColor(canChoose ? .primary : AppColors.secondary)

                // Requirements
                if let requirements = choice.requirements {
                    requirementsView(requirements, canMeet: canChoose)
                }

                // Preview consequences (only positive ones)
                consequencesPreview(choice.consequences)
            }
            .frame(maxWidth: .infinity, alignment: .leading)
            .padding()
            .background(
                RoundedRectangle(cornerRadius: CornerRadius.lg)
                    .fill(canChoose ? AppColors.cardBackground : AppColors.secondary.opacity(0.1))
            )
            .overlay(
                RoundedRectangle(cornerRadius: CornerRadius.lg)
                    .stroke(canChoose ? AppColors.primary.opacity(Opacity.medium) : Color.clear, lineWidth: 2)
            )
            .contentShape(Rectangle())
        }
        .buttonStyle(.plain)
        .disabled(!canChoose)
    }

    func requirementsView(_ requirements: EventRequirements, canMeet: Bool) -> some View {
        VStack(alignment: .leading, spacing: Spacing.xxs) {
            if let minFaith = requirements.minimumFaith {
                HStack(spacing: Spacing.xxs) {
                    Image(systemName: "sparkles")
                        .font(.caption2)
                    Text(L10n.eventRequiresFaith.localized(with: minFaith))
                        .font(.caption2)
                    // Engine-First: read from engine
                    Text(L10n.eventYouHaveFaith.localized(with: engine.playerFaith))
                        .font(.caption2)
                        .foregroundColor(engine.playerFaith >= minFaith ? AppColors.success : AppColors.danger)
                }
                .foregroundColor(AppColors.muted)
            }

            if let minHealth = requirements.minimumHealth {
                HStack(spacing: Spacing.xxs) {
                    Image(systemName: "heart.fill")
                        .font(.caption2)
                    Text(L10n.eventRequiresHealth.localized(with: minHealth))
                        .font(.caption2)
                    // Engine-First: read from engine
                    Text(L10n.eventYouHaveHealth.localized(with: engine.playerHealth))
                        .font(.caption2)
                        .foregroundColor(engine.playerHealth >= minHealth ? AppColors.success : AppColors.danger)
                }
                .foregroundColor(AppColors.muted)
            }

            if let reqBalance = requirements.requiredBalance {
                // Engine-First: read from engine
                let playerBalanceEnum = getBalanceEnum(engine.playerBalance)
                let meetsRequirement = playerBalanceEnum == reqBalance

                HStack(spacing: Spacing.xxs) {
                    Image(systemName: "circle.lefthalf.filled")
                        .font(.caption2)
                    Text(L10n.eventRequiresPath.localized(with: balanceText(reqBalance)))
                        .font(.caption2)
                    Text(L10n.eventYourPath.localized(with: balanceText(playerBalanceEnum)))
                        .font(.caption2)
                        .foregroundColor(meetsRequirement ? AppColors.success : AppColors.danger)
                }
                .foregroundColor(AppColors.muted)
            }
        }
    }

    func consequencesPreview(_ consequences: EventConsequences) -> some View {
        VStack(alignment: .leading, spacing: Spacing.xxxs) {
            if let faithChange = consequences.faithChange, faithChange != 0 {
                HStack(spacing: Spacing.xxs) {
                    Image(systemName: faithChange > 0 ? "arrow.up" : "arrow.down")
                        .font(.caption2)
                    Text(L10n.eventFaithChange.localized(with: faithChange > 0 ? "+" : "", faithChange))
                        .font(.caption2)
                }
                .foregroundColor(faithChange > 0 ? AppColors.success : AppColors.warning)
            }

            if let healthChange = consequences.healthChange, healthChange != 0 {
                HStack(spacing: Spacing.xxs) {
                    Image(systemName: healthChange > 0 ? "arrow.up" : "arrow.down")
                        .font(.caption2)
                    Text(L10n.eventHealthChange.localized(with: healthChange > 0 ? "+" : "", healthChange))
                        .font(.caption2)
                }
                .foregroundColor(healthChange > 0 ? AppColors.success : AppColors.danger)
            }

            if let balanceChange = consequences.balanceChange, balanceChange != 0 {
                HStack(spacing: Spacing.xxs) {
                    Image(systemName: balanceChange > 0 ? "sun.max.fill" : "moon.fill")
                        .font(.caption2)
                    Text(balanceChange > 0 ? L10n.eventBalanceToLight.localized : L10n.eventBalanceToDark.localized)
                        .font(.caption2)
                }
                .foregroundColor(balanceChange > 0 ? AppColors.light : AppColors.dark)
            }

            if let reputationChange = consequences.reputationChange, reputationChange != 0 {
                HStack(spacing: Spacing.xxs) {
                    Image(systemName: reputationChange > 0 ? "hand.thumbsup.fill" : "hand.thumbsdown.fill")
                        .font(.caption2)
                    Text(L10n.eventReputationChange.localized(with: reputationChange > 0 ? "+" : "", reputationChange))
                        .font(.caption2)
                }
                .foregroundColor(reputationChange > 0 ? AppColors.success : AppColors.danger)
            }

            if consequences.addCards != nil {
                HStack(spacing: Spacing.xxs) {
                    Image(systemName: "rectangle.stack.fill.badge.plus")
                        .font(.caption2)
                    Text(L10n.eventReceiveCard.localized)
                        .font(.caption2)
                }
                .foregroundColor(AppColors.primary)
            }

            if consequences.addCurse != nil {
                HStack(spacing: Spacing.xxs) {
                    Image(systemName: "exclamationmark.triangle.fill")
                        .font(.caption2)
                    Text(L10n.eventReceiveCurse.localized)
                        .font(.caption2)
                }
                .foregroundColor(AppColors.danger)
            }
        }
    }

    // MARK: - Combat Management

    func initiateCombat(choice: EventChoice) {
        guard let monster = event.monsterCard else { return }

        // Engine-First: Get combat context from engine
        let regionState = engine.currentRegion?.state ?? .stable
        let combatContext = CombatContext(
            regionState: regionState,
            playerCurses: engine.playerActiveCurses.map { $0.type }
        )

        // Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ Ð²Ñ€Ð°Ð³Ð° Ñ Ð¼Ð¾Ð´Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð¾Ñ€Ð°Ð¼Ð¸ Ñ€ÐµÐ³Ð¸Ð¾Ð½Ð°
        var adjustedMonster = monster
        if let baseHealth = monster.health {
            adjustedMonster.health = combatContext.adjustedEnemyHealth(baseHealth)
        }
        if let basePower = monster.power {
            adjustedMonster.power = combatContext.adjustedEnemyPower(basePower)
        }
        if let baseDefense = monster.defense {
            adjustedMonster.defense = combatContext.adjustedEnemyDefense(baseDefense)
        }

        // Setup combat in engine first, then show fullScreenCover
        engine.setupCombatEnemy(adjustedMonster)
        combatMonster = adjustedMonster
    }

    func handleCombatEnd(outcome: CombatView.CombatOutcome) {
        // Apply non-combat consequences from the choice (if victory)
        if outcome.isVictory, let choice = selectedChoice {
            onChoiceSelected(choice)
        }

        // Combat already shows its own victory/defeat screen, no need for additional alert
        // Just close combat and dismiss event view
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
            combatMonster = nil
            // Small delay before dismissing to allow animation to complete
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
                onDismiss()
            }
        }
    }

    // MARK: - Helpers

    /// Engine-based requirement checking
    func canMeetRequirementsEngine(_ choice: EventChoice) -> Bool {
        guard let requirements = choice.requirements else { return true }

        // Check minimum faith
        if let minFaith = requirements.minimumFaith {
            if engine.playerFaith < minFaith {
                return false
            }
        }

        // Check minimum health
        if let minHealth = requirements.minimumHealth {
            if engine.playerHealth < minHealth {
                return false
            }
        }

        // Check balance requirement
        if let reqBalance = requirements.requiredBalance {
            let playerBalanceEnum = getBalanceEnum(engine.playerBalance)
            if playerBalanceEnum != reqBalance {
                return false
            }
        }

        return true
    }

    func balanceText(_ balance: CardBalance) -> String {
        switch balance {
        case .light: return L10n.tmBalanceLightGenitive.localized
        case .neutral: return L10n.tmBalanceNeutralGenitive.localized
        case .dark: return L10n.tmBalanceDarkGenitive.localized
        }
    }

    func getBalanceEnum(_ balanceValue: Int) -> CardBalance {
        if balanceValue >= 70 {        // Light path (70-100)
            return .light
        } else if balanceValue <= 30 { // Dark path (0-30)
            return .dark
        } else {                       // Neutral (30-70)
            return .neutral
        }
    }
}

// MARK: - Preview

struct EventView_Previews: PreviewProvider {
    static var previews: some View {
        // Engine-First: Use engine for preview
        let engine = TwilightGameEngine()
        engine.initializeNewGame(playerName: "Ð’Ð¾Ð»Ñ…Ð²", heroId: nil, startingDeck: [])

        let event = GameEvent(
            eventType: .narrative,
            title: "Ð¢ÐµÑÑ‚Ð¾Ð²Ð¾Ðµ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ðµ",
            description: "Ð­Ñ‚Ð¾ Ñ‚ÐµÑÑ‚Ð¾Ð²Ð¾Ðµ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ðµ Ð´Ð»Ñ Ð¿Ñ€ÐµÐ´Ð²Ð°Ñ€Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾Ð³Ð¾ Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€Ð°",
            choices: [
                EventChoice(
                    id: "preview_choice_1",
                    text: "Ð’Ñ‹Ð±Ð¾Ñ€ 1",
                    consequences: EventConsequences(
                        faithChange: 5,
                        message: "Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð²Ñ‹Ð±Ð¾Ñ€Ð° 1"
                    )
                ),
                EventChoice(
                    id: "preview_choice_2",
                    text: "Ð’Ñ‹Ð±Ð¾Ñ€ 2",
                    requirements: EventRequirements(minimumFaith: 10),
                    consequences: EventConsequences(
                        faithChange: -3,
                        healthChange: -2,
                        message: "Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð²Ñ‹Ð±Ð¾Ñ€Ð° 2"
                    )
                )
            ]
        )

        return EventView(
            engine: engine,
            event: event,
            regionId: UUID(),
            onChoiceSelected: { _ in },
            onDismiss: { }
        )
    }
}


// ==========================================
// FILE: Views/HeroSelectionView.swift
// ==========================================

import SwiftUI
import TwilightEngine

/// Ð­ÐºÑ€Ð°Ð½ Ð²Ñ‹Ð±Ð¾Ñ€Ð° Ð³ÐµÑ€Ð¾Ñ Ð¿Ñ€Ð¸ Ð½Ð°Ñ‡Ð°Ð»Ðµ Ð½Ð¾Ð²Ð¾Ð¹ Ð¸Ð³Ñ€Ñ‹
/// Ð“ÐµÑ€Ð¾Ð¸ Ð·Ð°Ð³Ñ€ÑƒÐ¶Ð°ÑŽÑ‚ÑÑ Ð¸Ð· HeroRegistry (data-driven)
struct HeroSelectionView: View {
    let onHeroSelected: (String) -> Void  // Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ heroId

    @State private var selectedHeroId: String?

    /// Ð’ÑÐµ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ðµ Ð³ÐµÑ€Ð¾Ð¸ Ð¸Ð· Ñ€ÐµÐµÑÑ‚Ñ€Ð°
    private var availableHeroes: [HeroDefinition] {
        HeroRegistry.shared.availableHeroes()
    }

    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Ð—Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº
                VStack(spacing: Spacing.sm) {
                    Text("Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð³ÐµÑ€Ð¾Ñ")
                        .font(.largeTitle)
                        .fontWeight(.bold)

                    Text("ÐšÐ°Ð¶Ð´Ñ‹Ð¹ Ð³ÐµÑ€Ð¾Ð¹ Ð¸Ð¼ÐµÐµÑ‚ ÑƒÐ½Ð¸ÐºÐ°Ð»ÑŒÐ½Ñ‹Ðµ Ñ…Ð°Ñ€Ð°ÐºÑ‚ÐµÑ€Ð¸ÑÑ‚Ð¸ÐºÐ¸ Ð¸ ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚Ð¸")
                        .font(.subheadline)
                        .foregroundColor(AppColors.muted)
                        .multilineTextAlignment(.center)
                        .padding(.horizontal)
                }
                .padding(.top, Spacing.xl)
                .padding(.bottom, Spacing.lg)

                // Ð¡Ð¿Ð¸ÑÐ¾Ðº Ð³ÐµÑ€Ð¾ÐµÐ²
                ScrollView {
                    VStack(spacing: Spacing.md) {
                        ForEach(availableHeroes, id: \.id) { hero in
                            HeroCard(
                                hero: hero,
                                isSelected: selectedHeroId == hero.id
                            ) {
                                withAnimation(.easeInOut(duration: AnimationDuration.fast)) {
                                    selectedHeroId = hero.id
                                }
                            }
                        }
                    }
                    .padding(.horizontal)
                    .padding(.bottom, Sizes.cardHeightSmall)  // ÐœÐµÑÑ‚Ð¾ Ð´Ð»Ñ ÐºÐ½Ð¾Ð¿ÐºÐ¸
                }

                Spacer()

                // ÐšÐ½Ð¾Ð¿ÐºÐ° Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ñ
                VStack(spacing: Spacing.sm) {
                    if let heroId = selectedHeroId,
                       let hero = HeroRegistry.shared.hero(id: heroId) {
                        Button(action: {
                            onHeroSelected(heroId)
                        }) {
                            HStack {
                                Text(hero.icon)
                                Text("ÐÐ°Ñ‡Ð°Ñ‚ÑŒ Ð¸Ð³Ñ€Ñƒ Ð·Ð° \(hero.name.localized)")
                                    .fontWeight(.semibold)
                            }
                            .frame(maxWidth: .infinity)
                            .padding()
                            .background(AppColors.primary)
                            .foregroundColor(.white)
                            .cornerRadius(CornerRadius.lg)
                        }
                        .padding(.horizontal)
                    } else {
                        Text("Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð³ÐµÑ€Ð¾Ñ")
                            .foregroundColor(AppColors.muted)
                            .padding()
                    }
                }
                .padding(.bottom, Spacing.xl)
                .background(
                    Color(UIColor.systemBackground)
                        .shadow(radius: 5)
                )
            }
            .background(AppColors.cardBackground)
            .navigationBarHidden(true)
        }
    }
}

/// ÐšÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐ° Ð³ÐµÑ€Ð¾Ñ
struct HeroCard: View {
    let hero: HeroDefinition
    let isSelected: Bool
    let onTap: () -> Void

    var body: some View {
        VStack(alignment: .leading, spacing: Spacing.md) {
            // Ð—Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº
            HStack {
                Text(hero.icon)
                    .font(.title)

                VStack(alignment: .leading, spacing: Spacing.xxxs) {
                    Text(hero.name.localized)
                        .font(.title2)
                        .fontWeight(.bold)

                    Text(hero.description.localized)
                        .font(.caption)
                        .foregroundColor(AppColors.muted)
                }

                Spacer()

                if isSelected {
                    Image(systemName: "checkmark.circle.fill")
                        .font(.title2)
                        .foregroundColor(AppColors.primary)
                }
            }

            // Ð¥Ð°Ñ€Ð°ÐºÑ‚ÐµÑ€Ð¸ÑÑ‚Ð¸ÐºÐ¸
            let stats = hero.baseStats
            HStack(spacing: Spacing.lg) {
                StatBadge(icon: "heart.fill", value: stats.health, label: "HP", color: AppColors.health)
                StatBadge(icon: "hand.raised.fill", value: stats.strength, label: "Ð¡Ð¸Ð»Ð°", color: AppColors.power)
                StatBadge(icon: "sparkles", value: stats.faith, label: "Ð’ÐµÑ€Ð°", color: AppColors.faith)
                StatBadge(icon: "brain.head.profile", value: stats.intelligence, label: "Ð˜Ð½Ñ‚", color: AppColors.dark)
            }

            // ÐžÑÐ¾Ð±Ð°Ñ ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚ÑŒ
            HStack(spacing: Spacing.sm) {
                Image(systemName: "star.fill")
                    .foregroundColor(AppColors.faith)
                    .font(.caption)

                Text(hero.specialAbility.description.localized)
                    .font(.caption)
                    .foregroundColor(AppColors.muted)
            }
            .padding(Spacing.sm)
            .background(AppColors.faith.opacity(0.1))
            .cornerRadius(CornerRadius.md)
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: CornerRadius.lg)
                .fill(Color(UIColor.systemBackground))
                .overlay(
                    RoundedRectangle(cornerRadius: CornerRadius.lg)
                        .stroke(isSelected ? AppColors.primary : AppColors.secondary.opacity(Opacity.light), lineWidth: isSelected ? 3 : 1)
                )
        )
        .onTapGesture {
            onTap()
        }
    }
}

/// Ð‘ÐµÐ¹Ð´Ð¶ Ñ…Ð°Ñ€Ð°ÐºÑ‚ÐµÑ€Ð¸ÑÑ‚Ð¸ÐºÐ¸
struct StatBadge: View {
    let icon: String
    let value: Int
    let label: String
    let color: Color

    var body: some View {
        VStack(spacing: Spacing.xxxs) {
            Image(systemName: icon)
                .font(.caption)
                .foregroundColor(color)

            Text("\(value)")
                .font(.caption)
                .fontWeight(.bold)

            Text(label)
                .font(.system(size: Spacing.sm))
                .foregroundColor(AppColors.muted)
        }
        .frame(minWidth: Sizes.iconXL)
    }
}

#Preview {
    HeroSelectionView { heroId in
        print("Selected: \(heroId)")
    }
}


// ==========================================
// FILE: Views/PlayerHandView.swift
// ==========================================

import SwiftUI
import TwilightEngine

struct PlayerHandView: View {
    @ObservedObject var engine: TwilightGameEngine
    @Binding var selectedCard: Card?
    var onCardPlay: ((Card) -> Void)?

    var body: some View {
        VStack(spacing: Spacing.xxs) {
            // Play card button (shown when card is selected)
            if let selected = selectedCard {
                HStack(spacing: Spacing.md) {
                    Button(action: {
                        onCardPlay?(selected)
                        selectedCard = nil
                    }) {
                        Label(L10n.combatPlayCard.localized, systemImage: "play.fill")
                            .font(.headline)
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, Spacing.sm)
                            .background(AppColors.success)
                            .cornerRadius(CornerRadius.md)
                    }

                    Button(action: {
                        selectedCard = nil
                    }) {
                        Image(systemName: "xmark.circle.fill")
                            .font(.title2)
                            .foregroundColor(AppColors.secondary)
                    }
                }
                .padding(.horizontal, Spacing.md)
                .padding(.vertical, Spacing.xxs)
                .background(Color(UIColor.tertiarySystemBackground))
            }

            // Compact deck info
            HStack(spacing: Spacing.lg) {
                Text(engine.playerName)
                    .font(.caption)
                    .fontWeight(.bold)

                Spacer()

                // Deck count
                HStack(spacing: Spacing.xxs) {
                    Image(systemName: "rectangle.stack.fill")
                        .font(.caption2)
                    Text("\(engine.playerDeck.count)")
                        .font(.caption2)
                }
                .foregroundColor(AppColors.primary)

                // Discard count
                HStack(spacing: Spacing.xxs) {
                    Image(systemName: "trash.fill")
                        .font(.caption2)
                    Text("\(engine.playerDiscard.count)")
                        .font(.caption2)
                }
                .foregroundColor(AppColors.secondary)
            }
            .padding(.horizontal, Spacing.md)
            .padding(.vertical, Spacing.xxs)
            .background(AppColors.cardBackground)

            // Hand of cards
            if engine.playerHand.isEmpty {
                Text(L10n.noCardsInHand.localized)
                    .font(.caption)
                    .foregroundColor(AppColors.muted)
                    .padding()
            } else {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: Spacing.sm) {
                        ForEach(engine.playerHand) { card in
                            HandCardView(
                                card: card,
                                isSelected: selectedCard?.id == card.id,
                                onTap: {
                                    if selectedCard?.id == card.id {
                                        selectedCard = nil
                                    } else {
                                        selectedCard = card
                                    }
                                }
                            )
                        }
                    }
                    .padding(.horizontal, Spacing.sm)
                    .padding(.vertical, Spacing.xxs)
                }
            }
        }
    }
}


// ==========================================
// FILE: Views/RulesView.swift
// ==========================================

import SwiftUI

struct RulesView: View {
    @Environment(\.dismiss) var dismiss

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: Spacing.xxl) {
                    // Game Objective
                    RuleSection(
                        icon: "target",
                        color: AppColors.primary,
                        title: L10n.rulesObjectiveTitle.localized,
                        content: L10n.rulesObjectiveContent.localized
                    )

                    // Game Phases
                    RuleSection(
                        icon: "arrow.triangle.2.circlepath",
                        color: AppColors.power,
                        title: L10n.rulesPhasesTitle.localized,
                        content: L10n.rulesPhasesContent.localized
                    )

                    VStack(alignment: .leading, spacing: Spacing.md) {
                        PhaseCard(
                            phase: L10n.phaseExploration.localized,
                            description: L10n.rulesPhaseExploration.localized,
                            color: AppColors.primary
                        )
                        PhaseCard(
                            phase: L10n.phaseEncounter.localized,
                            description: L10n.rulesPhaseEncounter.localized,
                            color: AppColors.power
                        )
                        PhaseCard(
                            phase: L10n.phasePlayerTurn.localized,
                            description: L10n.rulesPhasePlayerTurn.localized,
                            color: AppColors.success
                        )
                        PhaseCard(
                            phase: L10n.phaseEnemyTurn.localized,
                            description: L10n.rulesPhaseEnemyTurn.localized,
                            color: AppColors.danger
                        )
                        PhaseCard(
                            phase: L10n.phaseEndTurn.localized,
                            description: L10n.rulesPhaseEndTurn.localized,
                            color: AppColors.dark
                        )
                    }
                    .padding(.leading, Spacing.sm)

                    // Card Types
                    RuleSection(
                        icon: "rectangle.stack.fill",
                        color: AppColors.dark,
                        title: L10n.rulesCardsTitle.localized,
                        content: L10n.rulesCardsContent.localized
                    )

                    // Resources
                    RuleSection(
                        icon: "star.fill",
                        color: Color.pink,
                        title: L10n.rulesResourcesTitle.localized,
                        content: L10n.rulesResourcesContent.localized
                    )

                    // Actions
                    RuleSection(
                        icon: "bolt.fill",
                        color: AppColors.power,
                        title: L10n.rulesActionsTitle.localized,
                        content: L10n.rulesActionsContent.localized
                    )

                    // Dice Rolls
                    RuleSection(
                        icon: "dice.fill",
                        color: AppColors.success,
                        title: L10n.rulesDiceTitle.localized,
                        content: L10n.rulesDiceContent.localized
                    )

                    // Victory Conditions
                    RuleSection(
                        icon: "trophy.fill",
                        color: AppColors.faith,
                        title: L10n.rulesVictoryTitle.localized,
                        content: L10n.rulesVictoryContent.localized
                    )

                    // Tips
                    RuleSection(
                        icon: "lightbulb.fill",
                        color: Color.cyan,
                        title: L10n.rulesTipsTitle.localized,
                        content: L10n.rulesTipsContent.localized
                    )
                }
                .padding()
            }
            .navigationTitle(L10n.rulesTitle.localized)
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark.circle.fill")
                            .foregroundColor(AppColors.muted)
                    }
                }
            }
        }
    }
}

struct RuleSection: View {
    let icon: String
    let color: Color
    let title: String
    let content: String

    var body: some View {
        VStack(alignment: .leading, spacing: Spacing.md) {
            HStack(spacing: Spacing.md) {
                Image(systemName: icon)
                    .font(.title2)
                    .foregroundColor(color)

                Text(title)
                    .font(.title2)
                    .fontWeight(.bold)
            }

            Text(content)
                .font(.body)
                .foregroundColor(.primary)
                .fixedSize(horizontal: false, vertical: true)
        }
        .padding()
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(AppColors.cardBackground)
        .cornerRadius(CornerRadius.lg)
    }
}

struct PhaseCard: View {
    let phase: String
    let description: String
    let color: Color

    var body: some View {
        HStack(spacing: Spacing.md) {
            Circle()
                .fill(color)
                .frame(width: Spacing.md, height: Spacing.md)

            VStack(alignment: .leading, spacing: Spacing.xxs) {
                Text(phase)
                    .font(.headline)
                    .foregroundColor(color)

                Text(description)
                    .font(.subheadline)
                    .foregroundColor(AppColors.muted)
            }
        }
        .padding()
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(Color(UIColor.tertiarySystemBackground))
        .cornerRadius(CornerRadius.md)
    }
}

#Preview {
    RulesView()
}


// ==========================================
// FILE: Views/StatisticsView.swift
// ==========================================

import SwiftUI
import TwilightEngine

struct StatisticsView: View {
    @StateObject private var saveManager = SaveManager.shared
    @Environment(\.dismiss) var dismiss

    var allSaves: [EngineSave] {
        saveManager.allSaves
    }

    var longestSurvival: Int {
        allSaves.map { $0.currentDay }.max() ?? 0
    }

    var totalGames: Int {
        allSaves.count
    }

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: Spacing.xxl) {
                    // Header
                    VStack(spacing: Spacing.sm) {
                        Text("ðŸ“Š " + L10n.statsTitle.localized)
                            .font(.largeTitle)
                            .fontWeight(.bold)
                        Text(L10n.statsGameName.localized)
                            .font(.title3)
                            .foregroundColor(AppColors.muted)
                    }
                    .padding(.top)

                    // Overall Statistics
                    VStack(alignment: .leading, spacing: Spacing.lg) {
                        Text(L10n.statsGeneral.localized)
                            .font(.headline)

                        HStack(spacing: Spacing.lg) {
                            StatCard(
                                icon: "gamecontroller.fill",
                                title: L10n.statsGamesCount.localized,
                                value: "\(totalGames)",
                                color: AppColors.primary
                            )

                            StatCard(
                                icon: "clock.fill",
                                title: L10n.statsLongestSurvival.localized,
                                value: L10n.statsTurnsCount.localized(with: longestSurvival),
                                color: AppColors.success
                            )
                        }
                    }
                    .padding()
                    .background(AppColors.cardBackground)
                    .cornerRadius(CornerRadius.lg)

                    // Game Records
                    if !allSaves.isEmpty {
                        VStack(alignment: .leading, spacing: Spacing.lg) {
                            Text(L10n.statsHistory.localized)
                                .font(.headline)

                            ForEach(Array(allSaves.enumerated()), id: \.element.savedAt) { index, save in
                                GameRecordCard(slot: index + 1, save: save)
                            }
                        }
                        .padding()
                        .background(AppColors.cardBackground)
                        .cornerRadius(CornerRadius.lg)
                    } else {
                        VStack(spacing: Spacing.md) {
                            Image(systemName: "chart.bar.xaxis")
                                .font(.system(size: Sizes.iconRegion))
                                .foregroundColor(AppColors.muted)
                            Text(L10n.statsNoSaves.localized)
                                .font(.headline)
                                .foregroundColor(AppColors.muted)
                            Text(L10n.statsStartHint.localized)
                                .font(.subheadline)
                                .foregroundColor(AppColors.muted)
                                .multilineTextAlignment(.center)
                        }
                        .padding(Sizes.iconXL)
                        .background(AppColors.cardBackground)
                        .cornerRadius(CornerRadius.lg)
                    }
                }
                .padding()
            }
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: { dismiss() }) {
                        Text(L10n.statsDone.localized)
                            .fontWeight(.semibold)
                    }
                }
            }
        }
    }
}

struct StatCard: View {
    let icon: String
    let title: String
    let value: String
    let color: Color

    var body: some View {
        VStack(spacing: Spacing.sm) {
            Image(systemName: icon)
                .font(.title2)
                .foregroundColor(color)

            Text(value)
                .font(.title3)
                .fontWeight(.bold)

            Text(title)
                .font(.caption)
                .foregroundColor(AppColors.muted)
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(Color(UIColor.tertiarySystemBackground))
        .cornerRadius(Spacing.smd)
    }
}

struct GameRecordCard: View {
    let slot: Int
    let save: EngineSave

    var body: some View {
        VStack(alignment: .leading, spacing: Spacing.md) {
            HStack {
                VStack(alignment: .leading, spacing: Spacing.xxs) {
                    Text(save.playerName)
                        .font(.headline)
                    Text(L10n.uiSlotNumber.localized(with: slot))
                        .font(.caption)
                        .foregroundColor(AppColors.muted)
                }

                Spacer()

                Text(formatDate(save.savedAt))
                    .font(.caption)
                    .foregroundColor(AppColors.muted)
            }

            Divider()

            HStack(spacing: Spacing.xl) {
                VStack(alignment: .leading, spacing: Spacing.xxs) {
                    Text(L10n.statsResources.localized)
                        .font(.caption)
                        .foregroundColor(AppColors.muted)
                    HStack(spacing: Spacing.md) {
                        Label("\(save.playerHealth)/\(save.playerMaxHealth)", systemImage: "heart.fill")
                            .foregroundColor(AppColors.health)
                        Label("\(save.playerFaith)", systemImage: "sparkles")
                            .foregroundColor(AppColors.faith)
                        Label("\(save.playerBalance)", systemImage: "scale.3d")
                            .foregroundColor(AppColors.dark)
                    }
                    .font(.caption)
                }

                Spacer()

                VStack(alignment: .trailing, spacing: Spacing.xxs) {
                    Text(L10n.statsProgress.localized)
                        .font(.caption)
                        .foregroundColor(AppColors.muted)
                    Text(L10n.dayNumber.localized(with: save.currentDay))
                        .font(.headline)
                }
            }
        }
        .padding()
        .background(Color(UIColor.tertiarySystemBackground))
        .cornerRadius(Spacing.smd)
    }

    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        return formatter.string(from: date)
    }
}

#Preview {
    StatisticsView()
}


// ==========================================
// FILE: Views/WorldMapView.swift
// ==========================================

import SwiftUI
import TwilightEngine

struct WorldMapView: View {
    // MARK: - Engine-First Architecture
    // Engine is the ONLY source of truth for UI
    @ObservedObject var engine: TwilightGameEngine
    var onExit: (() -> Void)? = nil

    @State private var selectedRegion: EngineRegionState?
    @State private var showingExitConfirmation = false
    @State private var showingEventLog = false
    @State private var showingDayEvent = false
    @State private var currentDayEvent: DayEvent?

    // MARK: - Initialization (Engine-First only)

    init(engine: TwilightGameEngine, onExit: (() -> Void)? = nil) {
        self.engine = engine
        self.onExit = onExit
    }

    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Hero Panel (persistent, consistent design across all screens)
                HeroPanel(engine: engine)
                    .padding(.horizontal, Spacing.sm)
                    .padding(.top, Spacing.xxs)

                Divider()
                    .padding(.vertical, Spacing.xxs)

                // Top bar with world info
                worldInfoBar

                Divider()

                // Regions list (Engine-First: reads from engine.regionsArray)
                if engine.regionsArray.isEmpty {
                    // Show loading state if regions aren't loaded yet
                    VStack(spacing: Spacing.lg) {
                        ProgressView()
                            .scaleEffect(1.5)
                        Text(L10n.worldLoading.localized)
                            .font(.headline)
                            .foregroundColor(AppColors.muted)
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else {
                    ScrollView {
                        LazyVStack(spacing: Spacing.md) {
                            ForEach(engine.regionsArray, id: \.id) { region in
                                EngineRegionCardView(
                                    region: region,
                                    isCurrentLocation: region.id == engine.currentRegionId
                                )
                                .onTapGesture {
                                    selectedRegion = region
                                }
                            }
                        }
                        .padding()
                    }
                }
            }
            .navigationTitle(L10n.tmGameTitle.localized)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    if onExit != nil {
                        Button(action: {
                            showingExitConfirmation = true
                        }) {
                            HStack(spacing: Spacing.xxs) {
                                Image(systemName: "chevron.left")
                                Text(L10n.uiMenuButton.localized)
                            }
                        }
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        showingEventLog = true
                    }) {
                        Image(systemName: "book.closed")
                    }
                }
            }
            .sheet(isPresented: $showingEventLog) {
                EngineEventLogView(engine: engine)
            }
            .sheet(item: $selectedRegion) { region in
                EngineRegionDetailView(
                    region: region,
                    engine: engine,
                    onDismiss: {
                        selectedRegion = nil
                    },
                    onRegionChange: { newRegion in
                        selectedRegion = newRegion
                    }
                )
            }
            .alert(L10n.uiExit.localized + "?", isPresented: $showingExitConfirmation) {
                Button(L10n.uiCancel.localized, role: .cancel) { }
                Button(L10n.uiExit.localized, role: .destructive) {
                    onExit?()
                }
            } message: {
                Text(L10n.uiProgressSaved.localized)
            }
            .alert(currentDayEvent?.title ?? L10n.worldEvent.localized, isPresented: $showingDayEvent) {
                Button(L10n.buttonUnderstood.localized, role: .cancel) {
                    currentDayEvent = nil
                }
            } message: {
                if let event = currentDayEvent {
                    Text(L10n.dayNumber.localized(with: event.day) + "\n\n\(event.description)")
                }
            }
            .onChange(of: engine.lastDayEvent?.id) { _ in
                if let event = engine.lastDayEvent {
                    currentDayEvent = event
                    showingDayEvent = true
                    // Dismiss via Engine action (Engine-First)
                    engine.performAction(.dismissDayEvent)
                }
            }
        }
    }

    // MARK: - Player Info (now uses HeroPanel component)
    // Old playerInfoBar removed - using unified HeroPanel component instead

    // MARK: - World Info Bar (Engine-First: reads from engine.*)

    var worldInfoBar: some View {
        VStack(spacing: Spacing.sm) {
            HStack {
                // World Tension
                VStack(alignment: .leading, spacing: Spacing.xxxs) {
                    Text(L10n.tooltipBalance.localized)
                        .font(.caption2)
                        .foregroundColor(AppColors.muted)
                    HStack(spacing: Spacing.xxs) {
                        Image(systemName: "exclamationmark.triangle.fill")
                            .font(.caption)
                            .foregroundColor(tensionColor)
                        Text("\(engine.worldTension)%")
                            .font(.caption)
                            .fontWeight(.bold)
                    }
                }

                Spacer()

                // World Light/Dark Balance (Ð¯Ð²ÑŒ vs ÐÐ°Ð²ÑŒ)
                VStack(spacing: Spacing.xxxs) {
                    Text(L10n.worldLabel.localized)
                        .font(.caption2)
                        .foregroundColor(AppColors.muted)
                    Text(engine.worldBalanceDescription)
                        .font(.caption)
                        .fontWeight(.bold)
                        .foregroundColor(balanceColor)
                }

                Spacer()

                // Days passed
                VStack(alignment: .trailing, spacing: Spacing.xxxs) {
                    Text(L10n.daysInJourney.localized)
                        .font(.caption2)
                        .foregroundColor(AppColors.muted)
                    Text("\(engine.currentDay)")
                        .font(.caption)
                        .fontWeight(.bold)
                }
            }
            .padding(.horizontal)

            // Tension progress bar
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    Rectangle()
                        .fill(AppColors.secondary.opacity(Opacity.faint))
                        .frame(height: Sizes.progressThin)

                    Rectangle()
                        .fill(tensionColor)
                        .frame(
                            width: geometry.size.width * CGFloat(engine.worldTension) / 100,
                            height: Sizes.progressThin
                        )
                }
            }
            .frame(height: Sizes.progressThin)
            .padding(.horizontal)
        }
        .padding(.vertical, Spacing.sm)
        .background(AppColors.cardBackground)
    }

    var tensionColor: Color {
        switch engine.worldTension {
        case 0..<30: return AppColors.success
        case 30..<60: return AppColors.warning
        case 60..<80: return AppColors.warning
        default: return AppColors.danger
        }
    }

    var balanceColor: Color {
        switch engine.lightDarkBalance {
        case 0..<30: return AppColors.dark      // Ð¢ÑŒÐ¼Ð°
        case 30..<70: return AppColors.neutral  // ÐÐµÐ¹Ñ‚Ñ€Ð°Ð»ÑŒÐ½Ð¾
        case 70...100: return AppColors.light   // Ð¡Ð²ÐµÑ‚
        default: return AppColors.neutral
        }
    }
}
// MARK: - Event Log Entry View

struct EventLogEntryView: View {
    let entry: EventLogEntry

    var body: some View {
        VStack(alignment: .leading, spacing: Spacing.sm) {
            // Header
            HStack {
                Image(systemName: entry.type.icon)
                    .foregroundColor(typeColor)

                Text(L10n.dayNumber.localized(with: entry.dayNumber))
                    .font(.caption)
                    .fontWeight(.bold)

                Spacer()

                Text(entry.regionName)
                    .font(.caption)
                    .foregroundColor(AppColors.muted)
            }

            // Event title
            Text(entry.eventTitle)
                .font(.subheadline)
                .fontWeight(.semibold)

            // Choice made
            HStack {
                Image(systemName: "arrow.turn.down.right")
                    .font(.caption2)
                    .foregroundColor(AppColors.muted)
                Text(entry.choiceMade)
                    .font(.caption)
                    .foregroundColor(AppColors.muted)
            }

            // Outcome
            Text(entry.outcome)
                .font(.caption)
                .italic()
        }
        .padding(.vertical, Spacing.xxs)
    }

    var typeColor: Color {
        switch entry.type {
        case .combat: return AppColors.danger
        case .exploration: return AppColors.primary
        case .choice: return AppColors.warning
        case .quest: return AppColors.dark
        case .travel: return AppColors.success
        case .worldChange: return AppColors.light
        }
    }
}

// MARK: - Engine-First Region Card View

struct EngineRegionCardView: View {
    let region: EngineRegionState
    let isCurrentLocation: Bool

    var body: some View {
        HStack(spacing: Spacing.md) {
            // Icon
            ZStack {
                Circle()
                    .fill(stateColor.opacity(Opacity.faint))
                    .frame(width: Sizes.iconRegion, height: Sizes.iconRegion)

                Image(systemName: region.type.icon)
                    .font(.title2)
                    .foregroundColor(stateColor)
            }

            // Info
            VStack(alignment: .leading, spacing: Spacing.xxs) {
                HStack {
                    Text(region.name)
                        .font(.headline)
                        .fontWeight(.bold)

                    if isCurrentLocation {
                        Image(systemName: "location.fill")
                            .font(.caption)
                            .foregroundColor(AppColors.primary)
                    }
                }

                HStack(spacing: Spacing.sm) {
                    Text(region.state.emoji)
                        .font(.caption)
                    Text(region.state.displayName)
                        .font(.caption)
                        .foregroundColor(AppColors.muted)

                    Spacer()

                    Text(region.type.displayName)
                        .font(.caption2)
                        .padding(.horizontal, Spacing.xs)
                        .padding(.vertical, Spacing.xxxs)
                        .background(AppColors.secondary.opacity(Opacity.faint))
                        .cornerRadius(CornerRadius.sm)
                }

                // Anchor info
                if let anchor = region.anchor {
                    HStack(spacing: Spacing.xxs) {
                        Image(systemName: "flame")
                            .font(.caption2)
                            .foregroundColor(AppColors.power)
                        Text(anchor.name)
                            .font(.caption2)
                            .foregroundColor(AppColors.muted)
                        Spacer()
                        Text("\(anchor.integrity)%")
                            .font(.caption2)
                            .fontWeight(.bold)
                            .foregroundColor(anchorIntegrityColor(anchor.integrity))
                    }
                }

                // Reputation
                if region.reputation != 0 {
                    HStack(spacing: Spacing.xxs) {
                        Image(systemName: region.reputation > 0 ? "hand.thumbsup.fill" : "hand.thumbsdown.fill")
                            .font(.caption2)
                            .foregroundColor(region.reputation > 0 ? AppColors.success : AppColors.danger)
                        Text(L10n.regionReputation.localized + ": \(region.reputation > 0 ? "+" : "")\(region.reputation)")
                            .font(.caption2)
                            .foregroundColor(AppColors.muted)
                    }
                }
            }

            Spacer()

            // Arrow
            Image(systemName: "chevron.right")
                .font(.caption)
                .foregroundColor(AppColors.secondary)
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: CornerRadius.lg)
                .fill(AppColors.cardBackground)
                .shadow(color: isCurrentLocation ? AppColors.primary.opacity(Opacity.light) : .clear, radius: 4)
        )
        .overlay(
            RoundedRectangle(cornerRadius: CornerRadius.lg)
                .stroke(isCurrentLocation ? AppColors.regionCurrent : .clear, lineWidth: 2)
        )
    }

    var stateColor: Color {
        switch region.state {
        case .stable: return AppColors.success
        case .borderland: return AppColors.warning
        case .breach: return AppColors.danger
        }
    }

    func anchorIntegrityColor(_ integrity: Int) -> Color {
        switch integrity {
        case 70...100: return AppColors.success
        case 30..<70: return AppColors.warning
        default: return AppColors.danger
        }
    }
}

// MARK: - Engine-First Region Detail View

struct EngineRegionDetailView: View {
    let region: EngineRegionState
    @ObservedObject var engine: TwilightGameEngine
    let onDismiss: () -> Void
    var onRegionChange: ((EngineRegionState?) -> Void)? = nil

    @State private var showingActionConfirmation = false
    @State private var selectedAction: EngineRegionAction?
    @State private var eventToShow: GameEvent?
    @State private var showingNoEventsAlert = false
    @State private var showingActionError = false
    @State private var actionErrorMessage = ""

    // Card received notification
    @State private var showingCardNotification = false
    @State private var receivedCardNames: [String] = []

    enum EngineRegionAction {
        case travel
        case rest
        case trade
        case strengthenAnchor
        case explore
    }

    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Hero Panel (persistent, consistent design across all screens)
                HeroPanel(engine: engine)
                    .padding(.horizontal, Spacing.sm)
                    .padding(.vertical, Spacing.xxs)

                ScrollView {
                    VStack(alignment: .leading, spacing: Spacing.xl) {
                        // Region header
                        regionHeader

                        // Risk display for non-stable regions
                        if region.state != .stable {
                            riskInfoSection
                        }

                        Divider()

                        // Anchor section
                        if let anchor = region.anchor {
                            anchorSection(anchor: anchor)
                            Divider()
                        }

                        // Available actions
                        actionsSection
                    }
                    .padding()
                }
            }
            .navigationTitle(region.name)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(L10n.uiClose.localized) {
                        onDismiss()
                    }
                }
            }
            .alert(actionConfirmationTitle, isPresented: $showingActionConfirmation) {
                Button(L10n.buttonConfirm.localized) {
                    if let action = selectedAction {
                        performAction(action)
                    }
                }
                Button(L10n.uiCancel.localized, role: .cancel) { }
            } message: {
                Text(actionConfirmationMessage)
            }
            .alert(L10n.nothingFound.localized, isPresented: $showingNoEventsAlert) {
                Button(L10n.buttonUnderstood.localized, role: .cancel) { }
            } message: {
                Text(L10n.noEventsInRegion.localized)
            }
            .alert(L10n.actionImpossible.localized, isPresented: $showingActionError) {
                Button(L10n.buttonUnderstood.localized, role: .cancel) { }
            } message: {
                Text(actionErrorMessage)
            }
            .sheet(item: $eventToShow) { event in
                EventView(
                    engine: engine,
                    event: event,
                    regionId: region.id,
                    onChoiceSelected: { choice in
                        handleEventChoice(choice, event: event)
                    },
                    onDismiss: {
                        eventToShow = nil
                        // Dismiss current event in engine
                        engine.performAction(.dismissCurrentEvent)
                    }
                )
            }
            .onChange(of: engine.currentEvent?.id) { _ in
                // When engine triggers an event, show it
                if let event = engine.currentEvent {
                    eventToShow = event
                }
            }
            .overlay {
                // Card received notification overlay
                if showingCardNotification && !receivedCardNames.isEmpty {
                    cardReceivedNotificationView
                }
            }
        }
    }

    // MARK: - Card Received Notification View

    var cardReceivedNotificationView: some View {
        ZStack {
            // Semi-transparent background
            Color.black.opacity(Opacity.medium)
                .ignoresSafeArea()
                .onTapGesture {
                    withAnimation(.easeOut(duration: AnimationDuration.slow)) {
                        showingCardNotification = false
                    }
                }

            VStack(spacing: Spacing.xl) {
                // Header
                VStack(spacing: Spacing.sm) {
                    Text("ðŸƒ")
                        .font(.system(size: Sizes.iconHero))

                    Text(L10n.cardsReceived.localized)
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.white)

                    Text(L10n.addedToDeck.localized)
                        .font(.subheadline)
                        .foregroundColor(.white.opacity(Opacity.high))
                }

                // Cards list
                VStack(spacing: Spacing.md) {
                    ForEach(receivedCardNames, id: \.self) { cardName in
                        HStack {
                            Image(systemName: "rectangle.stack.badge.plus")
                                .foregroundColor(AppColors.faith)
                            Text(cardName)
                                .fontWeight(.semibold)
                                .foregroundColor(.white)
                        }
                        .padding(.horizontal, Spacing.lg)
                        .padding(.vertical, Spacing.smd)
                        .background(
                            RoundedRectangle(cornerRadius: CornerRadius.md)
                                .fill(AppColors.dark.opacity(Opacity.mediumHigh))
                        )
                    }
                }

                // Dismiss button
                Button(action: {
                    withAnimation(.easeOut(duration: AnimationDuration.slow)) {
                        showingCardNotification = false
                    }
                }) {
                    Text(L10n.buttonGreat.localized)
                        .font(.headline)
                        .foregroundColor(.white)
                        .frame(minWidth: Sizes.buttonMinWidth)
                        .padding()
                        .background(AppColors.primary)
                        .cornerRadius(CornerRadius.lg)
                }
            }
            .padding(Spacing.xxl)
            .background(
                RoundedRectangle(cornerRadius: CornerRadius.xxl)
                    .fill(Color(UIColor.systemBackground).opacity(Opacity.almostOpaque))
                    .shadow(radius: Spacing.xl)
            )
            .transition(.scale.combined(with: .opacity))
        }
    }

    // MARK: - Region Header

    var regionHeader: some View {
        VStack(alignment: .leading, spacing: Spacing.md) {
            HStack {
                Image(systemName: region.type.icon)
                    .font(.largeTitle)
                    .foregroundColor(stateColor)

                VStack(alignment: .leading) {
                    Text(region.type.displayName)
                        .font(.subheadline)
                        .foregroundColor(AppColors.muted)

                    HStack {
                        Text(region.state.emoji)
                        Text(region.state.displayName)
                            .font(.title3)
                            .fontWeight(.bold)
                            .foregroundColor(stateColor)
                    }
                }

                Spacer()

                // Current location indicator
                if isPlayerHere {
                    HStack(spacing: Spacing.xxs) {
                        Image(systemName: "person.fill")
                        Text(L10n.youAreHere.localized)
                    }
                    .font(.caption)
                    .fontWeight(.bold)
                    .foregroundColor(.white)
                    .padding(.horizontal, Spacing.smd)
                    .padding(.vertical, Spacing.xs)
                    .background(AppColors.primary)
                    .cornerRadius(CornerRadius.lg)
                }
            }

            Text(regionDescription)
                .font(.body)
                .foregroundColor(AppColors.muted)
        }
    }

    var regionDescription: String {
        switch region.state {
        case .stable:
            return L10n.regionDescStable.localized
        case .borderland:
            return L10n.regionDescBorderland.localized
        case .breach:
            return L10n.regionDescBreach.localized
        }
    }

    // MARK: - Risk Info Section

    var riskInfoSection: some View {
        VStack(alignment: .leading, spacing: Spacing.sm) {
            HStack {
                Image(systemName: "exclamationmark.triangle.fill")
                    .foregroundColor(region.state == .breach ? AppColors.danger : AppColors.warning)
                Text(L10n.warningTitle.localized)
                    .font(.caption)
                    .fontWeight(.bold)
            }

            Text(L10n.warningHighDanger.localized)
                .font(.caption)
                .foregroundColor(AppColors.muted)
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: CornerRadius.md)
                .fill(region.state == .breach ? AppColors.danger.opacity(0.1) : AppColors.warning.opacity(0.1))
        )
    }

    // MARK: - Anchor Section

    func anchorSection(anchor: EngineAnchorState) -> some View {
        VStack(alignment: .leading, spacing: Spacing.md) {
            Text(L10n.anchorOfYav.localized)
                .font(.headline)

            HStack(spacing: Spacing.md) {
                Image(systemName: "flame")
                    .font(.title)
                    .foregroundColor(AppColors.power)
                    .frame(width: Sizes.iconHero, height: Sizes.iconHero)
                    .background(Circle().fill(AppColors.power.opacity(Opacity.faint)))

                VStack(alignment: .leading, spacing: Spacing.xxs) {
                    Text(anchor.name)
                        .font(.subheadline)
                        .fontWeight(.bold)

                    // Integrity bar
                    HStack(spacing: Spacing.xxs) {
                        Text(L10n.anchorIntegrity.localized + ":")
                            .font(.caption2)
                        GeometryReader { geometry in
                            ZStack(alignment: .leading) {
                                Rectangle()
                                    .fill(AppColors.secondary.opacity(Opacity.faint))
                                    .frame(height: Sizes.progressMedium)

                                Rectangle()
                                    .fill(anchorIntegrityColor(anchor.integrity))
                                    .frame(
                                        width: geometry.size.width * CGFloat(anchor.integrity) / 100,
                                        height: Sizes.progressMedium
                                    )
                            }
                        }
                        .frame(height: Sizes.progressMedium)

                        Text("\(anchor.integrity)%")
                            .font(.caption2)
                            .fontWeight(.bold)
                            .foregroundColor(anchorIntegrityColor(anchor.integrity))
                    }
                }
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: CornerRadius.lg)
                    .fill(Color(UIColor.tertiarySystemBackground))
            )
        }
    }

    // MARK: - Actions Section

    var isPlayerHere: Bool {
        region.id == engine.currentRegionId
    }

    var actionsSection: some View {
        VStack(alignment: .leading, spacing: Spacing.md) {
            Text(L10n.availableActions.localized)
                .font(.headline)

            VStack(spacing: Spacing.sm) {
                // Travel action - only if player is NOT here
                if !isPlayerHere {
                    let canTravel = engine.canTravelTo(regionId: region.id)
                    let routingHint = engine.getRoutingHint(to: region.id)
                    let travelCost = engine.calculateTravelCost(to: region.id)
                    let dayWord = travelCost == 1 ? L10n.dayWord1.localized : L10n.dayWord234.localized

                    actionButton(
                        title: canTravel ? L10n.actionTravelTo.localized(with: travelCost, dayWord) : L10n.actionRegionFar.localized,
                        icon: canTravel ? "arrow.right.circle.fill" : "xmark.circle",
                        color: canTravel ? .blue : .gray,
                        enabled: canTravel
                    ) {
                        selectedAction = .travel
                        showingActionConfirmation = true
                    }

                    if canTravel {
                        HStack {
                            Image(systemName: "info.circle")
                                .foregroundColor(AppColors.muted)
                            Text(L10n.actionMoveToRegionHint.localized)
                                .font(.caption)
                                .foregroundColor(AppColors.muted)
                        }
                        .padding(.vertical, Spacing.sm)
                    } else {
                        // Show routing hint for distant regions
                        HStack {
                            Image(systemName: "map")
                                .foregroundColor(AppColors.warning)
                            if !routingHint.isEmpty {
                                Text(L10n.goThroughFirst.localized(with: routingHint.joined(separator: ", ")))
                                    .font(.caption)
                                    .foregroundColor(AppColors.warning)
                            } else {
                                Text(L10n.actionRegionNotDirectlyAccessible.localized)
                                    .font(.caption)
                                    .foregroundColor(AppColors.warning)
                            }
                        }
                        .padding(.vertical, Spacing.sm)
                    }
                }

                // Actions available ONLY if player is in the region
                if isPlayerHere {
                    // Rest action
                    actionButton(
                        title: L10n.actionRestHeal.localized(with: 3),
                        icon: "bed.double.fill",
                        color: .green,
                        enabled: region.canRest
                    ) {
                        selectedAction = .rest
                        showingActionConfirmation = true
                    }

                    // Trade action
                    actionButton(
                        title: L10n.actionTradeName.localized,
                        icon: "cart.fill",
                        color: .orange,
                        enabled: region.canTrade
                    ) {
                        selectedAction = .trade
                        showingActionConfirmation = true
                    }

                    // Strengthen anchor
                    if region.anchor != nil {
                        actionButton(
                            title: L10n.actionAnchorCost.localized(with: 5, 20),
                            icon: "hammer.fill",
                            color: .purple,
                            enabled: engine.canAffordFaith(5)
                        ) {
                            selectedAction = .strengthenAnchor
                            showingActionConfirmation = true
                        }
                    }

                    // Explore (only if events available)
                    let hasEvents = engine.hasAvailableEventsInCurrentRegion()
                    actionButton(
                        title: L10n.actionExploreName.localized,
                        icon: "magnifyingglass",
                        color: .cyan,
                        enabled: hasEvents
                    ) {
                        selectedAction = .explore
                        showingActionConfirmation = true
                    }
                }
            }
        }
    }

    func actionButton(
        title: String,
        icon: String,
        color: Color,
        enabled: Bool,
        action: @escaping () -> Void
    ) -> some View {
        Button(action: action) {
            HStack {
                Image(systemName: icon)
                    .font(.body)
                Text(title)
                    .font(.body)
                Spacer()
            }
            .padding()
            .foregroundColor(enabled ? .white : AppColors.secondary)
            .background(enabled ? color : AppColors.secondary.opacity(Opacity.light))
            .cornerRadius(Spacing.smd)
        }
        .disabled(!enabled)
    }

    // MARK: - Helpers

    var stateColor: Color {
        switch region.state {
        case .stable: return AppColors.success
        case .borderland: return AppColors.warning
        case .breach: return AppColors.danger
        }
    }

    func anchorIntegrityColor(_ integrity: Int) -> Color {
        switch integrity {
        case 70...100: return AppColors.success
        case 30..<70: return AppColors.warning
        default: return AppColors.danger
        }
    }

    // MARK: - Action Handling

    var actionConfirmationTitle: String {
        guard let action = selectedAction else { return L10n.confirmationTitle.localized }
        switch action {
        case .travel: return L10n.actionTravel.localized
        case .rest: return L10n.actionRest.localized
        case .trade: return L10n.actionTrade.localized
        case .strengthenAnchor: return L10n.actionStrengthenAnchor.localized
        case .explore: return L10n.actionExploreRegion.localized
        }
    }

    var actionConfirmationMessage: String {
        guard let action = selectedAction else { return "" }
        switch action {
        case .travel:
            let days = engine.calculateTravelCost(to: region.id)
            let dayWord = days == 1 ? L10n.dayWord1.localized : L10n.dayWord234.localized
            return L10n.confirmTravel.localized(with: region.name, days, dayWord)
        case .rest:
            return L10n.confirmRest.localized(with: 3)
        case .trade:
            return L10n.confirmTrade.localized
        case .strengthenAnchor:
            return L10n.confirmStrengthenAnchor.localized(with: 5, 20)
        case .explore:
            return L10n.confirmExplore.localized
        }
    }

    // MARK: - Actions via Engine

    func performAction(_ action: EngineRegionAction) {
        switch action {
        case .travel:
            let result = engine.performAction(.travel(toRegionId: region.id))
            if result.success {
                engine.addLogEntry(
                    regionName: region.name,
                    eventTitle: L10n.journalEntryTravel.localized,
                    choiceMade: L10n.journalEntryTravelChoice.localized,
                    outcome: L10n.journalEntryTravelOutcome.localized(with: region.name),
                    type: .travel
                )
                // ÐŸÐ¾ÑÐ»Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÑ‰ÐµÐ½Ð¸Ñ Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ð½Ð¾Ð²Ñ‹Ð¹ Ñ€ÐµÐ³Ð¸Ð¾Ð½ (Ñ‚ÐµÐºÑƒÑ‰ÑƒÑŽ Ð»Ð¾ÐºÐ°Ñ†Ð¸ÑŽ)
                if let newRegion = engine.regionsArray.first(where: { $0.id == engine.currentRegionId }) {
                    onRegionChange?(newRegion)
                } else {
                    onDismiss()
                }
            } else {
                // Show error to user
                actionErrorMessage = errorMessage(for: result.error)
                showingActionError = true
            }

        case .rest:
            let result = engine.performAction(.rest)
            if result.success {
                engine.addLogEntry(
                    regionName: region.name,
                    eventTitle: L10n.journalRestTitle.localized,
                    choiceMade: L10n.journalRestChoice.localized,
                    outcome: L10n.journalRestOutcome.localized,
                    type: .exploration
                )
            }

        case .trade:
            // Phase 4: Implement trade/market view
            break

        case .strengthenAnchor:
            let result = engine.performAction(.strengthenAnchor)
            if result.success {
                engine.addLogEntry(
                    regionName: region.name,
                    eventTitle: L10n.journalAnchorTitle.localized,
                    choiceMade: L10n.journalAnchorChoice.localized,
                    outcome: L10n.journalAnchorOutcome.localized,
                    type: .worldChange
                )
            }

        case .explore:
            let result = engine.performAction(.explore)
            if result.success {
                // Check if an event was triggered
                if result.currentEvent == nil {
                    // No event available - show alert
                    showingNoEventsAlert = true
                    engine.addLogEntry(
                        regionName: region.name,
                        eventTitle: L10n.journalEntryExplore.localized,
                        choiceMade: L10n.journalEntryExploreChoice.localized,
                        outcome: L10n.journalEntryExploreNothing.localized,
                        type: .exploration
                    )
                }
                // If event was triggered, it will be shown via onChange of engine.currentEvent
            }
        }
    }

    // MARK: - Error Messages

    func errorMessage(for error: ActionError?) -> String {
        guard let error = error else { return L10n.errorUnknown.localized }
        switch error {
        case .regionNotNeighbor:
            return L10n.errorRegionFar.localized
        case .regionNotAccessible:
            return L10n.errorRegionInaccessible.localized
        case .healthTooLow:
            return L10n.errorHealthLow.localized
        case .insufficientResources(let resource, let required, let available):
            return L10n.errorInsufficientResource.localized(with: resource, required, available)
        case .invalidAction(let reason):
            return reason
        case .combatInProgress:
            return L10n.errorInCombat.localized
        case .eventInProgress:
            return L10n.errorFinishEvent.localized
        default:
            return L10n.errorActionFailed.localized(with: "\(error)")
        }
    }

    // MARK: - Event Choice Handling

    func handleEventChoice(_ choice: EventChoice, event: GameEvent) {
        // Check for card rewards before processing
        var cardsToNotify: [String] = []
        if let cardIDs = choice.consequences.addCards {
            for cardID in cardIDs {
                if let card = CardFactory.shared.getCard(id: cardID) {
                    cardsToNotify.append(card.name)
                }
            }
        }

        // Execute choice via engine
        if let choiceIndex = event.choices.firstIndex(where: { $0.id == choice.id }) {
            let result = engine.performAction(.chooseEventOption(eventId: event.id, choiceIndex: choiceIndex))

            if result.success {
                // Log the event
                let logType: EventLogType = event.eventType == .combat ? .combat : .exploration
                let outcomeMessage = choice.consequences.message ?? L10n.journalChoiceMade.localized
                engine.addLogEntry(
                    regionName: region.name,
                    eventTitle: event.title,
                    choiceMade: choice.text,
                    outcome: outcomeMessage,
                    type: logType
                )
            }
        }

        // Dismiss event view
        eventToShow = nil
        engine.performAction(.dismissCurrentEvent)

        // Show card received notification if cards were gained
        if !cardsToNotify.isEmpty {
            receivedCardNames = cardsToNotify
            // Delay slightly to allow event sheet to dismiss first
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                    showingCardNotification = true
                }
            }
        }
    }
}

// MARK: - Engine-First Event Log View

struct EngineEventLogView: View {
    @ObservedObject var engine: TwilightGameEngine
    @Environment(\.dismiss) var dismiss

    var body: some View {
        NavigationView {
            List {
                if engine.publishedEventLog.isEmpty {
                    Text(L10n.journalEmpty.localized)
                        .foregroundColor(AppColors.muted)
                        .padding()
                } else {
                    ForEach(engine.publishedEventLog.reversed()) { entry in
                        EventLogEntryView(entry: entry)
                    }
                }
            }
            .navigationTitle(L10n.journalTitle.localized)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(L10n.uiClose.localized) {
                        dismiss()
                    }
                }
            }
        }
    }
}


// ==========================================
// FILE: Views/Components/HeroPanel.swift
// ==========================================

import SwiftUI
import TwilightEngine

/// Unified Hero Panel - displays hero stats consistently across all screens
/// Inspired by Arkham Horror LCG investigator cards but with unique Twilight Marches style
/// Engine-First Architecture: reads all data from TwilightGameEngine
struct HeroPanel: View {
    @ObservedObject var engine: TwilightGameEngine

    /// Compact mode for screens with limited space (like combat header)
    var compact: Bool = false

    /// Show hero portrait/avatar
    var showAvatar: Bool = true

    var body: some View {
        if compact {
            compactPanel
        } else {
            fullPanel
        }
    }

    // MARK: - Full Panel (for main screens like WorldMap, RegionDetail)

    var fullPanel: some View {
        HStack(spacing: Spacing.md) {
            // Hero Avatar
            if showAvatar {
                heroAvatar
            }

            // Hero Info
            VStack(alignment: .leading, spacing: Spacing.xxs) {
                // Name and class
                HStack {
                    Text(engine.playerName)
                        .font(.headline)
                        .fontWeight(.bold)
                    Text(heroClass)
                        .font(.caption)
                        .foregroundColor(AppColors.muted)
                        .padding(.horizontal, Spacing.xs)
                        .padding(.vertical, Spacing.xxxs)
                        .background(AppColors.secondary.opacity(Opacity.faint))
                        .cornerRadius(CornerRadius.sm)
                }

                // Stats row
                HStack(spacing: Spacing.md) {
                    // Health
                    statBadge(
                        icon: "heart.fill",
                        value: "\(engine.playerHealth)/\(engine.playerMaxHealth)",
                        color: healthColor,
                        label: nil
                    )

                    // Faith
                    statBadge(
                        icon: "sparkles",
                        value: "\(engine.playerFaith)",
                        color: AppColors.faith,
                        label: nil
                    )

                    // Strength
                    statBadge(
                        icon: "hand.raised.fill",
                        value: "\(engine.playerStrength)",
                        color: AppColors.power,
                        label: nil
                    )

                    // Balance indicator
                    balanceIndicator
                }
            }

            Spacer()
        }
        .padding(.horizontal, Spacing.md)
        .padding(.vertical, Spacing.smd)
        .background(heroPanelBackground)
    }

    // MARK: - Compact Panel (for combat, events with limited space)

    var compactPanel: some View {
        HStack(spacing: Spacing.sm) {
            // Mini avatar
            if showAvatar {
                ZStack {
                    Circle()
                        .fill(balanceGradient)
                        .frame(width: Sizes.iconLarge, height: Sizes.iconLarge)

                    Text(heroInitials)
                        .font(.caption)
                        .fontWeight(.bold)
                        .foregroundColor(.white)
                }
            }

            // Compact stats
            HStack(spacing: Spacing.sm) {
                // Health
                HStack(spacing: Spacing.xxxs) {
                    Image(systemName: "heart.fill")
                        .font(.caption2)
                        .foregroundColor(AppColors.health)
                    Text("\(engine.playerHealth)")
                        .font(.caption)
                        .fontWeight(.semibold)
                }

                // Faith
                HStack(spacing: Spacing.xxxs) {
                    Image(systemName: "sparkles")
                        .font(.caption2)
                        .foregroundColor(AppColors.faith)
                    Text("\(engine.playerFaith)")
                        .font(.caption)
                        .fontWeight(.semibold)
                }

                // Balance (small icon only)
                Image(systemName: balanceIcon)
                    .font(.caption2)
                    .foregroundColor(balanceColor)
            }

            Spacer()
        }
        .padding(.horizontal, Spacing.sm)
        .padding(.vertical, Spacing.xs)
        .background(AppColors.cardBackground.opacity(Opacity.almostOpaque))
        .cornerRadius(CornerRadius.md)
    }

    // MARK: - Hero Avatar

    var heroAvatar: some View {
        ZStack {
            // Background circle with balance gradient
            Circle()
                .fill(balanceGradient)
                .frame(width: Sizes.iconHero, height: Sizes.iconHero)

            // Inner circle
            Circle()
                .fill(Color(UIColor.systemBackground))
                .frame(width: Sizes.touchTarget, height: Sizes.touchTarget)

            // Hero initials or icon
            Text(heroInitials)
                .font(.title3)
                .fontWeight(.bold)
                .foregroundColor(balanceColor)
        }
    }

    // MARK: - Stat Badge

    func statBadge(icon: String, value: String, color: Color, label: String?) -> some View {
        HStack(spacing: Spacing.xxs) {
            Image(systemName: icon)
                .font(.caption)
                .foregroundColor(color)

            VStack(alignment: .leading, spacing: 0) {
                Text(value)
                    .font(.subheadline)
                    .fontWeight(.semibold)

                if let label = label {
                    Text(label)
                        .font(.system(size: 9))
                        .foregroundColor(AppColors.muted)
                }
            }
        }
        .padding(.horizontal, Spacing.sm)
        .padding(.vertical, Spacing.xxs)
        .background(color.opacity(0.15))
        .cornerRadius(Spacing.xs)
    }

    // MARK: - Balance Indicator

    var balanceIndicator: some View {
        HStack(spacing: Spacing.xxs) {
            Image(systemName: balanceIcon)
                .font(.caption)
                .foregroundColor(balanceColor)

            Text(balanceText)
                .font(.caption)
                .fontWeight(.medium)
                .foregroundColor(balanceColor)
        }
        .padding(.horizontal, Spacing.sm)
        .padding(.vertical, Spacing.xxs)
        .background(balanceColor.opacity(0.15))
        .cornerRadius(Spacing.xs)
    }

    // MARK: - Background

    var heroPanelBackground: some View {
        ZStack {
            // Base background
            RoundedRectangle(cornerRadius: CornerRadius.lg)
                .fill(AppColors.cardBackground)

            // Subtle balance-colored border
            RoundedRectangle(cornerRadius: CornerRadius.lg)
                .stroke(balanceColor.opacity(Opacity.light), lineWidth: 1)
        }
    }

    // MARK: - Computed Properties

    var heroClass: String {
        // In data-driven architecture, hero role comes from hero definition
        // For now, return localized default or hero name
        return L10n.heroClassDefault.localized
    }

    var heroInitials: String {
        let name = engine.playerName
        let words = name.split(separator: " ")
        if words.count >= 2 {
            return String(words[0].prefix(1)) + String(words[1].prefix(1))
        }
        return String(name.prefix(2)).uppercased()
    }

    var healthColor: Color {
        let percentage = Double(engine.playerHealth) / Double(max(engine.playerMaxHealth, 1))
        if percentage > 0.6 {
            return AppColors.success
        } else if percentage > 0.3 {
            return AppColors.warning
        } else {
            return AppColors.danger
        }
    }

    var balanceIcon: String {
        let balance = engine.playerBalance
        if balance >= 70 {
            return "sun.max.fill"      // Light path (70-100)
        } else if balance <= 30 {
            return "moon.fill"          // Dark path (0-30)
        } else {
            return "circle.lefthalf.filled"  // Neutral (30-70)
        }
    }

    var balanceColor: Color {
        let balance = engine.playerBalance
        if balance >= 70 {
            return AppColors.light      // Light path
        } else if balance <= 30 {
            return AppColors.dark       // Dark path
        } else {
            return AppColors.neutral    // Neutral
        }
    }

    var balanceText: String {
        let balance = engine.playerBalance
        if balance >= 70 {
            return L10n.balanceLight.localized
        } else if balance <= 30 {
            return L10n.balanceDark.localized
        } else {
            return L10n.balanceNeutral.localized
        }
    }

    var balanceGradient: LinearGradient {
        let balance = engine.playerBalance
        if balance >= 70 {
            return LinearGradient(
                colors: [AppColors.light.opacity(Opacity.high), AppColors.power.opacity(Opacity.mediumHigh)],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        } else if balance <= 30 {
            return LinearGradient(
                colors: [AppColors.dark.opacity(Opacity.high), Color.indigo.opacity(Opacity.mediumHigh)],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        } else {
            return LinearGradient(
                colors: [AppColors.neutral.opacity(Opacity.mediumHigh), AppColors.neutral.opacity(Opacity.medium)],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        }
    }
}

// MARK: - Preview

struct HeroPanel_Previews: PreviewProvider {
    static var previews: some View {
        VStack(spacing: Spacing.xl) {
            // Full panel
            HeroPanel(engine: previewEngine)
                .padding()

            // Compact panel
            HeroPanel(engine: previewEngine, compact: true)
                .padding()

            // Full panel without avatar
            HeroPanel(engine: previewEngine, showAvatar: false)
                .padding()
        }
        .background(Color(UIColor.systemBackground))
    }

    static var previewEngine: TwilightGameEngine {
        let engine = TwilightGameEngine()
        // Preview data would be set here
        return engine
    }
}

