=== DUMP GENERATED ===
Source: .

=== FILE STRUCTURE ===
CardGameApp.swift
ContentView.swift
Package.swift
ViewModels/
    GameViewModel.swift
.claude/
Models/
    Card.swift
    CardType.swift
    ExplorationModels.swift
    GameSave.swift
    GameState.swift
    Player.swift
    WorldState.swift
Utilities/
    AccessibilityIdentifiers.swift
    SafeImage.swift
    WorldRNG.swift
.github/
    workflows/
Data/
    TwilightMarchesCards.swift
Views/
    CardView.swift
    CombatView.swift
    EventView.swift
    GameBoardView.swift
    HeroSelectionView.swift
    PlayerHandView.swift
    RulesView.swift
    StatisticsView.swift
    WorldMapView.swift
    Components/
        HeroPanel.swift
Engine/
    Core/
        CoreGameEngine.swift
        EconomyManager.swift
        EngineProtocols.swift
        EngineSave.swift
        GameLoop.swift
        PressureEngine.swift
        RequirementsEvaluator.swift
        TimeEngine.swift
        TwilightGameAction.swift
        TwilightGameEngine.swift
    Combat/
        CombatCalculator.swift
    Config/
        DegradationRules.swift
        TwilightMarchesConfig.swift
    Heroes/
        HeroAbility.swift
        HeroClass.swift
        HeroDefinition.swift
        HeroRegistry.swift
    Cards/
        CardDefinition.swift
        CardRegistry.swift
    Runtime/
        EventRuntimeState.swift
        GameRuntimeState.swift
        PlayerRuntimeState.swift
        QuestRuntimeState.swift
        WorldRuntimeState.swift
    Events/
        EventPipeline.swift
        MiniGameDispatcher.swift
    Modules/
        CombatModule.swift
    Data/
        Providers/
            CodeContentProvider.swift
            ContentProvider.swift
            JSONContentProvider.swift
        Definitions/
            AnchorDefinition.swift
            EnemyDefinition.swift
            EventDefinition.swift
            GameDefinition.swift
            LocalizedString.swift
            MiniGameChallengeDefinition.swift
            QuestDefinition.swift
            RegionDefinition.swift
    Migration/
        EngineAdapters.swift
        EventDefinitionAdapter.swift
        LegacyAdapters.swift
        QuestDefinitionAdapter.swift
Helpers/
    Localization.swift

=== FILE CONTENTS ===

// ==========================================
// FILE: CardGameApp.swift
// ==========================================

import SwiftUI

@main
struct CardGameApp: App {
    @StateObject private var contentLoader = ContentLoader()

    var body: some Scene {
        WindowGroup {
            if contentLoader.isLoaded {
                ContentView()
            } else {
                LoadingView(progress: contentLoader.loadingProgress, message: contentLoader.loadingMessage)
            }
        }
    }
}

// MARK: - Content Loader (Background Thread)

/// Loads content packs on background thread to prevent main thread blocking
@MainActor
class ContentLoader: ObservableObject {
    @Published var isLoaded = false
    @Published var loadingProgress: Double = 0
    @Published var loadingMessage = "Загрузка..."

    init() {
        Task {
            await loadContentPacks()
        }
    }

    private func loadContentPacks() async {
        loadingMessage = "Поиск контент-паков..."
        loadingProgress = 0.1

        // Run file operations on background thread
        let packURL: URL? = await Task.detached(priority: .userInitiated) { () -> URL? in
            // Find ContentPacks in the bundle
            if let url = Bundle.main.url(forResource: "TwilightMarches", withExtension: nil, subdirectory: "ContentPacks") {
                return url
            }

            // Try finding ContentPacks directory in bundle
            if let resourceURL = Bundle.main.resourceURL {
                let contentPacksURL = resourceURL.appendingPathComponent("ContentPacks/TwilightMarches")
                if FileManager.default.fileExists(atPath: contentPacksURL.path) {
                    return contentPacksURL
                }
            }

            // Fallback: Try source directory path (for development/debugging)
            #if DEBUG
            let sourceURL = URL(fileURLWithPath: #filePath)
                .deletingLastPathComponent()
                .appendingPathComponent("ContentPacks/TwilightMarches")
            if FileManager.default.fileExists(atPath: sourceURL.path) {
                return sourceURL
            }
            #endif

            return nil
        }.value

        loadingProgress = 0.3

        if let url = packURL {
            loadingMessage = "Загрузка контента..."
            await loadPack(at: url)
        } else {
            loadingMessage = "Контент не найден"
            print("⚠️ ContentPacks not found - using fallback content")
        }

        loadingProgress = 1.0
        loadingMessage = "Готово!"

        // Small delay to show completion
        try? await Task.sleep(nanoseconds: 200_000_000)
        isLoaded = true
    }

    private func loadPack(at url: URL) async {
        let registry = ContentRegistry.shared

        // Run heavy loading on background thread
        let result = await Task.detached(priority: .userInitiated) { () -> Result<LoadedPack, Error> in
            do {
                let pack = try registry.loadPack(from: url)
                return .success(pack)
            } catch {
                return .failure(error)
            }
        }.value

        switch result {
        case .success(let pack):
            loadingProgress = 0.9
            loadingMessage = "Контент загружен"
            print("✅ Loaded pack: \(pack.manifest.packId) v\(pack.manifest.version)")
            print("   - \(pack.regions.count) regions")
            print("   - \(pack.events.count) events")
            print("   - \(pack.quests.count) quests")
            print("   - \(pack.anchors.count) anchors")
            print("   - \(pack.heroes.count) heroes")
            print("   - \(pack.cards.count) cards")
        case .failure(let error):
            loadingMessage = "Ошибка загрузки"
            print("❌ Failed to load pack from \(url.path): \(error)")
        }
    }
}

// MARK: - Loading View

struct LoadingView: View {
    let progress: Double
    let message: String

    var body: some View {
        VStack(spacing: 20) {
            Text("Сумрачные Пределы")
                .font(.largeTitle)
                .fontWeight(.bold)

            ProgressView(value: progress)
                .progressViewStyle(.linear)
                .frame(width: 200)

            Text(message)
                .font(.subheadline)
                .foregroundColor(.secondary)
        }
        .padding()
    }
}


// ==========================================
// FILE: ContentView.swift
// ==========================================

import SwiftUI

struct ContentView: View {
    @State private var showingWorldMap = false
    @State private var showingRules = false
    @State private var showingSaveSlots = false
    @State private var showingLoadSlots = false  // New: for "Continue" flow
    @State private var showingStatistics = false
    @State private var selectedCharacterIndex = 0
    @State private var selectedSaveSlot: Int?

    // MARK: - Engine-First Architecture
    // Engine is the single source of truth - replaces GameState
    @StateObject private var engine = TwilightGameEngine()
    @StateObject private var saveManager = SaveManager.shared

    // Legacy support for save/load during transition
    @StateObject private var gameState = GameState(players: [])

    // Using Twilight Marches characters
    let characters = TwilightMarchesCards.createGuardians()

    // Check if there are any saves
    var hasSaves: Bool {
        !saveManager.allSaves.isEmpty
    }

    var body: some View {
        NavigationView {
            if showingWorldMap {
                // MARK: - Engine-First: Pass engine directly to WorldMapView
                WorldMapView(
                    engine: engine,
                    onExit: {
                        // Save game before exiting (using legacy save system)
                        if let slot = selectedSaveSlot {
                            saveManager.saveGame(to: slot, gameState: gameState)
                        }
                        showingWorldMap = false
                        showingSaveSlots = false
                        showingLoadSlots = false
                    }
                )
            } else if showingSaveSlots {
                saveSlotSelectionView
            } else if showingLoadSlots {
                loadSlotSelectionView
            } else {
                characterSelectionView
            }
        }
    }

    var characterSelectionView: some View {
        GeometryReader { geometry in
            ZStack(alignment: .bottom) {
                // Scrollable content
                ScrollView {
                    VStack(spacing: 20) {
                        // Header with rules and statistics buttons
                        HStack(spacing: 8) {
                            VStack(alignment: .leading, spacing: 2) {
                                Text(L10n.tmGameTitle.localized)
                                    .font(.title2)
                                    .fontWeight(.bold)
                                    .minimumScaleFactor(0.6)
                                    .lineLimit(2)
                                Text(L10n.tmGameSubtitle.localized)
                                    .font(.caption2)
                                    .foregroundColor(.secondary)
                                    .lineLimit(1)
                                    .minimumScaleFactor(0.8)
                            }
                            .frame(maxWidth: .infinity, alignment: .leading)

                            Button(action: { showingStatistics = true }) {
                                Image(systemName: "chart.bar.fill")
                                    .font(.title3)
                                    .padding(8)
                                    .background(Color.orange.opacity(0.2))
                                    .foregroundColor(.orange)
                                    .cornerRadius(8)
                            }
                            Button(action: { showingRules = true }) {
                                Image(systemName: "book.fill")
                                    .font(.title3)
                                    .padding(8)
                                    .background(Color.blue.opacity(0.2))
                                    .foregroundColor(.blue)
                                    .cornerRadius(8)
                            }
                        }
                        .padding(.horizontal)
                        .padding(.top, 8)

                        Text(L10n.characterSelectTitle.localized)
                            .font(.title2)
                            .foregroundColor(.secondary)

                        // Character cards scroll
                        ScrollView(.horizontal, showsIndicators: false) {
                            HStack(spacing: 20) {
                                ForEach(Array(characters.enumerated()), id: \.element.id) { index, character in
                                    CompactCardView(
                                        card: character,
                                        isSelected: selectedCharacterIndex == index,
                                        onTap: {
                                            selectedCharacterIndex = index
                                        }
                                    )
                                    .frame(width: min(geometry.size.width * 0.65, 240), height: 280)
                                }
                            }
                            .padding(.horizontal)
                            .padding(.vertical, 12)
                        }
                        .frame(height: 320)

                        // Character stats
                        if selectedCharacterIndex < characters.count {
                            let character = characters[selectedCharacterIndex]
                            VStack(alignment: .leading, spacing: 16) {
                                Text(L10n.characterStats.localized)
                                    .font(.headline)

                                Text(character.description)
                                    .font(.body)
                                    .foregroundColor(.secondary)
                                    .fixedSize(horizontal: false, vertical: true)

                                HStack(spacing: 24) {
                                    if let health = character.health {
                                        StatDisplay(icon: "heart.fill", label: L10n.statHealth.localized, value: health, color: .red)
                                    }
                                    if let power = character.power {
                                        StatDisplay(icon: "bolt.fill", label: L10n.statPower.localized, value: power, color: .orange)
                                    }
                                    if let defense = character.defense {
                                        StatDisplay(icon: "shield.fill", label: L10n.statDefense.localized, value: defense, color: .blue)
                                    }
                                }

                                if !character.abilities.isEmpty {
                                    Divider()
                                    Text(L10n.characterAbilities.localized)
                                        .font(.headline)

                                    ForEach(character.abilities) { ability in
                                        VStack(alignment: .leading, spacing: 4) {
                                            Text(ability.name)
                                                .font(.subheadline)
                                                .fontWeight(.bold)
                                                .foregroundColor(.orange)
                                            Text(ability.description)
                                                .font(.caption)
                                                .foregroundColor(.secondary)
                                                .fixedSize(horizontal: false, vertical: true)
                                        }
                                        .padding(.vertical, 4)
                                    }
                                }
                            }
                            .padding()
                            .background(Color(UIColor.secondarySystemBackground))
                            .cornerRadius(12)
                            .padding(.horizontal)
                        }

                        // Extra space for button
                        Color.clear.frame(height: 90)
                    }
                    .padding(.bottom, 20)
                }

                // Fixed buttons at bottom with shadow
                VStack(spacing: 0) {
                    Rectangle()
                        .fill(
                            LinearGradient(
                                gradient: Gradient(colors: [Color.clear, Color(UIColor.systemBackground)]),
                                startPoint: .top,
                                endPoint: .bottom
                            )
                        )
                        .frame(height: 30)

                    VStack(spacing: 12) {
                        // Continue button (only if saves exist)
                        if hasSaves {
                            Button(action: { handleContinueGame() }) {
                                HStack {
                                    Image(systemName: "play.fill")
                                    Text(L10n.uiContinue.localized)
                                }
                                .font(.title3)
                                .fontWeight(.bold)
                                .foregroundColor(.white)
                                .frame(maxWidth: .infinity)
                                .padding()
                                .background(Color.green)
                                .cornerRadius(12)
                            }
                        }

                        // New game button
                        Button(action: { showingSaveSlots = true }) {
                            HStack {
                                Image(systemName: hasSaves ? "plus.circle.fill" : "play.fill")
                                Text(L10n.buttonStartAdventure.localized)
                            }
                            .font(.title3)
                            .fontWeight(.bold)
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .padding()
                            .background(Color.blue)
                            .cornerRadius(12)
                        }
                    }
                    .padding(.horizontal)
                    .padding(.bottom, 12)
                    .background(Color(UIColor.systemBackground))
                }
            }
        }
        .navigationBarHidden(true)
        .sheet(isPresented: $showingRules) {
            RulesView()
        }
        .sheet(isPresented: $showingStatistics) {
            StatisticsView()
        }
    }

    var saveSlotSelectionView: some View {
        VStack(spacing: 20) {
            // Header
            HStack {
                Button(action: { showingSaveSlots = false }) {
                    HStack(spacing: 4) {
                        Image(systemName: "chevron.left")
                        Text(L10n.uiBack.localized)
                    }
                    .foregroundColor(.blue)
                }
                Spacer()
                VStack(alignment: .trailing, spacing: 4) {
                    Text(L10n.uiSlotSelection.localized)
                        .font(.title2)
                        .fontWeight(.bold)
                    if selectedCharacterIndex < characters.count {
                        Text(characters[selectedCharacterIndex].name)
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                    }
                }
            }
            .padding()

            // Save slots
            ScrollView {
                VStack(spacing: 16) {
                    ForEach(1...3, id: \.self) { slotNumber in
                        SaveSlotCard(
                            slotNumber: slotNumber,
                            saveData: saveManager.loadGame(from: slotNumber),
                            onNewGame: { startGame(in: slotNumber) },
                            onLoadGame: { loadGame(from: slotNumber) },
                            onDelete: {
                                saveManager.deleteSave(from: slotNumber)
                            }
                        )
                    }
                }
                .padding()
            }
        }
        .navigationBarHidden(true)
    }

    func startGame(in slot: Int) {
        let selectedCharacter = characters[selectedCharacterIndex]

        // Create player with selected character
        let player = Player(
            name: selectedCharacter.name,
            health: selectedCharacter.health ?? 10,
            maxHealth: selectedCharacter.health ?? 10,
            maxHandSize: 5,  // Changed from 7 to 5 for deck-building mechanics
            strength: selectedCharacter.power ?? 0,
            dexterity: 0,
            constitution: 0,
            intelligence: 0,
            wisdom: 0,
            charisma: 0
        )

        // Build player's starting deck (10 unique cards per hero)
        player.deck = TwilightMarchesCards.createStartingDeck(for: selectedCharacter.name)
        player.shuffleDeck()

        // IMPORTANT: Create fresh WorldState for new game
        // This ensures previous game state doesn't persist
        gameState.worldState = WorldState()

        // Initialize game state with Twilight Marches encounters and market
        gameState.players = [player]
        gameState.encounterDeck = TwilightMarchesCards.createEncounterDeck()
        gameState.encounterDeck.shuffle()
        gameState.marketCards = TwilightMarchesCards.createMarketCards()

        // MARK: - Engine-First: Connect engine to legacy state
        // connectToLegacy also calls resetGameState() to clear isGameOver flag
        engine.connectToLegacy(worldState: gameState.worldState, player: player)

        // Save to selected slot
        selectedSaveSlot = slot
        saveManager.saveGame(to: slot, gameState: gameState)

        showingWorldMap = true
        showingSaveSlots = false
    }

    func loadGame(from slot: Int) {
        guard let saveData = saveManager.loadGame(from: slot) else { return }

        // Find the character
        if let characterIndex = characters.firstIndex(where: { $0.name == saveData.characterName }) {
            selectedCharacterIndex = characterIndex
        }

        // Create player from save data
        let player = Player(
            name: saveData.characterName,
            health: saveData.health,
            maxHealth: saveData.maxHealth,
            maxHandSize: 5,  // Changed from 7 to 5 for deck-building mechanics
            strength: 0,
            dexterity: 0,
            constitution: 0,
            intelligence: 0,
            wisdom: 0,
            charisma: 0
        )

        // Set player resources
        player.faith = saveData.faith
        player.balance = saveData.balance

        // Restore deck composition if saved
        if !saveData.playerDeck.isEmpty {
            player.deck = saveData.playerDeck
            player.hand = saveData.playerHand
            player.discard = saveData.playerDiscard
            player.buried = saveData.playerBuried
        } else {
            // Fallback: create starting deck
            player.deck = TwilightMarchesCards.createStartingDeck(for: saveData.characterName)
            player.shuffleDeck()
        }

        // Initialize game state with market
        gameState.players = [player]
        gameState.encounterDeck = TwilightMarchesCards.createEncounterDeck()
        gameState.encounterDeck.shuffle()
        gameState.marketCards = TwilightMarchesCards.createMarketCards()
        gameState.turnNumber = saveData.turnNumber
        gameState.encountersDefeated = saveData.encountersDefeated

        // Restore world state from save
        gameState.worldState = saveData.worldState

        // MARK: - Engine-First: Connect engine to loaded state
        engine.connectToLegacy(worldState: gameState.worldState, player: player)

        selectedSaveSlot = slot
        showingWorldMap = true
        showingSaveSlots = false
    }

    // MARK: - Continue Game

    func handleContinueGame() {
        let saves = saveManager.allSaves

        if saves.count == 1 {
            // Only one save - load it directly
            loadGame(from: saves[0].slotNumber)
        } else {
            // Multiple saves - show selection screen
            showingLoadSlots = true
        }
    }

    // MARK: - Load Slot Selection View

    var loadSlotSelectionView: some View {
        VStack(spacing: 20) {
            // Header
            HStack {
                Button(action: { showingLoadSlots = false }) {
                    HStack(spacing: 4) {
                        Image(systemName: "chevron.left")
                        Text(L10n.uiBack.localized)
                    }
                    .foregroundColor(.blue)
                }
                Spacer()
                Text(L10n.uiContinueGame.localized)
                    .font(.title2)
                    .fontWeight(.bold)
            }
            .padding()

            // Load slots (only show existing saves)
            ScrollView {
                VStack(spacing: 16) {
                    ForEach(saveManager.allSaves) { save in
                        LoadSlotCard(
                            saveData: save,
                            onLoad: { loadGame(from: save.slotNumber) }
                        )
                    }
                }
                .padding()
            }
        }
        .navigationBarHidden(true)
    }
}

struct StatDisplay: View {
    let icon: String
    let label: String
    let value: Int
    let color: Color

    var body: some View {
        VStack(spacing: 4) {
            Image(systemName: icon)
                .font(.title2)
                .foregroundColor(color)
            Text("\(value)")
                .font(.title3)
                .fontWeight(.bold)
            Text(label)
                .font(.caption)
                .foregroundColor(.secondary)
        }
    }
}

struct SaveSlotCard: View {
    let slotNumber: Int
    let saveData: GameSave?
    let onNewGame: () -> Void
    let onLoadGame: () -> Void
    let onDelete: () -> Void

    @State private var showingDeleteAlert = false
    @State private var showingOverwriteAlert = false

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text(L10n.uiSlotNumber.localized(with: slotNumber))
                    .font(.headline)
                Spacer()
                if saveData != nil {
                    Button(action: { showingDeleteAlert = true }) {
                        Image(systemName: "trash")
                            .foregroundColor(.red)
                    }
                }
            }

            if let save = saveData {
                // Existing save
                VStack(alignment: .leading, spacing: 8) {
                    Text(save.characterName)
                        .font(.title3)
                        .fontWeight(.bold)

                    HStack(spacing: 16) {
                        Label("\(save.health)/\(save.maxHealth)", systemImage: "heart.fill")
                            .foregroundColor(.red)
                        Label("\(save.faith)", systemImage: "sparkles")
                            .foregroundColor(.yellow)
                        Label("\(save.balance)", systemImage: "scale.3d")
                            .foregroundColor(.purple)
                    }
                    .font(.subheadline)

                    HStack {
                        Text(L10n.uiTurnNumber.localized(with: save.turnNumber))
                        Text("•")
                        Text(L10n.uiVictories.localized(with: save.encountersDefeated))
                    }
                    .font(.caption)
                    .foregroundColor(.secondary)

                    Text(save.formattedDate)
                        .font(.caption2)
                        .foregroundColor(.secondary)

                    Divider()

                    HStack(spacing: 12) {
                        Button(action: onLoadGame) {
                            Text(L10n.uiLoad.localized)
                                .font(.subheadline)
                                .fontWeight(.semibold)
                                .foregroundColor(.white)
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, 10)
                                .background(Color.blue)
                                .cornerRadius(8)
                        }

                        Button(action: { showingOverwriteAlert = true }) {
                            Text(L10n.uiNewGame.localized)
                                .font(.subheadline)
                                .fontWeight(.semibold)
                                .foregroundColor(.blue)
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, 10)
                                .background(Color.blue.opacity(0.1))
                                .cornerRadius(8)
                        }
                    }
                }
            } else {
                // Empty slot
                VStack(spacing: 12) {
                    Image(systemName: "square.dashed")
                        .font(.largeTitle)
                        .foregroundColor(.secondary)

                    Text(L10n.uiEmptySlot.localized)
                        .font(.subheadline)
                        .foregroundColor(.secondary)

                    Button(action: onNewGame) {
                        Text(L10n.uiStartNewGame.localized)
                            .font(.subheadline)
                            .fontWeight(.semibold)
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 10)
                            .background(Color.green)
                            .cornerRadius(8)
                    }
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 20)
            }
        }
        .padding()
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(12)
        .alert(L10n.uiDeleteSave.localized, isPresented: $showingDeleteAlert) {
            Button(L10n.uiCancel.localized, role: .cancel) { }
            Button(L10n.uiDelete.localized, role: .destructive) {
                onDelete()
            }
        } message: {
            Text(L10n.uiDeleteConfirm.localized)
        }
        .alert(L10n.uiOverwriteSave.localized, isPresented: $showingOverwriteAlert) {
            Button(L10n.uiCancel.localized, role: .cancel) { }
            Button(L10n.uiOverwrite.localized, role: .destructive) {
                onNewGame()
            }
        } message: {
            Text(L10n.uiOverwriteConfirm.localized)
        }
    }
}

// MARK: - Load Slot Card (for Continue flow)

struct LoadSlotCard: View {
    let saveData: GameSave
    let onLoad: () -> Void

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Save info
            HStack {
                Text(L10n.uiSlotNumber.localized(with: saveData.slotNumber))
                    .font(.headline)
                Spacer()
                Image(systemName: "chevron.right")
                    .foregroundColor(.blue)
            }

            VStack(alignment: .leading, spacing: 8) {
                Text(saveData.characterName)
                    .font(.title3)
                    .fontWeight(.bold)

                HStack(spacing: 16) {
                    Label("\(saveData.health)/\(saveData.maxHealth)", systemImage: "heart.fill")
                        .foregroundColor(.red)
                    Label("\(saveData.faith)", systemImage: "sparkles")
                        .foregroundColor(.yellow)
                    Label("\(saveData.balance)", systemImage: "scale.3d")
                        .foregroundColor(.purple)
                }
                .font(.subheadline)

                HStack {
                    Text(L10n.uiTurnNumber.localized(with: saveData.turnNumber))
                    Text("•")
                    Text(L10n.uiVictories.localized(with: saveData.encountersDefeated))
                }
                .font(.caption)
                .foregroundColor(.secondary)

                Text(saveData.formattedDate)
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(12)
        .onTapGesture {
            onLoad()
        }
    }
}

#Preview {
    ContentView()
}


// ==========================================
// FILE: Package.swift
// ==========================================

// swift-tools-version:5.9
import PackageDescription

let package = Package(
    name: "CardSampleGame",
    platforms: [
        .iOS(.v16),
        .macOS(.v13)
    ],
    products: [
        .library(
            name: "CardSampleGame",
            targets: ["CardSampleGame"])
    ],
    targets: [
        .target(
            name: "CardSampleGame",
            path: ".",
            exclude: ["CardSampleGameTests", "CardSampleGame.xcodeproj", "CardSampleGame.entitlements"],
            sources: [
                "CardGameApp.swift",
                "ContentView.swift",
                "Models",
                "Views",
                "Data",
                "Helpers"
            ]
        ),
        .testTarget(
            name: "CardSampleGameTests",
            dependencies: ["CardSampleGame"],
            path: "CardSampleGameTests"
        )
    ]
)


// ==========================================
// FILE: ViewModels/GameViewModel.swift
// ==========================================

import Foundation
import Combine
import SwiftUI

// MARK: - Game View Model
// Central ViewModel that bridges UI with TwilightGameEngine
// All UI actions should go through this ViewModel

/// Main ViewModel for game UI
/// Replaces direct WorldState/Player mutations with Engine-based actions
@MainActor
final class GameViewModel: ObservableObject {
    // MARK: - Published State (for UI binding)

    /// Game engine (source of truth)
    @Published private(set) var engine: TwilightGameEngine

    /// Legacy models (for backward compatibility during migration)
    @Published var gameState: GameState
    @Published var player: Player
    @Published var worldState: WorldState

    // MARK: - UI State

    @Published var isLoading: Bool = false
    @Published var errorMessage: String?
    @Published var showError: Bool = false

    @Published var currentEvent: GameEvent?
    @Published var showEventSheet: Bool = false

    @Published var showCombatView: Bool = false

    // MARK: - Last Action Result

    @Published private(set) var lastResult: ActionResult?

    // MARK: - Cancellables

    private var cancellables = Set<AnyCancellable>()

    // MARK: - Initialization

    init(gameState: GameState) {
        self.gameState = gameState
        self.player = gameState.players.first ?? Player(name: "Default")
        self.worldState = gameState.worldState
        self.engine = TwilightGameEngine()

        // Connect engine to legacy models
        engine.connectToLegacy(worldState: worldState, player: player)

        setupBindings()
    }

    /// Convenience initializer for new game
    convenience init(playerName: String = "Герой") {
        let player = Player(name: playerName)
        let gameState = GameState(players: [player])
        self.init(gameState: gameState)
    }

    // MARK: - Setup

    private func setupBindings() {
        // Sync engine state to legacy models
        engine.$currentDay
            .sink { [weak self] day in
                self?.worldState.daysPassed = day
            }
            .store(in: &cancellables)

        engine.$worldTension
            .sink { [weak self] tension in
                self?.worldState.worldTension = tension
            }
            .store(in: &cancellables)

        engine.$currentRegionId
            .sink { [weak self] regionId in
                self?.worldState.currentRegionId = regionId
            }
            .store(in: &cancellables)

        // Note: gameState.isGameOver is computed from isVictory || isDefeat
        // Engine game result already handles setting these via $gameResult subscriber below

        engine.$gameResult
            .compactMap { $0 }
            .sink { [weak self] result in
                switch result {
                case .victory:
                    self?.gameState.isVictory = true
                case .defeat:
                    self?.gameState.isDefeat = true
                case .abandoned:
                    break
                }
            }
            .store(in: &cancellables)
    }

    // MARK: - Game Actions (Through Engine)

    /// Travel to a region
    func travel(to regionId: UUID) {
        let result = engine.performAction(.travel(toRegionId: regionId))
        handleResult(result)

        // Log travel in legacy
        if result.success {
            let fromRegion = worldState.getCurrentRegion()?.name ?? "Неизвестно"
            let toRegion = worldState.getRegion(byId: regionId)?.name ?? "Неизвестно"
            let cost = worldState.calculateTravelCost(to: regionId)
            worldState.logTravel(from: fromRegion, to: toRegion, days: cost)
        }
    }

    /// Rest in current region
    func rest() {
        let result = engine.performAction(.rest)
        handleResult(result)

        // Log in legacy
        if result.success, let region = worldState.getCurrentRegion() {
            worldState.logEvent(
                regionName: region.name,
                eventTitle: "Отдых",
                choiceMade: "Решил отдохнуть",
                outcome: "Здоровье восстановлено",
                type: .exploration
            )
        }
    }

    /// Explore current region
    func explore() {
        let result = engine.performAction(.explore)
        handleResult(result)

        // Show event if triggered
        if let eventId = result.currentEvent {
            showEventForId(eventId)
        }
    }

    /// Trade at market
    func trade() {
        let result = engine.performAction(.trade)
        handleResult(result)
        // Market UI handled separately
    }

    /// Strengthen anchor in current region
    func strengthenAnchor() {
        let result = engine.performAction(.strengthenAnchor)
        handleResult(result)

        // Log in legacy
        if result.success, let region = worldState.getCurrentRegion() {
            worldState.logEvent(
                regionName: region.name,
                eventTitle: "Укрепление якоря",
                choiceMade: "Потрачено веры",
                outcome: "Якорь укреплён",
                type: .worldChange
            )
        }
    }

    /// Choose an option in current event
    func chooseEventOption(_ choiceIndex: Int) {
        guard let event = currentEvent else { return }

        let result = engine.performAction(.chooseEventOption(eventId: event.id, choiceIndex: choiceIndex))
        handleResult(result)

        // Apply consequences to legacy
        if result.success {
            let choice = event.choices[choiceIndex]
            worldState.applyConsequences(choice.consequences, to: player, in: worldState.currentRegionId ?? UUID())

            // Log event
            if let region = worldState.getCurrentRegion() {
                worldState.logEvent(
                    regionName: region.name,
                    eventTitle: event.title,
                    choiceMade: choice.text,
                    outcome: choice.consequences.message ?? "Выбор сделан",
                    type: .exploration
                )
            }

            // Mark oneTime event as completed
            if event.oneTime {
                worldState.markEventCompleted(event.id)
            }
        }

        // Close event sheet
        currentEvent = nil
        showEventSheet = false

        // Check for triggered combat
        if result.combatStarted {
            showCombatView = true
        }
    }

    /// Skip turn (just advance time)
    func skipTurn() {
        let result = engine.performAction(.skipTurn)
        handleResult(result)
    }

    // MARK: - Legacy Action Bridge

    /// Perform legacy action through Engine
    /// Used during migration to gradually replace direct mutations
    func performLegacyAction(_ action: RegionAction, for region: Region) {
        switch action {
        case .travel:
            travel(to: region.id)

        case .rest:
            rest()

        case .trade:
            trade()

        case .strengthenAnchor:
            strengthenAnchor()

        case .explore:
            explore()
        }
    }

    // MARK: - Event Handling

    private func showEventForId(_ eventId: UUID) {
        // Find event in worldState
        guard let region = worldState.getCurrentRegion() else { return }

        let events = worldState.getAvailableEvents(for: region)
        if let event = events.first(where: { $0.id == eventId }) {
            currentEvent = event
            showEventSheet = true
        }
    }

    /// Trigger exploration and show event
    func triggerExploration() {
        guard let region = worldState.getCurrentRegion() else { return }

        // Get available events
        let events = worldState.getAvailableEvents(for: region)

        // Weighted selection from available events
        if let event = selectWeightedEvent(from: events) {
            currentEvent = event
            showEventSheet = true
        }
    }

    /// Select event using weighted random selection
    private func selectWeightedEvent(from events: [GameEvent]) -> GameEvent? {
        guard !events.isEmpty else { return nil }

        let totalWeight = events.reduce(0) { $0 + $1.weight }
        guard totalWeight > 0 else { return events.first }

        let roll = WorldRNG.shared.nextInt(in: 0..<totalWeight)
        var cumulative = 0

        for event in events {
            cumulative += event.weight
            if roll < cumulative {
                return event
            }
        }

        return events.first
    }

    // MARK: - Result Handling

    private func handleResult(_ result: ActionResult) {
        lastResult = result

        if !result.success, let error = result.error {
            errorMessage = error.localizedDescription
            showError = true
        }

        // Sync legacy models after engine action
        objectWillChange.send()
    }

    // MARK: - Validation Helpers

    /// Check if action is available
    func canPerformAction(_ action: TwilightGameAction) -> Bool {
        // Quick validation without executing
        switch action {
        case .travel(let toRegionId):
            guard let currentId = worldState.currentRegionId,
                  let currentRegion = worldState.getRegion(byId: currentId) else {
                return false
            }
            return currentRegion.neighborIds.contains(toRegionId)

        case .rest:
            guard let region = worldState.getCurrentRegion() else { return false }
            return region.canRest

        case .trade:
            guard let region = worldState.getCurrentRegion() else { return false }
            return region.canTrade

        case .strengthenAnchor:
            guard let region = worldState.getCurrentRegion(),
                  region.anchor != nil else { return false }
            return player.faith >= 10

        case .explore:
            return !engine.isInCombat

        default:
            return true
        }
    }

    // MARK: - State Queries

    var currentRegion: Region? {
        worldState.getCurrentRegion()
    }

    var currentDay: Int {
        engine.currentDay
    }

    var tension: Int {
        engine.worldTension
    }

    var isGameOver: Bool {
        engine.isGameOver
    }
}

// MARK: - Region Action

/// Actions available in a region (for ViewModel bridge)
/// Mirrors WorldMapView.RegionAction for migration compatibility
enum RegionAction {
    case travel
    case rest
    case trade
    case strengthenAnchor
    case explore

    /// Convert to TwilightGameAction
    func toEngineAction(for region: Region) -> TwilightGameAction {
        switch self {
        case .travel:
            return .travel(toRegionId: region.id)
        case .rest:
            return .rest
        case .trade:
            return .trade
        case .strengthenAnchor:
            return .strengthenAnchor
        case .explore:
            return .explore
        }
    }
}


// ==========================================
// FILE: Models/Card.swift
// ==========================================

import Foundation

struct Card: Identifiable, Codable, Hashable {
    let id: UUID
    let name: String
    let type: CardType
    let rarity: CardRarity
    let description: String
    let imageURL: String?

    // Stats
    var power: Int?
    var defense: Int?
    var health: Int?
    var cost: Int?

    // Abilities and traits
    var abilities: [CardAbility]
    var traits: [String]

    // Card-specific properties
    var damageType: DamageType?
    var range: Int?

    // Twilight Marches mechanics
    var balance: CardBalance?  // Light/Dark alignment
    var realm: Realm?  // Yav/Nav/Prav
    var curseType: CurseType?  // For curse cards
    var expansionSet: String?  // For DLC/expansions tracking
    var role: CardRole?  // Functional role in campaign (Sustain/Control/Power/Utility)
    var regionRequirement: String?  // Required region flag to purchase (for story pool)
    var faithCost: Int  // Cost in faith to purchase from market

    init(
        id: UUID = UUID(),
        name: String,
        type: CardType,
        rarity: CardRarity = .common,
        description: String,
        imageURL: String? = nil,
        power: Int? = nil,
        defense: Int? = nil,
        health: Int? = nil,
        cost: Int? = nil,
        abilities: [CardAbility] = [],
        traits: [String] = [],
        damageType: DamageType? = nil,
        range: Int? = nil,
        balance: CardBalance? = nil,
        realm: Realm? = nil,
        curseType: CurseType? = nil,
        expansionSet: String? = nil,
        role: CardRole? = nil,
        regionRequirement: String? = nil,
        faithCost: Int = 3
    ) {
        self.id = id
        self.name = name
        self.type = type
        self.rarity = rarity
        self.description = description
        self.imageURL = imageURL
        self.power = power
        self.defense = defense
        self.health = health
        self.cost = cost
        self.abilities = abilities
        self.traits = traits
        self.damageType = damageType
        self.range = range
        self.balance = balance
        self.realm = realm
        self.curseType = curseType
        self.expansionSet = expansionSet
        self.role = role
        self.regionRequirement = regionRequirement
        self.faithCost = faithCost
    }

    /// Calculate adjusted cost based on player's Light/Dark balance
    /// See EXPLORATION_CORE_DESIGN.md, section 23.4
    func adjustedFaithCost(playerBalance: Int) -> Int {
        guard let cardBalance = balance else { return faithCost }

        switch cardBalance {
        case .light:
            // Light cards cheaper when player is aligned to light (>50)
            let discount = max(0, (playerBalance - 50) / 20)  // 0 to +2 discount
            return max(1, faithCost - discount)

        case .dark:
            // Dark cards cheaper when player is aligned to dark (<50)
            let discount = max(0, (50 - playerBalance) / 20)  // 0 to +2 discount
            return max(1, faithCost - discount)

        case .neutral:
            return faithCost  // Neutral always base cost
        }
    }
}

struct CardAbility: Identifiable, Codable, Hashable {
    let id: UUID
    let name: String
    let description: String
    let effect: AbilityEffect

    init(
        id: UUID = UUID(),
        name: String,
        description: String,
        effect: AbilityEffect
    ) {
        self.id = id
        self.name = name
        self.description = description
        self.effect = effect
    }
}

enum AbilityEffect: Codable, Hashable {
    case damage(amount: Int, type: DamageType)
    case heal(amount: Int)
    case drawCards(count: Int)
    case addDice(count: Int)
    case reroll
    case explore
    case custom(String)

    // Twilight Marches mechanics
    case applyCurse(type: CurseType, duration: Int)  // Apply curse
    case removeCurse(type: CurseType?)  // Remove specific or any curse
    case summonSpirit(power: Int, realm: Realm)  // Summon spirit guardian
    case shiftBalance(towards: CardBalance, amount: Int)  // Shift light/dark balance
    case travelRealm(to: Realm)  // Travel between Yav/Nav/Prav
    case gainFaith(amount: Int)  // Gain faith resource
    case sacrifice(cost: Int, benefit: String)  // Sacrifice health/cards for benefit
}


// ==========================================
// FILE: Models/CardType.swift
// ==========================================

import Foundation

enum CardType: String, Codable, Hashable {
    case character
    case weapon
    case spell
    case armor
    case item
    case ally
    case blessing
    case monster
    case location
    case scenario

    // Twilight Marches specific card types
    case curse      // Проклятия - negative effects
    case spirit     // Духи - summonable allies/enemies
    case artifact   // Артефакты - powerful ancient items
    case ritual     // Ритуалы - special spells requiring preparation

    // Deck-building game card types
    case resource   // Ресурсы - used to purchase cards from market
    case attack     // Атака - deal damage to enemies
    case defense    // Защита - block damage or protect
    case special    // Особые - unique effects and abilities
}

enum CardRarity: String, Codable, Hashable {
    case common
    case uncommon
    case rare
    case epic
    case legendary
}

enum DamageType: String, Codable, Hashable {
    case physical
    case fire
    case cold
    case electricity
    case acid
    case mental
    case poison
    case arcane
}

// Twilight Marches: Balance system (Light/Dark)
enum CardBalance: String, Codable, Hashable {
    case light      // Cards from Prav, protective/healing
    case neutral    // Balanced cards
    case dark       // Cards from Nav, aggressive/cursing
}

// Twilight Marches: Three Realms system
enum Realm: String, Codable, Hashable {
    case yav        // Явь - World of the Living (reality, settlements, heroes)
    case nav        // Навь - World of the Dead (spirits, undead, curses)
    case prav       // Правь - World of the Gods (higher powers, blessings, ancient magic)
}

// Twilight Marches: Functional Card Roles (Campaign system)
// See EXPLORATION_CORE_DESIGN.md, section 22
enum CardRole: String, Codable, Hashable {
    case sustain    // Поддержка - healing, curse removal, recovery
    case control    // Контроль - region stabilization, anchor protection, tension reduction
    case power      // Сила - fast progress, elite enemies, rare rewards (always with a price)
    case utility    // Гибкость - card draw, deck manipulation, preparation

    /// Default balance alignment for this role
    var defaultBalance: CardBalance {
        switch self {
        case .sustain: return .light
        case .control: return .light
        case .power: return .dark
        case .utility: return .neutral
        }
    }

    /// Typical rarity for this role
    var typicalRarity: [CardRarity] {
        switch self {
        case .sustain: return [.common, .uncommon]
        case .control: return [.rare, .epic]
        case .power: return [.uncommon, .rare]
        case .utility: return [.common, .uncommon]
        }
    }
}

// Twilight Marches: Curse system (PLAYABLE curses)
// See EXPLORATION_CORE_DESIGN.md, section 26
enum CurseType: String, Codable, Hashable {
    case weakness       // Слабость: -1 к урону до конца боя (2 веры снять)
    case fear           // Страх: -1 к защите до конца боя (2 веры)
    case exhaustion     // Истощение: -1 действие в этом ходу (3 веры)
    case greed          // Жадность: +2 веры, но WorldTension +1 (4 веры)
    case shadowOfNav    // Тень Нави: +3 урона, но -2 HP (5 веры)
    case bloodCurse     // Проклятие крови: При убийстве +2 HP, баланс к тьме (6 веры)
    case sealOfNav      // Печать Нави: Нельзя использовать Sustain карты (8 веры)

    /// Cost in faith to remove this curse
    var removalCost: Int {
        switch self {
        case .weakness: return 2
        case .fear: return 2
        case .exhaustion: return 3
        case .greed: return 4
        case .shadowOfNav: return 5
        case .bloodCurse: return 6
        case .sealOfNav: return 8
        }
    }

    /// Localized name
    var displayName: String {
        switch self {
        case .weakness: return "Слабость"
        case .fear: return "Страх"
        case .exhaustion: return "Истощение"
        case .greed: return "Жадность"
        case .shadowOfNav: return "Тень Нави"
        case .bloodCurse: return "Проклятие крови"
        case .sealOfNav: return "Печать Нави"
        }
    }
}

// Expansion tracking
enum ExpansionSet: String, Codable {
    case baseSet        // Базовый набор
    case borderlands    // Порубежье (first expansion)
    case deepForest     // Дремучий Лес
    case ancientRuins   // Древние Руины
    case frozenNorth    // Замерзший Север
}


// ==========================================
// FILE: Models/ExplorationModels.swift
// ==========================================

import Foundation

// MARK: - Region State

enum RegionState: String, Codable, Hashable {
    case stable         // Стабильная Явь - безопасно
    case borderland     // Пограничье - повышенный риск
    case breach         // Прорыв Нави - опасно

    var displayName: String {
        switch self {
        case .stable: return "Стабильная"
        case .borderland: return "Пограничье"
        case .breach: return "Прорыв Нави"
        }
    }

    var emoji: String {
        switch self {
        case .stable: return "🟢"
        case .borderland: return "🟡"
        case .breach: return "🔴"
        }
    }

    // MARK: - Combat Modifiers

    /// Бонус к силе врага в этом регионе
    var enemyPowerBonus: Int {
        switch self {
        case .stable: return 0
        case .borderland: return 1
        case .breach: return 2
        }
    }

    /// Бонус к здоровью врага в этом регионе
    var enemyHealthBonus: Int {
        switch self {
        case .stable: return 0
        case .borderland: return 2
        case .breach: return 5
        }
    }

    /// Бонус к защите врага в этом регионе
    var enemyDefenseBonus: Int {
        switch self {
        case .stable: return 0
        case .borderland: return 1
        case .breach: return 2
        }
    }
}

// MARK: - Combat Context

/// Контекст боя с учётом региона и проклятий
struct CombatContext {
    let regionState: RegionState
    let playerCurses: [CurseType]

    /// Рассчитать эффективную силу врага
    func adjustedEnemyPower(_ basePower: Int) -> Int {
        return basePower + regionState.enemyPowerBonus
    }

    /// Рассчитать эффективное здоровье врага
    func adjustedEnemyHealth(_ baseHealth: Int) -> Int {
        return baseHealth + regionState.enemyHealthBonus
    }

    /// Рассчитать эффективную защиту врага
    func adjustedEnemyDefense(_ baseDefense: Int) -> Int {
        return baseDefense + regionState.enemyDefenseBonus
    }

    /// Описание модификаторов региона для UI
    var regionModifierDescription: String? {
        switch regionState {
        case .stable:
            return nil
        case .borderland:
            return "Пограничье: враги +1 сила, +1 защита"
        case .breach:
            return "Прорыв Нави: враги +2 сила, +2 защита"
        }
    }
}

// MARK: - Region Type

enum RegionType: String, Codable, Hashable {
    case forest         // Лес
    case swamp          // Болото
    case mountain       // Горы
    case settlement     // Поселение
    case water          // Водная зона
    case wasteland      // Пустошь
    case sacred         // Священное место

    var displayName: String {
        switch self {
        case .forest: return "Лес"
        case .swamp: return "Болото"
        case .mountain: return "Горы"
        case .settlement: return "Поселение"
        case .water: return "Водная зона"
        case .wasteland: return "Пустошь"
        case .sacred: return "Священное место"
        }
    }

    var icon: String {
        switch self {
        case .forest: return "tree.fill"
        case .swamp: return "cloud.fog.fill"
        case .mountain: return "mountain.2.fill"
        case .settlement: return "house.fill"
        case .water: return "drop.fill"
        case .wasteland: return "wind"
        case .sacred: return "star.fill"
        }
    }
}

// MARK: - Anchor Type

enum AnchorType: String, Codable {
    case shrine         // Капище
    case barrow         // Курган
    case sacredTree     // Священный дуб
    case stoneIdol      // Каменная баба
    case spring         // Родник
    case chapel         // Часовня
    case temple         // Храм
    case cross          // Обетный крест

    var displayName: String {
        switch self {
        case .shrine: return "Капище"
        case .barrow: return "Курган"
        case .sacredTree: return "Священный Дуб"
        case .stoneIdol: return "Каменная Баба"
        case .spring: return "Родник"
        case .chapel: return "Часовня"
        case .temple: return "Храм"
        case .cross: return "Обетный Крест"
        }
    }

    var icon: String {
        switch self {
        case .shrine: return "flame.fill"
        case .barrow: return "mountain.2"
        case .sacredTree: return "leaf.fill"
        case .stoneIdol: return "figure.stand"
        case .spring: return "drop.circle.fill"
        case .chapel: return "building.columns.fill"
        case .temple: return "building.2.fill"
        case .cross: return "cross.fill"
        }
    }
}

// MARK: - Anchor

struct Anchor: Identifiable, Codable {
    let id: UUID
    let name: String
    let type: AnchorType
    var integrity: Int          // 0-100%
    var influence: CardBalance  // .light, .neutral, .dark
    let power: Int              // Сила влияния (1-10)

    init(
        id: UUID = UUID(),
        name: String,
        type: AnchorType,
        integrity: Int = 100,
        influence: CardBalance = .light,
        power: Int = 5
    ) {
        self.id = id
        self.name = name
        self.type = type
        self.integrity = max(0, min(100, integrity))
        self.influence = influence
        self.power = power
    }

    // Определяет состояние региона на основе целостности якоря
    var determinedRegionState: RegionState {
        switch integrity {
        case 70...100:
            return .stable
        case 30..<70:
            return .borderland
        default:
            return .breach
        }
    }

    // Проверка, осквернен ли якорь
    var isDefiled: Bool {
        return influence == .dark
    }
}

// MARK: - Region

/// Legacy Region model used for world state persistence and direct UI binding.
///
/// ⚠️ МИГРАЦИЯ (Audit v1.1 Issue #9):
/// - Для нового кода предпочтительнее использовать Engine модели:
///   - `RegionDefinition` - статические данные региона (из ContentProvider)
///   - `RegionRuntimeState` - изменяемое состояние (Engine/Runtime/WorldRuntimeState.swift)
///   - `EngineRegionState` - объединённое состояние для UI (TwilightGameEngine.swift)
/// - Эта модель сохраняется для: сериализации сейвов, legacy UI, unit-тестов
/// - После полной миграции UI на Engine эта модель станет internal для persistence
struct Region: Identifiable, Codable {
    let id: UUID
    let name: String
    let type: RegionType
    var state: RegionState
    var anchor: Anchor?
    var availableEvents: [String]   // ID событий
    var activeQuests: [String]      // ID активных квестов
    var reputation: Int             // -100 to 100
    var visited: Bool               // Был ли игрок здесь
    var neighborIds: [UUID]         // ID соседних регионов (путешествие = 1 день)

    init(
        id: UUID = UUID(),
        name: String,
        type: RegionType,
        state: RegionState = .stable,
        anchor: Anchor? = nil,
        availableEvents: [String] = [],
        activeQuests: [String] = [],
        reputation: Int = 0,
        visited: Bool = false,
        neighborIds: [UUID] = []
    ) {
        self.id = id
        self.name = name
        self.type = type
        self.state = state
        self.anchor = anchor
        self.availableEvents = availableEvents
        self.activeQuests = activeQuests
        self.reputation = max(-100, min(100, reputation))
        self.visited = visited
        self.neighborIds = neighborIds
    }

    /// Проверить, является ли регион соседним
    func isNeighbor(_ regionId: UUID) -> Bool {
        return neighborIds.contains(regionId)
    }

    // Обновить состояние региона на основе якоря
    mutating func updateStateFromAnchor() {
        if let anchor = anchor {
            self.state = anchor.determinedRegionState
        } else {
            // Без якоря регион всегда в Breach
            self.state = .breach
        }
    }

    // Можно ли торговать в регионе
    var canTrade: Bool {
        return state == .stable && type == .settlement && reputation >= 0
    }

    // Можно ли отдохнуть в регионе
    var canRest: Bool {
        return state == .stable && (type == .settlement || type == .sacred)
    }
}

// MARK: - Event Type

enum EventType: String, Codable, Hashable {
    case combat         // Бой
    case ritual         // Ритуал/Выбор
    case narrative      // Нарративное событие
    case exploration    // Исследование
    case worldShift     // Сдвиг мира

    var displayName: String {
        switch self {
        case .combat: return "Бой"
        case .ritual: return "Ритуал"
        case .narrative: return "Встреча"
        case .exploration: return "Исследование"
        case .worldShift: return "Сдвиг Мира"
        }
    }

    var icon: String {
        switch self {
        case .combat: return "bolt.fill"
        case .ritual: return "sparkles"
        case .narrative: return "text.bubble.fill"
        case .exploration: return "magnifyingglass"
        case .worldShift: return "globe"
        }
    }
}

// MARK: - Event Choice

struct EventChoice: Identifiable, Codable, Hashable {
    let id: String
    let text: String
    let requirements: EventRequirements?
    let consequences: EventConsequences

    init(
        id: String = UUID().uuidString,
        text: String,
        requirements: EventRequirements? = nil,
        consequences: EventConsequences
    ) {
        self.id = id
        self.text = text
        self.requirements = requirements
        self.consequences = consequences
    }
}

// MARK: - Event Requirements

struct EventRequirements: Codable, Hashable {
    var minimumFaith: Int?
    var minimumHealth: Int?
    var requiredBalance: CardBalance?    // Требуется определенный баланс
    var requiredFlags: [String]?         // Требуются флаги мира

    func canMeet(with player: Player, worldState: WorldState) -> Bool {
        if let minFaith = minimumFaith, player.faith < minFaith {
            return false
        }
        if let minHealth = minimumHealth, player.health < minHealth {
            return false
        }
        if let reqBalance = requiredBalance {
            // Проверка баланса игрока (0-100 scale)
            let playerBalanceEnum: CardBalance
            if player.balance >= 70 {
                playerBalanceEnum = .light
            } else if player.balance <= 30 {
                playerBalanceEnum = .dark
            } else {
                playerBalanceEnum = .neutral
            }

            if playerBalanceEnum != reqBalance {
                return false
            }
        }
        if let reqFlags = requiredFlags {
            for flag in reqFlags {
                if worldState.worldFlags[flag] != true {
                    return false
                }
            }
        }
        return true
    }
}

// MARK: - Event Consequences

struct EventConsequences: Codable, Hashable {
    var faithChange: Int?
    var healthChange: Int?
    var balanceChange: Int?         // Изменение Light/Dark (дельта: +N сдвиг к Свету, -N к Тьме)
    var tensionChange: Int?
    var reputationChange: Int?
    var addCards: [String]?         // ID карт для добавления
    var addCurse: String?           // ID проклятия
    var giveArtifact: String?       // ID артефакта
    var setFlags: [String: Bool]?   // Установить флаги
    var anchorIntegrityChange: Int? // Изменение целостности якоря
    var message: String?            // Сообщение игроку
}

// MARK: - Game Event

struct GameEvent: Identifiable, Codable, Hashable {
    let id: UUID
    let eventType: EventType
    let title: String
    let description: String
    let regionTypes: [RegionType]       // В каких типах регионов может произойти
    let regionStates: [RegionState]     // В каких состояниях может произойти
    let choices: [EventChoice]
    let questLinks: [String]            // Связь с квестами
    var oneTime: Bool                   // Происходит только один раз
    var completed: Bool                 // Уже произошло
    let monsterCard: Card?              // Карта монстра для боевых событий

    // Новые поля согласно документации
    let instant: Bool                   // true = не тратит день (короткие нарративные события)
    let weight: Int                     // Вес для взвешенного выбора (по умолчанию 1)
    let minTension: Int?                // Минимальный уровень напряжения (0-100)
    let maxTension: Int?                // Максимальный уровень напряжения (0-100)
    let requiredFlags: [String]?        // Флаги, которые должны быть установлены
    let forbiddenFlags: [String]?       // Флаги, которые НЕ должны быть установлены

    init(
        id: UUID = UUID(),
        eventType: EventType,
        title: String,
        description: String,
        regionTypes: [RegionType] = [],
        regionStates: [RegionState] = [.stable, .borderland, .breach],
        choices: [EventChoice],
        questLinks: [String] = [],
        oneTime: Bool = false,
        completed: Bool = false,
        monsterCard: Card? = nil,
        instant: Bool = false,
        weight: Int = 1,
        minTension: Int? = nil,
        maxTension: Int? = nil,
        requiredFlags: [String]? = nil,
        forbiddenFlags: [String]? = nil
    ) {
        self.id = id
        self.eventType = eventType
        self.title = title
        self.description = description
        self.regionTypes = regionTypes
        self.regionStates = regionStates
        self.choices = choices
        self.questLinks = questLinks
        self.oneTime = oneTime
        self.completed = completed
        self.monsterCard = monsterCard
        self.instant = instant
        self.weight = max(1, weight)  // Минимум 1
        self.minTension = minTension
        self.maxTension = maxTension
        self.requiredFlags = requiredFlags
        self.forbiddenFlags = forbiddenFlags
    }

    // Проверка, может ли событие произойти в регионе
    func canOccur(in region: Region) -> Bool {
        if completed && oneTime {
            return false
        }

        if !regionTypes.isEmpty && !regionTypes.contains(region.type) {
            return false
        }

        if !regionStates.contains(region.state) {
            return false
        }

        return true
    }

    /// Проверка с учётом напряжения и флагов мира
    func canOccur(in region: Region, worldTension: Int, worldFlags: [String: Bool]) -> Bool {
        // Базовые проверки
        guard canOccur(in: region) else { return false }

        // Проверка напряжения
        if let min = minTension, worldTension < min {
            return false
        }
        if let max = maxTension, worldTension > max {
            return false
        }

        // Проверка обязательных флагов
        if let required = requiredFlags {
            for flag in required {
                if worldFlags[flag] != true {
                    return false
                }
            }
        }

        // Проверка запрещённых флагов
        if let forbidden = forbiddenFlags {
            for flag in forbidden {
                if worldFlags[flag] == true {
                    return false
                }
            }
        }

        return true
    }
}

// MARK: - Quest Type

enum QuestType: String, Codable {
    case main       // Основной квест
    case side       // Побочный квест
}

// MARK: - Quest Objective

struct QuestObjective: Identifiable, Codable {
    let id: UUID
    let description: String
    var completed: Bool
    var requiredFlags: [String]?  // Флаги, необходимые для выполнения цели

    init(id: UUID = UUID(), description: String, completed: Bool = false, requiredFlags: [String]? = nil) {
        self.id = id
        self.description = description
        self.completed = completed
        self.requiredFlags = requiredFlags
    }
}

// MARK: - Quest Rewards

struct QuestRewards: Codable {
    var faith: Int?
    var cards: [String]?
    var artifact: String?
    var experience: Int?
}

// MARK: - Quest

/// Квест в игре
/// Для side-квестов используйте theme для определения нарративной темы
/// См. EXPLORATION_CORE_DESIGN.md, раздел 30 (Side-квесты как "зеркала мира")
struct Quest: Identifiable, Codable {
    let id: UUID
    let title: String
    let description: String
    let questType: QuestType
    var stage: Int                      // Текущая стадия квеста (0 = не начат)
    var objectives: [QuestObjective]
    let rewards: QuestRewards
    var completed: Bool

    // Narrative System properties (see EXPLORATION_CORE_DESIGN.md, section 30)
    var theme: SideQuestTheme?          // Тема квеста (для side-квестов): consequence/warning/temptation
    var mirrorFlag: String?             // Какой выбор игрока этот квест "отражает"

    init(
        id: UUID = UUID(),
        title: String,
        description: String,
        questType: QuestType,
        stage: Int = 0,
        objectives: [QuestObjective],
        rewards: QuestRewards,
        completed: Bool = false,
        theme: SideQuestTheme? = nil,
        mirrorFlag: String? = nil
    ) {
        self.id = id
        self.title = title
        self.description = description
        self.questType = questType
        self.stage = stage
        self.objectives = objectives
        self.rewards = rewards
        self.completed = completed
        self.theme = theme
        self.mirrorFlag = mirrorFlag
    }

    // Проверка, все ли цели выполнены
    var allObjectivesCompleted: Bool {
        return objectives.allSatisfy { $0.completed }
    }

    /// Проверяет, является ли квест "зеркалом" данного флага
    func mirrors(flag: String) -> Bool {
        return mirrorFlag == flag
    }
}

// MARK: - Deck Path (for Ending calculation)

/// Доминирующий путь колоды игрока
/// См. EXPLORATION_CORE_DESIGN.md, раздел 32.5
enum DeckPath: String, Codable {
    case light      // Преобладают Light-карты (>60%)
    case dark       // Преобладают Dark-карты (>60%)
    case balance    // Нет явного преобладания
}

// MARK: - Ending Profile

/// Профиль финала кампании
/// См. EXPLORATION_CORE_DESIGN.md, раздел 32.4
struct EndingProfile: Identifiable, Codable {
    let id: String
    let title: String
    let conditions: EndingConditions
    let summary: String
    let epilogue: EndingEpilogue
    let unlocksForNextRun: [String]?

    init(
        id: String,
        title: String,
        conditions: EndingConditions,
        summary: String,
        epilogue: EndingEpilogue,
        unlocksForNextRun: [String]? = nil
    ) {
        self.id = id
        self.title = title
        self.conditions = conditions
        self.summary = summary
        self.epilogue = epilogue
        self.unlocksForNextRun = unlocksForNextRun
    }
}

/// Условия для получения финала
/// См. EXPLORATION_CORE_DESIGN.md, раздел 32
struct EndingConditions: Codable {
    // WorldTension conditions
    let minTension: Int?                    // Минимальный WorldTension
    let maxTension: Int?                    // Максимальный WorldTension

    // Deck path condition
    let deckPath: DeckPath?                 // Требуемый путь колоды

    // Flag conditions
    let requiredFlags: [String]?            // Обязательные флаги
    let forbiddenFlags: [String]?           // Запрещённые флаги

    // Anchor conditions
    let minStableAnchors: Int?              // Минимум stable якорей
    let maxBreachAnchors: Int?              // Максимум breach регионов

    // Balance conditions
    let minBalance: Int?                    // Минимальный lightDarkBalance
    let maxBalance: Int?                    // Максимальный lightDarkBalance

    init(
        minTension: Int? = nil,
        maxTension: Int? = nil,
        deckPath: DeckPath? = nil,
        requiredFlags: [String]? = nil,
        forbiddenFlags: [String]? = nil,
        minStableAnchors: Int? = nil,
        maxBreachAnchors: Int? = nil,
        minBalance: Int? = nil,
        maxBalance: Int? = nil
    ) {
        self.minTension = minTension
        self.maxTension = maxTension
        self.deckPath = deckPath
        self.requiredFlags = requiredFlags
        self.forbiddenFlags = forbiddenFlags
        self.minStableAnchors = minStableAnchors
        self.maxBreachAnchors = maxBreachAnchors
        self.minBalance = minBalance
        self.maxBalance = maxBalance
    }
}

/// Эпилог финала
struct EndingEpilogue: Codable {
    let anchors: String     // Судьба якорей
    let hero: String        // Судьба героя
    let world: String       // Судьба мира
}

// MARK: - Side Quest Theme

/// Тема побочного квеста (влияет на тон и последствия)
/// См. EXPLORATION_CORE_DESIGN.md, раздел 30.2
enum SideQuestTheme: String, Codable {
    case consequence    // Последствия — мир уже пострадал
    case warning        // Предупреждение — можно предотвратить деградацию
    case temptation     // Соблазн — быстрые выгоды за долгосрочный урон
}

// MARK: - Main Quest Step

/// Шаг основного квеста
/// См. EXPLORATION_CORE_DESIGN.md, раздел 29.3
struct MainQuestStep: Identifiable, Codable {
    let id: String
    let title: String
    let goal: String
    let unlockConditions: QuestConditions
    let completionConditions: QuestConditions
    let effects: QuestEffects?

    init(
        id: String,
        title: String,
        goal: String,
        unlockConditions: QuestConditions,
        completionConditions: QuestConditions,
        effects: QuestEffects? = nil
    ) {
        self.id = id
        self.title = title
        self.goal = goal
        self.unlockConditions = unlockConditions
        self.completionConditions = completionConditions
        self.effects = effects
    }
}

/// Условия для квеста (разблокировки или завершения)
/// См. EXPLORATION_CORE_DESIGN.md, раздел 29
struct QuestConditions: Codable {
    var requiredFlags: [String]?    // Флаги, которые должны быть установлены
    var forbiddenFlags: [String]?   // Флаги, которых НЕ должно быть
    var minTension: Int?            // Минимальный WorldTension
    var maxTension: Int?            // Максимальный WorldTension
    var minBalance: Int?            // Минимальный lightDarkBalance
    var maxBalance: Int?            // Максимальный lightDarkBalance
    var visitedRegions: [String]?   // Посещённые регионы

    init(
        requiredFlags: [String]? = nil,
        forbiddenFlags: [String]? = nil,
        minTension: Int? = nil,
        maxTension: Int? = nil,
        minBalance: Int? = nil,
        maxBalance: Int? = nil,
        visitedRegions: [String]? = nil
    ) {
        self.requiredFlags = requiredFlags
        self.forbiddenFlags = forbiddenFlags
        self.minTension = minTension
        self.maxTension = maxTension
        self.minBalance = minBalance
        self.maxBalance = maxBalance
        self.visitedRegions = visitedRegions
    }
}

/// Эффекты выполнения шага квеста
struct QuestEffects: Codable {
    var unlockRegions: [String]?    // Разблокировать регионы
    var setFlags: [String]?         // Установить флаги
    var tensionChange: Int?         // Изменение WorldTension
    var addCards: [String]?         // Добавить карты

    init(
        unlockRegions: [String]? = nil,
        setFlags: [String]? = nil,
        tensionChange: Int? = nil,
        addCards: [String]? = nil
    ) {
        self.unlockRegions = unlockRegions
        self.setFlags = setFlags
        self.tensionChange = tensionChange
        self.addCards = addCards
    }
}


// ==========================================
// FILE: Models/GameSave.swift
// ==========================================

import Foundation

// Save slot for saving/loading games (Campaign v2.0)
struct GameSave: Codable, Identifiable {
    let id: UUID
    let slotNumber: Int
    let characterName: String
    let turnNumber: Int

    // Basic player stats
    let health: Int
    let maxHealth: Int
    let faith: Int
    let maxFaith: Int
    let balance: Int

    // CRITICAL: Deck composition (deck-building mechanic)
    let playerDeck: [Card]
    let playerHand: [Card]
    let playerDiscard: [Card]
    let playerBuried: [Card]

    // Player curses and spirits
    let activeCurses: [ActiveCurse]
    let spirits: [Card]
    let currentRealm: Realm

    // Character stats
    let strength: Int
    let dexterity: Int
    let constitution: Int
    let intelligence: Int
    let wisdom: Int
    let charisma: Int

    // CRITICAL: World state (campaign progression)
    let worldState: WorldState

    // Game progress (old system - kept for compatibility)
    let encountersDefeated: Int
    let isVictory: Bool
    let isDefeat: Bool

    let timestamp: Date

    var formattedDate: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        return formatter.string(from: timestamp)
    }
}

// Manager for saving/loading games
class SaveManager: ObservableObject {
    static let shared = SaveManager()

    @Published var saveSlots: [Int: GameSave] = [:]

    private let savesKey = "twilight_marches_saves"

    init() {
        loadAllSaves()
    }

    // Save game to slot (Campaign v2.0 - full save)
    func saveGame(to slot: Int, gameState: GameState) {
        guard let player = gameState.players.first else { return }

        let save = GameSave(
            id: UUID(),
            slotNumber: slot,
            characterName: player.name,
            turnNumber: gameState.turnNumber,
            health: player.health,
            maxHealth: player.maxHealth,
            faith: player.faith,
            maxFaith: player.maxFaith,
            balance: player.balance,
            // CRITICAL: Save deck composition
            playerDeck: player.deck,
            playerHand: player.hand,
            playerDiscard: player.discard,
            playerBuried: player.buried,
            // Save curses and spirits
            activeCurses: player.activeCurses,
            spirits: player.spirits,
            currentRealm: player.currentRealm,
            // Save character stats
            strength: player.strength,
            dexterity: player.dexterity,
            constitution: player.constitution,
            intelligence: player.intelligence,
            wisdom: player.wisdom,
            charisma: player.charisma,
            // CRITICAL: Save world state (campaign progression)
            worldState: gameState.worldState,
            // Old system (compatibility)
            encountersDefeated: gameState.encountersDefeated,
            isVictory: gameState.isVictory,
            isDefeat: gameState.isDefeat,
            timestamp: Date()
        )

        saveSlots[slot] = save
        persistSaves()
    }

    // Load game from slot
    func loadGame(from slot: Int) -> GameSave? {
        return saveSlots[slot]
    }

    // Restore full game state from save (Campaign v2.0)
    func restoreGameState(from save: GameSave) -> GameState {
        // Restore player with full state
        let player = Player(
            name: save.characterName,
            health: save.health,
            maxHealth: save.maxHealth,
            strength: save.strength,
            dexterity: save.dexterity,
            constitution: save.constitution,
            intelligence: save.intelligence,
            wisdom: save.wisdom,
            charisma: save.charisma,
            faith: save.faith,
            maxFaith: save.maxFaith,
            balance: save.balance,
            currentRealm: save.currentRealm
        )

        // Restore deck composition (CRITICAL for deck-building)
        player.deck = save.playerDeck
        player.hand = save.playerHand
        player.discard = save.playerDiscard
        player.buried = save.playerBuried

        // Restore curses and spirits
        player.activeCurses = save.activeCurses
        player.spirits = save.spirits

        // Create game state with restored player
        let gameState = GameState(players: [player])

        // Restore world state (CRITICAL for campaign)
        gameState.worldState = save.worldState

        // Restore game progress
        gameState.turnNumber = save.turnNumber
        gameState.encountersDefeated = save.encountersDefeated
        gameState.isVictory = save.isVictory
        gameState.isDefeat = save.isDefeat

        // Set initial phase
        if gameState.isGameOver {
            gameState.currentPhase = .gameOver
        } else {
            gameState.currentPhase = .exploration
        }

        return gameState
    }

    // Delete save from slot
    func deleteSave(from slot: Int) {
        saveSlots.removeValue(forKey: slot)
        persistSaves()
    }

    // Check if slot is empty
    func isSlotEmpty(_ slot: Int) -> Bool {
        return saveSlots[slot] == nil
    }

    // Get all saves sorted by slot number
    var allSaves: [GameSave] {
        return saveSlots.values.sorted { $0.slotNumber < $1.slotNumber }
    }

    // MARK: - Persistence

    private func persistSaves() {
        if let encoded = try? JSONEncoder().encode(saveSlots) {
            UserDefaults.standard.set(encoded, forKey: savesKey)
        }
    }

    private func loadAllSaves() {
        if let data = UserDefaults.standard.data(forKey: savesKey),
           let decoded = try? JSONDecoder().decode([Int: GameSave].self, from: data) {
            saveSlots = decoded
        }
    }
}


// ==========================================
// FILE: Models/GameState.swift
// ==========================================

import Foundation
import Combine

enum GamePhase {
    case setup
    case exploration
    case encounter
    case playerTurn
    case enemyTurn
    case endTurn
    case gameOver
}

class GameState: ObservableObject {
    @Published var currentPhase: GamePhase = .setup
    @Published var players: [Player]
    @Published var currentPlayerIndex: Int = 0
    @Published var encounterDeck: [Card]
    @Published var locationDeck: [Card]
    @Published var activeEncounter: Card?
    @Published var turnNumber: Int = 0
    @Published var diceRoll: Int?
    @Published var encountersDefeated: Int = 0
    @Published var isVictory: Bool = false
    @Published var isDefeat: Bool = false
    @Published var actionsRemaining: Int = 3

    // Marketplace for deck-building
    @Published var marketCards: [Card] = []

    // World exploration system
    @Published var worldState: WorldState = WorldState()

    // Auto-save callback
    var onAutoSave: (() -> Void)?

    // Actions per turn
    var actionsPerTurn: Int { 3 }

    var currentPlayer: Player {
        players[currentPlayerIndex]
    }

    // DEPRECATED: Old victory condition (kept for compatibility)
    // New victory: complete main quest (mainQuestStage == 5 && act_completed flags)
    var victoryThreshold: Int { 10 }

    // Game is over if victory or defeat
    var isGameOver: Bool {
        isVictory || isDefeat
    }

    // MARK: - Victory/Defeat Conditions

    /// Check quest-based victory (new system)
    func checkQuestVictory() {
        // Victory: Main quest completed (Act 5 finished)
        if worldState.mainQuestStage >= 5 && worldState.worldFlags["act5_completed"] == true {
            isVictory = true
            currentPhase = .gameOver
        }
    }

    /// Check defeat conditions
    func checkDefeatConditions() {
        // Defeat 1: Player HP = 0
        if currentPlayer.health <= 0 {
            isDefeat = true
            currentPhase = .gameOver
            return
        }

        // Defeat 2: WorldTension = 100% (world fell to Nav)
        if worldState.worldTension >= 100 {
            isDefeat = true
            currentPhase = .gameOver
            return
        }

        // Defeat 3: Critical anchor destroyed (if implemented via flags)
        if worldState.worldFlags["critical_anchor_destroyed"] == true {
            isDefeat = true
            currentPhase = .gameOver
            return
        }
    }

    init(players: [Player]) {
        self.players = players
        self.encounterDeck = []
        self.locationDeck = []
    }

    func startGame() {
        currentPhase = .exploration
        turnNumber = 1
        isVictory = false
        isDefeat = false
        encountersDefeated = 0
        activeEncounter = nil

        // Deal initial hands
        for player in players {
            player.shuffleDeck()
            player.drawCards(count: player.maxHandSize)
        }
    }

    // Purchase card from market
    func purchaseCard(_ card: Card) -> Bool {
        guard let cardCost = card.cost else { return false }

        // Check if player has enough faith
        if currentPlayer.spendFaith(cardCost) {
            // Remove card from market
            if let index = marketCards.firstIndex(where: { $0.id == card.id }) {
                marketCards.remove(at: index)
            }

            // Add card to player's discard pile (standard deck-building mechanic)
            currentPlayer.discard.append(card)

            return true
        }

        return false
    }

    func nextPhase() {
        switch currentPhase {
        case .setup:
            currentPhase = .exploration
        case .exploration:
            currentPhase = .encounter
        case .encounter:
            currentPhase = .playerTurn
        case .playerTurn:
            currentPhase = .enemyTurn
        case .enemyTurn:
            currentPhase = .endTurn
        case .endTurn:
            endTurn()
        case .gameOver:
            break
        }
    }

    func endTurn() {
        currentPlayerIndex = (currentPlayerIndex + 1) % players.count

        if currentPlayerIndex == 0 {
            turnNumber += 1
        }

        // Tick curses at end of turn
        currentPlayer.tickCurses()

        // Check defeat and victory conditions (new system)
        checkDefeatConditions()
        checkQuestVictory()

        if !isGameOver {
            currentPhase = .exploration
            activeEncounter = nil
            actionsRemaining = actionsPerTurn

            // Проклятие истощения: -1 действие в этом ходу
            if currentPlayer.hasCurse(.exhaustion) {
                actionsRemaining = max(1, actionsRemaining - 1)
            }

            // NEW: Discard all cards and draw 5 new ones (deck-building mechanic)
            let player = currentPlayer
            // Discard all cards in hand
            player.discard.append(contentsOf: player.hand)
            player.hand.removeAll()

            // Draw 5 new cards
            player.drawCards(count: 5)

            // Regenerate faith
            currentPlayer.gainFaith(1)
        }

        // Auto-save after turn ends
        onAutoSave?()
    }

    func defeatEncounter() {
        encountersDefeated += 1

        // Check if a boss was defeated (for quest objectives)
        if let encounter = activeEncounter {
            worldState.markBossDefeated(bossName: encounter.name, player: currentPlayer)
        }

        // Проклятие крови: при убийстве +2 HP и баланс смещается к тьме
        if currentPlayer.hasCurse(.bloodCurse) {
            currentPlayer.heal(2)
            currentPlayer.shiftBalance(towards: .dark, amount: 5)
        }

        activeEncounter = nil
        currentPhase = .exploration

        // DEPRECATED: Old victory condition (kept for compatibility)
        // New system: quest-based victory via checkQuestVictory()
        if encountersDefeated >= victoryThreshold {
            isVictory = true
            currentPhase = .gameOver
        }

        // Check new victory conditions
        checkQuestVictory()

        // Auto-save after defeating encounter
        onAutoSave?()
    }

    // DEPRECATED: Use checkDefeatConditions() instead
    // Kept for backwards compatibility with existing code
    func checkDefeat() {
        checkDefeatConditions()
    }

    func rollDice(sides: Int = 6, count: Int = 1) -> Int {
        // Используем WorldRNG для детерминизма при тестировании
        let total = (0..<count).reduce(0) { sum, _ in
            sum + WorldRNG.shared.nextInt(in: 1...sides)
        }
        diceRoll = total
        return total
    }

    func drawEncounter() {
        guard !encounterDeck.isEmpty else { return }
        activeEncounter = encounterDeck.removeFirst()
        currentPhase = .encounter
    }

    func useAction() -> Bool {
        guard actionsRemaining > 0 else { return false }
        actionsRemaining -= 1
        return true
    }

    func enemyPhaseAction() {
        // Enemy attacks during their phase
        guard let encounter = activeEncounter else { return }

        let encounterPower = encounter.power ?? 3
        // Применяем урон с учётом проклятий (fear увеличивает получаемый урон)
        currentPlayer.takeDamageWithCurses(encounterPower)
        checkDefeat()
    }
}


// ==========================================
// FILE: Models/Player.swift
// ==========================================

import Foundation

// Twilight Marches: Active curse tracking
struct ActiveCurse: Identifiable, Codable {
    let id: UUID
    let type: CurseType
    var duration: Int  // turns remaining
    let sourceCard: String?  // name of card that applied curse

    init(id: UUID = UUID(), type: CurseType, duration: Int, sourceCard: String? = nil) {
        self.id = id
        self.type = type
        self.duration = duration
        self.sourceCard = sourceCard
    }
}

class Player: ObservableObject, Identifiable {
    let id: UUID
    @Published var name: String
    @Published var health: Int
    @Published var maxHealth: Int
    @Published var hand: [Card]
    @Published var deck: [Card]
    @Published var discard: [Card]
    @Published var buried: [Card]

    // Character stats
    @Published var strength: Int
    @Published var dexterity: Int
    @Published var constitution: Int
    @Published var intelligence: Int
    @Published var wisdom: Int
    @Published var charisma: Int

    // Hand size management
    let maxHandSize: Int

    // Hero class system
    let heroClass: HeroClass?

    // Twilight Marches mechanics
    @Published var faith: Int  // Вера - resource for powerful abilities
    @Published var maxFaith: Int
    @Published var balance: Int  // 0 (dark) to 100 (light), 50 is neutral
    @Published var activeCurses: [ActiveCurse]
    @Published var currentRealm: Realm
    @Published var spirits: [Card]  // Summoned spirits

    init(
        id: UUID = UUID(),
        name: String,
        health: Int = 10,
        maxHealth: Int = 10,
        maxHandSize: Int = 7,
        strength: Int = 5,      // Базовая сила для боя (атака = strength + d6)
        dexterity: Int = 0,
        constitution: Int = 0,
        intelligence: Int = 0,
        wisdom: Int = 0,
        charisma: Int = 0,
        faith: Int = 3,
        maxFaith: Int = 10,
        balance: Int = 50,
        currentRealm: Realm = .yav,
        heroClass: HeroClass? = nil
    ) {
        self.id = id
        self.name = name
        self.heroClass = heroClass
        self.maxHandSize = maxHandSize
        self.hand = []
        self.deck = []
        self.discard = []
        self.buried = []
        self.activeCurses = []
        self.currentRealm = currentRealm
        self.spirits = []

        // Если указан класс героя, применяем его характеристики
        if let heroClass = heroClass {
            let stats = heroClass.baseStats
            self.health = stats.health
            self.maxHealth = stats.maxHealth
            self.strength = stats.strength
            self.dexterity = stats.dexterity
            self.constitution = stats.constitution
            self.intelligence = stats.intelligence
            self.wisdom = stats.wisdom
            self.charisma = stats.charisma
            self.faith = stats.faith
            self.maxFaith = stats.maxFaith
            self.balance = stats.startingBalance
        } else {
            // Дефолтные значения для тестов
            self.health = health
            self.maxHealth = maxHealth
            self.strength = strength
            self.dexterity = dexterity
            self.constitution = constitution
            self.intelligence = intelligence
            self.wisdom = wisdom
            self.charisma = charisma
            self.faith = faith
            self.maxFaith = maxFaith
            self.balance = balance
        }
    }

    func drawCard() {
        // Auto-reshuffle discard when deck is empty
        if deck.isEmpty && !discard.isEmpty {
            reshuffleDiscard()
        }

        guard !deck.isEmpty else { return }
        let card = deck.removeFirst()
        hand.append(card)
    }

    func drawCards(count: Int) {
        for _ in 0..<count {
            drawCard()
        }
    }

    func playCard(_ card: Card) {
        guard let index = hand.firstIndex(where: { $0.id == card.id }) else { return }
        let playedCard = hand.remove(at: index)
        discard.append(playedCard)
    }

    func shuffleDeck() {
        deck.shuffle()
    }

    func reshuffleDiscard() {
        deck.append(contentsOf: discard)
        discard.removeAll()
        shuffleDeck()
    }

    func takeDamage(_ amount: Int) {
        health = max(0, health - amount)
    }

    func heal(_ amount: Int) {
        health = min(maxHealth, health + amount)
    }

    // Twilight Marches methods
    func gainFaith(_ amount: Int) {
        faith = min(maxFaith, faith + amount)
    }

    func spendFaith(_ amount: Int) -> Bool {
        guard faith >= amount else { return false }
        faith -= amount
        return true
    }

    func shiftBalance(towards: CardBalance, amount: Int) {
        switch towards {
        case .light:
            balance = min(100, balance + amount)
        case .dark:
            balance = max(0, balance - amount)
        case .neutral:
            // Move towards 50 (neutral)
            if balance > 50 {
                balance = max(50, balance - amount)
            } else if balance < 50 {
                balance = min(50, balance + amount)
            }
        }
    }

    func applyCurse(type: CurseType, duration: Int, sourceCard: String? = nil) {
        let curse = ActiveCurse(type: type, duration: duration, sourceCard: sourceCard)
        activeCurses.append(curse)
    }

    func removeCurse(type: CurseType? = nil) {
        if let specificType = type {
            activeCurses.removeAll { $0.type == specificType }
        } else {
            // Remove first curse if no type specified
            if !activeCurses.isEmpty {
                activeCurses.removeFirst()
            }
        }
    }

    func hasCurse(_ type: CurseType) -> Bool {
        return activeCurses.contains { $0.type == type }
    }

    func tickCurses() {
        // Reduce duration of all curses and remove expired ones
        for i in (0..<activeCurses.count).reversed() {
            activeCurses[i].duration -= 1
            if activeCurses[i].duration <= 0 {
                activeCurses.remove(at: i)
            }
        }
    }

    // MARK: - Curse Combat Modifiers

    /// Получить модификатор наносимого урона от проклятий
    /// weakness: -1, shadowOfNav: +3
    func getDamageDealtModifier() -> Int {
        var modifier = 0
        if hasCurse(.weakness) {
            modifier -= 1
        }
        if hasCurse(.shadowOfNav) {
            modifier += 3
        }
        return modifier
    }

    /// Получить модификатор получаемого урона от проклятий
    /// fear: +1 (больше урона получаем)
    func getDamageTakenModifier() -> Int {
        var modifier = 0
        if hasCurse(.fear) {
            modifier += 1
        }
        return modifier
    }

    /// Применить урон с учётом модификаторов проклятий
    func takeDamageWithCurses(_ baseDamage: Int) {
        let modifier = getDamageTakenModifier()
        let actualDamage = max(0, baseDamage + modifier)
        takeDamage(actualDamage)
    }

    /// Рассчитать урон с учётом модификаторов проклятий
    func calculateDamageDealt(_ baseDamage: Int) -> Int {
        let modifier = getDamageDealtModifier()
        return max(0, baseDamage + modifier)
    }

    func summonSpirit(_ spirit: Card) {
        spirits.append(spirit)
    }

    func dismissSpirit(_ spirit: Card) {
        spirits.removeAll { $0.id == spirit.id }
    }

    func travelToRealm(_ realm: Realm) {
        currentRealm = realm
    }

    var balanceState: CardBalance {
        if balance >= 70 {
            return .light
        } else if balance <= 30 {
            return .dark
        } else {
            return .neutral
        }
    }

    // Описание баланса для UI
    var balanceDescription: String {
        switch balance {
        case 0..<30:
            return "Путь Тьмы"
        case 30..<70:
            return "Нейтральный"
        case 70...100:
            return "Путь Света"
        default:
            return "Неизвестно"
        }
    }

    // MARK: - Hero Class Abilities

    /// Бонус урона от способности класса
    /// - Warrior: +2 при HP ниже 50%
    /// - Shadow: +3 если цель на полном HP (targetFullHP = true)
    func getHeroClassDamageBonus(targetFullHP: Bool = false) -> Int {
        guard let heroClass = heroClass else { return 0 }

        switch heroClass {
        case .warrior:
            // Ярость: +2 к урону при HP ниже 50%
            if health < maxHealth / 2 {
                return 2
            }
        case .shadow:
            // Засада: +3 урона по полным HP
            if targetFullHP {
                return 3
            }
        default:
            break
        }
        return 0
    }

    /// Снижение получаемого урона от способности класса
    /// - Priest: -1 от тёмных источников
    func getHeroClassDamageReduction(fromDarkSource: Bool = false) -> Int {
        guard let heroClass = heroClass else { return 0 }

        switch heroClass {
        case .priest:
            // Благословение: -1 урон от тёмных источников
            if fromDarkSource {
                return 1
            }
        default:
            break
        }
        return 0
    }

    /// Бонусные кубики от способности класса (для первой атаки)
    /// - Ranger: +1 кубик при первой атаке
    func getHeroClassBonusDice(isFirstAttack: Bool) -> Int {
        guard let heroClass = heroClass else { return 0 }

        switch heroClass {
        case .ranger:
            // Выслеживание: +1 кубик при первой атаке
            if isFirstAttack {
                return 1
            }
        default:
            break
        }
        return 0
    }

    /// Проверка способности Мага: +1 вера в конце хода
    var shouldGainFaithEndOfTurn: Bool {
        return heroClass == .mage
    }

    /// Полный расчёт урона с учётом проклятий и классовых способностей
    func calculateTotalDamageDealt(_ baseDamage: Int, targetFullHP: Bool = false) -> Int {
        let curseModifier = getDamageDealtModifier()
        let heroBonus = getHeroClassDamageBonus(targetFullHP: targetFullHP)
        return max(0, baseDamage + curseModifier + heroBonus)
    }

    /// Полный расчёт получаемого урона с учётом проклятий и классовых способностей
    func takeDamageWithAllModifiers(_ baseDamage: Int, fromDarkSource: Bool = false) {
        let curseModifier = getDamageTakenModifier()
        let heroReduction = getHeroClassDamageReduction(fromDarkSource: fromDarkSource)
        let actualDamage = max(0, baseDamage + curseModifier - heroReduction)
        takeDamage(actualDamage)
    }
}


// ==========================================
// FILE: Models/WorldState.swift
// ==========================================

import Foundation
import Combine

// MARK: - Event Log Entry

/// Запись в журнале событий
struct EventLogEntry: Identifiable, Codable {
    let id: UUID
    let dayNumber: Int
    let timestamp: Date
    let regionName: String
    let eventTitle: String
    let choiceMade: String
    let outcome: String
    let type: EventLogType

    init(
        id: UUID = UUID(),
        dayNumber: Int,
        timestamp: Date = Date(),
        regionName: String,
        eventTitle: String,
        choiceMade: String,
        outcome: String,
        type: EventLogType
    ) {
        self.id = id
        self.dayNumber = dayNumber
        self.timestamp = timestamp
        self.regionName = regionName
        self.eventTitle = eventTitle
        self.choiceMade = choiceMade
        self.outcome = outcome
        self.type = type
    }
}

/// Тип записи в журнале
enum EventLogType: String, Codable {
    case exploration    // Исследование
    case combat         // Бой
    case choice         // Выбор
    case quest          // Квест
    case travel         // Путешествие
    case worldChange    // Изменение мира

    var icon: String {
        switch self {
        case .exploration: return "magnifyingglass"
        case .combat: return "swords"
        case .choice: return "questionmark.circle"
        case .quest: return "scroll"
        case .travel: return "figure.walk"
        case .worldChange: return "globe"
        }
    }
}

/// Событие, произошедшее в конце дня (для уведомлений)
struct DayEvent: Identifiable {
    let id = UUID()
    let day: Int
    let title: String
    let description: String
    let isNegative: Bool

    static func tensionIncrease(day: Int, newTension: Int) -> DayEvent {
        DayEvent(
            day: day,
            title: "Напряжение растёт",
            description: "Влияние Нави усиливается. Напряжение мира: \(newTension)%",
            isNegative: true
        )
    }

    static func regionDegraded(day: Int, regionName: String, newState: RegionState) -> DayEvent {
        DayEvent(
            day: day,
            title: "Регион деградирует",
            description: "\(regionName) переходит в состояние: \(newState.displayName)",
            isNegative: true
        )
    }

    static func worldImproving(day: Int) -> DayEvent {
        DayEvent(
            day: day,
            title: "Мир восстанавливается",
            description: "Влияние Яви укрепляется, напряжение спадает",
            isNegative: false
        )
    }
}

/// Глобальное состояние мира для системы исследования
class WorldState: ObservableObject, Codable {
    // MARK: - Published Properties

    @Published var regions: [Region] = []
    @Published var worldTension: Int = 30           // 0-100, сила вторжения Нави
    @Published var lightDarkBalance: Int = 50       // 0 (dark) - 100 (light)
    @Published var mainQuestStage: Int = 1          // 1-5 актов
    @Published var activeQuests: [Quest] = []
    @Published var completedQuests: [String] = []   // ID завершенных квестов
    @Published var worldFlags: [String: Bool] = [:] // Сюжетные флаги
    @Published var allEvents: [GameEvent] = []
    @Published var currentRegionId: UUID?           // Текущий регион игрока
    @Published var daysPassed: Int = 0              // Дни в пути
    @Published var eventLog: [EventLogEntry] = []   // Журнал событий
    @Published var lastDayEvent: DayEvent?          // Последнее событие дня (для уведомлений)

    // MARK: - Computed Properties

    var currentRegion: Region? {
        guard let id = currentRegionId else { return nil }
        return regions.first { $0.id == id }
    }

    var averageRegionState: RegionState {
        let stableCount = regions.filter { $0.state == .stable }.count
        let totalCount = regions.count
        let percentage = totalCount > 0 ? (Double(stableCount) / Double(totalCount)) * 100 : 0

        switch percentage {
        case 60...100:
            return .stable
        case 30..<60:
            return .borderland
        default:
            return .breach
        }
    }

    // MARK: - Initialization

    init() {
        setupInitialWorld()
    }

    // MARK: - World Setup

    private func setupInitialWorld() {
        // DATA-DRIVEN: Load regions from ContentProvider
        // Reference: ENGINE_ARCHITECTURE.md, Section 5
        // Use CodeContentProvider with Twilight Marches content
        let provider = TwilightMarchesCodeContentProvider()
        regions = createRegionsFromProvider(provider)

        // Создаем начальные события
        allEvents = createInitialEvents()

        // Создаем начальные квесты (Act I)
        let initialQuests = createInitialQuests()
        // Main quest starts automatically
        if let mainQuest = initialQuests.first(where: { $0.questType == .main }) {
            startQuest(mainQuest)
        }

        // Устанавливаем начальные параметры
        worldTension = 30
        lightDarkBalance = 50
        mainQuestStage = 1
        daysPassed = 0

        // Стартовый регион - "Деревня у тракта" (village)
        // Canonical starting region is the Village per game design
        if let villageRegion = regions.first(where: { $0.name == "Деревня у тракта" }) {
            currentRegionId = villageRegion.id
        } else if let firstStable = regions.first(where: { $0.state == .stable }) {
            // Fallback to any stable region if village not found
            currentRegionId = firstStable.id
        }
    }

    /// Convert RegionDefinitions from ContentProvider to legacy Region models
    /// This bridges the new Data-Driven architecture with existing runtime models
    private func createRegionsFromProvider(_ provider: ContentProvider) -> [Region] {
        let regionDefs = provider.getAllRegionDefinitions()
        var regionMap: [String: Region] = [:]

        // First pass: create regions without neighbor links
        for def in regionDefs {
            let anchor = createAnchorFromDefinition(provider.getAnchorDefinition(forRegion: def.id))
            let regionType = mapRegionType(def.id)
            let regionState = mapRegionState(def.initialState)

            var region = Region(
                name: TwilightMarchesCodeContentProvider.regionName(for: def.id),
                type: regionType,
                state: regionState,
                anchor: anchor,
                reputation: 0
            )
            region.updateStateFromAnchor()
            regionMap[def.id] = region
        }

        // Second pass: link neighbors using UUIDs
        for def in regionDefs {
            guard var region = regionMap[def.id] else { continue }
            region.neighborIds = def.neighborIds.compactMap { regionMap[$0]?.id }
            regionMap[def.id] = region
        }

        // Sort by name for deterministic ordering (Dictionary values order is non-deterministic)
        return Array(regionMap.values).sorted { $0.name < $1.name }
    }

    /// Create legacy Anchor from AnchorDefinition
    private func createAnchorFromDefinition(_ def: AnchorDefinition?) -> Anchor? {
        guard let def = def else { return nil }

        let anchorType = mapAnchorType(def.anchorType)
        let influence = mapInfluence(def.initialInfluence)

        return Anchor(
            name: TwilightMarchesCodeContentProvider.anchorName(for: def.id),
            type: anchorType,
            integrity: def.initialIntegrity,
            influence: influence,
            power: def.power
        )
    }

    /// Map string anchor type to AnchorType enum
    private func mapAnchorType(_ typeString: String) -> AnchorType {
        switch typeString {
        case "chapel": return .chapel
        case "shrine": return .shrine
        case "sacred_tree": return .sacredTree
        case "stone_idol": return .stoneIdol
        case "spring": return .spring
        case "barrow": return .barrow
        case "temple": return .temple
        case "cross": return .cross
        default: return .shrine
        }
    }

    /// Map AnchorInfluence to CardBalance
    private func mapInfluence(_ influence: AnchorInfluence) -> CardBalance {
        switch influence {
        case .light: return .light
        case .neutral: return .neutral
        case .dark: return .dark
        }
    }

    /// Map RegionStateType to RegionState
    private func mapRegionState(_ state: RegionStateType) -> RegionState {
        switch state {
        case .stable: return .stable
        case .borderland: return .borderland
        case .breach: return .breach
        }
    }

    /// Map region ID to RegionType (game-specific mapping)
    private func mapRegionType(_ regionId: String) -> RegionType {
        switch regionId {
        case "village": return .settlement
        case "oak": return .sacred
        case "forest": return .forest
        case "swamp": return .swamp
        case "mountain": return .mountain
        case "breach": return .wasteland
        case "dark_lowland": return .swamp
        default: return .forest // Default to forest for unknown regions
        }
    }

    // MARK: - Region Management

    func updateRegion(_ updatedRegion: Region) {
        if let index = regions.firstIndex(where: { $0.id == updatedRegion.id }) {
            regions[index] = updatedRegion
        }
    }

    func getRegion(byId id: UUID) -> Region? {
        return regions.first { $0.id == id }
    }

    /// Получить текущий регион игрока
    func getCurrentRegion() -> Region? {
        guard let currentId = currentRegionId else { return nil }
        return getRegion(byId: currentId)
    }

    /// - Warning: DEPRECATED для UI. Используйте `TwilightGameEngine.performAction(.travel(toRegionId:))` вместо прямого вызова.
    /// Этот метод оставлен для совместимости и внутреннего использования Engine.
    func moveToRegion(_ regionId: UUID) {
        // ⚠️ MIGRATION: После Phase 3 этот метод будет вызываться только из Engine
        // Отметить текущий регион как посещенный
        if let currentId = currentRegionId,
           let index = regions.firstIndex(where: { $0.id == currentId }) {
            regions[index].visited = true
        }

        // Рассчитать стоимость путешествия
        let travelCost = calculateTravelCost(to: regionId)

        // Переместиться в новый регион
        currentRegionId = regionId

        // Отметить новый регион как посещенный
        if let index = regions.firstIndex(where: { $0.id == regionId }) {
            regions[index].visited = true
        }

        // Продвинуть время корректно - каждый день обрабатывается отдельно
        // Это критично: travel cost 2 должен обработать день 3, если мы были на дне 2
        advanceTimeInternal(by: travelCost)
    }

    /// Рассчитать стоимость путешествия в регион
    /// Соседний регион: 1 день, дальний: 2 дня
    func calculateTravelCost(to targetId: UUID) -> Int {
        guard let currentId = currentRegionId,
              let currentRegion = getRegion(byId: currentId) else {
            return 1  // По умолчанию 1 день
        }

        return currentRegion.isNeighbor(targetId) ? 1 : 2
    }

    // MARK: - Time-based Degradation (Day Start Algorithm)

    /// Канонический алгоритм начала дня (см. EXPLORATION_CORE_DESIGN.md, раздел 18.1)
    /// Вызывается при каждом увеличении daysPassed
    ///
    /// ## DEPRECATED
    /// - **UI Code**: Use `TwilightGameEngine.performAction()` instead
    /// - **Tests**: This method is retained for testing the canonical day algorithm
    /// - **Internal**: Called automatically from `advanceTime(by:)`
    ///
    /// Duplicate logic exists in `TwilightGameEngine.advanceTime(by:)`.
    /// After full migration, this method will be removed.
    ///
    /// - Warning: Do not call directly from UI/ViewModel code. Use Engine actions.
    func processDayStart() {
        performDayStartLogic()
    }

    /// Advance day and process day start logic.
    ///
    /// **TRANSITIONAL API**: This method exists for Views that don't yet have access to TwilightGameEngine.
    /// Once full migration to Engine is complete, this will be deprecated in favor of Engine actions.
    ///
    /// - Note: Increments `daysPassed` by 1 and processes day start logic (tension, degradation, etc.)
    func advanceDayForUI() {
        daysPassed += 1
        performDayStartLogic()
    }

    /// Internal day start logic - shared by processDayStart() and advanceDayForUI()
    private func performDayStartLogic() {
        // ⚠️ MIGRATION: This method uses TwilightPressureRules as single source of truth (Audit v1.1 Issue #6)
        // 1. Каждые 3 дня — автоматическая деградация мира
        guard daysPassed > 0 && daysPassed % 3 == 0 else { return }

        // 2. Увеличить напряжение мира с ЭСКАЛАЦИЕЙ
        // Формула из TwilightPressureRules: base + (daysPassed / 10)
        // День 1-9: +3, День 10-19: +4, День 20-29: +5, ...
        let totalIncrement = TwilightPressureRules.calculateTensionIncrease(daysPassed: daysPassed)
        increaseTension(by: totalIncrement)

        // Уведомить о росте напряжения
        lastDayEvent = .tensionIncrease(day: daysPassed, newTension: worldTension)
        logWorldChange(description: "Напряжение мира выросло до \(worldTension)% (+\(totalIncrement))")

        // 3. Проверить деградацию региона с вероятностью (Tension/100)
        // Используем WorldRNG для детерминизма при тестировании
        let probability = Double(worldTension) / 100.0
        if WorldRNG.shared.checkProbability(probability) {
            checkRegionDegradation()
        }

        // 4. Проверить улучшение мира при низком напряжении
        if worldTension <= 20 {
            improveRandomRegion()
        }

        // 5. Проверить триггеры квестов
        checkQuestTriggers()

        // 6. Проверить глобальные триггеры мира
        checkWorldShiftTriggers()
    }

    /// Проверка автоматической деградации мира (legacy alias)
    /// - Warning: DEPRECATED. Use `processDayStart()` or `TwilightGameEngine.performAction()`
    @available(*, deprecated, renamed: "processDayStart()")
    func checkTimeDegradation() {
        processDayStart()
    }

    /// Проверка деградации региона по весовому алгоритму
    /// (см. EXPLORATION_CORE_DESIGN.md, раздел 18.2)
    /// Использует DegradationRules для определения поведения
    private func checkRegionDegradation() {
        let rules = DegradationRules.current

        // 1. Выбрать случайный регион с весами из правил
        guard let selectedRegion = selectRegionForDegradation() else { return }

        // 2. Проверить сопротивление якоря (вероятностное, не пороговое)
        // P(resist) = integrity/100: чем сильнее якорь, тем выше шанс сопротивляться
        if let anchor = selectedRegion.anchor {
            let resistProb = rules.resistanceProbability(anchorIntegrity: anchor.integrity)
            if WorldRNG.shared.checkProbability(resistProb) {
                // Якорь сопротивляется — деградация не происходит
                logWorldChange(description: "Якорь в \(selectedRegion.name) сопротивляется влиянию Нави (\(anchor.integrity)% integrity)")
                return
            }
        }

        // 3. Применить деградацию и уведомить
        let oldState = selectedRegion.state
        degradeRegion(selectedRegion.id, amount: rules.degradationAmount)

        // Получить новое состояние после деградации
        if let updatedRegion = getRegion(byId: selectedRegion.id), updatedRegion.state != oldState {
            lastDayEvent = .regionDegraded(day: daysPassed, regionName: updatedRegion.name, newState: updatedRegion.state)
            logWorldChange(description: "\(updatedRegion.name) деградировал до \(updatedRegion.state.displayName)")
        }
    }

    /// Выбор региона для деградации с учётом весов из DegradationRules
    /// Веса определяются правилами: Stable = 0, Borderland = 1, Breach = 2
    private func selectRegionForDegradation() -> Region? {
        let rules = DegradationRules.current

        // Формируем пул регионов с весами из правил
        var weightedPool: [(region: Region, weight: Int)] = []

        for region in regions {
            let weight = rules.selectionWeight(for: region.state)
            if weight > 0 {
                weightedPool.append((region, weight))
            }
        }

        // Если нет подходящих регионов (все Stable), деградация не происходит
        // ВАЖНО: Stable регионы НЕ деградируют напрямую согласно документации
        if weightedPool.isEmpty {
            return nil
        }

        // Взвешенный случайный выбор (используем WorldRNG для детерминизма)
        let totalWeight = weightedPool.reduce(0) { $0 + $1.weight }
        guard totalWeight > 0 else { return nil }

        var randomValue = WorldRNG.shared.nextInt(in: 0..<totalWeight)
        for (region, weight) in weightedPool {
            randomValue -= weight
            if randomValue < 0 {
                return region
            }
        }

        return weightedPool.first?.region
    }

    /// Применить деградацию к конкретному региону
    /// - Parameters:
    ///   - regionId: ID региона для деградации
    ///   - amount: Урон якорю (по умолчанию из DegradationRules.current)
    private func degradeRegion(_ regionId: UUID, amount: Int? = nil) {
        guard var region = getRegion(byId: regionId) else { return }

        let degradationAmount = amount ?? DegradationRules.current.degradationAmount

        if var anchor = region.anchor {
            // Уменьшить integrity якоря на указанное значение
            anchor.integrity = max(0, anchor.integrity - degradationAmount)
            region.anchor = anchor
            region.updateStateFromAnchor()
            updateRegion(region)
        }
    }

    /// Проверка триггеров квестов (вызывается каждые 3 дня)
    private func checkQuestTriggers() {
        // Проверить условия продвижения для каждого активного квеста
        for quest in activeQuests {
            checkQuestProgress(quest)
        }
    }

    /// Проверка глобальных триггеров мира (World Shift Events)
    private func checkWorldShiftTriggers() {
        // При пороговых значениях Tension могут срабатывать глобальные события
        if worldTension >= 50 && !hasFlag("world_shift_50") {
            setFlag("world_shift_50", value: true)
            // Можно триггерить World Shift Event здесь
        }
        if worldTension >= 75 && !hasFlag("world_shift_75") {
            setFlag("world_shift_75", value: true)
        }
        if worldTension >= 90 && !hasFlag("world_shift_90") {
            setFlag("world_shift_90", value: true)
        }
    }

    /// Метод для ручного продвижения времени (для Rest, StrengthenAnchor и т.д.)
    ///
    /// ## DEPRECATED
    /// - **UI Code**: Use `TwilightGameEngine.performAction()` instead
    /// - **Tests**: This method is retained for testing time mechanics
    /// - **Internal**: Used by `moveToRegion` and similar legacy methods
    ///
    /// - Warning: Do not call directly from UI/ViewModel code. Use Engine actions.
    func advanceTime(by days: Int = 1) {
        advanceTimeInternal(by: days)
    }

    /// Internal time advancement - used by travelToRegion and other internal methods
    private func advanceTimeInternal(by days: Int) {
        // ⚠️ MIGRATION: This method contains canonical time logic used by tests
        for _ in 0..<days {
            daysPassed += 1
            performDayStartLogic()
        }
    }

    // MARK: - Anchor Management

    func strengthenAnchor(in regionId: UUID, amount: Int = 20) -> Bool {
        guard var region = getRegion(byId: regionId),
              var anchor = region.anchor else {
            return false
        }

        anchor.integrity = min(100, anchor.integrity + amount)
        region.anchor = anchor
        region.updateStateFromAnchor()
        updateRegion(region)

        return true
    }

    func defileAnchor(in regionId: UUID, amount: Int = 30) -> Bool {
        guard var region = getRegion(byId: regionId),
              var anchor = region.anchor else {
            return false
        }

        anchor.integrity = max(0, anchor.integrity - amount)
        anchor.influence = .dark
        region.anchor = anchor
        region.updateStateFromAnchor()
        updateRegion(region)

        // Увеличиваем напряжение мира
        increaseTension(by: 10)

        return true
    }

    func purifyAnchor(in regionId: UUID) -> Bool {
        guard var region = getRegion(byId: regionId),
              var anchor = region.anchor else {
            return false
        }

        anchor.influence = .light
        anchor.integrity = min(100, anchor.integrity + 50)
        region.anchor = anchor
        region.updateStateFromAnchor()
        updateRegion(region)

        // Уменьшаем напряжение мира
        decreaseTension(by: 15)

        return true
    }

    // MARK: - World Tension Management

    func increaseTension(by amount: Int) {
        worldTension = min(100, worldTension + amount)
        checkTensionEffects()
    }

    func decreaseTension(by amount: Int) {
        worldTension = max(0, worldTension - amount)
        checkTensionEffects()
    }

    private func checkTensionEffects() {
        // При высоком напряжении (≥80) — немедленная деградация через весовой алгоритм
        if worldTension >= 80 {
            checkRegionDegradation()
        }

        // При низком напряжении (≤20) — мир начинает восстанавливаться
        if worldTension <= 20 {
            improveRandomRegion()
        }
    }

    /// Улучшение случайного региона (при низком Tension)
    private func improveRandomRegion() {
        // Предпочитаем улучшать Breach регионы
        let breachRegions = regions.filter { $0.state == .breach }
        let borderlandRegions = regions.filter { $0.state == .borderland }

        let targetRegion: Region?
        if !breachRegions.isEmpty {
            targetRegion = WorldRNG.shared.randomElement(from: breachRegions)
        } else if !borderlandRegions.isEmpty {
            targetRegion = WorldRNG.shared.randomElement(from: borderlandRegions)
        } else {
            targetRegion = nil
        }

        guard let region = targetRegion,
              let index = regions.firstIndex(where: { $0.id == region.id }) else {
            return
        }

        var updatedRegion = regions[index]
        if var anchor = updatedRegion.anchor {
            anchor.integrity = min(100, anchor.integrity + 15)
            updatedRegion.anchor = anchor
            updatedRegion.updateStateFromAnchor()
            updateRegion(updatedRegion)
        }
    }

    // MARK: - Campaign Market System
    // See EXPLORATION_CORE_DESIGN.md, section 24

    /// Generate market cards based on current region and world state
    /// Market is formed from 3 pools: Global, Regional, Story
    func generateMarket(allCards: [Card], globalPoolSize: Int = 3, regionalPoolSize: Int = 2) -> [Card] {
        var market: [Card] = []

        // 1. Global pool (always available Sustain/Utility cards)
        let globalCards = allCards.filter { card in
            guard let role = card.role else { return false }
            return role == .sustain || role == .utility
        }
        let shuffledGlobal = WorldRNG.shared.shuffled(globalCards)
        market.append(contentsOf: shuffledGlobal.prefix(globalPoolSize))

        // 2. Regional pool (based on current region state)
        if let region = currentRegion {
            let regionalCards = getRegionalCards(allCards: allCards, regionState: region.state)
            let shuffledRegional = WorldRNG.shared.shuffled(regionalCards)
            market.append(contentsOf: shuffledRegional.prefix(regionalPoolSize))
        }

        // 3. Story pool (cards unlocked by flags)
        if let storyCard = getStoryCard(allCards: allCards) {
            market.append(storyCard)
        }

        return market
    }

    /// Get cards appropriate for the region state
    private func getRegionalCards(allCards: [Card], regionState: RegionState) -> [Card] {
        switch regionState {
        case .stable:
            // Stable regions offer Sustain and Control cards
            return allCards.filter { card in
                guard let role = card.role else { return false }
                return role == .sustain || role == .control
            }

        case .borderland:
            // Borderland offers Utility and Power cards
            return allCards.filter { card in
                guard let role = card.role else { return false }
                return role == .utility || role == .power
            }

        case .breach:
            // Breach offers Power cards (risky but rewarding)
            return allCards.filter { card in
                guard let role = card.role else { return false }
                return role == .power
            }
        }
    }

    /// Get a story card if player has the required flag
    private func getStoryCard(allCards: [Card]) -> Card? {
        // Find cards that require specific flags
        let storyCards = allCards.filter { card in
            guard let requirement = card.regionRequirement else { return false }
            return hasFlag(requirement)
        }
        return WorldRNG.shared.randomElement(from: storyCards)
    }

    /// Calculate adjusted card cost based on Light/Dark balance
    func adjustedCardCost(_ card: Card) -> Int {
        return card.adjustedFaithCost(playerBalance: lightDarkBalance)
    }

    // MARK: - Balance Management

    func shiftToLight(by amount: Int) {
        lightDarkBalance = min(100, lightDarkBalance + amount)
    }

    func shiftToDark(by amount: Int) {
        lightDarkBalance = max(0, lightDarkBalance - amount)
    }

    var balanceDescription: String {
        switch lightDarkBalance {
        case 0..<30:
            return "Путь Тьмы"
        case 30..<70:
            return "Нейтральный"
        case 70...100:
            return "Путь Света"
        default:
            return "Неизвестно"
        }
    }

    // MARK: - Event Management

    func getAvailableEvents(for region: Region) -> [GameEvent] {
        return allEvents.filter { event in
            event.canOccur(in: region, worldTension: worldTension, worldFlags: worldFlags)
        }
    }

    /// Взвешенный случайный выбор события
    /// События с большим весом имеют пропорционально большую вероятность быть выбранными
    func selectWeightedRandomEvent(from events: [GameEvent]) -> GameEvent? {
        guard !events.isEmpty else { return nil }

        let totalWeight = events.reduce(0) { $0 + $1.weight }
        guard totalWeight > 0 else {
            // Используем WorldRNG для randomElement
            let index = WorldRNG.shared.nextInt(in: 0..<events.count)
            return events[index]
        }

        // Используем WorldRNG для детерминизма
        let randomValue = WorldRNG.shared.nextInt(in: 1...totalWeight)
        var cumulativeWeight = 0

        for event in events {
            cumulativeWeight += event.weight
            if randomValue <= cumulativeWeight {
                return event
            }
        }

        return events.last
    }

    func markEventCompleted(_ eventId: UUID) {
        if let index = allEvents.firstIndex(where: { $0.id == eventId }) {
            allEvents[index].completed = true
        }
    }

    // MARK: - Event Log Management

    /// Добавить запись в журнал событий
    func logEvent(
        regionName: String,
        eventTitle: String,
        choiceMade: String,
        outcome: String,
        type: EventLogType
    ) {
        let entry = EventLogEntry(
            dayNumber: daysPassed,
            regionName: regionName,
            eventTitle: eventTitle,
            choiceMade: choiceMade,
            outcome: outcome,
            type: type
        )
        eventLog.append(entry)

        // Ограничиваем журнал последними 100 записями
        if eventLog.count > 100 {
            eventLog.removeFirst(eventLog.count - 100)
        }
    }

    /// Добавить запись о путешествии
    func logTravel(from: String, to: String, days: Int) {
        logEvent(
            regionName: to,
            eventTitle: "Путешествие",
            choiceMade: "Отправился в \(to)",
            outcome: "Добрался за \(days) \(days == 1 ? "день" : "дня")",
            type: .travel
        )
    }

    /// Добавить запись об изменении мира
    func logWorldChange(description: String) {
        let regionName = getCurrentRegion()?.name ?? "Мир"
        logEvent(
            regionName: regionName,
            eventTitle: "Изменение мира",
            choiceMade: "-",
            outcome: description,
            type: .worldChange
        )
    }

    /// Получить последние записи журнала
    func getRecentLogEntries(count: Int = 10) -> [EventLogEntry] {
        return Array(eventLog.suffix(count))
    }

    // MARK: - Quest Management

    func startQuest(_ quest: Quest) {
        var newQuest = quest
        newQuest.stage = 1
        activeQuests.append(newQuest)
    }

    func updateQuest(_ updatedQuest: Quest) {
        if let index = activeQuests.firstIndex(where: { $0.id == updatedQuest.id }) {
            activeQuests[index] = updatedQuest

            // Если квест завершен, переместить в завершенные
            if updatedQuest.completed {
                completedQuests.append(updatedQuest.id.uuidString)
                activeQuests.remove(at: index)
            }
        }
    }

    /// Проверка прогресса квеста по флагам (вызывается из processDayStart)
    func checkQuestProgress(_ quest: Quest) {
        // Проверить, выполнены ли условия для текущих целей квеста
        for (index, objective) in quest.objectives.enumerated() {
            if objective.completed { continue }

            // Проверить флаги, связанные с целью
            if let requiredFlags = objective.requiredFlags {
                let allFlagsSet = requiredFlags.allSatisfy { hasFlag($0) }
                if allFlagsSet {
                    var updatedQuest = quest
                    updatedQuest.objectives[index].completed = true
                    updateQuest(updatedQuest)
                }
            }
        }
    }

    // MARK: - Flag Management

    /// Проверить, установлен ли флаг
    func hasFlag(_ key: String) -> Bool {
        return worldFlags[key] == true
    }

    /// Установить значение флага
    func setFlag(_ key: String, value: Bool) {
        worldFlags[key] = value
    }

    /// Получить значение флага (nil если не установлен)
    func getFlag(_ key: String) -> Bool? {
        return worldFlags[key]
    }

    /// Переключить флаг
    func toggleFlag(_ key: String) {
        worldFlags[key] = !(worldFlags[key] ?? false)
    }

    // MARK: - Apply Event Consequences

    func applyConsequences(_ consequences: EventConsequences, to player: Player, in regionId: UUID) {
        // Изменение веры
        if let faithChange = consequences.faithChange {
            if faithChange > 0 {
                player.gainFaith(faithChange)
            } else {
                _ = player.spendFaith(abs(faithChange))
            }
        }

        // Изменение здоровья
        if let healthChange = consequences.healthChange {
            if healthChange > 0 {
                player.heal(healthChange)
            } else {
                player.takeDamage(abs(healthChange))
            }
        }

        // Изменение баланса
        if let balanceChange = consequences.balanceChange {
            if balanceChange > 0 {
                shiftToLight(by: abs(balanceChange))
            } else {
                shiftToDark(by: abs(balanceChange))
            }
        }

        // Изменение напряжения мира
        if let tensionChange = consequences.tensionChange {
            if tensionChange > 0 {
                increaseTension(by: tensionChange)
            } else {
                decreaseTension(by: abs(tensionChange))
            }
        }

        // Изменение репутации
        if let reputationChange = consequences.reputationChange,
           let index = regions.firstIndex(where: { $0.id == regionId }) {
            regions[index].reputation += reputationChange
            regions[index].reputation = max(-100, min(100, regions[index].reputation))
        }

        // Изменение целостности якоря
        if let anchorChange = consequences.anchorIntegrityChange {
            if var region = getRegion(byId: regionId),
               var anchor = region.anchor {
                anchor.integrity = max(0, min(100, anchor.integrity + anchorChange))
                region.anchor = anchor
                region.updateStateFromAnchor()
                updateRegion(region)
            }
        }

        // Установка флагов (ключевая механика — события не меняют мир напрямую, а через флаги)
        // См. EXPLORATION_CORE_DESIGN.md, раздел 18.7
        var flagsChanged = false
        if let flags = consequences.setFlags {
            for (key, value) in flags {
                setFlag(key, value: value)
                flagsChanged = true
            }
        }

        // Если флаги изменились — проверить прогресс квестов
        if flagsChanged {
            checkQuestObjectivesByFlags(player)
        }

        // Добавление карт в колоду игрока
        if let cardIDs = consequences.addCards {
            for cardID in cardIDs {
                if let card = TwilightMarchesCards.getCardByID(cardID) {
                    // Add card to player's discard pile (standard deck-building mechanic)
                    player.discard.append(card)
                }
            }
        }

        // Проверка триггеров изменения состояния региона
        if consequences.anchorIntegrityChange != nil {
            // Якорь изменён — это может повлиять на глобальное состояние
            checkWorldShiftTriggers()
        }

        // TODO: Добавление проклятий и артефактов
        // if let curseID = consequences.addCurse { ... }
        // if let artifactID = consequences.giveArtifact { ... }
    }

    // MARK: - Quest Management

    /// Complete a quest and give rewards to the player
    func completeQuest(_ questId: UUID, player: Player) {
        guard let index = activeQuests.firstIndex(where: { $0.id == questId }) else { return }

        var quest = activeQuests[index]
        quest.completed = true

        // Move quest from active to completed
        completedQuests.append(quest.id.uuidString)
        activeQuests.remove(at: index)

        // Give rewards
        applyQuestRewards(quest.rewards, to: player)
    }

    /// Apply quest rewards to the player
    func applyQuestRewards(_ rewards: QuestRewards, to player: Player) {
        // Faith reward
        if let faith = rewards.faith {
            player.gainFaith(faith)
        }

        // Card rewards
        if let cardIDs = rewards.cards {
            for cardID in cardIDs {
                if let card = TwilightMarchesCards.getCardByID(cardID) {
                    // Add card to player's discard pile
                    player.discard.append(card)
                }
            }
        }

        // TODO: Artifact rewards
        // if let artifactID = rewards.artifact { ... }

        // TODO: Experience rewards
        // if let experience = rewards.experience { ... }
    }

    // MARK: - Quest Trigger System

    /// Check and update quest objectives based on world flags
    func checkQuestObjectivesByFlags(_ player: Player) {
        for i in 0..<activeQuests.count {
            var quest = activeQuests[i]
            var questUpdated = false

            // Main Quest - Objective 0: Learn about anchors from elder
            if quest.questType == .main && quest.objectives.count > 0 && !quest.objectives[0].completed {
                if worldFlags["main_quest_started"] == true {
                    quest.objectives[0].completed = true
                    questUpdated = true
                    print("Quest objective completed: \(quest.objectives[0].description)")
                }
            }

            // Main Quest - Objective 2: Find Sacred Oak
            if quest.questType == .main && quest.objectives.count > 2 && !quest.objectives[1].completed {
                if worldFlags["found_sacred_oak"] == true {
                    quest.objectives[1].completed = true
                    questUpdated = true
                    print("Quest objective completed: \(quest.objectives[1].description)")
                }
            }

            // Main Quest - Objective 3: Strengthen Oak or find ally
            if quest.questType == .main && quest.objectives.count > 3 && !quest.objectives[2].completed {
                if worldFlags["oak_strengthened"] == true || worldFlags["found_ally"] == true {
                    quest.objectives[2].completed = true
                    questUpdated = true
                    print("Quest objective completed: \(quest.objectives[2].description)")
                }
            }

            // Main Quest - Objective 4: Explore breach in Black Lowlands
            if quest.questType == .main && quest.objectives.count > 4 && !quest.objectives[3].completed {
                if worldFlags["explored_black_lowlands"] == true {
                    quest.objectives[3].completed = true
                    questUpdated = true
                    print("Quest objective completed: \(quest.objectives[3].description)")
                }
            }

            // Main Quest - Objective 5: Defeat Leshy-Guardian
            if quest.questType == .main && quest.objectives.count > 5 && !quest.objectives[4].completed {
                if worldFlags["leshy_guardian_defeated"] == true ||
                   worldFlags["leshy_guardian_peaceful"] == true ||
                   worldFlags["leshy_guardian_corrupted"] == true {
                    quest.objectives[4].completed = true
                    questUpdated = true
                    print("Quest objective completed: \(quest.objectives[4].description)")
                }
            }

            // Check if all objectives are completed
            if questUpdated {
                let allCompleted = quest.objectives.allSatisfy { $0.completed }
                if allCompleted {
                    completeQuest(quest.id, player: player)
                } else {
                    activeQuests[i] = quest
                }
            }
        }
    }

    /// Check quest objectives when visiting a region
    func checkQuestObjectivesByRegion(regionId: UUID, player: Player) {
        guard let region = getRegion(byId: regionId) else { return }

        // Main Quest - Objective 2: Find Sacred Oak
        if region.name == "Священный Дуб" {
            worldFlags["found_sacred_oak"] = true
            checkQuestObjectivesByFlags(player)
        }

        // Main Quest - Objective 4: Explore Black Lowlands
        if region.name == "Чёрная Низина" {
            worldFlags["explored_black_lowlands"] = true
            checkQuestObjectivesByFlags(player)
        }
    }

    /// Check quest objectives when an event is completed
    func checkQuestObjectivesByEvent(eventTitle: String, choiceText: String, player: Player) {
        // Main Quest - Objective 1: Talk to elder
        if eventTitle == "Просьба Старосты" && choiceText.contains("Согласиться") {
            worldFlags["main_quest_started"] = true
            checkQuestObjectivesByFlags(player)
        }

        // Main Quest - Objective 3: Strengthen Oak
        if eventTitle == "Мудрость Священного Дуба" && choiceText.contains("укрепить") {
            worldFlags["oak_strengthened"] = true
            checkQuestObjectivesByFlags(player)
        }

        // Main Quest - Objective 5: Boss defeated
        if eventTitle == "Леший-Хранитель" {
            if choiceText.contains("бой") {
                // Combat will set the flag via combat victory
                // This is handled in GameState after combat
            } else if choiceText.contains("договориться") {
                worldFlags["leshy_guardian_peaceful"] = true
                checkQuestObjectivesByFlags(player)
            } else if choiceText.contains("тьмы") {
                worldFlags["leshy_guardian_corrupted"] = true
                checkQuestObjectivesByFlags(player)
            }
        }
    }

    /// Mark boss as defeated after combat victory
    func markBossDefeated(bossName: String, player: Player) {
        if bossName == "Леший-Хранитель" {
            worldFlags["leshy_guardian_defeated"] = true
            checkQuestObjectivesByFlags(player)
        }
    }

    // MARK: - Data Creation (LEGACY - Replaced by ContentProvider)

    /// DEPRECATED: This method is no longer used.
    /// Region creation now uses `createRegionsFromProvider()` with `TwilightMarchesCodeContentProvider`.
    /// This code is kept as reference only and will be removed in a future version.
    /// See: ENGINE_ARCHITECTURE.md, Section 5 (Data-Driven Architecture)
    @available(*, deprecated, message: "Use createRegionsFromProvider(TwilightMarchesCodeContentProvider.shared) instead")
    private func createInitialRegions() -> [Region] {
        // АКТ I - 7 регионов (2 Stable, 3 Borderland, 2 Breach)
        // LEGACY CODE - Now handled by TwilightMarchesCodeContentProvider

        // 1. Деревня у тракта (Stable) - стартовая точка
        let villageAnchor = Anchor(
            name: "Часовня Света",
            type: .chapel,
            integrity: 85,
            influence: .light,
            power: 6
        )
        var village = Region(
            name: "Деревня у тракта",
            type: .settlement,
            state: .stable,
            anchor: villageAnchor,
            reputation: 30
        )
        village.updateStateFromAnchor()

        // 2. Священный Дуб (Stable) - точка силы
        let oakAnchor = Anchor(
            name: "Священный Дуб Велеса",
            type: .sacredTree,
            integrity: 90,
            influence: .light,
            power: 8
        )
        var oak = Region(
            name: "Священный Дуб",
            type: .sacred,
            state: .stable,
            anchor: oakAnchor,
            reputation: 25
        )
        oak.updateStateFromAnchor()

        // 3. Дремучий Лес (Borderland) - первая опасная зона
        let forestAnchor = Anchor(
            name: "Каменный Идол",
            type: .stoneIdol,
            integrity: 55,
            influence: .neutral,
            power: 5
        )
        var forest = Region(
            name: "Дремучий Лес",
            type: .forest,
            state: .borderland,
            anchor: forestAnchor,
            reputation: 0
        )
        forest.updateStateFromAnchor()

        // 4. Болото Нави (Borderland) - зона искажения
        let swampAnchor = Anchor(
            name: "Осквернённый Родник",
            type: .spring,
            integrity: 45,
            influence: .dark,
            power: 4
        )
        var swamp = Region(
            name: "Болото Нави",
            type: .swamp,
            state: .borderland,
            anchor: swampAnchor,
            reputation: -15
        )
        swamp.updateStateFromAnchor()

        // 5. Горный Перевал (Borderland) - путь к узлу
        let mountainAnchor = Anchor(
            name: "Курган Предков",
            type: .barrow,
            integrity: 50,
            influence: .neutral,
            power: 5
        )
        var mountain = Region(
            name: "Горный Перевал",
            type: .mountain,
            state: .borderland,
            anchor: mountainAnchor,
            reputation: 5
        )
        mountain.updateStateFromAnchor()

        // 6. Разлом Курганов (Breach) - первый узел вторжения
        let breachAnchor = Anchor(
            name: "Разрушенное Капище",
            type: .shrine,
            integrity: 15,
            influence: .dark,
            power: 3
        )
        var breach = Region(
            name: "Разлом Курганов",
            type: .wasteland,
            state: .breach,
            anchor: breachAnchor,
            reputation: -40
        )
        breach.updateStateFromAnchor()

        // 7. Чёрная Низина (Breach) - финал Акта I
        // Нет якоря - полностью разрушен
        var darkLowland = Region(
            name: "Чёрная Низина",
            type: .swamp,
            state: .breach,
            anchor: nil,
            reputation: -60
        )
        darkLowland.updateStateFromAnchor()

        // Настроить связи между регионами (соседи)
        // Карта Акта I:
        //     Oak ─── Forest ─── Mountain
        //      │        │            │
        //   Village ─────┼─────── Breach ─── Dark Lowland
        //      │                    │
        //    Swamp ─────────────────┘

        village.neighborIds = [oak.id, forest.id, swamp.id]
        oak.neighborIds = [village.id, forest.id]
        forest.neighborIds = [village.id, oak.id, mountain.id]
        swamp.neighborIds = [village.id, breach.id]
        mountain.neighborIds = [forest.id, breach.id]
        breach.neighborIds = [swamp.id, mountain.id, darkLowland.id]
        darkLowland.neighborIds = [breach.id]

        return [village, oak, forest, swamp, mountain, breach, darkLowland]
    }

    private func createInitialEvents() -> [GameEvent] {
        // MARK: - Data-Driven Events (ContentRegistry)
        // First, try to load events from ContentRegistry (new architecture)
        let registryEvents = ContentRegistry.shared.getAllEvents()
        if !registryEvents.isEmpty {
            print("📦 Loading \(registryEvents.count) events from ContentRegistry")
            return registryEvents.map { $0.toGameEvent() }
        }

        // MARK: - Legacy Hardcoded Events (fallback)
        print("⚠️ ContentRegistry empty, using legacy hardcoded events")
        var events: [GameEvent] = []

        // 1. COMBAT EVENT: Встреча с лешим (Forest guardian)
        let leshyMonster = Card(
            id: UUID(),
            name: "Леший",
            type: .monster,
            rarity: .uncommon,
            description: "Древний страж леса, чья сила растет от гнева.",
            power: 4,
            defense: 8,
            health: 12,
            cost: nil,
            abilities: [],
            balance: .neutral
        )

        let leshyEvent = GameEvent(
            eventType: .combat,
            title: "Встреча с Лешим",
            description: "Из чащи появляется древний страж леса. Его глаза горят зеленым огнем, а ветви скрипят угрожающе. Леший преграждает путь.",
            regionTypes: [.forest, .swamp],
            regionStates: [.borderland, .breach],
            choices: [
                EventChoice(
                    text: "Вступить в бой с духом леса",
                    requirements: EventRequirements(minimumHealth: 3),
                    consequences: EventConsequences(
                        faithChange: 1,
                        message: "Приготовьтесь к бою!"
                    )
                ),
                EventChoice(
                    text: "Попытаться задобрить дарами (стоит 5 ✨)",
                    requirements: EventRequirements(minimumFaith: 5),
                    consequences: EventConsequences(
                        faithChange: -5,
                        balanceChange: 5,
                        tensionChange: -5,
                        message: "Леший принял дары и пропустил вас. Лес стал спокойнее."
                    )
                ),
                EventChoice(
                    text: "Отступить и обойти стороной",
                    consequences: EventConsequences(
                        faithChange: nil,
                        healthChange: nil,
                        balanceChange: nil,
                        tensionChange: nil,
                        reputationChange: -5,
                        message: "Вы отступили, избежав конфликта, но потеряли уважение местных духов."
                    )
                )
            ],
            oneTime: false,
            monsterCard: leshyMonster
        )
        events.append(leshyEvent)

        // 2. RITUAL/CHOICE EVENT: Древний ритуал
        let ritualEvent = GameEvent(
            eventType: .ritual,
            title: "Древний Ритуал",
            description: "Вы находите место силы - старинное капище с угасающим пламенем. Вы чувствуете, что можете либо возродить святилище Света, либо осквернить его силой Тьмы для получения власти.",
            regionTypes: [.forest, .sacred, .mountain],
            regionStates: [.stable, .borderland],
            choices: [
                EventChoice(
                    text: "Возродить святилище Света (10 ✨)",
                    requirements: EventRequirements(minimumFaith: 10, minimumHealth: nil, requiredBalance: .light),
                    consequences: EventConsequences(
                        faithChange: -10,
                        balanceChange: 15,
                        tensionChange: -10,
                        anchorIntegrityChange: 20,
                        message: "Святилище возрождено! Свет Яви становится сильнее в этом регионе."
                    )
                ),
                EventChoice(
                    text: "Осквернить ритуал для получения силы",
                    requirements: EventRequirements(requiredBalance: .dark),
                    consequences: EventConsequences(
                        faithChange: 15,
                        balanceChange: -20,
                        tensionChange: 15,
                        addCards: ["dark_power_card"],
                        anchorIntegrityChange: -30,
                        message: "Вы получили темную силу, но Навь усилилась в этом месте."
                    )
                ),
                EventChoice(
                    text: "Не вмешиваться и уйти",
                    consequences: EventConsequences(
                        message: "Вы оставили место силы нетронутым."
                    )
                )
            ],
            oneTime: true
        )
        events.append(ritualEvent)

        // 3. NARRATIVE EVENT: Странник на развилке
        let wandererEvent = GameEvent(
            eventType: .narrative,
            title: "Странник на Развилке",
            description: "Старый путник сидит у костра. Он предлагает поделиться знаниями о мире в обмен на помощь.",
            regionTypes: [.forest, .settlement, .mountain],
            regionStates: [.stable, .borderland],
            choices: [
                EventChoice(
                    text: "Выслушать рассказы странника (3 ✨)",
                    requirements: EventRequirements(minimumFaith: 3),
                    consequences: EventConsequences(
                        faithChange: -3,
                        healthChange: nil,
                        balanceChange: nil,
                        tensionChange: nil,
                        reputationChange: nil,
                        addCards: nil,
                        addCurse: nil,
                        giveArtifact: nil,
                        setFlags: ["met_wanderer": true],
                        anchorIntegrityChange: nil,
                        message: "Странник рассказал вам о древних путях и тайнах мира."
                    )
                ),
                EventChoice(
                    text: "Помочь ему припасами",
                    consequences: EventConsequences(
                        faithChange: -2,
                        healthChange: nil,
                        balanceChange: 5,
                        tensionChange: nil,
                        reputationChange: 10,
                        addCards: nil,
                        addCurse: nil,
                        giveArtifact: nil,
                        setFlags: nil,
                        anchorIntegrityChange: nil,
                        message: "Странник благодарен за помощь и благословляет ваш путь."
                    )
                ),
                EventChoice(
                    text: "Пройти мимо",
                    consequences: EventConsequences(
                        message: "Вы продолжили свой путь."
                    )
                )
            ],
            oneTime: true
        )
        events.append(wandererEvent)

        // 4. EXPLORATION EVENT: Заброшенный храм
        let templeEvent = GameEvent(
            eventType: .exploration,
            title: "Заброшенный Храм",
            description: "Вы находите руины древнего храма. Внутри чувствуется присутствие силы, но и опасность.",
            regionTypes: [.settlement, .wasteland, .sacred],
            regionStates: [.borderland, .breach],
            choices: [
                EventChoice(
                    text: "Тщательно исследовать храм",
                    requirements: EventRequirements(minimumHealth: 5),
                    consequences: EventConsequences(
                        faithChange: 8,
                        healthChange: -3,
                        balanceChange: nil,
                        tensionChange: nil,
                        reputationChange: nil,
                        addCards: ["ancient_blessing"],
                        addCurse: nil,
                        giveArtifact: nil,
                        setFlags: nil,
                        anchorIntegrityChange: nil,
                        message: "Вы нашли древнюю реликвию, но исследование было опасным."
                    )
                ),
                EventChoice(
                    text: "Быстро осмотреть и уйти",
                    consequences: EventConsequences(
                        faithChange: 3,
                        message: "Вы нашли немного ценностей и быстро покинули опасное место."
                    )
                ),
                EventChoice(
                    text: "Обойти храм стороной",
                    consequences: EventConsequences(
                        message: "Вы решили не рисковать."
                    )
                )
            ],
            oneTime: false
        )
        events.append(templeEvent)

        // 5. WORLD SHIFT EVENT: Усиление Нави
        let breachEvent = GameEvent(
            eventType: .worldShift,
            title: "Прорыв Нави",
            description: "Граница между мирами истончается. Темные силы пытаются прорваться в Явь через слабый якорь.",
            regionTypes: [.forest, .swamp, .settlement, .wasteland],
            regionStates: [.breach],
            choices: [
                EventChoice(
                    text: "Укрепить якорь своей верой (15 ✨)",
                    requirements: EventRequirements(minimumFaith: 15),
                    consequences: EventConsequences(
                        faithChange: -15,
                        balanceChange: 10,
                        tensionChange: -20,
                        anchorIntegrityChange: 30,
                        message: "Вы закрыли прорыв! Регион стабилизировался."
                    )
                ),
                EventChoice(
                    text: "Отступить и предупредить других",
                    consequences: EventConsequences(
                        faithChange: nil,
                        healthChange: nil,
                        balanceChange: nil,
                        tensionChange: 10,
                        reputationChange: 5,
                        addCards: nil,
                        addCurse: nil,
                        giveArtifact: nil,
                        setFlags: nil,
                        anchorIntegrityChange: -10,
                        message: "Вы предупредили о прорыве, но Навь усилилась."
                    )
                ),
                EventChoice(
                    text: "Попытаться использовать силу прорыва",
                    requirements: EventRequirements(requiredBalance: .dark),
                    consequences: EventConsequences(
                        faithChange: 10,
                        healthChange: -5,
                        balanceChange: -15,
                        tensionChange: 5,
                        addCurse: "breach_corruption",
                        message: "Вы получили силу Нави, но она оставила след на вашей душе."
                    )
                )
            ],
            oneTime: false
        )
        events.append(breachEvent)

        // 6. UNIVERSAL EVENT: Дикий зверь (works in all regions)
        let beastMonster = Card(
            id: UUID(),
            name: "Дикий Зверь",
            type: .monster,
            rarity: .common,
            description: "Озверевшее создание, искаженное влиянием Нави.",
            power: 3,
            defense: 6,
            health: 8,
            cost: nil,
            abilities: [],
            balance: .dark
        )

        let beastEvent = GameEvent(
            eventType: .combat,
            title: "Дикий Зверь",
            description: "Из-за деревьев выскакивает озверевшее существо с горящими красными глазами. Оно рычит и готовится к атаке!",
            regionTypes: [], // Empty = all region types
            regionStates: [.stable, .borderland, .breach], // All states
            choices: [
                EventChoice(
                    text: "Сразиться со зверем",
                    requirements: EventRequirements(minimumHealth: 2),
                    consequences: EventConsequences(
                        message: "Вы вступаете в бой!"
                    )
                ),
                EventChoice(
                    text: "Попытаться испугать зверя (5 ✨)",
                    requirements: EventRequirements(minimumFaith: 5),
                    consequences: EventConsequences(
                        faithChange: -5,
                        message: "Вы используете силу веры, чтобы отпугнуть зверя."
                    )
                ),
                EventChoice(
                    text: "Убежать",
                    consequences: EventConsequences(
                        faithChange: nil,
                        healthChange: -1,
                        message: "Вы убегаете, но зверь успевает ранить вас."
                    )
                )
            ],
            oneTime: false,
            monsterCard: beastMonster
        )
        events.append(beastEvent)

        // 7. SETTLEMENT EVENT: Торговец на тракте
        let merchantEvent = GameEvent(
            eventType: .narrative,
            title: "Торговец на Тракте",
            description: "Вы встречаете странствующего торговца. У него есть интересные товары, но цены высоки.",
            regionTypes: [.settlement],
            regionStates: [.stable, .borderland],
            choices: [
                EventChoice(
                    text: "Купить благословение (8 ✨)",
                    requirements: EventRequirements(minimumFaith: 8),
                    consequences: EventConsequences(
                        faithChange: -8,
                        healthChange: 3,
                        balanceChange: 5,
                        tensionChange: nil,
                        reputationChange: nil,
                        addCards: ["merchant_blessing"],
                        addCurse: nil,
                        giveArtifact: nil,
                        setFlags: nil,
                        anchorIntegrityChange: nil,
                        message: "Вы приобрели благословение. Ваши силы восстановлены."
                    )
                ),
                EventChoice(
                    text: "Поторговаться за информацию (4 ✨)",
                    requirements: EventRequirements(minimumFaith: 4),
                    consequences: EventConsequences(
                        faithChange: -4,
                        healthChange: nil,
                        balanceChange: nil,
                        tensionChange: nil,
                        reputationChange: 5,
                        addCards: nil,
                        addCurse: nil,
                        giveArtifact: nil,
                        setFlags: ["merchant_info": true],
                        anchorIntegrityChange: nil,
                        message: "Торговец рассказал о путях и опасностях впереди."
                    )
                ),
                EventChoice(
                    text: "Просто поговорить и идти дальше",
                    consequences: EventConsequences(
                        message: "Вы обменялись новостями и продолжили путь."
                    )
                )
            ],
            oneTime: false
        )
        events.append(merchantEvent)

        // 8. MOUNTAIN EVENT: Перевал и горный дух
        let mountainSpiritMonster = Card(
            id: UUID(),
            name: "Горный Дух",
            type: .monster,
            rarity: .uncommon,
            description: "Древний страж горных троп, испытывающий путников.",
            power: 5,
            defense: 10,
            health: 14,
            cost: nil,
            abilities: [],
            balance: .neutral
        )

        let mountainEvent = GameEvent(
            eventType: .combat,
            title: "Испытание Перевала",
            description: "На горном перевале появляется каменный дух. Он говорит: 'Докажи свою силу или вернись назад, смертный!'",
            regionTypes: [.mountain],
            regionStates: [.stable, .borderland, .breach],
            choices: [
                EventChoice(
                    text: "Принять вызов духа",
                    requirements: EventRequirements(minimumHealth: 4),
                    consequences: EventConsequences(
                        faithChange: 2,
                        message: "Вы принимаете вызов горного духа!"
                    )
                ),
                EventChoice(
                    text: "Предложить дар горам (10 ✨)",
                    requirements: EventRequirements(minimumFaith: 10),
                    consequences: EventConsequences(
                        faithChange: -10,
                        healthChange: nil,
                        balanceChange: 8,
                        tensionChange: nil,
                        reputationChange: 15,
                        addCards: nil,
                        addCurse: nil,
                        giveArtifact: nil,
                        setFlags: ["mountain_blessing": true],
                        anchorIntegrityChange: nil,
                        message: "Горный дух принял дар. Он благословил ваш путь через перевал."
                    )
                ),
                EventChoice(
                    text: "Отступить с перевала",
                    consequences: EventConsequences(
                        message: "Вы спускаетесь вниз, не приняв вызов."
                    )
                )
            ],
            oneTime: true,
            monsterCard: mountainSpiritMonster
        )
        events.append(mountainEvent)

        // 9. SACRED EVENT: Священный Дуб
        let oakEvent = GameEvent(
            eventType: .ritual,
            title: "Мудрость Священного Дуба",
            description: "Древний дуб шепчет вам на языке ветра. Вы чувствуете его древнюю силу и мудрость веков.",
            regionTypes: [.sacred, .forest],
            regionStates: [.stable, .borderland],
            choices: [
                EventChoice(
                    text: "Медитировать под дубом (6 ✨)",
                    requirements: EventRequirements(minimumFaith: 6),
                    consequences: EventConsequences(
                        faithChange: -6,
                        healthChange: 5,
                        balanceChange: 10,
                        tensionChange: nil,
                        reputationChange: nil,
                        addCards: nil,
                        addCurse: nil,
                        giveArtifact: nil,
                        setFlags: ["oak_wisdom": true],
                        anchorIntegrityChange: nil,
                        message: "Дуб поделился древней мудростью. Вы чувствуете прилив сил и ясность разума."
                    )
                ),
                EventChoice(
                    text: "Укрепить связь дуба с землей (12 ✨)",
                    requirements: EventRequirements(minimumFaith: 12, minimumHealth: nil, requiredBalance: .light),
                    consequences: EventConsequences(
                        faithChange: -12,
                        healthChange: nil,
                        balanceChange: 15,
                        tensionChange: -15,
                        reputationChange: nil,
                        addCards: nil,
                        addCurse: nil,
                        giveArtifact: nil,
                        setFlags: ["oak_strengthened": true],
                        anchorIntegrityChange: 25,
                        message: "Вы усилили якорь! Священный Дуб сияет обновленной силой."
                    )
                ),
                EventChoice(
                    text: "Просто отдохнуть в тени дуба",
                    consequences: EventConsequences(
                        faithChange: nil,
                        healthChange: 2,
                        message: "Вы отдохнули под защитой древнего дуба."
                    )
                )
            ],
            oneTime: false
        )
        events.append(oakEvent)

        // 10. SWAMP EVENT: Болотная ведьма
        let swampWitchEvent = GameEvent(
            eventType: .narrative,
            title: "Болотная Ведьма",
            description: "Среди болотных туманов появляется старая ведьма. Она предлагает сделку: знания в обмен на часть вашей сущности.",
            regionTypes: [.swamp],
            regionStates: [.borderland, .breach],
            choices: [
                EventChoice(
                    text: "Принять сделку ведьмы",
                    requirements: EventRequirements(minimumHealth: 4),
                    consequences: EventConsequences(
                        faithChange: 5,
                        healthChange: -3,
                        balanceChange: -10,
                        addCards: ["witch_knowledge", "dark_pact"],
                        addCurse: "witch_mark",
                        setFlags: ["witch_pact": true],
                        message: "Ведьма дала вам темные знания, но вы чувствуете проклятие на своей душе."
                    )
                ),
                EventChoice(
                    text: "Отказаться и попросить о помощи (7 ✨)",
                    requirements: EventRequirements(minimumFaith: 7),
                    consequences: EventConsequences(
                        faithChange: -7,
                        healthChange: 2,
                        balanceChange: nil,
                        tensionChange: nil,
                        reputationChange: nil,
                        addCards: nil,
                        addCurse: nil,
                        giveArtifact: nil,
                        setFlags: ["witch_refused": true],
                        anchorIntegrityChange: nil,
                        message: "Ведьма уважает вашу стойкость и дает небольшую помощь без платы."
                    )
                ),
                EventChoice(
                    text: "Уйти, не связываясь с ведьмой",
                    consequences: EventConsequences(
                        message: "Вы обходите ведьму стороной и продолжаете путь через болото."
                    )
                )
            ],
            oneTime: true
        )
        events.append(swampWitchEvent)

        // 11. WASTELAND EVENT: Разлом Курганов
        let barrowWraithMonster = Card(
            id: UUID(),
            name: "Курганный Призрак",
            type: .monster,
            rarity: .rare,
            description: "Древний воин, восставший из кургана под влиянием Нави.",
            power: 6,
            defense: 8,
            health: 16,
            cost: nil,
            abilities: [],
            balance: .dark
        )

        let barrowEvent = GameEvent(
            eventType: .combat,
            title: "Стражи Курганов",
            description: "Древние курганы вскрываются, и из них поднимаются призрачные воины. Они защищают сокровища предков.",
            regionTypes: [.wasteland],
            regionStates: [.breach],
            choices: [
                EventChoice(
                    text: "Сразиться с призраками",
                    requirements: EventRequirements(minimumHealth: 5),
                    consequences: EventConsequences(
                        message: "Вы вступаете в бой с древними стражами!"
                    )
                ),
                EventChoice(
                    text: "Провести ритуал упокоения (15 ✨)",
                    requirements: EventRequirements(minimumFaith: 15, minimumHealth: nil, requiredBalance: .light),
                    consequences: EventConsequences(
                        faithChange: -15,
                        healthChange: nil,
                        balanceChange: 20,
                        tensionChange: -10,
                        reputationChange: nil,
                        addCards: ["ancestral_blessing"],
                        addCurse: nil,
                        giveArtifact: nil,
                        setFlags: ["barrow_cleansed": true],
                        anchorIntegrityChange: nil,
                        message: "Вы упокоили древних воинов. Они благословляют вас перед уходом."
                    )
                ),
                EventChoice(
                    text: "Разграбить курган и бежать",
                    consequences: EventConsequences(
                        faithChange: 5,
                        healthChange: -4,
                        balanceChange: -15,
                        tensionChange: nil,
                        reputationChange: nil,
                        addCards: nil,
                        addCurse: "ancestral_wrath",
                        giveArtifact: nil,
                        setFlags: nil,
                        anchorIntegrityChange: nil,
                        message: "Вы захватили сокровища, но навлекли гнев предков."
                    )
                )
            ],
            oneTime: false,
            monsterCard: barrowWraithMonster
        )
        events.append(barrowEvent)

        // 11. BOSS EVENT: Леший-Хранитель (Final Boss of Act I)
        let leshyGuardianBoss = TwilightMarchesCards.createLeshyGuardianBoss()
        let bossEvent = GameEvent(
            eventType: .combat,
            title: "Леший-Хранитель",
            description: "Перед вами возвышается древний страж Сумрачных Пределов. Леший-Хранитель - существо невиданной силы, чьи корни уходят в самые основы мира. Зелёное пламя в его глазах горит вечностью. Это финальное испытание Акта I.",
            regionTypes: [.swamp],
            regionStates: [.breach],
            choices: [
                EventChoice(
                    text: "Вступить в решающий бой",
                    requirements: EventRequirements(minimumFaith: 10, minimumHealth: 8),
                    consequences: EventConsequences(
                        message: "Последняя битва начинается! Судьба Сумрачных Пределов решается здесь!"
                    )
                ),
                EventChoice(
                    text: "Попытаться договориться (20 ✨)",
                    requirements: EventRequirements(minimumFaith: 20, minimumHealth: nil, requiredBalance: .light),
                    consequences: EventConsequences(
                        faithChange: -20,
                        healthChange: nil,
                        balanceChange: 15,
                        tensionChange: -20,
                        reputationChange: nil,
                        addCards: ["guardian_seal"],
                        addCurse: nil,
                        giveArtifact: nil,
                        setFlags: ["leshy_guardian_peaceful": true],
                        anchorIntegrityChange: nil,
                        message: "Хранитель видит свет в вашей душе и соглашается помочь вам. Он вручает вам печать защитника."
                    )
                ),
                EventChoice(
                    text: "Использовать силу тьмы (15 ✨)",
                    requirements: EventRequirements(minimumFaith: 15, minimumHealth: nil, requiredBalance: .dark),
                    consequences: EventConsequences(
                        faithChange: -15,
                        healthChange: -5,
                        balanceChange: -20,
                        tensionChange: nil,
                        reputationChange: nil,
                        addCards: ["corrupted_power"],
                        addCurse: nil,
                        giveArtifact: nil,
                        setFlags: ["leshy_guardian_corrupted": true],
                        anchorIntegrityChange: nil,
                        message: "Вы обрушиваете на хранителя силу тьмы. Он ослабевает, но часть его сущности входит в вас..."
                    )
                )
            ],
            questLinks: [], // Will be linked to main quest ID dynamically
            oneTime: true,
            monsterCard: leshyGuardianBoss
        )
        events.append(bossEvent)

        // 12. QUEST EVENT: Деревенский староста (Main Quest trigger)
        let elderEvent = GameEvent(
            eventType: .narrative,
            title: "Просьба Старосты",
            description: "Деревенский староста просит о помощи. Навь усиливается, и деревне нужен защитник, способный укрепить якоря и противостоять тьме.",
            regionTypes: [.settlement],
            regionStates: [.stable, .borderland],
            choices: [
                EventChoice(
                    text: "Согласиться помочь деревне",
                    consequences: EventConsequences(
                        faithChange: 3,
                        reputationChange: 20,
                        setFlags: ["main_quest_started": true, "helped_village": true],
                        message: "Староста благодарен. Он рассказывает о трех главных якорях, которые нужно укрепить."
                    )
                ),
                EventChoice(
                    text: "Попросить награду (10 ✨)",
                    consequences: EventConsequences(
                        faithChange: 10,
                        reputationChange: 5,
                        setFlags: ["main_quest_started": true, "mercenary_path": true],
                        message: "Староста соглашается заплатить. Вы берете задание как наемник."
                    )
                ),
                EventChoice(
                    text: "Отказать и идти своим путем",
                    consequences: EventConsequences(
                        faithChange: nil,
                        healthChange: nil,
                        balanceChange: nil,
                        tensionChange: nil,
                        reputationChange: -10,
                        setFlags: ["refused_main_quest": true],
                        message: "Староста разочарован вашим отказом."
                    )
                )
            ],
            questLinks: ["main_quest_act1"],
            oneTime: true
        )
        events.append(elderEvent)

        // 13. SIDE QUEST: Потерянный ребенок
        let lostChildEvent = GameEvent(
            eventType: .narrative,
            title: "Плач в Лесу",
            description: "Вы слышите детский плач в чаще. Местные говорят, что ребенок пропал три дня назад.",
            regionTypes: [.forest, .swamp],
            regionStates: [.borderland, .breach],
            choices: [
                EventChoice(
                    text: "Отправиться на поиски ребенка",
                    requirements: EventRequirements(minimumHealth: 4),
                    consequences: EventConsequences(
                        faithChange: -5,
                        healthChange: -2,
                        balanceChange: nil,
                        tensionChange: nil,
                        reputationChange: nil,
                        addCards: nil,
                        addCurse: nil,
                        giveArtifact: nil,
                        setFlags: ["child_quest_started": true],
                        anchorIntegrityChange: nil,
                        message: "Вы уходите вглубь леса на поиски пропавшего ребенка."
                    )
                ),
                EventChoice(
                    text: "Использовать веру для поиска (8 ✨)",
                    requirements: EventRequirements(minimumFaith: 8),
                    consequences: EventConsequences(
                        faithChange: -8,
                        healthChange: nil,
                        balanceChange: 15,
                        tensionChange: nil,
                        reputationChange: 25,
                        addCards: nil,
                        addCurse: nil,
                        giveArtifact: nil,
                        setFlags: ["child_saved": true],
                        anchorIntegrityChange: nil,
                        message: "Ваша вера помогла найти ребенка быстро. Деревня очень благодарна!"
                    )
                ),
                EventChoice(
                    text: "Это слишком опасно, вернуться",
                    consequences: EventConsequences(
                        faithChange: nil,
                        healthChange: nil,
                        balanceChange: nil,
                        tensionChange: nil,
                        reputationChange: -15,
                        addCards: nil,
                        addCurse: nil,
                        giveArtifact: nil,
                        setFlags: nil,
                        anchorIntegrityChange: nil,
                        message: "Вы решаете не рисковать. Судьба ребенка остается неизвестной."
                    )
                )
            ],
            questLinks: ["side_quest_lost_child"],
            oneTime: true
        )
        events.append(lostChildEvent)

        // 14. REST EVENT: Привал у костра
        let campEvent = GameEvent(
            eventType: .narrative,
            title: "Безопасное Место для Привала",
            description: "Вы находите укрытое место, подходящее для отдыха. Можно развести костер и восстановить силы.",
            regionTypes: [.forest, .mountain, .settlement],
            regionStates: [.stable, .borderland],
            choices: [
                EventChoice(
                    text: "Отдохнуть и восстановиться",
                    consequences: EventConsequences(
                        faithChange: 2,
                        healthChange: 4,
                        message: "Вы отдохнули у костра. Силы восстановлены."
                    )
                ),
                EventChoice(
                    text: "Провести ритуал очищения (5 ✨)",
                    requirements: EventRequirements(minimumFaith: 5),
                    consequences: EventConsequences(
                        faithChange: -5,
                        healthChange: 3,
                        balanceChange: 5,
                        message: "Ритуал очищения освежил тело и дух."
                    )
                ),
                EventChoice(
                    text: "Быстро перекусить и идти дальше",
                    consequences: EventConsequences(
                        faithChange: nil,
                        healthChange: 1,
                        message: "Вы немного отдохнули и продолжили путь."
                    )
                )
            ],
            oneTime: false
        )
        events.append(campEvent)

        // 15. WORLD SHIFT: Сдвиг границ (Act I critical event)
        let realmShiftEvent = GameEvent(
            eventType: .worldShift,
            title: "Сдвиг Границ Миров",
            description: "Граница между Явью и Навью содрогается. Вы чувствуете, как реальность искажается вокруг вас. Это критический момент.",
            regionTypes: [], // All regions
            regionStates: [.breach],
            choices: [
                EventChoice(
                    text: "Стабилизировать границу верой (20 ✨)",
                    requirements: EventRequirements(minimumFaith: 20, minimumHealth: nil, requiredBalance: .light),
                    consequences: EventConsequences(
                        faithChange: -20,
                        healthChange: nil,
                        balanceChange: 25,
                        tensionChange: -25,
                        reputationChange: nil,
                        addCards: nil,
                        addCurse: nil,
                        giveArtifact: nil,
                        setFlags: ["realm_stabilized": true],
                        anchorIntegrityChange: 40,
                        message: "Вы закрыли прорыв! Граница миров укреплена вашей верой."
                    )
                ),
                EventChoice(
                    text: "Использовать момент для получения силы",
                    requirements: EventRequirements(minimumFaith: 10, minimumHealth: nil, requiredBalance: .dark),
                    consequences: EventConsequences(
                        faithChange: 15,
                        healthChange: -5,
                        balanceChange: -20,
                        tensionChange: 15,
                        reputationChange: nil,
                        addCards: ["realm_power", "nav_essence"],
                        addCurse: "realm_corruption",
                        giveArtifact: nil,
                        setFlags: nil,
                        anchorIntegrityChange: nil,
                        message: "Вы вытянули силу из прорыва, но Навь пометила вас."
                    )
                ),
                EventChoice(
                    text: "Бежать от сдвига",
                    consequences: EventConsequences(
                        faithChange: nil,
                        healthChange: -3,
                        balanceChange: nil,
                        tensionChange: 20,
                        anchorIntegrityChange: -20,
                        message: "Вы бежите, но сдвиг усиливается. Мир становится опаснее."
                    )
                )
            ],
            questLinks: ["main_quest_act1"],
            oneTime: false
        )
        events.append(realmShiftEvent)

        return events
    }

    // MARK: - Initial Quests (Act I)

    private func createInitialQuests() -> [Quest] {
        // MARK: - Data-Driven Quests (ContentRegistry)
        // First, try to load quests from ContentRegistry (new architecture)
        let registryQuests = ContentRegistry.shared.getAllQuests()
        if !registryQuests.isEmpty {
            print("📦 Loading \(registryQuests.count) quests from ContentRegistry")
            return registryQuests.map { $0.toQuest() }
        }

        // MARK: - Legacy Hardcoded Quests (fallback)
        print("⚠️ ContentRegistry empty, using legacy hardcoded quests")
        var quests: [Quest] = []

        // MAIN QUEST: Путь Защитника (5 stages)
        let mainQuest = Quest(
            id: UUID(),
            title: "Путь Защитника",
            description: "Деревня в опасности. Навь усиливается с каждым днем. Вы должны укрепить три главных якоря и защитить границу между мирами.",
            questType: .main,
            stage: 0,
            objectives: [
                QuestObjective(
                    description: "Узнать о трех главных якорях от старосты",
                    completed: false
                ),
                QuestObjective(
                    description: "Найти Священный Дуб",
                    completed: false
                ),
                QuestObjective(
                    description: "Укрепить Дуб или найти союзника",
                    completed: false
                ),
                QuestObjective(
                    description: "Исследовать прорыв Нави в Чёрной Низине",
                    completed: false
                ),
                QuestObjective(
                    description: "Победить Лешего-Хранителя",
                    completed: false
                )
            ],
            rewards: QuestRewards(
                faith: 20,
                cards: ["defender_blessing", "anchor_power"],
                artifact: "guardian_seal",
                experience: 100
            ),
            completed: false
        )
        quests.append(mainQuest)

        // SIDE QUEST 1: Потерянный ребенок
        let lostChildQuest = Quest(
            id: UUID(),
            title: "Потерянный Ребенок",
            description: "Маленький ребенок пропал в лесу три дня назад. Его родители в отчаянии. Лес становится все опаснее с каждым часом.",
            questType: .side,
            stage: 0,
            objectives: [
                QuestObjective(
                    description: "Найти следы ребенка в лесу",
                    completed: false
                ),
                QuestObjective(
                    description: "Спасти ребенка от лесных духов",
                    completed: false
                ),
                QuestObjective(
                    description: "Вернуть ребенка в деревню",
                    completed: false
                )
            ],
            rewards: QuestRewards(
                faith: 8,
                cards: ["village_gratitude"],
                experience: 30
            ),
            completed: false
        )
        quests.append(lostChildQuest)

        // SIDE QUEST 2: Торговые пути
        let tradeRoutesQuest = Quest(
            id: UUID(),
            title: "Безопасность Торговых Путей",
            description: "Торговцы жалуются на участившиеся нападения на дорогах. Нужно очистить три ключевых участка пути.",
            questType: .side,
            stage: 0,
            objectives: [
                QuestObjective(
                    description: "Очистить лесную дорогу от тварей",
                    completed: false
                ),
                QuestObjective(
                    description: "Защитить караван через горный перевал",
                    completed: false
                ),
                QuestObjective(
                    description: "Договориться с лешим о безопасном проходе",
                    completed: false
                )
            ],
            rewards: QuestRewards(
                faith: 12,
                cards: ["merchant_discount", "trade_blessing"],
                experience: 40
            ),
            completed: false
        )
        quests.append(tradeRoutesQuest)

        // SIDE QUEST 3: Сделка с ведьмой
        let witchQuestLight = Quest(
            id: UUID(),
            title: "Тайна Болотной Ведьмы",
            description: "Болотная ведьма знает древние секреты. Она может помочь в борьбе с Навью, но за какую цену?",
            questType: .side,
            stage: 0,
            objectives: [
                QuestObjective(
                    description: "Найти ведьму в болоте",
                    completed: false
                ),
                QuestObjective(
                    description: "Выслушать её предложение",
                    completed: false
                ),
                QuestObjective(
                    description: "Сделать выбор: принять сделку или найти другой путь",
                    completed: false
                )
            ],
            rewards: QuestRewards(
                faith: 10,
                cards: ["witch_knowledge"],
                experience: 35
            ),
            completed: false
        )
        quests.append(witchQuestLight)

        // SIDE QUEST 4: Курганы предков
        let barrowQuest = Quest(
            id: UUID(),
            title: "Проклятие Курганов",
            description: "Древние курганы вскрылись, и мертвые восстали. Нужно упокоить духов предков или победить их.",
            questType: .side,
            stage: 0,
            objectives: [
                QuestObjective(
                    description: "Исследовать Разлом Курганов",
                    completed: false
                ),
                QuestObjective(
                    description: "Найти причину пробуждения мертвых",
                    completed: false
                ),
                QuestObjective(
                    description: "Упокоить духов или победить призраков",
                    completed: false
                )
            ],
            rewards: QuestRewards(
                faith: 15,
                cards: ["ancestral_blessing", "warrior_spirit"],
                artifact: "ancient_relic",
                experience: 50
            ),
            completed: false
        )
        quests.append(barrowQuest)

        // SIDE QUEST 5: Странствующий монах
        let monkQuest = Quest(
            id: UUID(),
            title: "Испытание Монаха",
            description: "Странствующий монах предлагает испытание духа. Пройдя его, вы обретете мудрость и силу.",
            questType: .side,
            stage: 0,
            objectives: [
                QuestObjective(
                    description: "Найти монаха в священном месте",
                    completed: false
                ),
                QuestObjective(
                    description: "Пройти три испытания: тела, разума и духа",
                    completed: false
                ),
                QuestObjective(
                    description: "Доказать свою чистоту намерений",
                    completed: false
                )
            ],
            rewards: QuestRewards(
                faith: 18,
                cards: ["inner_peace", "spiritual_armor"],
                experience: 45
            ),
            completed: false
        )
        quests.append(monkQuest)

        // SIDE QUEST 6: Дух горного перевала
        let mountainSpiritQuest = Quest(
            id: UUID(),
            title: "Благословение Гор",
            description: "Горный дух испытывает путников. Докажите свою силу или мудрость, чтобы получить благословение перевала.",
            questType: .side,
            stage: 0,
            objectives: [
                QuestObjective(
                    description: "Добраться до горного перевала",
                    completed: false
                ),
                QuestObjective(
                    description: "Встретить горного духа",
                    completed: false
                ),
                QuestObjective(
                    description: "Пройти испытание или принести достойный дар",
                    completed: false
                )
            ],
            rewards: QuestRewards(
                faith: 10,
                cards: ["mountain_blessing", "stone_armor"],
                experience: 35
            ),
            completed: false
        )
        quests.append(mountainSpiritQuest)

        return quests
    }

    // MARK: - Narrative System (Endings & Deck Path)
    // See EXPLORATION_CORE_DESIGN.md, sections 28-34

    /// Calculate player's dominant deck path based on card balance alignment
    ///
    /// Edge case: Если в колоде нет карт со смещением (все neutral или колода пуста),
    /// путь считается нейтральным (.balance). Это корректное поведение —
    /// игрок, не делавший выбора между Светом и Тьмой, идёт путём Равновесия.
    func calculateDeckPath(playerDeck: [Card]) -> DeckPath {
        guard !playerDeck.isEmpty else { return .balance }

        var lightCount = 0
        var darkCount = 0
        var neutralCount = 0

        for card in playerDeck {
            switch card.balance {
            case .light:
                lightCount += 1
            case .dark:
                darkCount += 1
            case .neutral, .none:
                neutralCount += 1
            }
        }

        let total = playerDeck.count
        let lightRatio = Double(lightCount) / Double(total)
        let darkRatio = Double(darkCount) / Double(total)

        // Need >50% of one type to be considered on that path
        // Если нет явного большинства — путь Равновесия
        if lightRatio > 0.5 {
            return .light
        } else if darkRatio > 0.5 {
            return .dark
        } else {
            return .balance
        }
    }

    /// Determine the ending based on world state and player choices
    /// See EXPLORATION_CORE_DESIGN.md, section 32 for ending matrix
    func determineEnding(playerDeck: [Card], allEndings: [EndingProfile]) -> EndingProfile? {
        let deckPath = calculateDeckPath(playerDeck: playerDeck)

        // Calculate anchor states summary
        let stableAnchors = regions.filter { $0.state == .stable }.count
        let breachAnchors = regions.filter { $0.state == .breach }.count

        // Check each ending's conditions
        for ending in allEndings {
            let conditions = ending.conditions

            // Check WorldTension range
            if let minTension = conditions.minTension, worldTension < minTension {
                continue
            }
            if let maxTension = conditions.maxTension, worldTension > maxTension {
                continue
            }

            // Check required flags
            if let requiredFlags = conditions.requiredFlags {
                let hasAllFlags = requiredFlags.allSatisfy { hasFlag($0) }
                if !hasAllFlags {
                    continue
                }
            }

            // Check forbidden flags
            if let forbiddenFlags = conditions.forbiddenFlags {
                let hasAnyForbidden = forbiddenFlags.contains { hasFlag($0) }
                if hasAnyForbidden {
                    continue
                }
            }

            // Check deck path requirement
            if let requiredPath = conditions.deckPath, deckPath != requiredPath {
                continue
            }

            // Check anchor state requirements
            if let minStable = conditions.minStableAnchors, stableAnchors < minStable {
                continue
            }
            if let maxBreach = conditions.maxBreachAnchors, breachAnchors > maxBreach {
                continue
            }

            // Check balance range
            if let minBalance = conditions.minBalance, lightDarkBalance < minBalance {
                continue
            }
            if let maxBalance = conditions.maxBalance, lightDarkBalance > maxBalance {
                continue
            }

            // All conditions met - return this ending
            return ending
        }

        // Fallback: return first ending or nil
        return allEndings.first
    }

    /// Get summary of current state for ending evaluation
    func getEndingStateDescription(playerDeck: [Card]) -> String {
        let deckPath = calculateDeckPath(playerDeck: playerDeck)
        let stableCount = regions.filter { $0.state == .stable }.count
        let breachCount = regions.filter { $0.state == .breach }.count

        return """
        Напряжение: \(worldTension)/100
        Баланс: \(balanceDescription) (\(lightDarkBalance))
        Путь колоды: \(deckPath.rawValue)
        Якоря: \(stableCount) stable, \(breachCount) breach
        Активные флаги: \(worldFlags.filter { $0.value }.count)
        """
    }

    /// Check if a main quest step can be unlocked
    func canUnlockQuestStep(_ step: MainQuestStep) -> Bool {
        let conditions = step.unlockConditions

        // Check required flags
        if let requiredFlags = conditions.requiredFlags {
            let hasAllFlags = requiredFlags.allSatisfy { hasFlag($0) }
            if !hasAllFlags { return false }
        }

        // Check forbidden flags
        if let forbiddenFlags = conditions.forbiddenFlags {
            let hasAnyForbidden = forbiddenFlags.contains { hasFlag($0) }
            if hasAnyForbidden { return false }
        }

        // Check tension requirements
        if let minTension = conditions.minTension, worldTension < minTension {
            return false
        }
        if let maxTension = conditions.maxTension, worldTension > maxTension {
            return false
        }

        // Check balance requirements
        if let minBalance = conditions.minBalance, lightDarkBalance < minBalance {
            return false
        }
        if let maxBalance = conditions.maxBalance, lightDarkBalance > maxBalance {
            return false
        }

        return true
    }

    /// Check if a main quest step is completed
    func isQuestStepCompleted(_ step: MainQuestStep) -> Bool {
        let conditions = step.completionConditions

        // Check required flags
        if let requiredFlags = conditions.requiredFlags {
            let hasAllFlags = requiredFlags.allSatisfy { hasFlag($0) }
            if !hasAllFlags { return false }
        }

        // Check forbidden flags (things that must NOT have happened)
        if let forbiddenFlags = conditions.forbiddenFlags {
            let hasAnyForbidden = forbiddenFlags.contains { hasFlag($0) }
            if hasAnyForbidden { return false }
        }

        return true
    }

    // MARK: - Codable Implementation

    enum CodingKeys: String, CodingKey {
        case regions
        case worldTension
        case lightDarkBalance
        case mainQuestStage
        case activeQuests
        case completedQuests
        case worldFlags
        case allEvents
        case currentRegionId
        case daysPassed
        case eventLog
    }

    required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        regions = try container.decode([Region].self, forKey: .regions)
        worldTension = try container.decode(Int.self, forKey: .worldTension)
        lightDarkBalance = try container.decode(Int.self, forKey: .lightDarkBalance)
        mainQuestStage = try container.decode(Int.self, forKey: .mainQuestStage)
        activeQuests = try container.decode([Quest].self, forKey: .activeQuests)
        completedQuests = try container.decode([String].self, forKey: .completedQuests)
        worldFlags = try container.decode([String: Bool].self, forKey: .worldFlags)
        allEvents = try container.decode([GameEvent].self, forKey: .allEvents)
        currentRegionId = try container.decodeIfPresent(UUID.self, forKey: .currentRegionId)
        daysPassed = try container.decode(Int.self, forKey: .daysPassed)
        eventLog = try container.decodeIfPresent([EventLogEntry].self, forKey: .eventLog) ?? []
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(regions, forKey: .regions)
        try container.encode(worldTension, forKey: .worldTension)
        try container.encode(lightDarkBalance, forKey: .lightDarkBalance)
        try container.encode(mainQuestStage, forKey: .mainQuestStage)
        try container.encode(activeQuests, forKey: .activeQuests)
        try container.encode(completedQuests, forKey: .completedQuests)
        try container.encode(worldFlags, forKey: .worldFlags)
        try container.encode(allEvents, forKey: .allEvents)
        try container.encodeIfPresent(currentRegionId, forKey: .currentRegionId)
        try container.encode(daysPassed, forKey: .daysPassed)
        try container.encode(eventLog, forKey: .eventLog)
    }
}

// MARK: - Twilight Marches Content Provider
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 5 (Data-Driven Architecture)
// This provider defines all game content for Twilight Marches

/// Content provider with Twilight Marches game definitions.
/// Separates content (Data) from runtime state (WorldState).
final class TwilightMarchesCodeContentProvider: CodeContentProvider {

    // MARK: - Region Loading

    override func loadRegions() {
        // ACT I - 7 regions (2 Stable, 3 Borderland, 2 Breach)

        // 1. Village (Stable) - starting point
        let village = RegionDefinition(
            id: "village",
            title: LocalizedString(en: "Border Village", ru: "Пограничная Деревня"),
            description: LocalizedString(en: "A small village on the edge of the realm", ru: "Небольшая деревня на краю королевства"),
            neighborIds: ["oak", "forest", "swamp"],
            initiallyDiscovered: true,
            anchorId: "anchor_village_chapel",
            eventPoolIds: ["pool_village", "pool_common"],
            initialState: .stable
        )
        registerRegion(village)

        // 2. Sacred Oak (Stable) - point of power
        let oak = RegionDefinition(
            id: "oak",
            title: LocalizedString(en: "Sacred Oak", ru: "Священный Дуб"),
            description: LocalizedString(en: "An ancient oak radiating divine power", ru: "Древний дуб, излучающий божественную силу"),
            neighborIds: ["village", "forest"],
            initiallyDiscovered: false,
            anchorId: "anchor_sacred_oak",
            eventPoolIds: ["pool_sacred", "pool_common"],
            initialState: .stable
        )
        registerRegion(oak)

        // 3. Dense Forest (Borderland)
        let forest = RegionDefinition(
            id: "forest",
            title: LocalizedString(en: "Dark Forest", ru: "Тёмный Лес"),
            description: LocalizedString(en: "A dense forest shrouded in shadow", ru: "Густой лес, окутанный тенью"),
            neighborIds: ["village", "oak", "mountain"],
            initiallyDiscovered: false,
            anchorId: "anchor_forest_idol",
            eventPoolIds: ["pool_forest", "pool_common"],
            initialState: .borderland,
            degradationWeight: 1
        )
        registerRegion(forest)

        // 4. Navi Swamp (Borderland)
        let swamp = RegionDefinition(
            id: "swamp",
            title: LocalizedString(en: "Cursed Swamp", ru: "Проклятое Болото"),
            description: LocalizedString(en: "A murky swamp tainted by dark magic", ru: "Мрачное болото, отравленное тёмной магией"),
            neighborIds: ["village", "breach"],
            initiallyDiscovered: false,
            anchorId: "anchor_swamp_spring",
            eventPoolIds: ["pool_swamp", "pool_common"],
            initialState: .borderland,
            degradationWeight: 1
        )
        registerRegion(swamp)

        // 5. Mountain Pass (Borderland)
        let mountain = RegionDefinition(
            id: "mountain",
            title: LocalizedString(en: "Mountain Pass", ru: "Горный Перевал"),
            description: LocalizedString(en: "A treacherous pass through the mountains", ru: "Опасный путь через горы"),
            neighborIds: ["forest", "breach"],
            initiallyDiscovered: false,
            anchorId: "anchor_mountain_barrow",
            eventPoolIds: ["pool_mountain", "pool_common"],
            initialState: .borderland,
            degradationWeight: 1
        )
        registerRegion(mountain)

        // 6. Barrow Breach (Breach)
        let breach = RegionDefinition(
            id: "breach",
            title: LocalizedString(en: "The Breach", ru: "Разлом"),
            description: LocalizedString(en: "A tear in reality where darkness seeps through", ru: "Разрыв в реальности, откуда сочится тьма"),
            neighborIds: ["swamp", "mountain", "dark_lowland"],
            initiallyDiscovered: false,
            anchorId: "anchor_breach_shrine",
            eventPoolIds: ["pool_breach", "pool_common"],
            initialState: .breach,
            degradationWeight: 2
        )
        registerRegion(breach)

        // 7. Dark Lowlands (Breach) - Act I finale
        let darkLowland = RegionDefinition(
            id: "dark_lowland",
            title: LocalizedString(en: "Dark Lowland", ru: "Тёмная Низина"),
            description: LocalizedString(en: "A forsaken land consumed by darkness", ru: "Проклятая земля, поглощённая тьмой"),
            neighborIds: ["breach"],
            initiallyDiscovered: false,
            anchorId: nil, // No anchor - fully destroyed
            eventPoolIds: ["pool_boss", "pool_breach"],
            initialState: .breach,
            degradationWeight: 2
        )
        registerRegion(darkLowland)

        rebuildIndices()
    }

    // MARK: - Anchor Loading

    override func loadAnchors() {
        // Village anchor
        let villageChapel = AnchorDefinition(
            id: "anchor_village_chapel",
            title: LocalizedString(en: "Village Chapel", ru: "Деревенская Часовня"),
            description: LocalizedString(en: "A small chapel offering protection to the village", ru: "Небольшая часовня, защищающая деревню"),
            regionId: "village",
            anchorType: "chapel",
            initialInfluence: .light,
            power: 6,
            initialIntegrity: 85
        )
        registerAnchor(villageChapel)

        // Sacred Oak anchor
        let sacredOak = AnchorDefinition(
            id: "anchor_sacred_oak",
            title: LocalizedString(en: "Sacred Oak", ru: "Священный Дуб"),
            description: LocalizedString(en: "An ancient tree imbued with divine essence", ru: "Древнее дерево, наполненное божественной сущностью"),
            regionId: "oak",
            anchorType: "sacred_tree",
            initialInfluence: .light,
            power: 8,
            initialIntegrity: 90
        )
        registerAnchor(sacredOak)

        // Forest idol anchor
        let forestIdol = AnchorDefinition(
            id: "anchor_forest_idol",
            title: LocalizedString(en: "Forest Stone Idol", ru: "Лесной Каменный Идол"),
            description: LocalizedString(en: "A weathered stone idol of forgotten gods", ru: "Обветшалый каменный идол забытых богов"),
            regionId: "forest",
            anchorType: "stone_idol",
            initialInfluence: .neutral,
            power: 5,
            initialIntegrity: 55
        )
        registerAnchor(forestIdol)

        // Swamp spring anchor
        let swampSpring = AnchorDefinition(
            id: "anchor_swamp_spring",
            title: LocalizedString(en: "Corrupted Spring", ru: "Осквернённый Источник"),
            description: LocalizedString(en: "A once-pure spring now tainted by darkness", ru: "Некогда чистый источник, осквернённый тьмой"),
            regionId: "swamp",
            anchorType: "spring",
            initialInfluence: .dark,
            power: 4,
            initialIntegrity: 45
        )
        registerAnchor(swampSpring)

        // Mountain barrow anchor
        let mountainBarrow = AnchorDefinition(
            id: "anchor_mountain_barrow",
            title: LocalizedString(en: "Ancestor Barrow", ru: "Курган Предков"),
            description: LocalizedString(en: "An ancient burial mound of revered ancestors", ru: "Древний курган почитаемых предков"),
            regionId: "mountain",
            anchorType: "barrow",
            initialInfluence: .neutral,
            power: 5,
            initialIntegrity: 50
        )
        registerAnchor(mountainBarrow)

        // Breach shrine anchor
        let breachShrine = AnchorDefinition(
            id: "anchor_breach_shrine",
            title: LocalizedString(en: "Breach Ward Shrine", ru: "Святилище у Разлома"),
            description: LocalizedString(en: "A crumbling shrine that wards against the breach", ru: "Разрушающееся святилище, защищающее от разлома"),
            regionId: "breach",
            anchorType: "shrine",
            initialInfluence: .dark,
            power: 3,
            initialIntegrity: 15
        )
        registerAnchor(breachShrine)
    }

    // MARK: - Localization Helpers

    /// Get localized region name
    static func regionName(for id: String) -> String {
        switch id {
        case "village": return "Деревня у тракта"
        case "oak": return "Священный Дуб"
        case "forest": return "Дремучий Лес"
        case "swamp": return "Болото Нави"
        case "mountain": return "Горный Перевал"
        case "breach": return "Разлом Курганов"
        case "dark_lowland": return "Чёрная Низина"
        default: return id
        }
    }

    /// Get localized anchor name
    static func anchorName(for id: String) -> String {
        switch id {
        case "anchor_village_chapel": return "Часовня Света"
        case "anchor_sacred_oak": return "Священный Дуб Велеса"
        case "anchor_forest_idol": return "Каменный Идол"
        case "anchor_swamp_spring": return "Осквернённый Родник"
        case "anchor_mountain_barrow": return "Курган Предков"
        case "anchor_breach_shrine": return "Разрушенное Капище"
        default: return id
        }
    }
}


// ==========================================
// FILE: Utilities/AccessibilityIdentifiers.swift
// ==========================================

import Foundation

/// Централизованные accessibility identifiers для UI тестов
/// Используйте эти константы вместо строковых литералов
enum AccessibilityIdentifiers {

    // MARK: - WorldMapView

    enum WorldMap {
        static let view = "worldMapView"
        static let playerInfoBar = "playerInfoBar"
        static let worldInfoBar = "worldInfoBar"
        static let regionsList = "regionsList"

        static func regionCard(_ regionId: UUID) -> String {
            "regionCard_\(regionId.uuidString)"
        }

        static func regionCard(name: String) -> String {
            "regionCard_\(name)"
        }
    }

    // MARK: - RegionDetailView

    enum RegionDetail {
        static let view = "regionDetailView"
        static let anchorInfo = "anchorInfo"
        static let stateIndicator = "stateIndicator"

        // Actions
        static let actionTravel = "action_travel"
        static let actionRest = "action_rest"
        static let actionTrade = "action_trade"
        static let actionExplore = "action_explore"
        static let actionStrengthenAnchor = "action_strengthenAnchor"
    }

    // MARK: - EventView

    enum Event {
        static let view = "eventView"
        static let title = "eventTitle"
        static let description = "eventDescription"
        static let consequencesPreview = "consequencesPreview"
        static let closeButton = "closeEvent"

        static func choice(_ choiceId: UUID) -> String {
            "choice_\(choiceId.uuidString)"
        }

        static func choice(index: Int) -> String {
            "choice_\(index)"
        }
    }

    // MARK: - CombatView

    enum Combat {
        static let view = "combatView"
        static let monsterCard = "monsterCard"
        static let playerStats = "playerStats"
        static let actionBar = "actionBar"
        static let combatLog = "combatLog"
        static let playerHand = "playerHand"

        // Actions
        static let attackButton = "attackButton"
        static let endTurnButton = "endTurnButton"
        static let fleeButton = "fleeButton"

        static func handCard(_ cardId: UUID) -> String {
            "handCard_\(cardId.uuidString)"
        }
    }

    // MARK: - GameBoardView

    enum GameBoard {
        static let view = "gameBoardView"
        static let topBar = "topBar"
        static let encounterArea = "encounterArea"
        static let marketView = "marketView"
        static let deckInfo = "deckInfo"
        static let phaseProgress = "phaseProgress"

        static let pauseButton = "pauseButton"
        static let nextPhaseButton = "nextPhaseButton"
        static let rollDiceButton = "rollDiceButton"
    }

    // MARK: - MainMenu / ContentView

    enum MainMenu {
        static let view = "mainMenuView"
        static let continueButton = "continueButton"
        static let newGameButton = "newGameButton"
        static let loadGameButton = "loadGameButton"
        static let settingsButton = "settingsButton"
    }
}


// ==========================================
// FILE: Utilities/SafeImage.swift
// ==========================================

import SwiftUI

// MARK: - Safe Image Loading
// Audit 2.0 Requirement: Fallback System for missing icons
// If icon not found in Assets → show default placeholder

/// Safe image view that handles missing assets gracefully
struct SafeImage: View {
    let name: String
    let fallbackSystemName: String

    init(_ name: String, fallback: String = "questionmark.circle") {
        self.name = name
        self.fallbackSystemName = fallback
    }

    var body: some View {
        if let uiImage = UIImage(named: name) {
            Image(uiImage: uiImage)
                .resizable()
                .scaledToFit()
        } else {
            // Fallback: show SF Symbol placeholder
            Image(systemName: fallbackSystemName)
                .foregroundColor(.secondary)
        }
    }
}

/// Safe async image loading with fallback
struct SafeAsyncImage: View {
    let name: String
    let fallbackSystemName: String

    init(_ name: String, fallback: String = "questionmark.circle") {
        self.name = name
        self.fallbackSystemName = fallback
    }

    var body: some View {
        if UIImage(named: name) != nil {
            Image(name)
                .resizable()
                .scaledToFit()
        } else {
            Image(systemName: fallbackSystemName)
                .foregroundColor(.secondary)
        }
    }
}

// MARK: - Image Validation Utility

/// Utility to validate asset availability at runtime
enum AssetValidator {

    /// Check if asset exists in bundle
    static func assetExists(_ name: String, in bundle: Bundle = .main) -> Bool {
        return UIImage(named: name, in: bundle, compatibleWith: nil) != nil
    }

    /// Validate all icons referenced in content pack
    static func validatePackIcons(icons: [String], in bundle: Bundle = .main) -> [String] {
        return icons.filter { !assetExists($0, in: bundle) }
    }

    /// Get safe icon name with fallback
    static func safeIconName(_ name: String?, fallback: String = "questionmark.circle") -> String {
        guard let name = name, !name.isEmpty else {
            return fallback
        }

        // If it looks like an SF Symbol (contains period), assume it exists
        if name.contains(".") {
            return name
        }

        // For custom assets, check if they exist
        if assetExists(name) {
            return name
        } else {
            return fallback
        }
    }
}

// MARK: - View Extension for Safe Images

extension View {
    /// Apply safe icon with fallback
    func safeIcon(_ name: String?, fallback: String = "questionmark.circle") -> some View {
        let safeName = AssetValidator.safeIconName(name, fallback: fallback)
        return AnyView(
            Group {
                if safeName.contains(".") {
                    // SF Symbol
                    Image(systemName: safeName)
                } else {
                    // Custom asset
                    SafeImage(safeName, fallback: fallback)
                }
            }
        )
    }
}

// MARK: - Preview

#if DEBUG
struct SafeImage_Previews: PreviewProvider {
    static var previews: some View {
        VStack(spacing: 20) {
            // Existing asset (should show image)
            SafeImage("AppIcon", fallback: "star.fill")
                .frame(width: 50, height: 50)

            // Missing asset (should show fallback)
            SafeImage("nonexistent_icon", fallback: "exclamationmark.triangle")
                .frame(width: 50, height: 50)

            // SF Symbol style
            Image(systemName: AssetValidator.safeIconName("valid.symbol", fallback: "questionmark"))
                .font(.largeTitle)
        }
        .padding()
    }
}
#endif


// ==========================================
// FILE: Utilities/WorldRNG.swift
// ==========================================

import Foundation

// MARK: - World Random Number Generator
// Детерминированный RNG для воспроизводимости игрового мира
// Использует LCG (Linear Congruential Generator) - тот же алгоритм что в тестах

/// Протокол для внедрения RNG в игровой мир
protocol WorldRandomGenerator {
    mutating func nextDouble() -> Double
    mutating func nextInt(in range: Range<Int>) -> Int
    mutating func nextInt(in range: ClosedRange<Int>) -> Int
}

/// Детерминированный RNG с seed (для тестов и воспроизводимости)
struct SeededWorldRNG: WorldRandomGenerator, RandomNumberGenerator {
    private(set) var state: UInt64

    init(seed: UInt64) {
        self.state = seed
    }

    mutating func next() -> UInt64 {
        // LCG параметры (те же что в существующих тестах)
        state = state &* 6364136223846793005 &+ 1442695040888963407
        return state
    }

    mutating func nextDouble() -> Double {
        // Преобразуем UInt64 в Double в диапазоне [0, 1)
        return Double(next()) / Double(UInt64.max)
    }

    mutating func nextInt(in range: Range<Int>) -> Int {
        guard !range.isEmpty else { return range.lowerBound }
        let bound = UInt64(range.count)
        return range.lowerBound + Int(next() % bound)
    }

    mutating func nextInt(in range: ClosedRange<Int>) -> Int {
        let bound = UInt64(range.count)
        return range.lowerBound + Int(next() % bound)
    }
}

/// Системный RNG (обёртка над Swift random для единообразия интерфейса)
struct SystemWorldRNG: WorldRandomGenerator {
    mutating func nextDouble() -> Double {
        return Double.random(in: 0..<1)
    }

    mutating func nextInt(in range: Range<Int>) -> Int {
        return Int.random(in: range)
    }

    mutating func nextInt(in range: ClosedRange<Int>) -> Int {
        return Int.random(in: range)
    }
}

// MARK: - WorldRNG Singleton with Injection Support

/// Глобальный RNG для игрового мира с поддержкой инъекции для тестов
final class WorldRNG {
    /// Shared instance (по умолчанию системный RNG)
    static var shared: WorldRNG = WorldRNG()

    private var rng: any WorldRandomGenerator

    /// Инициализация с системным RNG (по умолчанию)
    init() {
        self.rng = SystemWorldRNG()
    }

    /// Инициализация с seeded RNG (для тестов)
    init(seed: UInt64) {
        self.rng = SeededWorldRNG(seed: seed)
    }

    /// Установить seed для детерминированного поведения
    func setSeed(_ seed: UInt64) {
        self.rng = SeededWorldRNG(seed: seed)
    }

    /// Сбросить на системный RNG
    func resetToSystem() {
        self.rng = SystemWorldRNG()
    }

    /// Случайное Double в [0, 1)
    func nextDouble() -> Double {
        return rng.nextDouble()
    }

    /// Случайный Int в диапазоне [lowerBound, upperBound)
    func nextInt(in range: Range<Int>) -> Int {
        return rng.nextInt(in: range)
    }

    /// Случайный Int в диапазоне [lowerBound, upperBound]
    func nextInt(in range: ClosedRange<Int>) -> Int {
        return rng.nextInt(in: range)
    }

    /// Проверка вероятности (возвращает true с вероятностью p)
    func checkProbability(_ p: Double) -> Bool {
        return nextDouble() < p
    }

    // MARK: - Collection Helpers (Deterministic)

    /// Выбрать случайный элемент из массива (детерминировано)
    func randomElement<T>(from array: [T]) -> T? {
        guard !array.isEmpty else { return nil }
        let index = nextInt(in: 0..<array.count)
        return array[index]
    }

    /// Детерминированный shuffle массива (Fisher-Yates с WorldRNG)
    func shuffled<T>(_ array: [T]) -> [T] {
        guard array.count > 1 else { return array }
        var result = array
        for i in stride(from: result.count - 1, through: 1, by: -1) {
            let j = nextInt(in: 0...i)
            if i != j {
                result.swapAt(i, j)
            }
        }
        return result
    }
}


// ==========================================
// FILE: Data/TwilightMarchesCards.swift
// ==========================================

import Foundation

// Twilight Marches (Сумрачные Пределы)
// Original Slavic dark fantasy card game

struct TwilightMarchesCards {

    // MARK: - Playable Characters

    static func createGuardians() -> [Card] {
        return [
            // Велеслава - Ведунья пограничья (Vedunya - Wise Woman of the Borderlands)
            Card(
                name: "tm.char.veleslava.name".localized,
                type: .character,
                rarity: .rare,
                description: "tm.char.veleslava.desc".localized,
                power: 3,
                defense: 4,
                health: 10,
                abilities: [
                    CardAbility(
                        name: "tm.ability.herb.wisdom".localized,
                        description: "tm.ability.herb.wisdom.desc".localized,
                        effect: .heal(amount: 3)
                    ),
                    CardAbility(
                        name: "tm.ability.curse.breaker".localized,
                        description: "tm.ability.curse.breaker.desc".localized,
                        effect: .removeCurse(type: nil)
                    )
                ],
                traits: ["tm.trait.healer".localized, "tm.trait.vedunya".localized, "tm.trait.light".localized],
                balance: .light,
                realm: .yav,
                expansionSet: "baseSet"
            ),

            // Ратибор - Воевода-изгнанник (Voevoda - Exiled Warlord)
            Card(
                name: "tm.char.ratibor.name".localized,
                type: .character,
                rarity: .rare,
                description: "tm.char.ratibor.desc".localized,
                power: 8,
                defense: 6,
                health: 14,
                abilities: [
                    CardAbility(
                        name: "tm.ability.battle.fury".localized,
                        description: "tm.ability.battle.fury.desc".localized,
                        effect: .addDice(count: 3)
                    ),
                    CardAbility(
                        name: "tm.ability.commanders.will".localized,
                        description: "tm.ability.commanders.will.desc".localized,
                        effect: .gainFaith(amount: 2)
                    )
                ],
                traits: ["tm.trait.warrior".localized, "tm.trait.voevoda".localized, "tm.trait.neutral".localized],
                balance: .neutral,
                realm: .yav,
                expansionSet: "baseSet"
            ),

            // Мирослав - Волхв-отступник (Volkhv - Apostate Sorcerer)
            Card(
                name: "tm.char.miroslav.name".localized,
                type: .character,
                rarity: .rare,
                description: "tm.char.miroslav.desc".localized,
                power: 6,
                defense: 3,
                health: 9,
                abilities: [
                    CardAbility(
                        name: "tm.ability.dark.pact".localized,
                        description: "tm.ability.dark.pact.desc".localized,
                        effect: .summonSpirit(power: 5, realm: .nav)
                    ),
                    CardAbility(
                        name: "tm.ability.soul.drain".localized,
                        description: "tm.ability.soul.drain.desc".localized,
                        effect: .sacrifice(cost: 2, benefit: "Draw 3 cards")
                    )
                ],
                traits: ["tm.trait.sorcerer".localized, "tm.trait.volkhv".localized, "tm.trait.dark".localized],
                balance: .dark,
                realm: .yav,
                expansionSet: "baseSet"
            ),

            // Забава - Охотница на нечисть (Hunter of the Unclean)
            Card(
                name: "tm.char.zabava.name".localized,
                type: .character,
                rarity: .rare,
                description: "tm.char.zabava.desc".localized,
                power: 7,
                defense: 5,
                health: 11,
                abilities: [
                    CardAbility(
                        name: "tm.ability.silver.arrow".localized,
                        description: "tm.ability.silver.arrow.desc".localized,
                        effect: .damage(amount: 5, type: .physical)
                    ),
                    CardAbility(
                        name: "tm.ability.track.prey".localized,
                        description: "tm.ability.track.prey.desc".localized,
                        effect: .drawCards(count: 2)
                    )
                ],
                traits: ["tm.trait.hunter".localized, "tm.trait.ranger".localized, "tm.trait.neutral".localized],
                range: 3,
                balance: .neutral,
                realm: .yav,
                expansionSet: "baseSet"
            )
        ]
    }

    // MARK: - Enemies from Slavic Mythology

    static func createNavMonsters() -> [Card] {
        return [
            // Навий - Дух мертвого (Navii - Spirit of the Dead)
            Card(
                name: "tm.enemy.navii.name".localized,
                type: .monster,
                rarity: .common,
                description: "tm.enemy.navii.desc".localized,
                power: 3,
                defense: 2,
                health: 5,
                abilities: [
                    CardAbility(
                        name: "tm.ability.soul.touch".localized,
                        description: "tm.ability.soul.touch.desc".localized,
                        effect: .applyCurse(type: .weakness, duration: 2)
                    )
                ],
                traits: ["tm.trait.undead".localized, "tm.trait.spirit".localized, "tm.trait.nav".localized],
                damageType: .mental,
                balance: .dark,
                realm: .nav,
                expansionSet: "baseSet"
            ),

            // Упырь (Upyr - Vampire)
            Card(
                name: "tm.enemy.upyr.name".localized,
                type: .monster,
                rarity: .uncommon,
                description: "tm.enemy.upyr.desc".localized,
                power: 6,
                defense: 4,
                health: 8,
                abilities: [
                    CardAbility(
                        name: "tm.ability.blood.drain".localized,
                        description: "tm.ability.blood.drain.desc".localized,
                        effect: .damage(amount: 4, type: .mental)
                    ),
                    CardAbility(
                        name: "tm.ability.life.steal".localized,
                        description: "tm.ability.life.steal.desc".localized,
                        effect: .heal(amount: 2)
                    )
                ],
                traits: ["tm.trait.undead".localized, "tm.trait.upyr".localized, "tm.trait.nav".localized],
                damageType: .mental,
                balance: .dark,
                realm: .nav,
                expansionSet: "baseSet"
            ),

            // Леший (Leshiy - Forest Spirit)
            Card(
                name: "tm.enemy.leshiy.name".localized,
                type: .monster,
                rarity: .uncommon,
                description: "tm.enemy.leshiy.desc".localized,
                power: 5,
                defense: 6,
                health: 10,
                abilities: [
                    CardAbility(
                        name: "tm.ability.forest.maze".localized,
                        description: "tm.ability.forest.maze.desc".localized,
                        effect: .applyCurse(type: .exhaustion, duration: 3)
                    ),
                    CardAbility(
                        name: "tm.ability.natures.wrath".localized,
                        description: "tm.ability.natures.wrath.desc".localized,
                        effect: .damage(amount: 3, type: .physical)
                    )
                ],
                traits: ["tm.trait.spirit".localized, "tm.trait.nature".localized, "tm.trait.leshiy".localized],
                damageType: .physical,
                balance: .dark,
                realm: .yav,
                expansionSet: "baseSet"
            ),

            // Русалка (Rusalka - Water Spirit)
            Card(
                name: "tm.enemy.rusalka.name".localized,
                type: .monster,
                rarity: .rare,
                description: "tm.enemy.rusalka.desc".localized,
                power: 4,
                defense: 3,
                health: 7,
                abilities: [
                    CardAbility(
                        name: "tm.ability.drowning.song".localized,
                        description: "tm.ability.drowning.song.desc".localized,
                        effect: .applyCurse(type: .fear, duration: 2)
                    ),
                    CardAbility(
                        name: "tm.ability.water.grasp".localized,
                        description: "tm.ability.water.grasp.desc".localized,
                        effect: .damage(amount: 3, type: .cold)
                    )
                ],
                traits: ["tm.trait.spirit".localized, "tm.trait.water".localized, "tm.trait.rusalka".localized],
                damageType: .cold,
                balance: .dark,
                realm: .nav,
                expansionSet: "baseSet"
            ),

            // Змей Горыныч (Zmey Gorynych - Three-Headed Dragon)
            Card(
                name: "tm.enemy.zmey.name".localized,
                type: .monster,
                rarity: .legendary,
                description: "tm.enemy.zmey.desc".localized,
                power: 15,
                defense: 12,
                health: 30,
                abilities: [
                    CardAbility(
                        name: "tm.ability.three.breaths".localized,
                        description: "tm.ability.three.breaths.desc".localized,
                        effect: .damage(amount: 10, type: .fire)
                    ),
                    CardAbility(
                        name: "tm.ability.ancient.curse".localized,
                        description: "tm.ability.ancient.curse.desc".localized,
                        effect: .applyCurse(type: .shadowOfNav, duration: 5)
                    )
                ],
                traits: ["tm.trait.dragon".localized, "tm.trait.ancient".localized, "tm.trait.zmey".localized],
                damageType: .fire,
                balance: .dark,
                realm: .prav,
                expansionSet: "baseSet"
            )
        ]
    }

    // MARK: - Spirit Cards

    static func createSpirits() -> [Card] {
        return [
            // Домовой (Domovoy - House Spirit)
            Card(
                name: "tm.spirit.domovoy.name".localized,
                type: .spirit,
                rarity: .common,
                description: "tm.spirit.domovoy.desc".localized,
                power: 2,
                defense: 3,
                health: 5,
                cost: 2,
                abilities: [
                    CardAbility(
                        name: "tm.ability.home.guard".localized,
                        description: "tm.ability.home.guard.desc".localized,
                        effect: .addDice(count: 1)
                    )
                ],
                traits: ["tm.trait.spirit".localized, "tm.trait.guardian".localized, "tm.trait.light".localized],
                balance: .light,
                realm: .yav,
                expansionSet: "baseSet"
            ),

            // Берегиня (Bereginya - Protective Spirit)
            Card(
                name: "tm.spirit.bereginya.name".localized,
                type: .spirit,
                rarity: .uncommon,
                description: "tm.spirit.bereginya.desc".localized,
                power: 3,
                defense: 5,
                health: 8,
                cost: 3,
                abilities: [
                    CardAbility(
                        name: "tm.ability.protective.aura".localized,
                        description: "tm.ability.protective.aura.desc".localized,
                        effect: .removeCurse(type: nil)
                    ),
                    CardAbility(
                        name: "tm.ability.blessing.shield".localized,
                        description: "tm.ability.blessing.shield.desc".localized,
                        effect: .shiftBalance(towards: .light, amount: 2)
                    )
                ],
                traits: ["tm.trait.spirit".localized, "tm.trait.bereginya".localized, "tm.trait.light".localized],
                balance: .light,
                realm: .prav,
                expansionSet: "baseSet"
            )
        ]
    }

    // MARK: - Curse Cards

    static func createCurses() -> [Card] {
        return [
            // Черная метка (Black Mark)
            Card(
                name: "tm.curse.black.mark.name".localized,
                type: .curse,
                rarity: .common,
                description: "tm.curse.black.mark.desc".localized,
                cost: 0,
                abilities: [
                    CardAbility(
                        name: "tm.ability.mark.of.nav".localized,
                        description: "tm.ability.mark.of.nav.desc".localized,
                        effect: .applyCurse(type: .weakness, duration: 3)
                    )
                ],
                traits: ["tm.trait.curse".localized, "tm.trait.nav".localized],
                balance: .dark,
                realm: .nav,
                curseType: .weakness,
                expansionSet: "baseSet"
            ),

            // Безумие (Madness)
            Card(
                name: "tm.curse.madness.name".localized,
                type: .curse,
                rarity: .uncommon,
                description: "tm.curse.madness.desc".localized,
                cost: 0,
                abilities: [
                    CardAbility(
                        name: "tm.ability.lose.sanity".localized,
                        description: "tm.ability.lose.sanity.desc".localized,
                        effect: .applyCurse(type: .fear, duration: 4)
                    )
                ],
                traits: ["tm.trait.curse".localized, "tm.trait.mental".localized],
                balance: .dark,
                realm: .nav,
                curseType: .fear,
                expansionSet: "baseSet"
            )
        ]
    }

    // MARK: - Artifact Cards

    static func createArtifacts() -> [Card] {
        return [
            // Калинов Меч (Kalinov Sword - Legendary Blade)
            Card(
                name: "tm.artifact.kalinov.sword.name".localized,
                type: .artifact,
                rarity: .legendary,
                description: "tm.artifact.kalinov.sword.desc".localized,
                power: 10,
                cost: 5,
                abilities: [
                    CardAbility(
                        name: "tm.ability.cleaving.strike".localized,
                        description: "tm.ability.cleaving.strike.desc".localized,
                        effect: .damage(amount: 8, type: .physical)
                    ),
                    CardAbility(
                        name: "tm.ability.banish.darkness".localized,
                        description: "tm.ability.banish.darkness.desc".localized,
                        effect: .shiftBalance(towards: .light, amount: 3)
                    )
                ],
                traits: ["tm.trait.artifact".localized, "tm.trait.weapon".localized, "tm.trait.legendary".localized],
                damageType: .physical,
                balance: .light,
                realm: .prav,
                expansionSet: "baseSet"
            ),

            // Алатырь-камень (Alatyr Stone - Sacred Stone)
            Card(
                name: "tm.artifact.alatyr.stone.name".localized,
                type: .artifact,
                rarity: .epic,
                description: "tm.artifact.alatyr.stone.desc".localized,
                defense: 5,
                cost: 4,
                abilities: [
                    CardAbility(
                        name: "tm.ability.realm.anchor".localized,
                        description: "tm.ability.realm.anchor.desc".localized,
                        effect: .travelRealm(to: .yav)
                    ),
                    CardAbility(
                        name: "tm.ability.restore.balance".localized,
                        description: "tm.ability.restore.balance.desc".localized,
                        effect: .shiftBalance(towards: .neutral, amount: 5)
                    )
                ],
                traits: ["tm.trait.artifact".localized, "tm.trait.sacred".localized, "tm.trait.ancient".localized],
                balance: .neutral,
                realm: .prav,
                expansionSet: "baseSet"
            )
        ]
    }

    // MARK: - Deck Creation

    // MARK: - Starting Decks (10 cards each, unique per hero)

    static func createStartingDeck(for characterName: String) -> [Card] {
        // Determine which character and return their starting deck
        if characterName.contains("Велеслава") || characterName.contains("Veleslava") {
            return createVeleslavaStartingDeck()
        } else if characterName.contains("Ратибор") || characterName.contains("Ratibor") {
            return createRatiborStartingDeck()
        } else if characterName.contains("Мирослав") || characterName.contains("Miroslav") {
            return createMiroslavStartingDeck()
        } else if characterName.contains("Забава") || characterName.contains("Zabava") {
            return createZabavaStartingDeck()
        } else {
            // Default starting deck
            return createGenericStartingDeck()
        }
    }

    // Велеслава - Healer/Light focused deck
    // Card Economy: Resource cards are free (give faith), other cards cost faith to create strategic choices
    static func createVeleslavaStartingDeck() -> [Card] {
        return [
            // 5x Resource cards (FREE - these generate faith when played)
            Card(name: "Травяной Сбор", type: .resource, rarity: .common,
                 description: "Собранные целебные травы. Дают 1 веру.",
                 cost: 0, abilities: [
                     CardAbility(name: "Сбор трав", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))
                 ], balance: .light, realm: .yav),
            Card(name: "Травяной Сбор", type: .resource, rarity: .common,
                 description: "Собранные целебные травы. Дают 1 веру.",
                 cost: 0, abilities: [
                     CardAbility(name: "Сбор трав", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))
                 ], balance: .light, realm: .yav),
            Card(name: "Травяной Сбор", type: .resource, rarity: .common,
                 description: "Собранные целебные травы. Дают 1 веру.",
                 cost: 0, abilities: [
                     CardAbility(name: "Сбор трав", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))
                 ], balance: .light, realm: .yav),
            Card(name: "Травяной Сбор", type: .resource, rarity: .common,
                 description: "Собранные целебные травы. Дают 1 веру.",
                 cost: 0, abilities: [
                     CardAbility(name: "Сбор трав", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))
                 ], balance: .light, realm: .yav),
            Card(name: "Травяной Сбор", type: .resource, rarity: .common,
                 description: "Собранные целебные травы. Дают 1 веру.",
                 cost: 0, abilities: [
                     CardAbility(name: "Сбор трав", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))
                 ], balance: .light, realm: .yav),

            // 2x Attack cards (cost 1 faith - strategic choice)
            Card(name: "Защитный Посох", type: .attack, rarity: .common,
                 description: "Простой посох. Наносит 2 урона. Стоимость: 1 вера.",
                 power: 2, cost: 1, abilities: [], balance: .light, realm: .yav),
            Card(name: "Защитный Посох", type: .attack, rarity: .common,
                 description: "Простой посох. Наносит 2 урона. Стоимость: 1 вера.",
                 power: 2, cost: 1, abilities: [], balance: .light, realm: .yav),

            // 2x Defense cards (cost 1 faith)
            Card(name: "Светлый Оберег", type: .defense, rarity: .common,
                 description: "Простой защитный оберег. Блокирует 1 урона. Стоимость: 1 вера.",
                 defense: 1, cost: 1, abilities: [], balance: .light, realm: .yav),
            Card(name: "Светлый Оберег", type: .defense, rarity: .common,
                 description: "Простой защитный оберег. Блокирует 1 урона. Стоимость: 1 вера.",
                 defense: 1, cost: 1, abilities: [], balance: .light, realm: .yav),

            // 1x Special card (cost 2 faith - powerful effect)
            Card(name: "Исцеляющее Касание", type: .special, rarity: .uncommon,
                 description: "Ведунья лечит раны прикосновением. Восстанавливает 3 здоровья. Стоимость: 2 веры.",
                 cost: 2, abilities: [
                     CardAbility(name: "Исцеление", description: "Восстанавливает 3 здоровья.", effect: .heal(amount: 3))
                 ], balance: .light, realm: .yav)
        ]
    }

    // Ратибор - Warrior/Neutral focused deck
    // Card Economy: Resource cards are free (give faith), other cards cost faith to create strategic choices
    static func createRatiborStartingDeck() -> [Card] {
        return [
            // 5x Resource cards (FREE - these generate faith when played)
            Card(name: "Военная Добыча", type: .resource, rarity: .common,
                 description: "Трофеи с поля боя. Дают 1 веру.",
                 cost: 0, abilities: [
                     CardAbility(name: "Трофей", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))
                 ], balance: .neutral, realm: .yav),
            Card(name: "Военная Добыча", type: .resource, rarity: .common,
                 description: "Трофеи с поля боя. Дают 1 веру.",
                 cost: 0, abilities: [
                     CardAbility(name: "Трофей", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))
                 ], balance: .neutral, realm: .yav),
            Card(name: "Военная Добыча", type: .resource, rarity: .common,
                 description: "Трофеи с поля боя. Дают 1 веру.",
                 cost: 0, abilities: [
                     CardAbility(name: "Трофей", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))
                 ], balance: .neutral, realm: .yav),
            Card(name: "Военная Добыча", type: .resource, rarity: .common,
                 description: "Трофеи с поля боя. Дают 1 веру.",
                 cost: 0, abilities: [
                     CardAbility(name: "Трофей", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))
                 ], balance: .neutral, realm: .yav),
            Card(name: "Военная Добыча", type: .resource, rarity: .common,
                 description: "Трофеи с поля боя. Дают 1 веру.",
                 cost: 0, abilities: [
                     CardAbility(name: "Трофей", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))
                 ], balance: .neutral, realm: .yav),

            // 3x Attack cards (cost 1 faith - stronger than healer)
            Card(name: "Удар Мечом", type: .attack, rarity: .common,
                 description: "Удар воеводы. Наносит 3 урона. Стоимость: 1 вера.",
                 power: 3, cost: 1, abilities: [], balance: .neutral, realm: .yav),
            Card(name: "Удар Мечом", type: .attack, rarity: .common,
                 description: "Удар воеводы. Наносит 3 урона. Стоимость: 1 вера.",
                 power: 3, cost: 1, abilities: [], balance: .neutral, realm: .yav),
            Card(name: "Удар Мечом", type: .attack, rarity: .common,
                 description: "Удар воеводы. Наносит 3 урона. Стоимость: 1 вера.",
                 power: 3, cost: 1, abilities: [], balance: .neutral, realm: .yav),

            // 1x Defense card (cost 1 faith)
            Card(name: "Боевая Стойка", type: .defense, rarity: .common,
                 description: "Защитная стойка воина. Блокирует 2 урона. Стоимость: 1 вера.",
                 defense: 2, cost: 1, abilities: [], balance: .neutral, realm: .yav),

            // 1x Special card (cost 2 faith - powerful effect)
            Card(name: "Боевой Клич", type: .special, rarity: .uncommon,
                 description: "Воевода вдохновляет себя. Получает +2 к атаке до конца хода. Стоимость: 2 веры.",
                 cost: 2, abilities: [
                     CardAbility(name: "Вдохновение", description: "+2 к атаке до конца хода.", effect: .addDice(count: 2))
                 ], balance: .neutral, realm: .yav)
        ]
    }

    // Мирослав - Sorcerer/Dark focused deck
    // Card Economy: Resource cards are free (give faith), other cards cost faith to create strategic choices
    static func createMiroslavStartingDeck() -> [Card] {
        return [
            // 5x Resource cards (FREE - these generate faith when played)
            Card(name: "Темная Энергия", type: .resource, rarity: .common,
                 description: "Энергия из Нави. Даёт 1 веру.",
                 cost: 0, abilities: [
                     CardAbility(name: "Тёмная сила", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))
                 ], balance: .dark, realm: .nav),
            Card(name: "Темная Энергия", type: .resource, rarity: .common,
                 description: "Энергия из Нави. Даёт 1 веру.",
                 cost: 0, abilities: [
                     CardAbility(name: "Тёмная сила", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))
                 ], balance: .dark, realm: .nav),
            Card(name: "Темная Энергия", type: .resource, rarity: .common,
                 description: "Энергия из Нави. Даёт 1 веру.",
                 cost: 0, abilities: [
                     CardAbility(name: "Тёмная сила", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))
                 ], balance: .dark, realm: .nav),
            Card(name: "Темная Энергия", type: .resource, rarity: .common,
                 description: "Энергия из Нави. Даёт 1 веру.",
                 cost: 0, abilities: [
                     CardAbility(name: "Тёмная сила", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))
                 ], balance: .dark, realm: .nav),
            Card(name: "Темная Энергия", type: .resource, rarity: .common,
                 description: "Энергия из Нави. Даёт 1 веру.",
                 cost: 0, abilities: [
                     CardAbility(name: "Тёмная сила", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))
                 ], balance: .dark, realm: .nav),

            // 2x Attack cards (cost 1 faith - magical damage)
            Card(name: "Темный Снаряд", type: .attack, rarity: .common,
                 description: "Магический снаряд тьмы. Наносит 3 урона. Стоимость: 1 вера.",
                 power: 3, cost: 1, abilities: [], damageType: .arcane, balance: .dark, realm: .nav),
            Card(name: "Темный Снаряд", type: .attack, rarity: .common,
                 description: "Магический снаряд тьмы. Наносит 3 урона. Стоимость: 1 вера.",
                 power: 3, cost: 1, abilities: [], damageType: .arcane, balance: .dark, realm: .nav),

            // 1x Defense card (cost 1 faith - weak)
            Card(name: "Теневой Покров", type: .defense, rarity: .common,
                 description: "Защита тенями. Блокирует 1 урона. Стоимость: 1 вера.",
                 defense: 1, cost: 1, abilities: [], balance: .dark, realm: .nav),

            // 1x Special card (FREE - sacrifice health for faith, unique dark mechanic)
            Card(name: "Жертвоприношение", type: .special, rarity: .uncommon,
                 description: "Волхв жертвует здоровьем ради силы. Теряет 2 здоровья, получает 2 веры.",
                 cost: 0, abilities: [
                     CardAbility(name: "Жертва", description: "Теряет 2 здоровья, получает 2 веры.", effect: .sacrifice(cost: 2, benefit: "Gain 2 faith"))
                 ], balance: .dark, realm: .nav),

            // 1x Curse card (starting weakness - must pay faith to discard)
            Card(name: "Темное Проклятие", type: .curse, rarity: .common,
                 description: "Проклятие тьмы. Нужно 1 веру чтобы сбросить.",
                 cost: 1, abilities: [], balance: .dark, realm: .nav, curseType: .weakness)
        ]
    }

    // Забава - Hunter focused deck
    // Card Economy: Resource cards are free (give faith), other cards cost faith to create strategic choices
    static func createZabavaStartingDeck() -> [Card] {
        return [
            // 5x Resource cards (FREE - these generate faith when played)
            Card(name: "Охотничьи Припасы", type: .resource, rarity: .common,
                 description: "Запасы охотника. Дают 1 веру.",
                 cost: 0, abilities: [
                     CardAbility(name: "Припасы", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))
                 ], balance: .neutral, realm: .yav),
            Card(name: "Охотничьи Припасы", type: .resource, rarity: .common,
                 description: "Запасы охотника. Дают 1 веру.",
                 cost: 0, abilities: [
                     CardAbility(name: "Припасы", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))
                 ], balance: .neutral, realm: .yav),
            Card(name: "Охотничьи Припасы", type: .resource, rarity: .common,
                 description: "Запасы охотника. Дают 1 веру.",
                 cost: 0, abilities: [
                     CardAbility(name: "Припасы", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))
                 ], balance: .neutral, realm: .yav),
            Card(name: "Охотничьи Припасы", type: .resource, rarity: .common,
                 description: "Запасы охотника. Дают 1 веру.",
                 cost: 0, abilities: [
                     CardAbility(name: "Припасы", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))
                 ], balance: .neutral, realm: .yav),
            Card(name: "Охотничьи Припасы", type: .resource, rarity: .common,
                 description: "Запасы охотника. Дают 1 веру.",
                 cost: 0, abilities: [
                     CardAbility(name: "Припасы", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))
                 ], balance: .neutral, realm: .yav),

            // 3x Attack cards (cost 1 faith - ranged)
            Card(name: "Выстрел из Лука", type: .attack, rarity: .common,
                 description: "Точный выстрел. Наносит 2 урона. Стоимость: 1 вера.",
                 power: 2, cost: 1, abilities: [], range: 3, balance: .neutral, realm: .yav),
            Card(name: "Выстрел из Лука", type: .attack, rarity: .common,
                 description: "Точный выстрел. Наносит 2 урона. Стоимость: 1 вера.",
                 power: 2, cost: 1, abilities: [], range: 3, balance: .neutral, realm: .yav),
            Card(name: "Выстрел из Лука", type: .attack, rarity: .common,
                 description: "Точный выстрел. Наносит 2 урона. Стоимость: 1 вера.",
                 power: 2, cost: 1, abilities: [], range: 3, balance: .neutral, realm: .yav),

            // 1x Defense card (cost 1 faith)
            Card(name: "Уклонение", type: .defense, rarity: .common,
                 description: "Охотник уклоняется от удара. Блокирует 1 урона. Стоимость: 1 вера.",
                 defense: 1, cost: 1, abilities: [], balance: .neutral, realm: .yav),

            // 1x Special card (cost 2 faith - powerful effect)
            Card(name: "Меткий Выстрел", type: .special, rarity: .uncommon,
                 description: "Охотник целится точнее. Следующая атака наносит +3 урона. Стоимость: 2 веры.",
                 cost: 2, abilities: [
                     CardAbility(name: "Точность", description: "+3 к урону для следующей атаки.", effect: .damage(amount: 3, type: .physical))
                 ], balance: .neutral, realm: .yav)
        ]
    }

    // Generic starting deck for unknown characters
    // Card Economy: Resource cards are free (give faith), other cards cost faith to create strategic choices
    static func createGenericStartingDeck() -> [Card] {
        return [
            // 5x Resource cards (FREE - generate faith)
            Card(name: "Ресурс", type: .resource, rarity: .common,
                 description: "Базовый ресурс. Даёт 1 веру.", cost: 0,
                 abilities: [CardAbility(name: "Ресурс", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))]),
            Card(name: "Ресурс", type: .resource, rarity: .common,
                 description: "Базовый ресурс. Даёт 1 веру.", cost: 0,
                 abilities: [CardAbility(name: "Ресурс", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))]),
            Card(name: "Ресурс", type: .resource, rarity: .common,
                 description: "Базовый ресурс. Даёт 1 веру.", cost: 0,
                 abilities: [CardAbility(name: "Ресурс", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))]),
            Card(name: "Ресурс", type: .resource, rarity: .common,
                 description: "Базовый ресурс. Даёт 1 веру.", cost: 0,
                 abilities: [CardAbility(name: "Ресурс", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))]),
            Card(name: "Ресурс", type: .resource, rarity: .common,
                 description: "Базовый ресурс. Даёт 1 веру.", cost: 0,
                 abilities: [CardAbility(name: "Ресурс", description: "Даёт 1 веру.", effect: .gainFaith(amount: 1))]),
            // 2x Attack cards (cost 1 faith)
            Card(name: "Атака", type: .attack, rarity: .common,
                 description: "Базовая атака. Наносит 2 урона. Стоимость: 1 вера.",
                 power: 2, cost: 1, abilities: []),
            Card(name: "Атака", type: .attack, rarity: .common,
                 description: "Базовая атака. Наносит 2 урона. Стоимость: 1 вера.",
                 power: 2, cost: 1, abilities: []),
            // 2x Defense cards (cost 1 faith)
            Card(name: "Защита", type: .defense, rarity: .common,
                 description: "Базовая защита. Блокирует 1 урона. Стоимость: 1 вера.",
                 defense: 1, cost: 1, abilities: []),
            Card(name: "Защита", type: .defense, rarity: .common,
                 description: "Базовая защита. Блокирует 1 урона. Стоимость: 1 вера.",
                 defense: 1, cost: 1, abilities: []),
            // 1x Special card (cost 2 faith)
            Card(name: "Особое", type: .special, rarity: .common,
                 description: "Базовая особая карта. Восстанавливает 2 здоровья. Стоимость: 2 веры.",
                 cost: 2, abilities: [CardAbility(name: "Восстановление", description: "Восстанавливает 2 здоровья.", effect: .heal(amount: 2))])
        ]
    }

    static func createFullDeck() -> [Card] {
        var deck: [Card] = []

        // Add spirits
        let spirits = createSpirits()
        deck.append(contentsOf: spirits)
        deck.append(contentsOf: spirits)  // Add duplicates

        // Add artifacts (rare)
        deck.append(contentsOf: createArtifacts())

        // Add starting curses (like weaknesses in Arkham Horror)
        let curses = createCurses()
        deck.append(curses[0])  // Add one curse to start with

        return deck
    }

    static func createEncounterDeck() -> [Card] {
        var deck: [Card] = []

        let monsters = createNavMonsters()
        let curses = createCurses()

        deck.append(contentsOf: monsters)
        deck.append(contentsOf: monsters)  // Add duplicates
        deck.append(contentsOf: curses)
        deck.append(contentsOf: curses)
        deck.append(contentsOf: curses)  // More curses

        return deck
    }

    // MARK: - Card Registry (for event rewards)

    /// Returns a card by its string ID used in events and quests
    static func getCardByID(_ cardID: String) -> Card? {
        // Create a dictionary mapping card IDs to cards
        let rewardCards = createRewardCards()
        let artifactCards = createArtifactCards()

        // Map cards by their names or custom IDs
        let cardMapping: [String: Card] = [
            // Reward cards from events
            "dark_power_card": rewardCards[0],     // Темная Сила
            "ancient_blessing": rewardCards[1],    // Древнее Благословение
            "merchant_blessing": rewardCards[2],   // Благословение Торговца
            "witch_knowledge": rewardCards[3],     // Знание Ведьмы
            "dark_pact": rewardCards[4],           // Темный Пакт
            "ancestral_blessing": rewardCards[5],  // Благословение Предков
            "realm_power": rewardCards[6],         // Сила Реальности
            "nav_essence": rewardCards[7],         // Эссенция Нави
            "village_gratitude": rewardCards[8],   // Благодарность Деревни
            "merchant_discount": rewardCards[9],   // Торговая Скидка
            "trade_blessing": rewardCards[10],     // Благословение Торговли
            "warrior_spirit": rewardCards[11],     // Дух Воина
            "inner_peace": rewardCards[12],        // Внутренний Покой
            "spiritual_armor": rewardCards[13],    // Духовная Броня
            "mountain_blessing": rewardCards[14],  // Благословение Гор
            "stone_armor": rewardCards[15],        // Каменная Броня
            "defender_blessing": rewardCards[16],  // Благословение Защитника (from reward cards)
            "anchor_power": rewardCards[17],       // Сила Якоря (from reward cards)

            // Artifact cards (legendary items from quests and boss)
            "guardian_seal": artifactCards[0],     // Печать Защитника
            "ancient_relic": artifactCards[1],     // Древняя Реликвия
            "corrupted_power": artifactCards[2]    // Развращённая Сила
        ]

        return cardMapping[cardID]
    }

    // MARK: - Event and Quest Reward Cards

    static func createRewardCards() -> [Card] {
        return [
            // 1. Dark Power Card - from desecrating shrine ritual
            Card(
                id: UUID(),
                name: "Темная Сила",
                type: .special,
                rarity: .rare,
                description: "Сила, полученная осквернением святилища. Мощная, но опасная.",
                cost: 3,
                abilities: [
                    CardAbility(
                        name: "Темная Мощь",
                        description: "Наносит 6 урона и восстанавливает 2 веры.",
                        effect: .damage(amount: 6, type: .arcane)
                    ),
                    CardAbility(
                        name: "Цена Силы",
                        description: "Сдвигает баланс к тьме.",
                        effect: .shiftBalance(towards: .dark, amount: 5)
                    )
                ],
                balance: .dark,
                realm: .nav
            ),

            // 2. Ancient Blessing - from wanderer event
            Card(
                id: UUID(),
                name: "Древнее Благословение",
                type: .special,
                rarity: .uncommon,
                description: "Древняя реликвия, найденная в путешествии.",
                cost: 4,
                abilities: [
                    CardAbility(
                        name: "Дар Предков",
                        description: "Восстанавливает 4 здоровья и даёт 2 веры.",
                        effect: .heal(amount: 4)
                    )
                ],
                balance: .light,
                realm: .yav
            ),

            // 3. Merchant Blessing - from trader event
            Card(
                id: UUID(),
                name: "Благословение Торговца",
                type: .resource,
                rarity: .common,
                description: "Талисман удачи от благодарного торговца.",
                cost: 2,
                abilities: [
                    CardAbility(
                        name: "Торговая Удача",
                        description: "Даёт 3 веры и восстанавливает 2 здоровья.",
                        effect: .gainFaith(amount: 3)
                    )
                ],
                balance: .neutral,
                realm: .yav
            ),

            // 4. Witch Knowledge - from witch event and quest
            Card(
                id: UUID(),
                name: "Знание Ведьмы",
                type: .special,
                rarity: .rare,
                description: "Тайные знания болотной ведьмы. Могущественны, но опасны.",
                cost: 4,
                abilities: [
                    CardAbility(
                        name: "Темная Мудрость",
                        description: "Берёте 3 карты.",
                        effect: .drawCards(count: 3)
                    ),
                    CardAbility(
                        name: "Цена Знания",
                        description: "Сдвигает баланс к тьме.",
                        effect: .shiftBalance(towards: .dark, amount: 3)
                    )
                ],
                balance: .dark,
                realm: .nav
            ),

            // 5. Dark Pact - from witch event
            Card(
                id: UUID(),
                name: "Темный Пакт",
                type: .curse,
                rarity: .rare,
                description: "Пакт с тёмными силами. Даёт мощь ценой души.",
                cost: 5,
                abilities: [
                    CardAbility(
                        name: "Сила Пакта",
                        description: "Даёт 5 веры и наносит 7 урона врагу.",
                        effect: .damage(amount: 7, type: .arcane)
                    ),
                    CardAbility(
                        name: "Проклятие Пакта",
                        description: "Накладывает слабость на 2 хода.",
                        effect: .applyCurse(type: .weakness, duration: 2)
                    )
                ],
                balance: .dark,
                realm: .nav,
                curseType: .weakness
            ),

            // 6. Ancestral Blessing - from multiple events/quests
            Card(
                id: UUID(),
                name: "Благословение Предков",
                type: .special,
                rarity: .rare,
                description: "Благословение духов предков. Защищает и направляет.",
                cost: 4,
                abilities: [
                    CardAbility(
                        name: "Защита Предков",
                        description: "Блокирует 6 урона и снимает одно проклятие.",
                        effect: .removeCurse(type: nil)
                    ),
                    CardAbility(
                        name: "Свет Предков",
                        description: "Сдвигает баланс к свету.",
                        effect: .shiftBalance(towards: .light, amount: 5)
                    )
                ],
                balance: .light,
                realm: .prav
            ),

            // 7. Realm Power - from realm shift event
            Card(
                id: UUID(),
                name: "Сила Реальности",
                type: .special,
                rarity: .epic,
                description: "Необработанная сила границы миров. Непредсказуема и опасна.",
                cost: 6,
                abilities: [
                    CardAbility(
                        name: "Разлом Реальности",
                        description: "Наносит 10 урона всем врагам.",
                        effect: .damage(amount: 10, type: .arcane)
                    ),
                    CardAbility(
                        name: "Искажение",
                        description: "Случайный эффект на баланс.",
                        effect: .shiftBalance(towards: .dark, amount: 10)
                    )
                ],
                balance: .dark,
                realm: .nav
            ),

            // 8. Nav Essence - from realm shift event
            Card(
                id: UUID(),
                name: "Эссенция Нави",
                type: .resource,
                rarity: .rare,
                description: "Чистая эссенция мира мёртвых. Источник тёмной силы.",
                cost: 3,
                abilities: [
                    CardAbility(
                        name: "Сила Нави",
                        description: "Даёт 5 веры.",
                        effect: .gainFaith(amount: 5)
                    ),
                    CardAbility(
                        name: "Развращение",
                        description: "Сдвигает баланс к тьме на 8.",
                        effect: .shiftBalance(towards: .dark, amount: 8)
                    )
                ],
                balance: .dark,
                realm: .nav
            ),

            // 9. Village Gratitude - from lost child quest
            Card(
                id: UUID(),
                name: "Благодарность Деревни",
                type: .special,
                rarity: .uncommon,
                description: "Жители деревни благодарны за спасение ребёнка.",
                cost: 2,
                abilities: [
                    CardAbility(
                        name: "Дар Общины",
                        description: "Восстанавливает 5 здоровья и даёт 3 веры.",
                        effect: .heal(amount: 5)
                    ),
                    CardAbility(
                        name: "Добрая Воля",
                        description: "Сдвигает баланс к свету.",
                        effect: .shiftBalance(towards: .light, amount: 3)
                    )
                ],
                balance: .light,
                realm: .yav
            ),

            // 10. Merchant Discount - from trade routes quest
            Card(
                id: UUID(),
                name: "Торговая Скидка",
                type: .resource,
                rarity: .common,
                description: "Особая скидка от торговцев за защиту путей.",
                cost: 1,
                abilities: [
                    CardAbility(
                        name: "Выгодная Сделка",
                        description: "Следующая карта стоит на 2 веры меньше.",
                        effect: .gainFaith(amount: 2)
                    )
                ],
                balance: .neutral,
                realm: .yav
            ),

            // 11. Trade Blessing - from trade routes quest
            Card(
                id: UUID(),
                name: "Благословение Торговли",
                type: .special,
                rarity: .uncommon,
                description: "Благословение купеческой гильдии.",
                cost: 3,
                abilities: [
                    CardAbility(
                        name: "Процветание",
                        description: "Даёт 4 веры и берёте 2 карты.",
                        effect: .gainFaith(amount: 4)
                    )
                ],
                balance: .neutral,
                realm: .yav
            ),

            // 12. Warrior Spirit - from barrow quest
            Card(
                id: UUID(),
                name: "Дух Воина",
                type: .spirit,
                rarity: .rare,
                description: "Дух древнего воина, освобождённый из кургана.",
                power: 6,
                defense: 4,
                health: 8,
                cost: 4,
                abilities: [
                    CardAbility(
                        name: "Воинская Доблесть",
                        description: "Наносит 6 урона и получает +2 к защите.",
                        effect: .damage(amount: 6, type: .physical)
                    )
                ],
                balance: .neutral,
                realm: .yav
            ),

            // 13. Inner Peace - from monk quest
            Card(
                id: UUID(),
                name: "Внутренний Покой",
                type: .special,
                rarity: .rare,
                description: "Состояние духовного равновесия, дарованное монахом.",
                cost: 3,
                abilities: [
                    CardAbility(
                        name: "Просветление",
                        description: "Восстанавливает 6 здоровья и снимает все проклятия.",
                        effect: .heal(amount: 6)
                    ),
                    CardAbility(
                        name: "Баланс Духа",
                        description: "Восстанавливает баланс к нейтральному.",
                        effect: .shiftBalance(towards: .neutral, amount: 10)
                    )
                ],
                balance: .light,
                realm: .prav
            ),

            // 14. Spiritual Armor - from monk quest
            Card(
                id: UUID(),
                name: "Духовная Броня",
                type: .defense,
                rarity: .rare,
                description: "Незримая защита духа и тела.",
                defense: 8,
                cost: 4,
                abilities: [
                    CardAbility(
                        name: "Защита Духа",
                        description: "Блокирует 8 урона и предотвращает проклятия.",
                        effect: .removeCurse(type: nil)
                    )
                ],
                balance: .light,
                realm: .prav
            ),

            // 15. Mountain Blessing - from mountain spirit quest
            Card(
                id: UUID(),
                name: "Благословение Гор",
                type: .special,
                rarity: .uncommon,
                description: "Благословение горного духа. Даёт силу и стойкость.",
                cost: 3,
                abilities: [
                    CardAbility(
                        name: "Сила Гор",
                        description: "Наносит 5 урона и восстанавливает 3 здоровья.",
                        effect: .damage(amount: 5, type: .physical)
                    )
                ],
                balance: .neutral,
                realm: .yav
            ),

            // 16. Stone Armor - from mountain spirit quest
            Card(
                id: UUID(),
                name: "Каменная Броня",
                type: .defense,
                rarity: .uncommon,
                description: "Магическая броня из камня горного духа.",
                defense: 6,
                cost: 3,
                abilities: [
                    CardAbility(
                        name: "Несокрушимость",
                        description: "Блокирует 6 урона. Не может быть разрушена эффектами.",
                        effect: .shiftBalance(towards: .neutral, amount: 0)
                    )
                ],
                balance: .neutral,
                realm: .yav
            ),

            // 17. Defender Blessing - from main quest
            Card(
                id: UUID(),
                name: "Благословение Защитника",
                type: .special,
                rarity: .legendary,
                description: "Величайшее благословение за защиту мира от Нави.",
                cost: 5,
                abilities: [
                    CardAbility(
                        name: "Защитник Миров",
                        description: "Восстанавливает 10 здоровья, даёт 5 веры, берёте 2 карты.",
                        effect: .heal(amount: 10)
                    ),
                    CardAbility(
                        name: "Сила Света",
                        description: "Сильно сдвигает баланс к свету.",
                        effect: .shiftBalance(towards: .light, amount: 15)
                    )
                ],
                balance: .light,
                realm: .prav
            ),

            // 18. Anchor Power - from main quest
            Card(
                id: UUID(),
                name: "Сила Якоря",
                type: .artifact,
                rarity: .legendary,
                description: "Сила священных якорей, держащих границу миров.",
                power: 8,
                defense: 8,
                cost: 6,
                abilities: [
                    CardAbility(
                        name: "Якорь Реальности",
                        description: "Наносит 12 урона существам Нави. Восстанавливает якорь региона.",
                        effect: .damage(amount: 12, type: .arcane)
                    ),
                    CardAbility(
                        name: "Стабилизация",
                        description: "Снимает все проклятия и сдвигает баланс к свету.",
                        effect: .removeCurse(type: nil)
                    )
                ],
                balance: .light,
                realm: .prav
            )
        ]
    }

    // MARK: - Boss Cards

    /// Creates the final boss for Act I: Леший-Хранитель (Leshy-Guardian)
    /// This boss is encountered in the Чёрная Низина (Black Lowlands) as the final challenge
    static func createLeshyGuardianBoss() -> Card {
        return Card(
            id: UUID(),
            name: "Леший-Хранитель",
            type: .monster,
            rarity: .legendary,
            description: "Древний страж Сумрачных Пределов. Его сила неимоверна, корни уходят глубоко в землю, а глаза горят зелёным пламенем вечности.",
            power: 6,
            defense: 12,
            health: 25,
            cost: nil,
            abilities: [
                CardAbility(
                    name: "Регенерация",
                    description: "Восстанавливает 2 здоровья в начале каждого хода.",
                    effect: .heal(amount: 2)
                ),
                CardAbility(
                    name: "Удар Корнями",
                    description: "Наносит 8 урона и оглушает противника.",
                    effect: .damage(amount: 8, type: .physical)
                ),
                CardAbility(
                    name: "Гнев Природы",
                    description: "Призывает духов леса, наносящих 4 урона.",
                    effect: .damage(amount: 4, type: .physical)
                )
            ],
            balance: .neutral,
            realm: .nav
        )
    }

    // MARK: - Artifact Cards

    /// Creates legendary artifact cards - powerful unique items from quests
    static func createArtifactCards() -> [Card] {
        return [
            // 1. Guardian Seal - main quest reward, peaceful boss resolution
            Card(
                id: UUID(),
                name: "Печать Защитника",
                type: .special,
                rarity: .legendary,
                description: "Древняя печать, дарованная Лешим-Хранителем. Символизует союз с силами природы.",
                cost: 3,
                abilities: [
                    CardAbility(
                        name: "Защита Якоря",
                        description: "Восстанавливает целостность якоря на 25 пунктов.",
                        effect: .heal(amount: 10)
                    ),
                    CardAbility(
                        name: "Благословение Хранителя",
                        description: "Снижает напряжение мира на 10 пунктов.",
                        effect: .gainFaith(amount: 8)
                    ),
                    CardAbility(
                        name: "Связь с Природой",
                        description: "Сдвигает баланс к свету.",
                        effect: .shiftBalance(towards: .light, amount: 10)
                    )
                ],
                balance: .light,
                realm: .prav
            ),

            // 2. Ancient Relic - powerful neutral artifact
            Card(
                id: UUID(),
                name: "Древняя Реликвия",
                type: .special,
                rarity: .legendary,
                description: "Таинственный артефакт из времён до разделения миров. Пульсирует неизвестной силой.",
                cost: 4,
                abilities: [
                    CardAbility(
                        name: "Власть над Реальностью",
                        description: "Наносит 10 урона врагу или восстанавливает 10 здоровья.",
                        effect: .damage(amount: 10, type: .arcane)
                    ),
                    CardAbility(
                        name: "Временной Резонанс",
                        description: "Позволяет разыграть дополнительную карту.",
                        effect: .gainFaith(amount: 5)
                    )
                ],
                balance: .neutral,
                realm: .prav
            ),

            // 3. Corrupted Power - dark path from boss
            Card(
                id: UUID(),
                name: "Развращённая Сила",
                type: .special,
                rarity: .legendary,
                description: "Частица сущности Хранителя, искажённая тёмной магией. Могущественна, но опасна.",
                cost: 2,
                abilities: [
                    CardAbility(
                        name: "Пожирание Жизни",
                        description: "Наносит 12 урона врагу, но отнимает 3 здоровья у вас.",
                        effect: .damage(amount: 12, type: .arcane)
                    ),
                    CardAbility(
                        name: "Тёмное Влияние",
                        description: "Сильно сдвигает баланс к тьме.",
                        effect: .shiftBalance(towards: .dark, amount: 15)
                    )
                ],
                balance: .dark,
                realm: .nav
            )
        ]
    }

    // MARK: - Market Cards (for purchase during game)

    static func createMarketCards() -> [Card] {
        return [
            // Common Resource cards (cost 2 faith, give 2 faith when played)
            Card(name: "Молитва", type: .resource, rarity: .common,
                 description: "Молитва богам. Дает 2 веры.",
                 cost: 2, abilities: [], balance: .light, realm: .prav),
            Card(name: "Молитва", type: .resource, rarity: .common,
                 description: "Молитва богам. Дает 2 веры.",
                 cost: 2, abilities: [], balance: .light, realm: .prav),

            // Uncommon Resource cards (cost 4, give 3 faith)
            Card(name: "Древний Ритуал", type: .resource, rarity: .uncommon,
                 description: "Древний ритуал призыва силы. Дает 3 веры.",
                 cost: 4, abilities: [], balance: .neutral, realm: .prav),

            // Common Attack cards (cost 3, deal 4 damage)
            Card(name: "Меч Света", type: .attack, rarity: .common,
                 description: "Светлый меч. Наносит 4 урона.",
                 power: 4, cost: 3, abilities: [], balance: .light, realm: .yav),
            Card(name: "Меч Света", type: .attack, rarity: .common,
                 description: "Светлый меч. Наносит 4 урона.",
                 power: 4, cost: 3, abilities: [], balance: .light, realm: .yav),

            // Uncommon Attack cards (cost 5, deal 6 damage)
            Card(name: "Огненный Шар", type: .attack, rarity: .uncommon,
                 description: "Мощный огненный шар. Наносит 6 урона.",
                 power: 6, cost: 5, abilities: [], damageType: .fire, balance: .neutral, realm: .yav),

            // Rare Attack cards (cost 7, deal 8 damage + effect)
            Card(name: "Божественный Удар", type: .attack, rarity: .rare,
                 description: "Удар божественной силы. Наносит 8 урона и восстанавливает 2 здоровья.",
                 power: 8, cost: 7, abilities: [
                     CardAbility(name: "Исцеление", description: "Восстанавливает 2 здоровья.", effect: .heal(amount: 2))
                 ], balance: .light, realm: .prav),

            // Common Defense cards (cost 2, block 3 damage)
            Card(name: "Щит Веры", type: .defense, rarity: .common,
                 description: "Защитный щит. Блокирует 3 урона.",
                 defense: 3, cost: 2, abilities: [], balance: .light, realm: .yav),
            Card(name: "Щит Веры", type: .defense, rarity: .common,
                 description: "Защитный щит. Блокирует 3 урона.",
                 defense: 3, cost: 2, abilities: [], balance: .light, realm: .yav),

            // Uncommon Defense cards (cost 4, block 5 damage)
            Card(name: "Каменная Кожа", type: .defense, rarity: .uncommon,
                 description: "Магическая защита. Блокирует 5 урона.",
                 defense: 5, cost: 4, abilities: [], balance: .neutral, realm: .yav),

            // Common Special cards (cost 3, draw 2 cards)
            Card(name: "Прозрение", type: .special, rarity: .common,
                 description: "Видение будущего. Берете 2 карты.",
                 cost: 3, abilities: [
                     CardAbility(name: "Карты", description: "Берете 2 карты.", effect: .drawCards(count: 2))
                 ], balance: .light, realm: .prav),

            // Uncommon Special cards (cost 5, heal 5 health)
            Card(name: "Великое Исцеление", type: .special, rarity: .uncommon,
                 description: "Мощное целебное заклинание. Восстанавливает 5 здоровья.",
                 cost: 5, abilities: [
                     CardAbility(name: "Исцеление", description: "Восстанавливает 5 здоровья.", effect: .heal(amount: 5))
                 ], balance: .light, realm: .prav),

            // Rare Special cards (cost 6, powerful effects)
            Card(name: "Перерождение", type: .special, rarity: .rare,
                 description: "Древнее заклинание перерождения. Восстанавливает 7 здоровья и дает 2 веры.",
                 cost: 6, abilities: [
                     CardAbility(name: "Перерождение", description: "Восстанавливает 7 здоровья.", effect: .heal(amount: 7)),
                     CardAbility(name: "Сила", description: "Дает 2 веры.", effect: .gainFaith(amount: 2))
                 ], balance: .light, realm: .prav),

            // Legendary cards (cost 10, extremely powerful)
            Card(name: "Дар Богов", type: .special, rarity: .legendary,
                 description: "Величайший дар от богов. Берете 3 карты, восстанавливаете 5 здоровья, получаете 3 веры.",
                 cost: 10, abilities: [
                     CardAbility(name: "Дар", description: "Берете 3 карты.", effect: .drawCards(count: 3)),
                     CardAbility(name: "Исцеление", description: "Восстанавливаете 5 здоровья.", effect: .heal(amount: 5)),
                     CardAbility(name: "Сила", description: "Получаете 3 веры.", effect: .gainFaith(amount: 3))
                 ], balance: .light, realm: .prav)
        ]
    }
}


// ==========================================
// FILE: Views/CardView.swift
// ==========================================

import SwiftUI

struct CardView: View {
    let card: Card
    var isSelected: Bool = false
    var onTap: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Card header with name and type
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(card.name)
                        .font(.headline)
                        .fontWeight(.bold)
                        .foregroundColor(.white)
                    Spacer()
                    if let cost = card.cost {
                        Text("\(cost)")
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(.yellow)
                            .padding(6)
                            .background(Circle().fill(Color.black.opacity(0.6)))
                    }
                }

                Text(localizedCardType)
                    .font(.caption)
                    .foregroundColor(.white.opacity(0.8))
            }
            .padding(12)
            .background(headerColor)

            // Card image area
            ZStack {
                Rectangle()
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [cardColor.opacity(0.3), cardColor]),
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    )

                VStack {
                    Image(systemName: cardIcon)
                        .font(.system(size: 60))
                        .foregroundColor(.white.opacity(0.9))
                }
            }
            .frame(height: 120)

            // Stats section
            if hasStats {
                HStack(spacing: 16) {
                    if let power = card.power {
                        CardStatBadge(icon: "bolt.fill", value: power, color: .red)
                    }
                    if let defense = card.defense {
                        CardStatBadge(icon: "shield.fill", value: defense, color: .blue)
                    }
                    if let health = card.health {
                        CardStatBadge(icon: "heart.fill", value: health, color: .green)
                    }
                    Spacer()
                }
                .padding(.horizontal, 12)
                .padding(.vertical, 8)
                .background(Color.black.opacity(0.2))
            }

            // Description
            ScrollView {
                VStack(alignment: .leading, spacing: 8) {
                    Text(card.description)
                        .font(.caption)
                        .foregroundColor(.primary)
                        .fixedSize(horizontal: false, vertical: true)

                    // Abilities
                    ForEach(card.abilities) { ability in
                        VStack(alignment: .leading, spacing: 2) {
                            Text(ability.name)
                                .font(.caption)
                                .fontWeight(.bold)
                                .foregroundColor(.orange)
                            Text(ability.description)
                                .font(.caption2)
                                .foregroundColor(.secondary)
                                .fixedSize(horizontal: false, vertical: true)
                        }
                        .padding(.top, 4)
                    }

                    // Traits
                    if !card.traits.isEmpty {
                        HStack {
                            ForEach(card.traits, id: \.self) { trait in
                                Text(trait.localized)
                                    .font(.caption2)
                                    .padding(.horizontal, 6)
                                    .padding(.vertical, 2)
                                    .background(Capsule().fill(Color.gray.opacity(0.3)))
                            }
                        }
                        .padding(.top, 4)
                    }
                }
                .padding(12)
            }

            // Rarity indicator
            HStack {
                Spacer()
                Circle()
                    .fill(rarityColor)
                    .frame(width: 8, height: 8)
                Text(localizedRarity)
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
            .padding(8)
        }
        .frame(height: 320)
        .background(Color(UIColor.systemBackground))
        .cornerRadius(12)
        .shadow(color: isSelected ? .blue.opacity(0.5) : .black.opacity(0.2), radius: isSelected ? 8 : 4)
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(isSelected ? Color.blue : Color.clear, lineWidth: 3)
        )
        .onTapGesture {
            onTap?()
        }
    }

    var hasStats: Bool {
        card.power != nil || card.defense != nil || card.health != nil
    }

    var localizedCardType: String {
        switch card.type {
        case .character: return L10n.cardTypeCharacter.localized
        case .weapon: return L10n.cardTypeWeapon.localized
        case .spell: return L10n.cardTypeSpell.localized
        case .armor: return L10n.cardTypeArmor.localized
        case .item: return L10n.cardTypeItem.localized
        case .ally: return L10n.cardTypeAlly.localized
        case .blessing: return L10n.cardTypeBlessing.localized
        case .monster: return L10n.cardTypeMonster.localized
        case .location: return L10n.cardTypeLocation.localized
        case .scenario: return card.type.rawValue.capitalized
        case .curse: return L10n.tmCardTypeCurse.localized
        case .spirit: return L10n.tmCardTypeSpirit.localized
        case .artifact: return L10n.tmCardTypeArtifact.localized
        case .ritual: return L10n.tmCardTypeRitual.localized
        case .resource: return "Ресурс"
        case .attack: return "Атака"
        case .defense: return "Защита"
        case .special: return "Особая"
        }
    }

    var localizedRarity: String {
        switch card.rarity {
        case .common: return L10n.rarityCommon.localized
        case .uncommon: return L10n.rarityUncommon.localized
        case .rare: return L10n.rarityRare.localized
        case .epic: return L10n.rarityEpic.localized
        case .legendary: return L10n.rarityLegendary.localized
        }
    }

    var headerColor: Color {
        switch card.type {
        case .character: return Color.purple
        case .weapon: return Color.red
        case .spell: return Color.blue
        case .armor: return Color.gray
        case .item: return Color.brown
        case .ally: return Color.green
        case .blessing: return Color.yellow
        case .monster: return Color.red.opacity(0.8)
        case .location: return Color.teal
        case .scenario: return Color.indigo
        case .curse: return Color.black
        case .spirit: return Color.cyan
        case .artifact: return Color.orange
        case .ritual: return Color.indigo
        case .resource: return Color.green
        case .attack: return Color.red
        case .defense: return Color.blue
        case .special: return Color.purple
        }
    }

    var cardColor: Color {
        headerColor.opacity(0.6)
    }

    var cardIcon: String {
        switch card.type {
        case .character: return "person.fill"
        case .weapon: return "bolt.fill"
        case .spell: return "sparkles"
        case .armor: return "shield.fill"
        case .item: return "bag.fill"
        case .ally: return "person.2.fill"
        case .blessing: return "star.fill"
        case .monster: return "flame.fill"
        case .location: return "mappin.and.ellipse"
        case .scenario: return "book.fill"
        case .curse: return "cloud.bolt.fill"
        case .spirit: return "cloud.moon.fill"
        case .artifact: return "crown.fill"
        case .ritual: return "book.closed.fill"
        case .resource: return "leaf.fill"
        case .attack: return "bolt.fill"
        case .defense: return "shield.fill"
        case .special: return "star.circle.fill"
        }
    }

    var rarityColor: Color {
        switch card.rarity {
        case .common: return .gray
        case .uncommon: return .green
        case .rare: return .blue
        case .epic: return .purple
        case .legendary: return .orange
        }
    }
}

struct CardStatBadge: View {
    let icon: String
    let value: Int
    let color: Color

    var body: some View {
        HStack(spacing: 4) {
            Image(systemName: icon)
                .font(.caption)
            Text("\(value)")
                .font(.caption)
                .fontWeight(.bold)
        }
        .foregroundColor(color)
    }
}

// Compact card view for character selection
// Compact card view for character selection
struct CompactCardView: View {
    let card: Card
    var isSelected: Bool = false
    var onTap: (() -> Void)?

    var body: some View {
        VStack(spacing: 0) {
            // Card header
            Text(card.name)
                .font(.title3)
                .fontWeight(.bold)
                .foregroundColor(.white)
                .frame(maxWidth: .infinity)
                .padding(.vertical, 12)
                .background(headerColor)

            // Card image area
            ZStack {
                Rectangle()
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [headerColor.opacity(0.3), headerColor.opacity(0.6)]),
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    )

                Image(systemName: cardIcon)
                    .font(.system(size: 70))
                    .foregroundColor(.white.opacity(0.9))
            }
            .frame(height: 140)

            // Stats
            VStack(spacing: 8) {
                Text(localizedCardType)
                    .font(.caption)
                    .foregroundColor(.secondary)

                HStack(spacing: 20) {
                    if let health = card.health {
                        VStack(spacing: 2) {
                            Image(systemName: "heart.fill")
                                .font(.title3)
                                .foregroundColor(.red)
                            Text("\(health)")
                                .font(.headline)
                                .fontWeight(.bold)
                            Text("Здоровье")
                                .font(.system(size: 9))
                                .foregroundColor(.secondary)
                        }
                    }
                    if let power = card.power {
                        VStack(spacing: 2) {
                            Image(systemName: "bolt.fill")
                                .font(.title3)
                                .foregroundColor(.orange)
                            Text("\(power)")
                                .font(.headline)
                                .fontWeight(.bold)
                            Text("Сила")
                                .font(.system(size: 9))
                                .foregroundColor(.secondary)
                        }
                    }
                    if let defense = card.defense {
                        VStack(spacing: 2) {
                            Image(systemName: "shield.fill")
                                .font(.title3)
                                .foregroundColor(.blue)
                            Text("\(defense)")
                                .font(.headline)
                                .fontWeight(.bold)
                            Text("Защита")
                                .font(.system(size: 9))
                                .foregroundColor(.secondary)
                        }
                    }
                }

                Circle()
                    .fill(rarityColor)
                    .frame(width: 6, height: 6)
            }
            .padding(.vertical, 10)
            .frame(maxWidth: .infinity)
            .background(Color(UIColor.secondarySystemBackground))
        }
        .frame(height: 280)
        .background(Color(UIColor.systemBackground))
        .cornerRadius(16)
        .shadow(color: isSelected ? headerColor.opacity(0.5) : .black.opacity(0.2), radius: isSelected ? 10 : 5)
        .overlay(
            RoundedRectangle(cornerRadius: 16)
                .stroke(isSelected ? headerColor : Color.clear, lineWidth: 3)
        )
        .scaleEffect(isSelected ? 1.05 : 1.0)
        .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isSelected)
        .onTapGesture {
            onTap?()
        }
    }

    var headerColor: Color {
        switch card.type {
        case .character: return Color.purple
        case .weapon: return Color.red
        case .spell: return Color.blue
        case .armor: return Color.gray
        case .item: return Color.brown
        case .ally: return Color.green
        case .blessing: return Color.yellow
        case .monster: return Color.red.opacity(0.8)
        case .location: return Color.teal
        case .scenario: return Color.indigo
        case .curse: return Color.black
        case .spirit: return Color.cyan
        case .artifact: return Color.orange
        case .ritual: return Color.indigo
        case .resource: return Color.green
        case .attack: return Color.red
        case .defense: return Color.blue
        case .special: return Color.purple
        }
    }

    var cardIcon: String {
        switch card.type {
        case .character: return "person.fill"
        case .weapon: return "bolt.fill"
        case .spell: return "sparkles"
        case .armor: return "shield.fill"
        case .item: return "bag.fill"
        case .ally: return "person.2.fill"
        case .blessing: return "star.fill"
        case .monster: return "flame.fill"
        case .location: return "mappin.and.ellipse"
        case .scenario: return "book.fill"
        case .curse: return "cloud.bolt.fill"
        case .spirit: return "cloud.moon.fill"
        case .artifact: return "crown.fill"
        case .ritual: return "book.closed.fill"
        case .resource: return "leaf.fill"
        case .attack: return "bolt.fill"
        case .defense: return "shield.fill"
        case .special: return "star.circle.fill"
        }
    }

    var localizedCardType: String {
        switch card.type {
        case .character: return L10n.cardTypeCharacter.localized
        case .weapon: return L10n.cardTypeWeapon.localized
        case .spell: return L10n.cardTypeSpell.localized
        case .armor: return L10n.cardTypeArmor.localized
        case .item: return L10n.cardTypeItem.localized
        case .ally: return L10n.cardTypeAlly.localized
        case .blessing: return L10n.cardTypeBlessing.localized
        case .monster: return L10n.cardTypeMonster.localized
        case .location: return L10n.cardTypeLocation.localized
        case .scenario: return card.type.rawValue.capitalized
        case .curse: return L10n.tmCardTypeCurse.localized
        case .spirit: return L10n.tmCardTypeSpirit.localized
        case .artifact: return L10n.tmCardTypeArtifact.localized
        case .ritual: return L10n.tmCardTypeRitual.localized
        case .resource: return "Ресурс"
        case .attack: return "Атака"
        case .defense: return "Защита"
        case .special: return "Особая"
        }
    }

    var rarityColor: Color {
        switch card.rarity {
        case .common: return .gray
        case .uncommon: return .green
        case .rare: return .blue
        case .epic: return .purple
        case .legendary: return .orange
        }
    }
}

// Very compact card view for player hand
struct HandCardView: View {
    let card: Card
    var isSelected: Bool = false
    var onTap: (() -> Void)?

    var body: some View {
        VStack(spacing: 0) {
            // Card name
            Text(card.name)
                .font(.system(size: 10))
                .fontWeight(.bold)
                .foregroundColor(.white)
                .lineLimit(1)
                .minimumScaleFactor(0.7)
                .frame(maxWidth: .infinity)
                .padding(.vertical, 3)
                .padding(.horizontal, 2)
                .background(headerColor)

            // Card icon
            ZStack {
                Rectangle()
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [headerColor.opacity(0.3), headerColor.opacity(0.6)]),
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    )

                Image(systemName: cardIcon)
                    .font(.system(size: 32))
                    .foregroundColor(.white.opacity(0.9))
            }
            .frame(height: 55)

            // Stats in vertical column
            VStack(spacing: 2) {
                if let cost = card.cost {
                    HStack(spacing: 2) {
                        Image(systemName: "star.fill")
                            .font(.system(size: 8))
                            .foregroundColor(.yellow)
                        Text("\(cost)")
                            .font(.system(size: 9))
                            .fontWeight(.bold)
                    }
                }
                if let power = card.power {
                    HStack(spacing: 2) {
                        Image(systemName: "bolt.fill")
                            .font(.system(size: 8))
                            .foregroundColor(.red)
                        Text("\(power)")
                            .font(.system(size: 9))
                            .fontWeight(.bold)
                    }
                }
                if let defense = card.defense {
                    HStack(spacing: 2) {
                        Image(systemName: "shield.fill")
                            .font(.system(size: 8))
                            .foregroundColor(.blue)
                        Text("\(defense)")
                            .font(.system(size: 9))
                            .fontWeight(.bold)
                    }
                }
            }
            .padding(.vertical, 3)
            .frame(maxWidth: .infinity)
            .background(Color(UIColor.secondarySystemBackground))
        }
        .frame(width: 85, height: 115)
        .background(Color(UIColor.systemBackground))
        .cornerRadius(8)
        .shadow(color: isSelected ? headerColor.opacity(0.6) : .black.opacity(0.2), radius: isSelected ? 6 : 3)
        .overlay(
            RoundedRectangle(cornerRadius: 8)
                .stroke(isSelected ? headerColor : Color.clear, lineWidth: 2)
        )
        .scaleEffect(isSelected ? 1.1 : 1.0)
        .animation(.spring(response: 0.2, dampingFraction: 0.7), value: isSelected)
        .onTapGesture {
            onTap?()
        }
    }

    var headerColor: Color {
        switch card.type {
        case .character: return Color.purple
        case .weapon: return Color.red
        case .spell: return Color.blue
        case .armor: return Color.gray
        case .item: return Color.brown
        case .ally: return Color.green
        case .blessing: return Color.yellow
        case .monster: return Color.red.opacity(0.8)
        case .location: return Color.teal
        case .scenario: return Color.indigo
        case .curse: return Color.black
        case .spirit: return Color.cyan
        case .artifact: return Color.orange
        case .ritual: return Color.indigo
        case .resource: return Color.green
        case .attack: return Color.red
        case .defense: return Color.blue
        case .special: return Color.purple
        }
    }

    var cardIcon: String {
        switch card.type {
        case .character: return "person.fill"
        case .weapon: return "bolt.fill"
        case .spell: return "sparkles"
        case .armor: return "shield.fill"
        case .item: return "bag.fill"
        case .ally: return "person.2.fill"
        case .blessing: return "star.fill"
        case .monster: return "flame.fill"
        case .location: return "mappin.and.ellipse"
        case .scenario: return "book.fill"
        case .curse: return "cloud.bolt.fill"
        case .spirit: return "cloud.moon.fill"
        case .artifact: return "crown.fill"
        case .ritual: return "book.closed.fill"
        case .resource: return "leaf.fill"
        case .attack: return "bolt.fill"
        case .defense: return "shield.fill"
        case .special: return "star.circle.fill"
        }
    }
}


// ==========================================
// FILE: Views/CombatView.swift
// ==========================================

import SwiftUI

/// Боевой экран - реализация по документации GAME_DESIGN_DOCUMENT.md
/// Цикл: PlayerTurn → EnemyTurn → EndTurn (повтор до победы/поражения)
/// Действия: 3 за ход. Играть карту = 1 действие, Атаковать = 1 действие
///
/// Engine-First Architecture (Gate 1 Compliant):
/// - All player mutations go through engine.performAction()
/// - UI reads state from engine properties
struct CombatView: View {
    // MARK: - Engine-First Architecture
    @ObservedObject var engine: TwilightGameEngine
    let onCombatEnd: (CombatOutcome) -> Void

    // MARK: - Legacy Support (for backwards compatibility during migration)
    // Will be removed after full migration
    private var legacyPlayer: Player?
    private var legacyMonster: Binding<Card>?

    enum CombatOutcome: Equatable {
        case victory(stats: CombatStats)
        case defeat(stats: CombatStats)
        case fled

        var isVictory: Bool {
            if case .victory = self { return true }
            return false
        }
    }

    struct CombatStats: Equatable {
        let turnsPlayed: Int
        let totalDamageDealt: Int
        let totalDamageTaken: Int
        let cardsPlayed: Int

        var summary: String {
            "Ходов: \(turnsPlayed), урон нанесён: \(totalDamageDealt), урон получен: \(totalDamageTaken)"
        }
    }

    enum CombatPhase {
        case playerTurn
        case enemyTurn
        case endTurn
        case combatOver
    }

    @State private var phase: CombatPhase = .playerTurn
    @State private var turnNumber: Int = 1
    @State private var actionsRemaining: Int = 3
    @State private var combatLog: [String] = []
    @State private var lastMessage: String = ""
    @State private var showingMessage = false

    // Боевые бонусы (сбрасываются в конце хода/после атаки)
    @State private var bonusDice: Int = 0          // Дополнительные кубики от карт
    @State private var bonusDamage: Int = 0        // Бонусный урон
    @State private var canReroll: Bool = false     // Возможность перебросить кубик
    @State private var summonedSpirits: [(power: Int, realm: Realm)] = []  // Призванные духи
    @State private var isFirstAttackThisCombat: Bool = true  // Для способности Следопыта
    @State private var lastCombatResult: CombatResult? = nil  // Последний результат атаки

    // NEW: Temporary Shield (защита от карт, поглощает урон, сбрасывается в конце раунда)
    @State private var temporaryShield: Int = 0

    // Combat statistics tracking
    @State private var totalDamageDealt: Int = 0
    @State private var totalDamageTaken: Int = 0
    @State private var cardsPlayedCount: Int = 0

    // Combat end state (for victory/defeat screen)
    @State private var finalCombatStats: CombatStats? = nil
    @State private var isVictory: Bool = false
    @State private var defeatedMonsterName: String = ""  // Saved before combat ends for UI
    @State private var savedMonsterCard: Card? = nil     // Saved monster for display after combat ends

    // Dice roll animation state
    @State private var showDiceRollOverlay: Bool = false
    @State private var animatingDiceValues: [Int] = []
    @State private var diceAnimationPhase: Int = 0

    // MARK: - Computed Properties (Engine-First)

    /// Player from engine or legacy
    private var player: Player? {
        // In Engine-First mode, use engine's legacyPlayer
        // Fall back to stored legacyPlayer for backwards compatibility
        engine.legacyPlayer ?? legacyPlayer
    }

    /// Monster from engine combat state or legacy binding
    /// Uses savedMonsterCard when combat is over to avoid "Unknown" display
    private var monster: Card {
        get {
            // After combat ends, use saved monster card to display correct info
            if phase == .combatOver, let saved = savedMonsterCard {
                return saved
            }
            return engine.combatState?.enemy ?? legacyMonster?.wrappedValue ?? savedMonsterCard ?? Card(
                name: "Unknown",
                type: .monster,
                description: "Unknown enemy"
            )
        }
    }

    /// Monster health from engine
    private var monsterHealth: Int {
        engine.combatState?.enemyHealth ?? monster.health ?? 10
    }

    // MARK: - Initialization (Engine-First)

    init(engine: TwilightGameEngine, onCombatEnd: @escaping (CombatOutcome) -> Void) {
        self.engine = engine
        self.onCombatEnd = onCombatEnd
        self.legacyPlayer = nil
        self.legacyMonster = nil
    }

    // MARK: - Legacy Initialization (for backwards compatibility)

    init(player: Player, monster: Binding<Card>, onCombatEnd: @escaping (CombatOutcome) -> Void) {
        // Create engine connected to legacy player
        let newEngine = TwilightGameEngine()
        // Setup combat enemy in engine
        newEngine.setupCombatEnemy(monster.wrappedValue)
        self.engine = newEngine
        self.onCombatEnd = onCombatEnd
        self.legacyPlayer = player
        self.legacyMonster = monster
    }

    var body: some View {
        VStack(spacing: 0) {
            // Hero Panel (persistent, consistent design)
            HeroPanel(engine: engine, compact: true, showAvatar: true)
                .padding(.horizontal, 8)
                .padding(.top, 4)

            // Верхняя панель
            combatHeader

            // Основная область боя
            ScrollView {
                VStack(spacing: 16) {
                    // Монстр
                    monsterCard

                    // VS разделитель
                    vsIndicator

                    // Игрок
                    playerStats

                    // Инструкции и действия
                    if phase == .playerTurn {
                        playerTurnControls
                    } else if phase == .enemyTurn {
                        enemyTurnView
                    } else if phase == .endTurn {
                        endTurnView
                    } else if phase == .combatOver {
                        combatOverView
                    }

                    // Лог боя
                    combatLogView
                }
                .padding()
            }

            Divider()

            // Рука игрока
            playerHandView
        }
        .background(Color(UIColor.systemBackground))
        .accessibilityIdentifier(AccessibilityIdentifiers.Combat.view)
        .overlay {
            // Dice roll animation overlay
            if showDiceRollOverlay {
                diceRollOverlay
            }
        }
        .alert(L10n.combatTitle.localized, isPresented: $showingMessage) {
            Button(L10n.buttonOk.localized) { }
        } message: {
            Text(lastMessage)
        }
        .onAppear {
            startCombat()
        }
    }

    // MARK: - Header

    var combatHeader: some View {
        HStack {
            // Ход и фаза
            VStack(alignment: .leading, spacing: 2) {
                Text(L10n.combatTurnNumber.localized(with: turnNumber))
                    .font(.headline)
                Text(phaseText)
                    .font(.subheadline)
                    .foregroundColor(phaseColor)
            }

            Spacer()

            // Действия (показываем только в ход игрока)
            if phase == .playerTurn {
                HStack(spacing: 6) {
                    ForEach(0..<3, id: \.self) { i in
                        Circle()
                            .fill(i < actionsRemaining ? Color.orange : Color.gray.opacity(0.3))
                            .frame(width: 16, height: 16)
                    }
                }

                Text("\(actionsRemaining)/3")
                    .font(.headline)
                    .foregroundColor(.orange)
                    .padding(.leading, 4)
            }

            Spacer()

            // Кнопка побега
            Button(action: flee) {
                HStack(spacing: 4) {
                    Image(systemName: "figure.run")
                    Text(L10n.combatFleeButton.localized)
                        .font(.caption)
                }
                .foregroundColor(.gray)
                .padding(.horizontal, 12)
                .padding(.vertical, 6)
                .background(Color.gray.opacity(0.2))
                .cornerRadius(8)
            }
            .disabled(phase != .playerTurn)
        }
        .padding()
        .background(Color(UIColor.secondarySystemBackground))
    }

    // MARK: - Monster Card

    var monsterCard: some View {
        VStack(spacing: 8) {
            Text(monster.name)
                .font(.title2)
                .fontWeight(.bold)
                .foregroundColor(.red)

            HStack(spacing: 32) {
                // HP монстра (Engine-First: read from engine.combatState)
                VStack {
                    Image(systemName: "heart.fill")
                        .font(.title)
                        .foregroundColor(.red)
                    Text("\(monsterHealth)")
                        .font(.title)
                        .fontWeight(.bold)
                    Text(L10n.combatHP.localized)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }

                // Атака монстра
                VStack {
                    Image(systemName: "burst.fill")
                        .font(.title)
                        .foregroundColor(.orange)
                    Text("\(monster.power ?? 3)")
                        .font(.title)
                        .fontWeight(.bold)
                    Text(L10n.combatAttack.localized)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }

                // Защита монстра
                VStack {
                    Image(systemName: "shield.fill")
                        .font(.title)
                        .foregroundColor(.blue)
                    Text("\(monster.defense ?? 10)")
                        .font(.title)
                        .fontWeight(.bold)
                    Text(L10n.combatDefense.localized)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
        }
        .padding()
        .frame(maxWidth: .infinity)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.red.opacity(0.1))
                .overlay(
                    RoundedRectangle(cornerRadius: 12)
                        .stroke(Color.red, lineWidth: 2)
                )
        )
    }

    var vsIndicator: some View {
        HStack {
            Rectangle().fill(Color.red.opacity(0.5)).frame(height: 2)
            Text("⚔️ VS ⚔️")
                .font(.headline)
                .padding(.horizontal, 8)
            Rectangle().fill(Color.red.opacity(0.5)).frame(height: 2)
        }
    }

    // MARK: - Player Stats (Engine-First: reads from engine.player*)

    var playerStats: some View {
        VStack(spacing: 8) {
            // Main stats row
            HStack(spacing: 20) {
                VStack {
                    Image(systemName: "heart.fill")
                        .foregroundColor(.red)
                    Text("\(engine.playerHealth)/\(engine.playerMaxHealth)")
                        .fontWeight(.bold)
                    Text(L10n.combatHP.localized)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }

                VStack {
                    Image(systemName: "hand.raised.fill")
                        .foregroundColor(.orange)
                    Text("\(player?.strength ?? 1)")
                        .fontWeight(.bold)
                    Text(L10n.combatStrength.localized)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }

                VStack {
                    Image(systemName: "sparkles")
                        .foregroundColor(.yellow)
                    Text("\(engine.playerFaith)")
                        .fontWeight(.bold)
                    Text(L10n.tmResourceFaith.localized)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }

                // NEW: Shield display
                if temporaryShield > 0 {
                    VStack {
                        Image(systemName: "shield.fill")
                            .foregroundColor(.cyan)
                        Text("\(temporaryShield)")
                            .fontWeight(.bold)
                        Text("Щит")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
            }

            // Combat bonuses indicator (if any)
            if bonusDice > 0 || bonusDamage > 0 {
                HStack(spacing: 12) {
                    if bonusDice > 0 {
                        HStack(spacing: 4) {
                            Image(systemName: "dice.fill")
                                .foregroundColor(.purple)
                            Text("+\(bonusDice)")
                                .font(.caption)
                                .fontWeight(.bold)
                                .foregroundColor(.purple)
                        }
                    }
                    if bonusDamage > 0 {
                        HStack(spacing: 4) {
                            Image(systemName: "flame.fill")
                                .foregroundColor(.orange)
                            Text("+\(bonusDamage)")
                                .font(.caption)
                                .fontWeight(.bold)
                                .foregroundColor(.orange)
                        }
                    }
                }
                .padding(.horizontal, 8)
                .padding(.vertical, 4)
                .background(Color.purple.opacity(0.1))
                .cornerRadius(8)
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.blue.opacity(0.1))
        )
    }

    // MARK: - Player Turn Controls

    var playerTurnControls: some View {
        VStack(spacing: 16) {
            // Инструкция
            VStack(spacing: 4) {
                Text(L10n.combatPlayerTurn.localized)
                    .font(.headline)
                    .foregroundColor(.green)

                if actionsRemaining > 0 {
                    Text(L10n.combatActionsRemaining.localized(with: actionsRemaining))
                        .font(.subheadline)
                    Text(L10n.combatTapToPlay.localized)
                        .font(.caption)
                        .foregroundColor(.secondary)
                } else {
                    Text(L10n.combatActionsRemaining.localized(with: 0))
                        .font(.subheadline)
                        .foregroundColor(.orange)
                    Text(L10n.combatEndTurnButton.localized)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            .padding()
            .frame(maxWidth: .infinity)
            .background(Color.green.opacity(0.1))
            .cornerRadius(12)

            // Кнопки действий (каждое действие тратит 1 из 3)
            HStack(spacing: 8) {
                // Базовая атака
                Button(action: performBasicAttack) {
                    VStack(spacing: 4) {
                        Image(systemName: "hand.raised.fill")
                            .font(.title2)
                        Text(L10n.combatAttackButton.localized)
                            .font(.caption)
                            .fontWeight(.semibold)
                        // Show accumulated bonuses
                        if bonusDamage > 0 || bonusDice > 0 {
                            Text("+\(bonusDamage)💥 +\(bonusDice)🎲")
                                .font(.system(size: 9))
                                .foregroundColor(.yellow)
                        } else {
                            Text("(-1 действие)")
                                .font(.system(size: 9))
                                .foregroundColor(.white.opacity(0.7))
                        }
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(actionsRemaining > 0 ? Color.orange : Color.gray)
                    .foregroundColor(.white)
                    .cornerRadius(12)
                }
                .disabled(actionsRemaining <= 0)
                .accessibilityIdentifier(AccessibilityIdentifiers.Combat.attackButton)

                // NEW: Укрытие (Defend/Take Cover)
                Button(action: performDefend) {
                    VStack(spacing: 4) {
                        Image(systemName: "shield.fill")
                            .font(.title2)
                        Text("Укрытие")
                            .font(.caption)
                            .fontWeight(.semibold)
                        Text("+3🛡️ (-1)")
                            .font(.system(size: 9))
                            .foregroundColor(.white.opacity(0.7))
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(actionsRemaining > 0 ? Color.cyan : Color.gray)
                    .foregroundColor(.white)
                    .cornerRadius(12)
                }
                .disabled(actionsRemaining <= 0)

                // Завершить ход
                Button(action: endPlayerTurn) {
                    VStack(spacing: 4) {
                        Image(systemName: "arrow.right.circle.fill")
                            .font(.title2)
                        Text(L10n.combatEndTurnButton.localized)
                            .font(.caption)
                            .fontWeight(.semibold)
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.purple)
                    .foregroundColor(.white)
                    .cornerRadius(12)
                }
                .accessibilityIdentifier(AccessibilityIdentifiers.Combat.endTurnButton)
            }
            .accessibilityIdentifier(AccessibilityIdentifiers.Combat.actionBar)
        }
    }

    // MARK: - Enemy Turn View

    var enemyTurnView: some View {
        VStack(spacing: 12) {
            Text(L10n.combatEnemyTurn.localized)
                .font(.headline)
                .foregroundColor(.red)

            HStack {
                Image(systemName: "burst.fill")
                    .foregroundColor(.red)
                Text(L10n.combatLogEnemyAttacks.localized(with: monster.name))
            }

            ProgressView()
                .progressViewStyle(CircularProgressViewStyle(tint: .red))
        }
        .padding()
        .frame(maxWidth: .infinity)
        .background(Color.red.opacity(0.1))
        .cornerRadius(12)
        .onAppear {
            performEnemyAttack()
        }
    }

    // MARK: - End Turn View

    var endTurnView: some View {
        VStack(spacing: 12) {
            Text(L10n.combatEndTurn.localized)
                .font(.headline)
                .foregroundColor(.purple)

            ProgressView()
                .progressViewStyle(CircularProgressViewStyle(tint: .purple))
        }
        .padding()
        .frame(maxWidth: .infinity)
        .background(Color.purple.opacity(0.1))
        .cornerRadius(12)
        .onAppear {
            performEndTurn()
        }
    }

    // MARK: - Combat Over View (Full-screen victory/defeat display)
    // Player must tap "Continue" to dismiss - no auto-dismiss

    var combatOverView: some View {
        VStack(spacing: 24) {
            Spacer()

            // Victory/Defeat Icon and Title
            if isVictory {
                VStack(spacing: 12) {
                    Text("🎉")
                        .font(.system(size: 72))

                    Text(L10n.combatVictory.localized)
                        .font(.largeTitle)
                        .fontWeight(.bold)
                        .foregroundColor(.green)

                    Text("\(defeatedMonsterName) повержен!")
                        .font(.title3)
                        .foregroundColor(.secondary)
                }
            } else {
                VStack(spacing: 12) {
                    Text("💀")
                        .font(.system(size: 72))

                    Text(L10n.combatDefeat.localized)
                        .font(.largeTitle)
                        .fontWeight(.bold)
                        .foregroundColor(.red)

                    Text("Вы пали в бою...")
                        .font(.title3)
                        .foregroundColor(.secondary)
                }
            }

            // Combat Statistics
            if let stats = finalCombatStats {
                VStack(spacing: 16) {
                    Text("📊 Статистика боя")
                        .font(.headline)
                        .foregroundColor(.primary)

                    HStack(spacing: 32) {
                        // Turns
                        VStack {
                            Text("\(stats.turnsPlayed)")
                                .font(.title)
                                .fontWeight(.bold)
                                .foregroundColor(.blue)
                            Text("Ходов")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }

                        // Damage dealt
                        VStack {
                            Text("\(stats.totalDamageDealt)")
                                .font(.title)
                                .fontWeight(.bold)
                                .foregroundColor(.orange)
                            Text("Урон нанесён")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }

                        // Damage taken
                        VStack {
                            Text("\(stats.totalDamageTaken)")
                                .font(.title)
                                .fontWeight(.bold)
                                .foregroundColor(.red)
                            Text("Урон получен")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }

                        // Cards played
                        VStack {
                            Text("\(stats.cardsPlayed)")
                                .font(.title)
                                .fontWeight(.bold)
                                .foregroundColor(.purple)
                            Text("Карт сыграно")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                    }
                }
                .padding()
                .background(Color(UIColor.secondarySystemBackground))
                .cornerRadius(12)
            }

            Spacer()

            // Continue Button - player controls when to dismiss
            Button(action: {
                let stats = finalCombatStats ?? CombatStats(
                    turnsPlayed: turnNumber,
                    totalDamageDealt: totalDamageDealt,
                    totalDamageTaken: totalDamageTaken,
                    cardsPlayed: cardsPlayedCount
                )
                let outcome: CombatOutcome = isVictory ? .victory(stats: stats) : .defeat(stats: stats)
                onCombatEnd(outcome)
            }) {
                HStack {
                    Image(systemName: isVictory ? "arrow.right.circle.fill" : "arrow.counterclockwise.circle.fill")
                    Text(isVictory ? "Продолжить" : "Вернуться")
                }
                .font(.title2)
                .fontWeight(.semibold)
                .foregroundColor(.white)
                .frame(maxWidth: .infinity)
                .padding()
                .background(isVictory ? Color.green : Color.blue)
                .cornerRadius(12)
            }
            .padding(.horizontal)
            .padding(.bottom, 32)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(
            LinearGradient(
                gradient: Gradient(colors: isVictory
                    ? [Color.green.opacity(0.1), Color.black.opacity(0.3)]
                    : [Color.red.opacity(0.1), Color.black.opacity(0.3)]),
                startPoint: .top,
                endPoint: .bottom
            )
        )
    }

    // MARK: - Combat Log

    var combatLogView: some View {
        VStack(alignment: .leading, spacing: 8) {
            // Детальный результат последней атаки
            if let result = lastCombatResult {
                combatResultDetailView(result)
            }

            // Журнал боя
            VStack(alignment: .leading, spacing: 4) {
                Text("📜 " + L10n.combatLogTitle.localized)
                    .font(.caption)
                    .fontWeight(.bold)
                    .foregroundColor(.secondary)

                ForEach(Array(combatLog.suffix(5).enumerated()), id: \.offset) { index, entry in
                    Text("• \(entry)")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                }
            }
            .frame(maxWidth: .infinity, alignment: .leading)
            .padding()
            .background(Color(UIColor.tertiarySystemBackground))
            .cornerRadius(8)
        }
    }

    /// Детальный вид результата атаки
    func combatResultDetailView(_ result: CombatResult) -> some View {
        VStack(alignment: .leading, spacing: 6) {
            // Заголовок попадание/промах
            HStack {
                Text(result.isHit ? "✅ ПОПАДАНИЕ!" : "❌ ПРОМАХ!")
                    .font(.headline)
                    .fontWeight(.bold)
                    .foregroundColor(result.isHit ? .green : .red)

                Spacer()

                // Общий результат
                Text("Атака \(result.attackRoll.total) vs Защита \(result.defenseValue)")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }

            Divider()

            // Разбивка броска атаки
            VStack(alignment: .leading, spacing: 2) {
                Text("Бросок атаки:")
                    .font(.caption)
                    .fontWeight(.semibold)

                HStack(spacing: 4) {
                    Text("💪 \(result.attackRoll.baseStrength)")
                        .font(.caption2)

                    Text("+")
                        .font(.caption2)
                        .foregroundColor(.secondary)

                    // Кубики
                    ForEach(result.attackRoll.diceRolls.indices, id: \.self) { index in
                        diceView(result.attackRoll.diceRolls[index])
                    }

                    if result.attackRoll.bonusDamage > 0 {
                        Text("+ \(result.attackRoll.bonusDamage)")
                            .font(.caption2)
                            .foregroundColor(.orange)
                    }

                    Text("= \(result.attackRoll.total)")
                        .font(.caption)
                        .fontWeight(.bold)
                }

                // Модификаторы атаки
                ForEach(result.attackRoll.modifiers.indices, id: \.self) { index in
                    let modifier = result.attackRoll.modifiers[index]
                    Text("\(modifier.icon) \(modifier.description)")
                        .font(.caption2)
                        .foregroundColor(.blue)
                }
            }

            // Расчёт урона (если попадание)
            if result.isHit, let damage = result.damageCalculation {
                Divider()

                VStack(alignment: .leading, spacing: 2) {
                    Text("Расчёт урона:")
                        .font(.caption)
                        .fontWeight(.semibold)

                    HStack {
                        Text("Базовый: \(damage.base)")
                            .font(.caption2)

                        ForEach(damage.modifiers.indices, id: \.self) { index in
                            let mod = damage.modifiers[index]
                            Text("\(mod.value > 0 ? "+" : "")\(mod.value)")
                                .font(.caption2)
                                .foregroundColor(mod.value > 0 ? .green : .red)
                        }

                        Text("= \(damage.total) 💥")
                            .font(.caption)
                            .fontWeight(.bold)
                            .foregroundColor(.red)
                    }

                    // Детализация модификаторов урона
                    ForEach(damage.modifiers.indices, id: \.self) { index in
                        let modifier = damage.modifiers[index]
                        HStack(spacing: 4) {
                            Text(modifier.icon)
                            Text(modifier.description)
                            Text("\(modifier.value > 0 ? "+" : "")\(modifier.value)")
                                .foregroundColor(modifier.value > 0 ? .green : .red)
                        }
                        .font(.caption2)
                    }
                }
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(result.isHit ? Color.green.opacity(0.1) : Color.red.opacity(0.1))
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(result.isHit ? Color.green : Color.red, lineWidth: 1)
                )
        )
    }

    /// Вид кубика
    func diceView(_ value: Int) -> some View {
        ZStack {
            RoundedRectangle(cornerRadius: 4)
                .fill(Color.white)
                .frame(width: 24, height: 24)
                .shadow(radius: 1)

            Text("\(value)")
                .font(.caption)
                .fontWeight(.bold)
                .foregroundColor(value >= 5 ? .green : value <= 2 ? .red : .black)
        }
    }

    // MARK: - Dice Roll Overlay

    /// Prominent dice roll animation overlay
    var diceRollOverlay: some View {
        ZStack {
            // Semi-transparent background
            Color.black.opacity(0.6)
                .ignoresSafeArea()

            VStack(spacing: 20) {
                // Title
                Text("🎲 БРОСОК КУБИКОВ")
                    .font(.title2)
                    .fontWeight(.bold)
                    .foregroundColor(.white)

                // Animated dice
                HStack(spacing: 16) {
                    ForEach(animatingDiceValues.indices, id: \.self) { index in
                        animatedDiceView(value: animatingDiceValues[index], index: index)
                    }
                }
                .padding()

                // Result display (after animation completes)
                if let result = lastCombatResult, diceAnimationPhase >= 3 {
                    VStack(spacing: 12) {
                        // Attack total
                        HStack(spacing: 8) {
                            Text("💪 \(result.attackRoll.baseStrength)")
                                .foregroundColor(.cyan)
                            Text("+")
                                .foregroundColor(.white)
                            Text("🎲 \(result.attackRoll.diceTotal)")
                                .foregroundColor(.yellow)
                            if result.attackRoll.bonusDamage > 0 {
                                Text("+")
                                    .foregroundColor(.white)
                                Text("⚔️ \(result.attackRoll.bonusDamage)")
                                    .foregroundColor(.orange)
                            }
                            Text("=")
                                .foregroundColor(.white)
                            Text("\(result.attackRoll.total)")
                                .font(.title)
                                .fontWeight(.bold)
                                .foregroundColor(.white)
                        }
                        .font(.headline)

                        // VS Defense
                        HStack(spacing: 8) {
                            Text("vs")
                                .foregroundColor(.gray)
                            Text("🛡️ Защита: \(result.defenseValue)")
                                .foregroundColor(.blue)
                        }
                        .font(.subheadline)

                        // Hit/Miss result
                        if result.isHit {
                            VStack(spacing: 4) {
                                Text("✅ ПОПАДАНИЕ!")
                                    .font(.title)
                                    .fontWeight(.bold)
                                    .foregroundColor(.green)

                                if let damage = result.damageCalculation {
                                    Text("💥 Урон: \(damage.total)")
                                        .font(.headline)
                                        .foregroundColor(.red)
                                }
                            }
                        } else {
                            Text("❌ ПРОМАХ!")
                                .font(.title)
                                .fontWeight(.bold)
                                .foregroundColor(.red)
                        }
                    }
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: 12)
                            .fill(Color.black.opacity(0.8))
                    )
                    .transition(.scale.combined(with: .opacity))
                }
            }
        }
        .onTapGesture {
            // Allow dismissing overlay by tapping
            withAnimation(.easeOut(duration: 0.2)) {
                showDiceRollOverlay = false
            }
        }
    }

    /// Single animated dice
    func animatedDiceView(value: Int, index: Int) -> some View {
        ZStack {
            // Dice background
            RoundedRectangle(cornerRadius: 8)
                .fill(Color.white)
                .frame(width: 60, height: 60)
                .shadow(color: .black.opacity(0.3), radius: 4, x: 2, y: 2)

            // Dice value
            Text("\(value)")
                .font(.system(size: 32, weight: .bold, design: .rounded))
                .foregroundColor(value >= 5 ? .green : value <= 2 ? .red : .black)
        }
        .scaleEffect(diceAnimationPhase >= 2 ? 1.0 : 1.2)
        .rotationEffect(.degrees(diceAnimationPhase >= 2 ? 0 : Double(index * 30)))
        .animation(
            .spring(response: 0.3, dampingFraction: 0.6),
            value: diceAnimationPhase
        )
    }

    /// Trigger dice roll animation
    func showDiceAnimation(diceRolls: [Int]) {
        // Start with random values
        animatingDiceValues = diceRolls.map { _ in Int.random(in: 1...6) }
        diceAnimationPhase = 0

        withAnimation(.easeIn(duration: 0.1)) {
            showDiceRollOverlay = true
        }

        // Animation sequence: roll several times then show final result
        let rollDuration = 0.1

        // Roll 1
        DispatchQueue.main.asyncAfter(deadline: .now() + rollDuration) {
            animatingDiceValues = diceRolls.map { _ in Int.random(in: 1...6) }
            diceAnimationPhase = 1
        }

        // Roll 2
        DispatchQueue.main.asyncAfter(deadline: .now() + rollDuration * 2) {
            animatingDiceValues = diceRolls.map { _ in Int.random(in: 1...6) }
        }

        // Roll 3
        DispatchQueue.main.asyncAfter(deadline: .now() + rollDuration * 3) {
            animatingDiceValues = diceRolls.map { _ in Int.random(in: 1...6) }
        }

        // Final result
        DispatchQueue.main.asyncAfter(deadline: .now() + rollDuration * 4) {
            withAnimation(.spring(response: 0.4, dampingFraction: 0.7)) {
                animatingDiceValues = diceRolls
                diceAnimationPhase = 2
            }
        }

        // Show hit/miss result
        DispatchQueue.main.asyncAfter(deadline: .now() + rollDuration * 4 + 0.3) {
            withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                diceAnimationPhase = 3
            }
        }

        // Auto-dismiss after showing result
        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
            withAnimation(.easeOut(duration: 0.3)) {
                showDiceRollOverlay = false
            }
        }
    }

    // MARK: - Player Hand (Engine-First)

    /// Player's hand cards - use engine's published playerHand for proper UI updates
    private var playerHand: [Card] {
        // Engine-First: prefer engine.playerHand for proper @Published reactivity
        // Fall back to legacy player.hand if engine doesn't have cards yet
        if !engine.playerHand.isEmpty {
            return engine.playerHand
        }
        return player?.hand ?? []
    }

    var playerHandView: some View {
        VStack(spacing: 4) {
            HStack {
                Text("🃏 " + L10n.combatYourHand.localized + " (\(playerHand.count))")
                    .font(.caption)
                    .foregroundColor(.secondary)

                Spacer()

                if phase == .playerTurn && actionsRemaining > 0 {
                    Text(L10n.combatTapToPlay.localized)
                        .font(.system(size: 10))
                        .foregroundColor(.green)
                }
            }
            .padding(.horizontal)

            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 8) {
                    ForEach(playerHand) { card in
                        CombatCardView(
                            card: card,
                            canPlay: actionsRemaining > 0 && phase == .playerTurn
                        ) {
                            playCard(card)
                        }
                    }
                }
                .padding(.horizontal)
            }
        }
        .frame(height: 150)
        .background(Color(UIColor.secondarySystemBackground))
    }

    // MARK: - Combat Logic (Engine-First: uses engine.performAction())

    func startCombat() {
        // Save monster card for display after combat ends
        savedMonsterCard = engine.combatState?.enemy ?? legacyMonster?.wrappedValue

        combatLog.append("Бой начался! Враг: \(monster.name)")
        combatLog.append("У вас 3 действия за ход")

        // Engine-First: Initialize combat through engine
        engine.performAction(.combatInitialize)

        // Legacy fallback for deck operations
        if let p = player {
            p.shuffleDeck()
            p.drawCards(count: p.maxHandSize)
            // Sync engine's playerHand after legacy deck operations
            engine.syncPlayerHand()
        }

        actionsRemaining = 3
        phase = .playerTurn
    }

    func performBasicAttack() {
        guard actionsRemaining > 0 else { return }

        actionsRemaining -= 1

        let monsterDef = monster.defense ?? 10
        let monsterCurrentHP = monsterHealth
        let monsterMaxHP = monster.health ?? 10

        // Используем CombatCalculator для расчёта атаки
        guard let p = player else { return }
        let result = CombatCalculator.calculatePlayerAttack(
            player: p,
            monsterDefense: monsterDef,
            monsterCurrentHP: monsterCurrentHP,
            monsterMaxHP: monsterMaxHP,
            bonusDice: bonusDice,
            bonusDamage: bonusDamage,
            isFirstAttack: isFirstAttackThisCombat
        )

        // Сохраняем результат для отображения
        lastCombatResult = result

        // Show dice roll animation
        showDiceAnimation(diceRolls: result.attackRoll.diceRolls)

        if result.isHit, let damageCalc = result.damageCalculation {
            let damage = damageCalc.total

            // Track damage for statistics
            totalDamageDealt += damage

            // Engine-First: Apply damage through engine action
            engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: damage)))

            // Update legacy monster binding if available
            legacyMonster?.wrappedValue.health = monsterHealth

            combatLog.append("⚔️ ПОПАДАНИЕ! Бросок: \(result.attackRoll.total) vs \(monsterDef). Урон: \(damage) (HP врага: \(monsterHealth))")

            if monsterHealth <= 0 {
                finishCombat(victory: true)
            }
        } else {
            combatLog.append("⚔️ ПРОМАХ! (\(result.attackRoll.total) vs \(monsterDef))")
        }

        // Сбросить бонусы после атаки
        bonusDice = 0
        bonusDamage = 0
        isFirstAttackThisCombat = false
    }

    /// Take Cover / Defend action - adds shield to absorb damage
    func performDefend() {
        guard actionsRemaining > 0 else { return }

        actionsRemaining -= 1

        // Base defend gives +3 shield
        let baseShield = 3

        // Player strength adds to defense (some classes may have bonus)
        let strengthBonus = (player?.strength ?? 1) / 2  // Half strength as shield bonus

        let totalShield = baseShield + strengthBonus
        temporaryShield += totalShield

        combatLog.append("🛡️ Укрытие! +\(totalShield) к щиту (всего: \(temporaryShield))")

        // Log breakdown
        if strengthBonus > 0 {
            combatLog.append("   💪 Бонус силы: +\(strengthBonus)")
        }
    }

    /// Play a card as a modifier (does NOT consume actions)
    /// Cards enhance the next action (attack) or add to shield (defense)
    func playCard(_ card: Card) {
        guard phase == .playerTurn else { return }

        // Проверяем стоимость веры (Engine-First: check via engine)
        // Cards cost Faith to play - this limits infinite card usage
        let faithCost = card.cost ?? 0
        if faithCost > 0 {
            guard engine.playerFaith >= faithCost else {
                combatLog.append("❌ Недостаточно веры для \(card.name) (нужно: \(faithCost), есть: \(engine.playerFaith))")
                return
            }
            // Engine-First: Spend faith through engine action
            engine.performAction(.combatApplyEffect(effect: .spendFaith(amount: faithCost)))
            combatLog.append("💫 Потрачено \(faithCost) веры")
        }

        // Track cards played for statistics
        cardsPlayedCount += 1

        // Legacy: play card from hand (remove from hand)
        player?.playCard(card)

        // Sync engine's playerHand with legacy player (for @Published reactivity)
        engine.syncPlayerHand()

        // NEW: Cards are modifiers, not actions
        // Defense cards add to temporary shield
        // Attack cards add to bonus damage/dice
        switch card.type {
        case .defense, .armor:
            // Defense cards add to temporary shield
            let shieldValue = card.defense ?? card.power ?? 2
            temporaryShield += shieldValue
            combatLog.append("🛡️ \(card.name): +\(shieldValue) к щиту (всего: \(temporaryShield))")

        case .attack, .weapon:
            // Attack cards add bonus damage
            let attackBonus = card.power ?? 2
            bonusDamage += attackBonus
            combatLog.append("⚔️ \(card.name): +\(attackBonus) к урону следующей атаки")

        case .spell, .ritual:
            // Spells apply their effects
            combatLog.append("✨ Заклинание: \(card.name)")
            applyCardEffects(card)

        default:
            // Other cards (items, etc.) apply their effects
            combatLog.append("🃏 Сыграна: \(card.name)")
            applyCardEffects(card)
        }

        // Apply card abilities (on top of type-based effects)
        if card.type != .spell && card.type != .ritual {
            applyCardEffects(card)
        }

        // Проверяем победу (Engine-First: read from engine)
        if monsterHealth <= 0 {
            finishCombat(victory: true)
        }
    }

    func applyCardEffects(_ card: Card) {
        for ability in card.abilities {
            switch ability.effect {
            case .heal(let amount):
                // Engine-First: Heal through engine action
                engine.performAction(.combatApplyEffect(effect: .heal(amount: amount)))
                combatLog.append("   💚 Исцеление +\(amount) HP")

            case .damage(let amount, _):
                let actualDamage = player?.calculateDamageDealt(amount) ?? amount
                // Engine-First: Damage enemy through engine action
                engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: actualDamage)))
                legacyMonster?.wrappedValue.health = monsterHealth
                combatLog.append("   💥 Урон \(actualDamage) (HP врага: \(monsterHealth))")

            case .drawCards(let count):
                // Engine-First: Draw cards through engine action
                engine.performAction(.combatApplyEffect(effect: .drawCards(count: count)))
                player?.drawCards(count: count)  // Legacy sync
                engine.syncPlayerHand()  // Sync for UI reactivity
                combatLog.append("   🃏 Взято карт: \(count)")

            case .gainFaith(let amount):
                // Engine-First: Gain faith through engine action
                engine.performAction(.combatApplyEffect(effect: .gainFaith(amount: amount)))
                combatLog.append("   ✨ Вера +\(amount)")

            case .removeCurse(let type):
                // Engine-First: Remove curse through engine action (convert CurseType to String)
                engine.performAction(.combatApplyEffect(effect: .removeCurse(type: type?.rawValue)))
                combatLog.append("   🌟 Снято проклятие")

            case .addDice(let count):
                // Engine-First: Add bonus dice through engine action
                engine.performAction(.combatApplyEffect(effect: .addBonusDice(count: count)))
                bonusDice += count  // Local tracking for UI
                combatLog.append("   🎲 +\(count) кубик(ов) к следующей атаке")

            case .reroll:
                // Reroll даёт +1 кубик (выбирается лучший результат)
                engine.performAction(.combatApplyEffect(effect: .addBonusDice(count: 1)))
                bonusDice += 1
                combatLog.append("   🔄 Перебросок: +1 кубик (лучший результат)")

            case .shiftBalance(let towards, let amount):
                // Engine-First: Shift balance through engine action
                let directionString = towards == .light ? "light" : towards == .dark ? "dark" : "equilibrium"
                engine.performAction(.combatApplyEffect(effect: .shiftBalance(towards: directionString, amount: amount)))
                let directionText = towards == .light ? "Свету" : towards == .dark ? "Тьме" : "Равновесию"
                combatLog.append("   ⚖️ Баланс сдвинут к \(directionText) на \(amount)")

            case .applyCurse(let curseType, let duration):
                // В бою проклятие наносит урон монстру (тёмная магия)
                let curseDamage = duration * 2
                // Engine-First: Damage enemy through engine action
                engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: curseDamage)))
                legacyMonster?.wrappedValue.health = monsterHealth
                combatLog.append("   💀 Проклятие \(curseType): \(curseDamage) урона врагу")

            case .summonSpirit(let power, let realm):
                summonedSpirits.append((power: power, realm: realm))
                let realmName = realm == .yav ? "Явь" : realm == .nav ? "Навь" : "Правь"
                let realmString = realm == .yav ? "yav" : realm == .nav ? "nav" : "prav"
                combatLog.append("   👻 Призван дух из \(realmName) (сила: \(power))")
                // Engine-First: Spirit attacks enemy immediately through engine action
                engine.performAction(.combatApplyEffect(effect: .summonSpirit(power: power, realm: realmString)))
                legacyMonster?.wrappedValue.health = monsterHealth
                combatLog.append("   👻 Дух атакует! Урон: \(power)")

            case .sacrifice(let cost, let benefit):
                // Engine-First: Take damage through engine action
                engine.performAction(.combatApplyEffect(effect: .takeDamage(amount: cost)))
                combatLog.append("   🩸 Жертва: -\(cost) HP")
                // Парсим benefit для эффекта
                if benefit.lowercased().contains("урон") || benefit.lowercased().contains("damage") {
                    engine.performAction(.combatApplyEffect(effect: .addBonusDamage(amount: cost * 2)))
                    bonusDamage += cost * 2
                    combatLog.append("   🔥 +\(cost * 2) к урону следующей атаки")
                } else if benefit.lowercased().contains("карт") || benefit.lowercased().contains("draw") {
                    engine.performAction(.combatApplyEffect(effect: .drawCards(count: cost)))
                    player?.drawCards(count: cost)  // Legacy sync
                    engine.syncPlayerHand()  // Sync for UI reactivity
                    combatLog.append("   🃏 Взято карт: \(cost)")
                } else {
                    // Общий бонус - добавить урон
                    engine.performAction(.combatApplyEffect(effect: .addBonusDamage(amount: cost)))
                    bonusDamage += cost
                    combatLog.append("   🔥 +\(cost) к урону (\(benefit))")
                }

            case .explore:
                // Исследование не применимо в бою
                combatLog.append("   🔍 Исследование недоступно в бою")

            case .travelRealm:
                // Путешествие между мирами не применимо в бою
                combatLog.append("   🌀 Путешествие недоступно в бою")

            case .custom(let description):
                combatLog.append("   📜 \(description)")
            }
        }
    }

    func endPlayerTurn() {
        phase = .enemyTurn
    }

    func performEnemyAttack() {
        // Capture engine weakly to prevent retain cycles (engine is a class)
        // SwiftUI View is a struct, so @State vars are managed by SwiftUI
        let engineRef = engine
        let monsterName = monster.name
        let monsterPowerVal = monster.power ?? 3
        let currentShield = temporaryShield

        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) { [weak engineRef] in
            guard let engine = engineRef else { return }
            guard engine.combatState?.enemyHealth ?? 0 > 0 else {
                phase = .endTurn
                return
            }

            var rawDamage = monsterPowerVal
            var shieldAbsorbed = 0
            var actualDamage = 0

            // NEW: Shield absorbs damage first
            if currentShield > 0 {
                shieldAbsorbed = min(currentShield, rawDamage)
                rawDamage -= shieldAbsorbed
                temporaryShield -= shieldAbsorbed
            }

            // Remaining damage goes to HP
            if rawDamage > 0 {
                let healthBefore = engine.playerHealth
                engine.performAction(.combatEnemyAttack(damage: rawDamage))
                actualDamage = healthBefore - engine.playerHealth
            }

            // Track damage taken for statistics (only HP damage, not shield)
            totalDamageTaken += actualDamage

            // Build detailed combat log message
            var logMessage = "👹 \(monsterName) атакует! Сила: \(monsterPowerVal)"
            if shieldAbsorbed > 0 {
                logMessage += " | 🛡️ Щит поглотил: \(shieldAbsorbed)"
            }
            if actualDamage > 0 {
                logMessage += " | 💔 Урон HP: \(actualDamage)"
            } else if shieldAbsorbed == monsterPowerVal {
                logMessage += " | ✨ Полностью заблокировано!"
            }
            logMessage += " (HP: \(engine.playerHealth)/\(engine.playerMaxHealth), Щит: \(temporaryShield))"
            combatLog.append(logMessage)

            if engine.playerHealth <= 0 {
                finishCombat(victory: false)
            } else {
                phase = .endTurn
            }
        }
    }

    func performEndTurn() {
        // Capture engine weakly to prevent retain cycles
        let engineRef = engine
        let currentSpirits = summonedSpirits
        let currentPlayer = player

        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) { [weak engineRef] in
            guard let engine = engineRef else { return }

            // Духи атакуют в конце хода (если ещё живы)
            if !currentSpirits.isEmpty {
                for spirit in currentSpirits {
                    let spiritDamage = spirit.power
                    // Engine-First: Spirit damage through engine action
                    engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: spiritDamage)))
                    legacyMonster?.wrappedValue.health = monsterHealth
                    let realmName = spirit.realm == .yav ? "Явь" : spirit.realm == .nav ? "Навь" : "Правь"
                    combatLog.append("👻 Дух \(realmName) атакует: \(spiritDamage) урона")
                }
                // Духи исчезают после атаки
                summonedSpirits.removeAll()
            }

            // Проверяем победу после атак духов (Engine-First: read from engine)
            if engine.combatState?.enemyHealth ?? 0 <= 0 {
                finishCombat(victory: true)
                return
            }

            // Сбрасываем бонусы и щит на конец раунда
            if temporaryShield > 0 {
                combatLog.append("🛡️ Временный щит рассеялся (\(temporaryShield) → 0)")
            }
            bonusDice = 0
            bonusDamage = 0
            temporaryShield = 0  // Shield resets at end of round
            canReroll = false

            // Engine-First: End turn phase through engine action (discard, draw, faith restore)
            engine.performAction(.combatEndTurnPhase)

            // Legacy sync: discard and draw (with safety limit to prevent infinite loop)
            if let p = currentPlayer {
                let maxIterations = p.hand.count + 1  // Safety limit
                var iterations = 0
                while !p.hand.isEmpty && iterations < maxIterations {
                    p.playCard(p.hand[0])
                    iterations += 1
                }
                p.drawCards(count: p.maxHandSize)
                // Sync engine's playerHand after legacy deck operations
                engine.syncPlayerHand()
            }

            // Способность Мага: +1 вера в конце хода (Медитация)
            if currentPlayer?.shouldGainFaithEndOfTurn == true {
                combatLog.append("🔮 Медитация: +1 вера")
            }

            // Новый ход
            turnNumber += 1
            actionsRemaining = 3

            combatLog.append("━━━ Ход \(turnNumber) ━━━")

            phase = .playerTurn
        }
    }

    func finishCombat(victory: Bool) {
        phase = .combatOver

        // Save monster name BEFORE engine clears combatEnemy
        defeatedMonsterName = monster.name

        // Engine-First: Finish combat through engine action
        engine.performAction(.combatFinish(victory: victory))

        // Create combat statistics
        let stats = CombatStats(
            turnsPlayed: turnNumber,
            totalDamageDealt: totalDamageDealt,
            totalDamageTaken: totalDamageTaken,
            cardsPlayed: cardsPlayedCount
        )

        // Store stats for display in victory/defeat screen
        finalCombatStats = stats
        isVictory = victory

        if victory {
            combatLog.append("🎉 Победа! \(defeatedMonsterName) повержен!")
            combatLog.append("📊 \(stats.summary)")
        } else {
            combatLog.append("💀 Поражение...")
            combatLog.append("📊 \(stats.summary)")
        }

        // NOTE: No auto-dismiss! Player taps "Continue" button in combatOverView
        // This lets the player enjoy the victory moment and review stats
    }

    func flee() {
        // Engine-First: Flee combat through engine action
        engine.performAction(.combatFlee)

        combatLog.append("🏃 Вы сбежали из боя!")
        onCombatEnd(.fled)
    }

    // MARK: - Helpers

    var phaseText: String {
        switch phase {
        case .playerTurn: return L10n.combatPlayerTurn.localized
        case .enemyTurn: return L10n.combatEnemyTurn.localized
        case .endTurn: return L10n.combatEndTurn.localized
        case .combatOver: return L10n.combatOver.localized
        }
    }

    var phaseColor: Color {
        switch phase {
        case .playerTurn: return .green
        case .enemyTurn: return .red
        case .endTurn: return .purple
        case .combatOver: return .gray
        }
    }
}

// MARK: - Combat Card View

struct CombatCardView: View {
    let card: Card
    let canPlay: Bool
    let onPlay: () -> Void

    var body: some View {
        VStack(spacing: 4) {
            // Название карты
            Text(card.name)
                .font(.caption)
                .fontWeight(.semibold)
                .lineLimit(2)
                .multilineTextAlignment(.center)

            // Стоимость веры (если есть)
            if let cost = card.cost, cost > 0 {
                HStack(spacing: 2) {
                    Image(systemName: "sparkles")
                        .font(.system(size: 10))
                    Text("\(cost)")
                        .font(.caption2)
                }
                .foregroundColor(.yellow)
            }

            // Тип карты
            Text(cardTypeText)
                .font(.system(size: 9))
                .foregroundColor(cardTypeColor)
                .fontWeight(.medium)

            // Основной эффект
            if let ability = card.abilities.first {
                Text(abilityText(ability))
                    .font(.system(size: 10))
                    .foregroundColor(.secondary)
                    .lineLimit(2)
            }
        }
        .frame(width: 85, height: 110)
        .padding(6)
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(cardBackground)
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(canPlay ? cardBorder : Color.gray, lineWidth: canPlay ? 2 : 1)
                )
        )
        .opacity(canPlay ? 1.0 : 0.5)
        .scaleEffect(canPlay ? 1.0 : 0.95)
        .onTapGesture {
            if canPlay {
                onPlay()
            }
        }
    }

    var cardTypeText: String {
        switch card.type {
        case .attack: return "⚔️ Атака"
        case .defense: return "🛡 Защита"
        case .spell: return "✨ Заклинание"
        case .resource: return "💰 Ресурс"
        default: return "📜 Карта"
        }
    }

    var cardTypeColor: Color {
        switch card.type {
        case .attack: return .red
        case .defense: return .blue
        case .spell: return .purple
        case .resource: return .yellow
        default: return .gray
        }
    }

    var cardBackground: Color {
        switch card.type {
        case .attack: return Color.red.opacity(0.15)
        case .defense: return Color.blue.opacity(0.15)
        case .spell: return Color.purple.opacity(0.15)
        case .resource: return Color.yellow.opacity(0.15)
        default: return Color.gray.opacity(0.15)
        }
    }

    var cardBorder: Color {
        switch card.type {
        case .attack: return .red
        case .defense: return .blue
        case .spell: return .purple
        case .resource: return .yellow
        default: return .gray
        }
    }

    func abilityText(_ ability: CardAbility) -> String {
        switch ability.effect {
        case .damage(let amount, _): return "Урон: \(amount)"
        case .heal(let amount): return "Лечение: +\(amount)"
        case .drawCards(let count): return "Карты: +\(count)"
        case .gainFaith(let amount): return "Вера: +\(amount)"
        case .addDice(let count): return "+\(count) 🎲"
        case .reroll: return "Перебросок"
        case .shiftBalance(let towards, let amount):
            let dir = towards == .light ? "☀️" : towards == .dark ? "🌙" : "⚖️"
            return "\(dir) +\(amount)"
        case .applyCurse(let type, _): return "Проклятие: \(type)"
        case .removeCurse: return "Снять проклятие"
        case .summonSpirit(let power, let realm):
            let realmIcon = realm == .yav ? "🌳" : realm == .nav ? "💀" : "⭐"
            return "\(realmIcon) Дух (\(power))"
        case .sacrifice(let cost, _): return "Жертва: \(cost) HP"
        case .explore: return "Исследовать"
        case .travelRealm(let realm):
            let realmName = realm == .yav ? "Явь" : realm == .nav ? "Навь" : "Правь"
            return "→ \(realmName)"
        case .custom: return ability.description
        }
    }
}


// ==========================================
// FILE: Views/EventView.swift
// ==========================================

import SwiftUI

/// Event view with Engine-First Architecture
/// - All state mutations go through engine.performAction()
/// - UI reads state from engine properties
struct EventView: View {
    // MARK: - Engine-First Architecture
    @ObservedObject var engine: TwilightGameEngine

    let event: GameEvent
    let regionId: UUID
    let onChoiceSelected: (EventChoice) -> Void
    let onDismiss: () -> Void

    // MARK: - Legacy Support (for backwards compatibility)
    private var legacyPlayer: Player?
    private var legacyWorldState: WorldState?

    @State private var selectedChoice: EventChoice?
    @State private var showingResult = false
    @State private var resultMessage: String = ""
    @State private var combatMonster: Card?
    @State private var combatVictory: Bool?

    // MARK: - Computed Properties (Engine-First with legacy fallback)

    private var player: Player? {
        legacyPlayer
    }

    // MARK: - Initialization (Engine-First)

    init(
        engine: TwilightGameEngine,
        event: GameEvent,
        regionId: UUID,
        onChoiceSelected: @escaping (EventChoice) -> Void,
        onDismiss: @escaping () -> Void
    ) {
        self.engine = engine
        self.event = event
        self.regionId = regionId
        self.onChoiceSelected = onChoiceSelected
        self.onDismiss = onDismiss
        self.legacyPlayer = nil
        self.legacyWorldState = nil
    }

    // MARK: - Legacy Initialization (for backwards compatibility)

    init(
        event: GameEvent,
        player: Player,
        worldState: WorldState,
        regionId: UUID,
        onChoiceSelected: @escaping (EventChoice) -> Void,
        onDismiss: @escaping () -> Void
    ) {
        // Create engine connected to legacy
        let newEngine = TwilightGameEngine()
        newEngine.connectToLegacy(worldState: worldState, player: player)
        self.engine = newEngine
        self.event = event
        self.regionId = regionId
        self.onChoiceSelected = onChoiceSelected
        self.onDismiss = onDismiss
        self.legacyPlayer = player
        self.legacyWorldState = worldState
    }

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 20) {
                    // Hero Panel (consistent design across all screens)
                    HeroPanel(engine: engine, compact: true)
                        .padding(.horizontal)

                    // Event header
                    eventHeader

                    Divider()

                    // Event description
                    Text(event.description)
                        .font(.body)
                        .foregroundColor(.secondary)
                        .padding(.horizontal)

                    Divider()

                    // Choices
                    VStack(spacing: 12) {
                        Text(L10n.eventChooseAction.localized)
                            .font(.headline)
                            .padding(.horizontal)

                        ForEach(event.choices) { choice in
                            choiceButton(choice)
                        }
                    }
                    .padding(.horizontal)
                }
                .padding(.vertical)
            }
            .navigationTitle(event.title)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(L10n.uiClose.localized) {
                        onDismiss()
                    }
                }
            }
            .alert(L10n.uiResult.localized, isPresented: $showingResult) {
                Button(L10n.buttonOk.localized) {
                    // Note: onChoiceSelected is already called in handleCombatEnd for combat victories
                    // or in handleNonCombatChoice for non-combat choices
                    onDismiss()
                }
            } message: {
                Text(resultMessage)
            }
            .fullScreenCover(item: $combatMonster) { _ in
                // Combat already set up in initiateCombat via engine.setupCombatEnemy
                CombatView(
                    engine: engine,
                    onCombatEnd: { outcome in
                        handleCombatEnd(outcome: outcome)
                    }
                )
            }
        }
    }

    // MARK: - Event Header

    var eventHeader: some View {
        HStack(spacing: 12) {
            // Event type icon
            ZStack {
                Circle()
                    .fill(eventTypeColor.opacity(0.2))
                    .frame(width: 60, height: 60)

                Image(systemName: event.eventType.icon)
                    .font(.title2)
                    .foregroundColor(eventTypeColor)
            }

            VStack(alignment: .leading, spacing: 4) {
                Text(event.eventType.displayName)
                    .font(.caption)
                    .foregroundColor(.secondary)

                Text(event.title)
                    .font(.title3)
                    .fontWeight(.bold)
            }

            Spacer()
        }
        .padding(.horizontal)
    }

    // MARK: - Hero Stats (now uses HeroPanel component)
    // Old heroStatsBar removed - using unified HeroPanel component instead

    var eventTypeColor: Color {
        switch event.eventType {
        case .combat: return .red
        case .ritual: return .purple
        case .narrative: return .blue
        case .exploration: return .cyan
        case .worldShift: return .orange
        }
    }

    // MARK: - Choice Button

    func choiceButton(_ choice: EventChoice) -> some View {
        let canChoose = canMeetRequirementsEngine(choice)
        let isCombatChoice = event.eventType == .combat &&
                             choice.id == event.choices.first?.id &&
                             event.monsterCard != nil

        return Button {
            guard canChoose else { return }

            // Defer all state changes to avoid "Publishing changes from within view updates"
            DispatchQueue.main.async {
                selectedChoice = choice

                // Check if this is a combat choice
                if isCombatChoice {
                    initiateCombat(choice: choice)
                } else {
                    onChoiceSelected(choice)
                    onDismiss()
                }
            }
        } label: {
            VStack(alignment: .leading, spacing: 8) {
                Text(choice.text)
                    .font(.body)
                    .fontWeight(.medium)
                    .foregroundColor(canChoose ? .primary : .gray)

                // Requirements
                if let requirements = choice.requirements {
                    requirementsView(requirements, canMeet: canChoose)
                }

                // Preview consequences (only positive ones)
                consequencesPreview(choice.consequences)
            }
            .frame(maxWidth: .infinity, alignment: .leading)
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(canChoose ? Color(UIColor.secondarySystemBackground) : Color.gray.opacity(0.1))
            )
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(canChoose ? Color.blue.opacity(0.5) : Color.clear, lineWidth: 2)
            )
            .contentShape(Rectangle())
        }
        .buttonStyle(.plain)
        .disabled(!canChoose)
    }

    func requirementsView(_ requirements: EventRequirements, canMeet: Bool) -> some View {
        VStack(alignment: .leading, spacing: 4) {
            if let minFaith = requirements.minimumFaith {
                HStack(spacing: 4) {
                    Image(systemName: "sparkles")
                        .font(.caption2)
                    Text(L10n.eventRequiresFaith.localized(with: minFaith))
                        .font(.caption2)
                    // Engine-First: read from engine
                    Text(L10n.eventYouHaveFaith.localized(with: engine.playerFaith))
                        .font(.caption2)
                        .foregroundColor(engine.playerFaith >= minFaith ? .green : .red)
                }
                .foregroundColor(.secondary)
            }

            if let minHealth = requirements.minimumHealth {
                HStack(spacing: 4) {
                    Image(systemName: "heart.fill")
                        .font(.caption2)
                    Text(L10n.eventRequiresHealth.localized(with: minHealth))
                        .font(.caption2)
                    // Engine-First: read from engine
                    Text(L10n.eventYouHaveHealth.localized(with: engine.playerHealth))
                        .font(.caption2)
                        .foregroundColor(engine.playerHealth >= minHealth ? .green : .red)
                }
                .foregroundColor(.secondary)
            }

            if let reqBalance = requirements.requiredBalance {
                // Engine-First: read from engine
                let playerBalanceEnum = getBalanceEnum(engine.playerBalance)
                let meetsRequirement = playerBalanceEnum == reqBalance

                HStack(spacing: 4) {
                    Image(systemName: "circle.lefthalf.filled")
                        .font(.caption2)
                    Text(L10n.eventRequiresPath.localized(with: balanceText(reqBalance)))
                        .font(.caption2)
                    Text(L10n.eventYourPath.localized(with: balanceText(playerBalanceEnum)))
                        .font(.caption2)
                        .foregroundColor(meetsRequirement ? .green : .red)
                }
                .foregroundColor(.secondary)
            }
        }
    }

    func consequencesPreview(_ consequences: EventConsequences) -> some View {
        VStack(alignment: .leading, spacing: 2) {
            if let faithChange = consequences.faithChange, faithChange != 0 {
                HStack(spacing: 4) {
                    Image(systemName: faithChange > 0 ? "arrow.up" : "arrow.down")
                        .font(.caption2)
                    Text(L10n.eventFaithChange.localized(with: faithChange > 0 ? "+" : "", faithChange))
                        .font(.caption2)
                }
                .foregroundColor(faithChange > 0 ? .green : .orange)
            }

            if let healthChange = consequences.healthChange, healthChange != 0 {
                HStack(spacing: 4) {
                    Image(systemName: healthChange > 0 ? "arrow.up" : "arrow.down")
                        .font(.caption2)
                    Text(L10n.eventHealthChange.localized(with: healthChange > 0 ? "+" : "", healthChange))
                        .font(.caption2)
                }
                .foregroundColor(healthChange > 0 ? .green : .red)
            }

            if let balanceChange = consequences.balanceChange, balanceChange != 0 {
                HStack(spacing: 4) {
                    Image(systemName: balanceChange > 0 ? "sun.max.fill" : "moon.fill")
                        .font(.caption2)
                    Text(balanceChange > 0 ? L10n.eventBalanceToLight.localized : L10n.eventBalanceToDark.localized)
                        .font(.caption2)
                }
                .foregroundColor(balanceChange > 0 ? .yellow : .purple)
            }

            if let reputationChange = consequences.reputationChange, reputationChange != 0 {
                HStack(spacing: 4) {
                    Image(systemName: reputationChange > 0 ? "hand.thumbsup.fill" : "hand.thumbsdown.fill")
                        .font(.caption2)
                    Text(L10n.eventReputationChange.localized(with: reputationChange > 0 ? "+" : "", reputationChange))
                        .font(.caption2)
                }
                .foregroundColor(reputationChange > 0 ? .green : .red)
            }

            if consequences.addCards != nil {
                HStack(spacing: 4) {
                    Image(systemName: "rectangle.stack.fill.badge.plus")
                        .font(.caption2)
                    Text(L10n.eventReceiveCard.localized)
                        .font(.caption2)
                }
                .foregroundColor(.blue)
            }

            if consequences.addCurse != nil {
                HStack(spacing: 4) {
                    Image(systemName: "exclamationmark.triangle.fill")
                        .font(.caption2)
                    Text(L10n.eventReceiveCurse.localized)
                        .font(.caption2)
                }
                .foregroundColor(.red)
            }
        }
    }

    // MARK: - Combat Management

    func initiateCombat(choice: EventChoice) {
        guard let monster = event.monsterCard else { return }

        // Engine-First: Get combat context from engine or legacy
        let regionState = engine.currentRegion?.state ?? .stable
        let combatContext = CombatContext(
            regionState: regionState,
            playerCurses: player?.activeCurses.map { $0.type } ?? []
        )

        // Создать врага с модификаторами региона
        var adjustedMonster = monster
        if let baseHealth = monster.health {
            adjustedMonster.health = combatContext.adjustedEnemyHealth(baseHealth)
        }
        if let basePower = monster.power {
            adjustedMonster.power = combatContext.adjustedEnemyPower(basePower)
        }
        if let baseDefense = monster.defense {
            adjustedMonster.defense = combatContext.adjustedEnemyDefense(baseDefense)
        }

        // Setup combat in engine first, then show fullScreenCover
        engine.setupCombatEnemy(adjustedMonster)
        combatMonster = adjustedMonster
    }

    func handleCombatEnd(outcome: CombatView.CombatOutcome) {
        // Apply non-combat consequences from the choice (if victory)
        if outcome.isVictory, let choice = selectedChoice {
            onChoiceSelected(choice)
        }

        // Combat already shows its own victory/defeat screen, no need for additional alert
        // Just close combat and dismiss event view
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
            combatMonster = nil
            // Small delay before dismissing to allow animation to complete
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
                onDismiss()
            }
        }
    }

    // MARK: - Helpers

    func canMeetRequirements(_ choice: EventChoice) -> Bool {
        guard let requirements = choice.requirements else { return true }
        // Engine-First: check requirements using engine state or legacy fallback
        if let ws = legacyWorldState, let p = legacyPlayer {
            return requirements.canMeet(with: p, worldState: ws)
        }
        // TODO: Implement pure engine-based requirement checking
        return true
    }

    /// Engine-based requirement checking
    func canMeetRequirementsEngine(_ choice: EventChoice) -> Bool {
        guard let requirements = choice.requirements else { return true }

        // Check minimum faith
        if let minFaith = requirements.minimumFaith {
            if engine.playerFaith < minFaith {
                return false
            }
        }

        // Check minimum health
        if let minHealth = requirements.minimumHealth {
            if engine.playerHealth < minHealth {
                return false
            }
        }

        // Check balance requirement
        if let reqBalance = requirements.requiredBalance {
            let playerBalanceEnum = getBalanceEnum(engine.playerBalance)
            if playerBalanceEnum != reqBalance {
                return false
            }
        }

        return true
    }

    func balanceText(_ balance: CardBalance) -> String {
        switch balance {
        case .light: return L10n.tmBalanceLightGenitive.localized
        case .neutral: return L10n.tmBalanceNeutralGenitive.localized
        case .dark: return L10n.tmBalanceDarkGenitive.localized
        }
    }

    func getBalanceEnum(_ balanceValue: Int) -> CardBalance {
        if balanceValue >= 70 {        // Light path (70-100)
            return .light
        } else if balanceValue <= 30 { // Dark path (0-30)
            return .dark
        } else {                       // Neutral (30-70)
            return .neutral
        }
    }
}

// MARK: - Preview

struct EventView_Previews: PreviewProvider {
    static var previews: some View {
        let player = Player(
            name: "Волхв",
            health: 20,
            maxHealth: 20,
            maxHandSize: 5,
            faith: 10,
            balance: 0
        )

        let worldState = WorldState()

        let event = GameEvent(
            eventType: .narrative,
            title: "Тестовое событие",
            description: "Это тестовое событие для предварительного просмотра",
            choices: [
                EventChoice(
                    text: "Выбор 1",
                    consequences: EventConsequences(
                        faithChange: 5,
                        message: "Результат выбора 1"
                    )
                ),
                EventChoice(
                    text: "Выбор 2",
                    requirements: EventRequirements(minimumFaith: 10),
                    consequences: EventConsequences(
                        faithChange: -3,
                        healthChange: -2,
                        message: "Результат выбора 2"
                    )
                )
            ]
        )

        return EventView(
            event: event,
            player: player,
            worldState: worldState,
            regionId: UUID(),
            onChoiceSelected: { _ in },
            onDismiss: { }
        )
    }
}


// ==========================================
// FILE: Views/GameBoardView.swift
// ==========================================

import SwiftUI

struct GameBoardView: View {
    @StateObject var gameState: GameState
    var saveSlot: Int?
    var onExit: (() -> Void)?
    @State private var selectedCard: Card?
    @State private var showingDiceRoll = false
    @State private var combatResult: CombatResult?
    @State private var showingRules = false
    @State private var showingPauseMenu = false
    @State private var showingSaveConfirmation = false
    @State private var showingEnemyAttack = false
    @State private var showingWorldMap = false
    @State private var enemyDamage: Int = 0
    @State private var showingEventCombatVictory = false  // Для победы в бою из события
    @State private var isExitingCombat = false  // Флаг что выходим из боя
    @StateObject private var saveManager = SaveManager.shared

    struct CombatResult {
        let diceRoll: Int
        let total: Int
        let defense: Int
        let success: Bool
        let damage: Int
    }

    // Custom initializer to accept external GameState instance
    init(gameState: GameState, saveSlot: Int? = nil, onExit: (() -> Void)? = nil) {
        _gameState = StateObject(wrappedValue: gameState)
        self.saveSlot = saveSlot
        self.onExit = onExit
    }

    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // Main game view
                VStack(spacing: 0) {
                    // Top bar
                    topBar
                        .frame(height: 95)
                        .background(Color(UIColor.systemBackground))
                        .shadow(radius: 2)

                    // Main game area (scrollable)
                    ScrollView {
                        VStack(spacing: 16) {
                            // Current encounter or exploration
                            encounterArea
                                .padding(.horizontal)

                            // Market section
                            marketView
                                .padding(.horizontal)

                            // Deck info
                            deckInfoView
                                .padding(.horizontal)

                            // Space for hand
                            Color.clear.frame(height: 120)
                        }
                        .padding(.vertical)
                    }

                    Divider()

                    // Fixed player hand at bottom
                    PlayerHandView(
                        player: gameState.currentPlayer,
                        selectedCard: $selectedCard,
                        onCardPlay: playCard
                    )
                    .frame(height: 120)
                    .background(Color(UIColor.secondarySystemBackground))
                }

                // Pause menu overlay
                if showingPauseMenu {
                    pauseMenuOverlay
                }

                // Victory screen
                if gameState.isVictory {
                    Color.black.opacity(0.3)
                        .ignoresSafeArea()
                    VictoryView(
                        encountersDefeated: gameState.encountersDefeated,
                        turnsTaken: gameState.turnNumber,
                        onDismiss: {
                            onExit?()
                        }
                    )
                    .padding(20)
                }

                // Defeat screen
                if gameState.isDefeat {
                    Color.black.opacity(0.3)
                        .ignoresSafeArea()
                    DefeatView(
                        encountersDefeated: gameState.encountersDefeated,
                        turnsTaken: gameState.turnNumber,
                        onDismiss: {
                            onExit?()
                        }
                    )
                    .padding(20)
                }

                // Оверлей победы в бою из события (не полная победа в игре)
                if showingEventCombatVictory {
                    Color.black.opacity(0.5)
                        .ignoresSafeArea()
                    VStack(spacing: 16) {
                        Image(systemName: "checkmark.circle.fill")
                            .font(.system(size: 60))
                            .foregroundColor(.green)
                        Text("Враг побеждён!")
                            .font(.title)
                            .fontWeight(.bold)
                            .foregroundColor(.white)
                        Text("Возвращаемся к событию...")
                            .font(.subheadline)
                            .foregroundColor(.white.opacity(0.8))
                    }
                    .padding(40)
                    .background(Color(UIColor.systemBackground).opacity(0.95))
                    .cornerRadius(20)
                    .shadow(radius: 20)
                }
            }
        }
        .navigationBarHidden(true)
        .onAppear {
            setupAutoSave()
        }
        .onDisappear {
            autoSaveOnExit()
        }
        .onChange(of: gameState.currentPhase) { newPhase in
            if newPhase == .enemyTurn {
                // Enemy attacks during their phase
                // Capture game state weakly (it's a class via @ObservedObject)
                let gameStateRef = gameState
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak gameStateRef] in
                    guard let gs = gameStateRef else { return }
                    if let encounter = gs.activeEncounter {
                        let damage = encounter.power ?? 3
                        enemyDamage = damage
                        gs.enemyPhaseAction()
                        showingEnemyAttack = true
                    }
                }
            }
        }
        .onChange(of: gameState.activeEncounter?.id) { _ in
            // Если враг побеждён (activeEncounter стал nil) и это бой из события,
            // показываем оверлей победы и затем закрываем
            if gameState.activeEncounter == nil && onExit != nil && !gameState.isGameOver && !isExitingCombat {
                isExitingCombat = true

                // Сначала закрываем все открытые alerts
                showingDiceRoll = false
                showingEnemyAttack = false
                combatResult = nil

                // Показываем оверлей победы
                showingEventCombatVictory = true

                // После небольшой задержки закрываем экран боя
                // Capture callback before async to avoid retaining view
                let exitCallback = onExit
                DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                    showingEventCombatVictory = false
                    exitCallback?()
                }
            }
        }
        .sheet(isPresented: $showingRules) {
            RulesView()
        }
        .sheet(isPresented: $showingWorldMap) {
            WorldMapView(worldState: gameState.worldState, player: gameState.currentPlayer)
        }
        .alert(combatResult?.success == true ? "Успех!" : "Провал", isPresented: $showingDiceRoll) {
            Button(L10n.buttonOk.localized, role: .cancel) {
                combatResult = nil
            }
        } message: {
            if let result = combatResult {
                if result.success {
                    Text("Бросок: \(result.diceRoll) + Сила: \(result.total - result.diceRoll) = \(result.total)\nЗащита врага: \(result.defense)\nУрон: \(result.damage)")
                } else {
                    Text("Бросок: \(result.diceRoll) + Сила: \(result.total - result.diceRoll) = \(result.total)\nЗащита врага: \(result.defense)\nВраг атакует вас!")
                }
            }
        }
        .alert(L10n.uiGameSaved.localized, isPresented: $showingSaveConfirmation) {
            Button(L10n.buttonOk.localized, role: .cancel) { }
        } message: {
            Text(L10n.uiProgressSaved.localized)
        }
        .alert("Атака врага!", isPresented: $showingEnemyAttack) {
            Button(L10n.buttonOk.localized, role: .cancel) { }
        } message: {
            Text("Враг атакует вас и наносит \(enemyDamage) урона!\nВаше здоровье: \(gameState.currentPlayer.health)")
        }
    }

    // MARK: - Top Bar

    var topBar: some View {
        VStack(spacing: 4) {
            HStack(spacing: 12) {
                // Pause/Menu button
                Button(action: { showingPauseMenu = true }) {
                    Image(systemName: "line.3.horizontal")
                        .font(.title3)
                        .foregroundColor(.blue)
                        .padding(8)
                }

                VStack(alignment: .leading, spacing: 2) {
                    Text(L10n.turnLabel.localized(with: gameState.turnNumber))
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text(phaseText)
                        .font(.caption)
                        .fontWeight(.bold)
                        .foregroundColor(phaseColor)
                }

                Spacer()

                // Player resources - compact with icons only
                HStack(spacing: 8) {
                    // Actions
                    HStack(spacing: 2) {
                        Image(systemName: "bolt.fill")
                            .font(.system(size: 12))
                            .foregroundColor(.orange)
                        Text("\(gameState.actionsRemaining)")
                            .font(.system(size: 13))
                            .fontWeight(.bold)
                    }

                    // Health
                    HStack(spacing: 2) {
                        Image(systemName: "heart.fill")
                            .font(.system(size: 12))
                            .foregroundColor(.red)
                        Text("\(gameState.currentPlayer.health)")
                            .font(.system(size: 13))
                            .fontWeight(.bold)
                    }

                    // Faith
                    HStack(spacing: 2) {
                        Image(systemName: "sparkles")
                            .font(.system(size: 12))
                            .foregroundColor(.yellow)
                        Text("\(gameState.currentPlayer.faith)")
                            .font(.system(size: 13))
                            .fontWeight(.bold)
                    }
                }

                // Next phase button
                Button(action: {
                    gameState.nextPhase()
                }) {
                    Image(systemName: "arrow.right.circle.fill")
                        .font(.title2)
                        .foregroundColor(.green)
                }
                .padding(4)
            }
            .padding(.horizontal)

            // Phase progress bar
            PhaseProgressBar(currentPhase: gameState.currentPhase)
                .padding(.horizontal, 12)
                .padding(.bottom, 4)
        }
    }

    func resourceBadge(icon: String, value: String, color: Color, label: String) -> some View {
        HStack(spacing: 4) {
            Image(systemName: icon)
                .font(.caption)
                .foregroundColor(color)
            Text(value)
                .font(.caption2)
                .fontWeight(.bold)
            if !label.isEmpty {
                Text(label)
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
        }
        .padding(.horizontal, 6)
        .padding(.vertical, 4)
        .background(Color(UIColor.tertiarySystemBackground))
        .cornerRadius(6)
    }

    // MARK: - Encounter Area

    var encounterArea: some View {
        Group {
            if let encounter = gameState.activeEncounter {
                VStack(spacing: 12) {
                    Text(L10n.uiActiveEncounter.localized)
                        .font(.headline)
                        .foregroundColor(.red)

                    CardView(card: encounter)
                        .frame(width: 180, height: 280)

                    HStack(spacing: 16) {
                        Button(action: rollDice) {
                            Label(L10n.uiRoll.localized, systemImage: "dice.fill")
                                .font(.caption)
                                .padding(.horizontal, 12)
                                .padding(.vertical, 6)
                                .background(Color.orange)
                                .foregroundColor(.white)
                                .cornerRadius(8)
                        }

                        if let roll = gameState.diceRoll {
                            Text(L10n.uiResult.localized(with: roll))
                                .font(.subheadline)
                                .fontWeight(.bold)
                                .foregroundColor(.orange)
                        }
                    }
                }
                .padding()
                .background(
                    RoundedRectangle(cornerRadius: 12)
                        .fill(Color.red.opacity(0.1))
                        .overlay(
                            RoundedRectangle(cornerRadius: 12)
                                .stroke(Color.red, lineWidth: 2)
                        )
                )
            } else if gameState.currentPhase == .exploration {
                Button(action: {
                    gameState.drawEncounter()
                }) {
                    VStack(spacing: 12) {
                        Image(systemName: "magnifyingglass")
                            .font(.system(size: 40))
                        Text(L10n.uiExplore.localized)
                            .font(.title3)
                            .fontWeight(.bold)
                    }
                    .frame(maxWidth: .infinity)
                    .frame(height: 120)
                    .background(Color.blue.opacity(0.2))
                    .cornerRadius(12)
                }
            }
        }
    }

    // MARK: - Market View

    var marketView: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Image(systemName: "cart.fill")
                    .font(.title3)
                    .foregroundColor(.orange)
                Text("Рынок")
                    .font(.title3)
                    .fontWeight(.bold)
                Spacer()
                HStack(spacing: 4) {
                    Image(systemName: "sparkles")
                        .font(.caption)
                        .foregroundColor(.yellow)
                    Text("\(gameState.currentPlayer.faith)")
                        .font(.subheadline)
                        .fontWeight(.bold)
                }
            }

            if gameState.marketCards.isEmpty {
                Text("Нет карт для покупки")
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .frame(maxWidth: .infinity)
                    .padding()
            } else {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 12) {
                        ForEach(gameState.marketCards) { card in
                            MarketCardView(
                                card: card,
                                canAfford: gameState.currentPlayer.faith >= (card.cost ?? 0),
                                onPurchase: {
                                    if gameState.purchaseCard(card) {
                                        // Card purchased successfully
                                    }
                                }
                            )
                        }
                    }
                    .padding(.vertical, 8)
                }
            }
        }
        .padding()
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(12)
    }

    // MARK: - Deck Info

    var deckInfoView: some View {
        HStack(spacing: 12) {
            DeckPileView(
                title: L10n.uiEncounters.localized,
                count: gameState.encounterDeck.count,
                color: .red
            )

            DeckPileView(
                title: L10n.uiYourDeck.localized,
                count: gameState.currentPlayer.deck.count,
                color: .blue
            )

            DeckPileView(
                title: L10n.uiDiscard.localized,
                count: gameState.currentPlayer.discard.count,
                color: .gray
            )
        }
    }

    // MARK: - Pause Menu

    var pauseMenuOverlay: some View {
        ZStack {
            Color.black.opacity(0.5)
                .ignoresSafeArea()
                .onTapGesture {
                    showingPauseMenu = false
                }

            VStack(spacing: 16) {
                Text(L10n.uiPauseMenu.localized)
                    .font(.title2)
                    .fontWeight(.bold)

                Button(action: {
                    showingPauseMenu = false
                }) {
                    Label(L10n.uiResume.localized, systemImage: "play.fill")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.green)
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }

                Button(action: {
                    showingRules = true
                    showingPauseMenu = false
                }) {
                    Label(L10n.uiRules.localized, systemImage: "book.fill")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.blue)
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }

                Button(action: {
                    showingWorldMap = true
                    showingPauseMenu = false
                }) {
                    Label("Карта Мира", systemImage: "map.fill")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.cyan)
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }

                if let slot = saveSlot {
                    Button(action: {
                        saveManager.saveGame(to: slot, gameState: gameState)
                        showingSaveConfirmation = true
                        showingPauseMenu = false
                    }) {
                        Label(L10n.uiSaveGame.localized, systemImage: "tray.and.arrow.down.fill")
                            .frame(maxWidth: .infinity)
                            .padding()
                            .background(Color.orange)
                            .foregroundColor(.white)
                            .cornerRadius(10)
                    }
                }

                Button(action: {
                    showingPauseMenu = false
                    onExit?()
                }) {
                    Label(L10n.uiExit.localized, systemImage: "house.fill")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.red)
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }
            }
            .padding(30)
            .background(Color(UIColor.systemBackground))
            .cornerRadius(16)
            .shadow(radius: 20)
            .padding(40)
        }
    }

    // MARK: - Helper Properties

    var phaseText: String {
        switch gameState.currentPhase {
        case .setup: return L10n.phaseSetup.localized
        case .exploration: return L10n.phaseExploration.localized
        case .encounter: return L10n.phaseEncounter.localized
        case .playerTurn: return L10n.phasePlayerTurn.localized
        case .enemyTurn: return L10n.phaseEnemyTurn.localized
        case .endTurn: return L10n.phaseEndTurn.localized
        case .gameOver: return L10n.phaseGameOver.localized
        }
    }

    var phaseColor: Color {
        switch gameState.currentPhase {
        case .setup: return .gray
        case .exploration: return .blue
        case .encounter: return .orange
        case .playerTurn: return .green
        case .enemyTurn: return .red
        case .endTurn: return .purple
        case .gameOver: return .black
        }
    }

    var balanceIcon: String {
        let balance = gameState.currentPlayer.balance
        if balance >= 70 {              // Light path (70-100)
            return "sun.max.fill"
        } else if balance <= 30 {       // Dark path (0-30)
            return "moon.fill"
        } else {                        // Neutral (30-70)
            return "circle.lefthalf.filled"
        }
    }

    var balanceColor: Color {
        let balance = gameState.currentPlayer.balance
        if balance >= 70 {              // Light path (70-100)
            return .yellow
        } else if balance <= 30 {       // Dark path (0-30)
            return .purple
        } else {                        // Neutral (30-70)
            return .gray
        }
    }

    // MARK: - Helper Functions

    func rollDice() {
        guard let encounter = gameState.activeEncounter else { return }

        // Check if player has actions remaining
        guard gameState.useAction() else {
            // Show alert that no actions left
            return
        }

        // Roll dice
        let diceResult = gameState.rollDice(sides: 6, count: 1)

        // Calculate total (dice + player power)
        let playerPower = gameState.currentPlayer.strength
        let total = diceResult + playerPower

        // Get encounter defense (or use default 10 if not specified)
        let encounterDefense = encounter.defense ?? 10

        // Combat resolution
        let success = total >= encounterDefense
        var damageDealt = 0

        if success {
            // Success! Deal damage to encounter with curse modifiers
            let baseDamage = max(1, total - encounterDefense + 3) // Base 3 damage + excess
            damageDealt = gameState.currentPlayer.calculateDamageDealt(baseDamage)
            if var updatedEncounter = gameState.activeEncounter {
                let currentHealth = updatedEncounter.health ?? 10
                updatedEncounter.health = max(0, currentHealth - damageDealt)
                gameState.activeEncounter = updatedEncounter

                // Check if encounter defeated
                if updatedEncounter.health == 0 {
                    gameState.defeatEncounter()
                }
            }
        }
        // Enemy attacks during enemy phase, not immediately after player attack

        // Store combat result for display
        combatResult = CombatResult(
            diceRoll: diceResult,
            total: total,
            defense: encounterDefense,
            success: success,
            damage: damageDealt
        )

        showingDiceRoll = true
    }

    func playCard(_ card: Card) {
        // Печать Нави: нельзя использовать Sustain карты
        if card.role == .sustain && gameState.currentPlayer.hasCurse(.sealOfNav) {
            // TODO: Show alert that Sustain cards are blocked by curse
            return
        }

        // Check if player has actions remaining
        guard gameState.useAction() else {
            // TODO: Show alert that no actions left
            return
        }

        // Check if player has enough faith
        guard let cost = card.cost else {
            gameState.currentPlayer.playCard(card)
            applyCardEffects(card)
            return
        }

        if gameState.currentPlayer.spendFaith(cost) {
            gameState.currentPlayer.playCard(card)
            applyCardEffects(card)
        } else {
            // Refund action if couldn't spend faith
            gameState.actionsRemaining += 1
        }
    }

    func applyCardEffects(_ card: Card) {
        for ability in card.abilities {
            switch ability.effect {
            case .heal(let amount):
                gameState.currentPlayer.heal(amount)

            case .damage(let amount, _):
                if var encounter = gameState.activeEncounter, let health = encounter.health {
                    // Применяем модификаторы проклятий к урону
                    let actualDamage = gameState.currentPlayer.calculateDamageDealt(amount)
                    encounter.health = max(0, health - actualDamage)
                    gameState.activeEncounter = encounter
                    if encounter.health == 0 {
                        // Encounter defeated!
                        gameState.defeatEncounter()
                    }
                }

            case .drawCards(let count):
                gameState.currentPlayer.drawCards(count: count)

            case .gainFaith(let amount):
                gameState.currentPlayer.gainFaith(amount)

            case .removeCurse(let type):
                gameState.currentPlayer.removeCurse(type: type)

            case .shiftBalance(let towards, let amount):
                gameState.currentPlayer.shiftBalance(towards: towards, amount: amount)

            default:
                break
            }
        }
    }

    // MARK: - Auto-Save Functions

    func setupAutoSave() {
        guard let slot = saveSlot else { return }

        gameState.onAutoSave = { [weak saveManager, weak gameState] in
            guard let saveManager = saveManager,
                  let gameState = gameState else { return }
            saveManager.saveGame(to: slot, gameState: gameState)
        }
    }

    func autoSaveOnExit() {
        guard let slot = saveSlot else { return }
        saveManager.saveGame(to: slot, gameState: gameState)
    }
}

// MARK: - Victory/Defeat Screens

struct VictoryView: View {
    let encountersDefeated: Int
    let turnsTaken: Int
    let onDismiss: () -> Void

    var body: some View {
        VStack(spacing: 20) {
            Image(systemName: "crown.fill")
                .font(.system(size: 80))
                .foregroundColor(.yellow)

            Text(L10n.uiVictoryTitle.localized)
                .font(.largeTitle)
                .fontWeight(.bold)

            Text("Вы защитили земли от тьмы!")
                .font(.title3)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)

            VStack(spacing: 12) {
                StatRow(label: "Побеждено столкновений", value: "\(encountersDefeated)")
                StatRow(label: "Ходов сделано", value: "\(turnsTaken)")
            }
            .padding()
            .background(Color(UIColor.secondarySystemBackground))
            .cornerRadius(12)

            Button(action: onDismiss) {
                Text(L10n.uiReturnMenu.localized)
                    .font(.headline)
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.blue)
                    .cornerRadius(12)
            }
        }
        .padding(40)
        .background(Color(UIColor.systemBackground))
        .cornerRadius(20)
        .shadow(radius: 20)
    }
}

struct DefeatView: View {
    let encountersDefeated: Int
    let turnsTaken: Int
    let onDismiss: () -> Void

    var body: some View {
        VStack(spacing: 20) {
            Image(systemName: "xmark.circle.fill")
                .font(.system(size: 80))
                .foregroundColor(.red)

            Text(L10n.uiDefeatTitle.localized)
                .font(.largeTitle)
                .fontWeight(.bold)

            Text("Тьма одержала победу...")
                .font(.title3)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)

            VStack(spacing: 12) {
                StatRow(label: "Побеждено столкновений", value: "\(encountersDefeated)")
                StatRow(label: "Ходов выжито", value: "\(turnsTaken)")
            }
            .padding()
            .background(Color(UIColor.secondarySystemBackground))
            .cornerRadius(12)

            Button(action: onDismiss) {
                Text(L10n.uiReturnMenu.localized)
                    .font(.headline)
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.blue)
                    .cornerRadius(12)
            }
        }
        .padding(40)
        .background(Color(UIColor.systemBackground))
        .cornerRadius(20)
        .shadow(radius: 20)
    }
}

struct StatRow: View {
    let label: String
    let value: String

    var body: some View {
        HStack {
            Text(label)
                .foregroundColor(.secondary)
            Spacer()
            Text(value)
                .fontWeight(.bold)
        }
    }
}

// MARK: - Deck Pile View

struct DeckPileView: View {
    let title: String
    let count: Int
    let color: Color

    var body: some View {
        VStack(spacing: 6) {
            ZStack {
                ForEach(0..<min(count, 3), id: \.self) { index in
                    RoundedRectangle(cornerRadius: 4)
                        .fill(color.opacity(0.7))
                        .frame(width: 50, height: 70)
                        .offset(x: CGFloat(index) * 2, y: CGFloat(index) * -2)
                }
            }
            .frame(width: 60, height: 80)

            Text(title)
                .font(.caption2)
                .fontWeight(.bold)
                .multilineTextAlignment(.center)
            Text("\(count)")
                .font(.caption2)
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity)
    }
}

// MARK: - Market Card View

struct MarketCardView: View {
    let card: Card
    let canAfford: Bool
    let onPurchase: () -> Void

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // Rarity badge
            HStack {
                rarityBadge
                Spacer()
                // Cost badge
                HStack(spacing: 2) {
                    Image(systemName: "sparkles")
                        .font(.caption2)
                    Text("\(card.cost ?? 0)")
                        .font(.caption)
                        .fontWeight(.bold)
                }
                .padding(.horizontal, 6)
                .padding(.vertical, 2)
                .background(canAfford ? Color.yellow.opacity(0.3) : Color.gray.opacity(0.3))
                .foregroundColor(canAfford ? .yellow : .gray)
                .cornerRadius(8)
            }

            // Card name
            Text(card.name)
                .font(.subheadline)
                .fontWeight(.bold)
                .lineLimit(2)
                .minimumScaleFactor(0.8)
                .frame(height: 32, alignment: .top)

            // Card type
            Text(cardTypeText)
                .font(.caption2)
                .foregroundColor(.secondary)

            // Card stats
            HStack(spacing: 8) {
                if let power = card.power {
                    HStack(spacing: 2) {
                        Image(systemName: "bolt.fill")
                            .font(.caption2)
                            .foregroundColor(.orange)
                        Text("\(power)")
                            .font(.caption)
                    }
                }
                if let defense = card.defense {
                    HStack(spacing: 2) {
                        Image(systemName: "shield.fill")
                            .font(.caption2)
                            .foregroundColor(.blue)
                        Text("\(defense)")
                            .font(.caption)
                    }
                }
            }

            Spacer()

            // Purchase button
            Button(action: onPurchase) {
                Text("Купить")
                    .font(.caption)
                    .fontWeight(.semibold)
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 6)
                    .background(canAfford ? Color.green : Color.gray)
                    .cornerRadius(6)
            }
            .disabled(!canAfford)
        }
        .padding(8)
        .frame(width: 120, height: 180)
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(rarityBackgroundColor)
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(rarityBorderColor, lineWidth: 2)
                )
        )
    }

    var cardTypeText: String {
        switch card.type {
        case .resource: return "Ресурс"
        case .attack: return "Атака"
        case .defense: return "Защита"
        case .special: return "Особая"
        default: return card.type.rawValue
        }
    }

    var rarityBadge: some View {
        Text(rarityText)
            .font(.system(size: 8))
            .fontWeight(.bold)
            .foregroundColor(.white)
            .padding(.horizontal, 4)
            .padding(.vertical, 2)
            .background(rarityBorderColor)
            .cornerRadius(4)
    }

    var rarityText: String {
        switch card.rarity {
        case .common: return "Обычная"
        case .uncommon: return "Необычная"
        case .rare: return "Редкая"
        case .epic: return "Эпическая"
        case .legendary: return "Легендарная"
        }
    }

    var rarityBackgroundColor: Color {
        switch card.rarity {
        case .common: return Color(UIColor.tertiarySystemBackground)
        case .uncommon: return Color.green.opacity(0.1)
        case .rare: return Color.blue.opacity(0.1)
        case .epic: return Color.purple.opacity(0.1)
        case .legendary: return Color.orange.opacity(0.1)
        }
    }

    var rarityBorderColor: Color {
        switch card.rarity {
        case .common: return .gray
        case .uncommon: return .green
        case .rare: return .blue
        case .epic: return .purple
        case .legendary: return .orange
        }
    }
}

// MARK: - Phase Progress Bar

struct PhaseProgressBar: View {
    let currentPhase: GamePhase

    let phases: [(phase: GamePhase, name: String, color: Color)] = [
        (.exploration, "Исследование", .blue),
        (.encounter, "Встреча", .orange),
        (.playerTurn, "Ход игрока", .green),
        (.enemyTurn, "Ход врага", .red),
        (.endTurn, "Конец хода", .purple)
    ]

    var body: some View {
        VStack(spacing: 4) {
            // Progress bar
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    // Background
                    Rectangle()
                        .fill(Color.gray.opacity(0.2))
                        .frame(height: 4)
                        .cornerRadius(2)

                    // Progress indicator
                    Rectangle()
                        .fill(currentPhaseColor)
                        .frame(width: progressWidth(totalWidth: geometry.size.width), height: 4)
                        .cornerRadius(2)
                }
            }
            .frame(height: 4)

            // Phase indicators
            HStack(spacing: 0) {
                ForEach(Array(phases.enumerated()), id: \.offset) { index, phaseInfo in
                    VStack(spacing: 2) {
                        Circle()
                            .fill(phaseInfo.phase == currentPhase ? phaseInfo.color : Color.gray.opacity(0.3))
                            .frame(width: 8, height: 8)
                            .overlay(
                                Circle()
                                    .stroke(phaseInfo.color, lineWidth: phaseInfo.phase == currentPhase ? 2 : 0)
                            )

                        Text(phaseInfo.name)
                            .font(.system(size: 8))
                            .foregroundColor(phaseInfo.phase == currentPhase ? phaseInfo.color : .secondary)
                            .lineLimit(1)
                            .minimumScaleFactor(0.5)
                    }
                    .frame(maxWidth: .infinity)
                }
            }
        }
    }

    var currentPhaseColor: Color {
        phases.first(where: { $0.phase == currentPhase })?.color ?? .gray
    }

    func progressWidth(totalWidth: CGFloat) -> CGFloat {
        guard let currentIndex = phases.firstIndex(where: { $0.phase == currentPhase }) else {
            return 0
        }
        let progress = CGFloat(currentIndex + 1) / CGFloat(phases.count)
        return totalWidth * progress
    }
}


// ==========================================
// FILE: Views/HeroSelectionView.swift
// ==========================================

import SwiftUI

/// Экран выбора класса героя при начале новой игры
struct HeroSelectionView: View {
    let onHeroSelected: (HeroClass) -> Void

    @State private var selectedClass: HeroClass?

    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Заголовок
                VStack(spacing: 8) {
                    Text("Выберите героя")
                        .font(.largeTitle)
                        .fontWeight(.bold)

                    Text("Каждый класс имеет уникальные характеристики и способности")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                        .padding(.horizontal)
                }
                .padding(.top, 20)
                .padding(.bottom, 16)

                // Список героев
                ScrollView {
                    VStack(spacing: 12) {
                        ForEach(HeroClass.allCases, id: \.self) { heroClass in
                            HeroClassCard(
                                heroClass: heroClass,
                                isSelected: selectedClass == heroClass
                            ) {
                                withAnimation(.easeInOut(duration: 0.2)) {
                                    selectedClass = heroClass
                                }
                            }
                        }
                    }
                    .padding(.horizontal)
                    .padding(.bottom, 100)  // Место для кнопки
                }

                Spacer()

                // Кнопка подтверждения
                VStack(spacing: 8) {
                    if let selected = selectedClass {
                        Button(action: {
                            onHeroSelected(selected)
                        }) {
                            HStack {
                                Text(selected.icon)
                                Text("Начать игру за \(selected.rawValue)")
                                    .fontWeight(.semibold)
                            }
                            .frame(maxWidth: .infinity)
                            .padding()
                            .background(Color.blue)
                            .foregroundColor(.white)
                            .cornerRadius(12)
                        }
                        .padding(.horizontal)
                    } else {
                        Text("Выберите класс героя")
                            .foregroundColor(.secondary)
                            .padding()
                    }
                }
                .padding(.bottom, 20)
                .background(
                    Color(UIColor.systemBackground)
                        .shadow(radius: 5)
                )
            }
            .background(Color(UIColor.secondarySystemBackground))
            .navigationBarHidden(true)
        }
    }
}

/// Карточка класса героя
struct HeroClassCard: View {
    let heroClass: HeroClass
    let isSelected: Bool
    let onTap: () -> Void

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Заголовок
            HStack {
                Text(heroClass.icon)
                    .font(.title)

                VStack(alignment: .leading, spacing: 2) {
                    Text(heroClass.rawValue)
                        .font(.title2)
                        .fontWeight(.bold)

                    Text(heroClass.description)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }

                Spacer()

                if isSelected {
                    Image(systemName: "checkmark.circle.fill")
                        .font(.title2)
                        .foregroundColor(.blue)
                }
            }

            // Характеристики
            let stats = heroClass.baseStats
            HStack(spacing: 16) {
                StatBadge(icon: "heart.fill", value: stats.health, label: "HP", color: .red)
                StatBadge(icon: "hand.raised.fill", value: stats.strength, label: "Сила", color: .orange)
                StatBadge(icon: "sparkles", value: stats.faith, label: "Вера", color: .yellow)
                StatBadge(icon: "brain.head.profile", value: stats.intelligence, label: "Инт", color: .purple)
            }

            // Особая способность
            HStack(spacing: 8) {
                Image(systemName: "star.fill")
                    .foregroundColor(.yellow)
                    .font(.caption)

                Text(heroClass.specialAbility)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            .padding(8)
            .background(Color.yellow.opacity(0.1))
            .cornerRadius(8)

            // Стартовый путь
            HStack(spacing: 8) {
                Image(systemName: "rectangle.stack.fill")
                    .foregroundColor(deckPathColor(heroClass.startingDeckType))
                    .font(.caption)

                Text("Путь: \(deckPathName(heroClass.startingDeckType))")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(UIColor.systemBackground))
                .overlay(
                    RoundedRectangle(cornerRadius: 12)
                        .stroke(isSelected ? Color.blue : Color.gray.opacity(0.3), lineWidth: isSelected ? 3 : 1)
                )
        )
        .onTapGesture {
            onTap()
        }
    }

    func deckPathName(_ path: DeckPath) -> String {
        switch path {
        case .light: return "Свет"
        case .dark: return "Тьма"
        case .balance: return "Равновесие"
        }
    }

    func deckPathColor(_ path: DeckPath) -> Color {
        switch path {
        case .light: return .yellow
        case .dark: return .purple
        case .balance: return .gray
        }
    }
}

/// Бейдж характеристики
struct StatBadge: View {
    let icon: String
    let value: Int
    let label: String
    let color: Color

    var body: some View {
        VStack(spacing: 2) {
            Image(systemName: icon)
                .font(.caption)
                .foregroundColor(color)

            Text("\(value)")
                .font(.caption)
                .fontWeight(.bold)

            Text(label)
                .font(.system(size: 8))
                .foregroundColor(.secondary)
        }
        .frame(minWidth: 40)
    }
}

#Preview {
    HeroSelectionView { heroClass in
        print("Selected: \(heroClass.rawValue)")
    }
}


// ==========================================
// FILE: Views/PlayerHandView.swift
// ==========================================

import SwiftUI

struct PlayerHandView: View {
    @ObservedObject var player: Player
    @Binding var selectedCard: Card?
    var onCardPlay: ((Card) -> Void)?

    var body: some View {
        VStack(spacing: 4) {
            // Play card button (shown when card is selected)
            if let selected = selectedCard {
                HStack(spacing: 12) {
                    Button(action: {
                        onCardPlay?(selected)
                        selectedCard = nil
                    }) {
                        Label("Сыграть карту", systemImage: "play.fill")
                            .font(.headline)
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 8)
                            .background(Color.green)
                            .cornerRadius(8)
                    }

                    Button(action: {
                        selectedCard = nil
                    }) {
                        Image(systemName: "xmark.circle.fill")
                            .font(.title2)
                            .foregroundColor(.gray)
                    }
                }
                .padding(.horizontal, 12)
                .padding(.vertical, 4)
                .background(Color(UIColor.tertiarySystemBackground))
            }

            // Compact deck info
            HStack(spacing: 16) {
                Text(player.name)
                    .font(.caption)
                    .fontWeight(.bold)

                Spacer()

                // Deck count
                HStack(spacing: 4) {
                    Image(systemName: "rectangle.stack.fill")
                        .font(.caption2)
                    Text("\(player.deck.count)")
                        .font(.caption2)
                }
                .foregroundColor(.blue)

                // Discard count
                HStack(spacing: 4) {
                    Image(systemName: "trash.fill")
                        .font(.caption2)
                    Text("\(player.discard.count)")
                        .font(.caption2)
                }
                .foregroundColor(.gray)
            }
            .padding(.horizontal, 12)
            .padding(.vertical, 4)
            .background(Color(UIColor.secondarySystemBackground))

            // Hand of cards
            if player.hand.isEmpty {
                Text("Нет карт в руке")
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .padding()
            } else {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 8) {
                        ForEach(player.hand) { card in
                            HandCardView(
                                card: card,
                                isSelected: selectedCard?.id == card.id,
                                onTap: {
                                    if selectedCard?.id == card.id {
                                        selectedCard = nil
                                    } else {
                                        selectedCard = card
                                    }
                                }
                            )
                        }
                    }
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                }
            }
        }
    }
}


// ==========================================
// FILE: Views/RulesView.swift
// ==========================================

import SwiftUI

struct RulesView: View {
    @Environment(\.dismiss) var dismiss

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 24) {
                    // Game Objective
                    RuleSection(
                        icon: "target",
                        color: .blue,
                        title: L10n.rulesObjectiveTitle.localized,
                        content: L10n.rulesObjectiveContent.localized
                    )

                    // Game Phases
                    RuleSection(
                        icon: "arrow.triangle.2.circlepath",
                        color: .orange,
                        title: L10n.rulesPhasesTitle.localized,
                        content: L10n.rulesPhasesContent.localized
                    )

                    VStack(alignment: .leading, spacing: 12) {
                        PhaseCard(
                            phase: L10n.phaseExploration.localized,
                            description: L10n.rulesPhaseExploration.localized,
                            color: .blue
                        )
                        PhaseCard(
                            phase: L10n.phaseEncounter.localized,
                            description: L10n.rulesPhaseEncounter.localized,
                            color: .orange
                        )
                        PhaseCard(
                            phase: L10n.phasePlayerTurn.localized,
                            description: L10n.rulesPhasePlayerTurn.localized,
                            color: .green
                        )
                        PhaseCard(
                            phase: L10n.phaseEnemyTurn.localized,
                            description: L10n.rulesPhaseEnemyTurn.localized,
                            color: .red
                        )
                        PhaseCard(
                            phase: L10n.phaseEndTurn.localized,
                            description: L10n.rulesPhaseEndTurn.localized,
                            color: .purple
                        )
                    }
                    .padding(.leading, 8)

                    // Card Types
                    RuleSection(
                        icon: "rectangle.stack.fill",
                        color: .purple,
                        title: L10n.rulesCardsTitle.localized,
                        content: L10n.rulesCardsContent.localized
                    )

                    // Resources
                    RuleSection(
                        icon: "star.fill",
                        color: .pink,
                        title: L10n.rulesResourcesTitle.localized,
                        content: L10n.rulesResourcesContent.localized
                    )

                    // Actions
                    RuleSection(
                        icon: "bolt.fill",
                        color: .orange,
                        title: L10n.rulesActionsTitle.localized,
                        content: L10n.rulesActionsContent.localized
                    )

                    // Dice Rolls
                    RuleSection(
                        icon: "dice.fill",
                        color: .green,
                        title: L10n.rulesDiceTitle.localized,
                        content: L10n.rulesDiceContent.localized
                    )

                    // Victory Conditions
                    RuleSection(
                        icon: "trophy.fill",
                        color: .yellow,
                        title: L10n.rulesVictoryTitle.localized,
                        content: L10n.rulesVictoryContent.localized
                    )

                    // Tips
                    RuleSection(
                        icon: "lightbulb.fill",
                        color: .cyan,
                        title: L10n.rulesTipsTitle.localized,
                        content: L10n.rulesTipsContent.localized
                    )
                }
                .padding()
            }
            .navigationTitle(L10n.rulesTitle.localized)
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark.circle.fill")
                            .foregroundColor(.secondary)
                    }
                }
            }
        }
    }
}

struct RuleSection: View {
    let icon: String
    let color: Color
    let title: String
    let content: String

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack(spacing: 12) {
                Image(systemName: icon)
                    .font(.title2)
                    .foregroundColor(color)

                Text(title)
                    .font(.title2)
                    .fontWeight(.bold)
            }

            Text(content)
                .font(.body)
                .foregroundColor(.primary)
                .fixedSize(horizontal: false, vertical: true)
        }
        .padding()
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(12)
    }
}

struct PhaseCard: View {
    let phase: String
    let description: String
    let color: Color

    var body: some View {
        HStack(spacing: 12) {
            Circle()
                .fill(color)
                .frame(width: 12, height: 12)

            VStack(alignment: .leading, spacing: 4) {
                Text(phase)
                    .font(.headline)
                    .foregroundColor(color)

                Text(description)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(Color(UIColor.tertiarySystemBackground))
        .cornerRadius(8)
    }
}

#Preview {
    RulesView()
}


// ==========================================
// FILE: Views/StatisticsView.swift
// ==========================================

import SwiftUI

struct StatisticsView: View {
    @StateObject private var saveManager = SaveManager.shared
    @Environment(\.dismiss) var dismiss

    var allSaves: [GameSave] {
        [1, 2, 3].compactMap { saveManager.loadGame(from: $0) }
    }

    var bestEncountersDefeated: Int {
        allSaves.map { $0.encountersDefeated }.max() ?? 0
    }

    var longestSurvival: Int {
        allSaves.map { $0.turnNumber }.max() ?? 0
    }

    var totalGames: Int {
        allSaves.count
    }

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 24) {
                    // Header
                    VStack(spacing: 8) {
                        Text("📊 " + L10n.statsTitle.localized)
                            .font(.largeTitle)
                            .fontWeight(.bold)
                        Text(L10n.statsGameName.localized)
                            .font(.title3)
                            .foregroundColor(.secondary)
                    }
                    .padding(.top)

                    // Overall Statistics
                    VStack(alignment: .leading, spacing: 16) {
                        Text(L10n.statsGeneral.localized)
                            .font(.headline)

                        HStack(spacing: 16) {
                            StatCard(
                                icon: "gamecontroller.fill",
                                title: L10n.statsGamesCount.localized,
                                value: "\(totalGames)",
                                color: .blue
                            )

                            StatCard(
                                icon: "trophy.fill",
                                title: L10n.statsBestResult.localized,
                                value: "\(bestEncountersDefeated)",
                                color: .orange
                            )

                            StatCard(
                                icon: "clock.fill",
                                title: L10n.statsLongestSurvival.localized,
                                value: L10n.statsTurnsCount.localized(with: longestSurvival),
                                color: .green
                            )
                        }
                    }
                    .padding()
                    .background(Color(UIColor.secondarySystemBackground))
                    .cornerRadius(12)

                    // Leaderboard
                    if !allSaves.isEmpty {
                        VStack(alignment: .leading, spacing: 16) {
                            Text(L10n.statsLeaderboard.localized)
                                .font(.headline)

                            ForEach(Array(allSaves.sorted(by: { $0.encountersDefeated > $1.encountersDefeated }).enumerated()), id: \.element.id) { index, save in
                                LeaderboardRow(
                                    rank: index + 1,
                                    save: save
                                )
                            }
                        }
                        .padding()
                        .background(Color(UIColor.secondarySystemBackground))
                        .cornerRadius(12)

                        // Detailed Game Records
                        VStack(alignment: .leading, spacing: 16) {
                            Text(L10n.statsHistory.localized)
                                .font(.headline)

                            ForEach(allSaves.sorted(by: { $0.timestamp > $1.timestamp })) { save in
                                GameRecordCard(save: save)
                            }
                        }
                        .padding()
                        .background(Color(UIColor.secondarySystemBackground))
                        .cornerRadius(12)
                    } else {
                        VStack(spacing: 12) {
                            Image(systemName: "chart.bar.xaxis")
                                .font(.system(size: 60))
                                .foregroundColor(.secondary)
                            Text(L10n.statsNoSaves.localized)
                                .font(.headline)
                                .foregroundColor(.secondary)
                            Text(L10n.statsStartHint.localized)
                                .font(.subheadline)
                                .foregroundColor(.secondary)
                                .multilineTextAlignment(.center)
                        }
                        .padding(40)
                        .background(Color(UIColor.secondarySystemBackground))
                        .cornerRadius(12)
                    }
                }
                .padding()
            }
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: { dismiss() }) {
                        Text(L10n.statsDone.localized)
                            .fontWeight(.semibold)
                    }
                }
            }
        }
    }
}

struct StatCard: View {
    let icon: String
    let title: String
    let value: String
    let color: Color

    var body: some View {
        VStack(spacing: 8) {
            Image(systemName: icon)
                .font(.title2)
                .foregroundColor(color)

            Text(value)
                .font(.title3)
                .fontWeight(.bold)

            Text(title)
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(Color(UIColor.tertiarySystemBackground))
        .cornerRadius(10)
    }
}

struct LeaderboardRow: View {
    let rank: Int
    let save: GameSave

    var rankIcon: String {
        switch rank {
        case 1: return "🥇"
        case 2: return "🥈"
        case 3: return "🥉"
        default: return "\(rank)."
        }
    }

    var body: some View {
        HStack(spacing: 12) {
            Text(rankIcon)
                .font(.title2)
                .frame(width: 40)

            VStack(alignment: .leading, spacing: 4) {
                Text(save.characterName)
                    .font(.subheadline)
                    .fontWeight(.semibold)

                HStack(spacing: 8) {
                    Label("\(save.encountersDefeated)", systemImage: "star.fill")
                        .font(.caption)
                        .foregroundColor(.orange)
                    Label("\(save.turnNumber)", systemImage: "clock.fill")
                        .font(.caption)
                        .foregroundColor(.blue)
                }
            }

            Spacer()

            VStack(alignment: .trailing, spacing: 4) {
                Text(L10n.uiSlotNumber.localized(with: save.slotNumber))
                    .font(.caption2)
                    .foregroundColor(.secondary)
                Text(save.formattedDate)
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color(UIColor.tertiarySystemBackground))
        .cornerRadius(8)
    }
}

struct GameRecordCard: View {
    let save: GameSave

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(save.characterName)
                        .font(.headline)
                    Text(L10n.uiSlotNumber.localized(with: save.slotNumber))
                        .font(.caption)
                        .foregroundColor(.secondary)
                }

                Spacer()

                Text(save.formattedDate)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }

            Divider()

            HStack(spacing: 20) {
                VStack(alignment: .leading, spacing: 4) {
                    Text(L10n.statsResources.localized)
                        .font(.caption)
                        .foregroundColor(.secondary)
                    HStack(spacing: 12) {
                        Label("\(save.health)/\(save.maxHealth)", systemImage: "heart.fill")
                            .foregroundColor(.red)
                        Label("\(save.faith)", systemImage: "sparkles")
                            .foregroundColor(.yellow)
                        Label("\(save.balance)", systemImage: "scale.3d")
                            .foregroundColor(.purple)
                    }
                    .font(.caption)
                }

                Spacer()

                VStack(alignment: .trailing, spacing: 4) {
                    Text(L10n.statsProgress.localized)
                        .font(.caption)
                        .foregroundColor(.secondary)
                    HStack(spacing: 12) {
                        VStack(alignment: .trailing, spacing: 2) {
                            Text("\(save.encountersDefeated)")
                                .font(.headline)
                            Text(L10n.statsVictoriesLabel.localized)
                                .font(.caption2)
                                .foregroundColor(.secondary)
                        }
                        VStack(alignment: .trailing, spacing: 2) {
                            Text("\(save.turnNumber)")
                                .font(.headline)
                            Text(L10n.statsTurnsLabel.localized)
                                .font(.caption2)
                                .foregroundColor(.secondary)
                        }
                    }
                }
            }
        }
        .padding()
        .background(Color(UIColor.tertiarySystemBackground))
        .cornerRadius(10)
    }
}

#Preview {
    StatisticsView()
}


// ==========================================
// FILE: Views/WorldMapView.swift
// ==========================================

import SwiftUI

struct WorldMapView: View {
    // MARK: - Engine-First Architecture
    // Engine is the ONLY source of truth for UI
    @ObservedObject var engine: TwilightGameEngine
    var onExit: (() -> Void)? = nil

    // MARK: - Legacy Support (for gradual migration)
    // These will be removed once all Views are migrated
    private var worldState: WorldState?
    private var player: Player?

    @State private var selectedRegion: EngineRegionState?
    @State private var showingExitConfirmation = false
    @State private var showingEventLog = false
    @State private var showingDayEvent = false
    @State private var currentDayEvent: DayEvent?

    // MARK: - Initialization (Engine-First)

    init(engine: TwilightGameEngine, onExit: (() -> Void)? = nil) {
        self.engine = engine
        self.onExit = onExit
        self.worldState = nil
        self.player = nil
    }

    // MARK: - Legacy Initialization (for backwards compatibility during migration)

    init(worldState: WorldState, player: Player, onExit: (() -> Void)? = nil) {
        // Create new engine connected to legacy
        let newEngine = TwilightGameEngine()
        newEngine.connectToLegacy(worldState: worldState, player: player)
        self.engine = newEngine
        self.onExit = onExit
        self.worldState = worldState
        self.player = player
    }

    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Hero Panel (persistent, consistent design across all screens)
                HeroPanel(engine: engine)
                    .padding(.horizontal, 8)
                    .padding(.top, 4)

                Divider()
                    .padding(.vertical, 4)

                // Top bar with world info
                worldInfoBar

                Divider()

                // Regions list (Engine-First: reads from engine.regionsArray)
                if engine.regionsArray.isEmpty {
                    // Show loading state if regions aren't loaded yet
                    VStack(spacing: 16) {
                        ProgressView()
                            .scaleEffect(1.5)
                        Text("Загрузка мира...")
                            .font(.headline)
                            .foregroundColor(.secondary)
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else {
                    ScrollView {
                        LazyVStack(spacing: 12) {
                            ForEach(engine.regionsArray, id: \.id) { region in
                                EngineRegionCardView(
                                    region: region,
                                    isCurrentLocation: region.id == engine.currentRegionId
                                )
                                .onTapGesture {
                                    selectedRegion = region
                                }
                            }
                        }
                        .padding()
                    }
                }
            }
            .navigationTitle(L10n.tmGameTitle.localized)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    if onExit != nil {
                        Button(action: {
                            showingExitConfirmation = true
                        }) {
                            HStack(spacing: 4) {
                                Image(systemName: "chevron.left")
                                Text(L10n.uiMenuButton.localized)
                            }
                        }
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        showingEventLog = true
                    }) {
                        Image(systemName: "book.closed")
                    }
                }
            }
            .sheet(isPresented: $showingEventLog) {
                EngineEventLogView(engine: engine)
            }
            .sheet(item: $selectedRegion) { region in
                EngineRegionDetailView(
                    region: region,
                    engine: engine,
                    onDismiss: {
                        selectedRegion = nil
                    },
                    onRegionChange: { newRegion in
                        selectedRegion = newRegion
                    }
                )
            }
            .alert(L10n.uiExit.localized + "?", isPresented: $showingExitConfirmation) {
                Button(L10n.uiCancel.localized, role: .cancel) { }
                Button(L10n.uiExit.localized, role: .destructive) {
                    onExit?()
                }
            } message: {
                Text(L10n.uiProgressSaved.localized)
            }
            .alert(currentDayEvent?.title ?? "Событие мира", isPresented: $showingDayEvent) {
                Button("Понятно", role: .cancel) {
                    currentDayEvent = nil
                }
            } message: {
                if let event = currentDayEvent {
                    Text("День \(event.day)\n\n\(event.description)")
                }
            }
            .onChange(of: engine.lastDayEvent?.id) { _ in
                if let event = engine.lastDayEvent {
                    currentDayEvent = event
                    showingDayEvent = true
                    // Dismiss via Engine action (Engine-First)
                    engine.performAction(.dismissDayEvent)
                }
            }
        }
    }

    // MARK: - Player Info (now uses HeroPanel component)
    // Old playerInfoBar removed - using unified HeroPanel component instead

    // MARK: - World Info Bar (Engine-First: reads from engine.*)

    var worldInfoBar: some View {
        VStack(spacing: 8) {
            HStack {
                // World Tension
                VStack(alignment: .leading, spacing: 2) {
                    Text(L10n.tooltipBalance.localized)
                        .font(.caption2)
                        .foregroundColor(.secondary)
                    HStack(spacing: 4) {
                        Image(systemName: "exclamationmark.triangle.fill")
                            .font(.caption)
                            .foregroundColor(tensionColor)
                        Text("\(engine.worldTension)%")
                            .font(.caption)
                            .fontWeight(.bold)
                    }
                }

                Spacer()

                // World Light/Dark Balance (Явь vs Навь)
                VStack(spacing: 2) {
                    Text("Мир")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                    Text(engine.worldBalanceDescription)
                        .font(.caption)
                        .fontWeight(.bold)
                        .foregroundColor(balanceColor)
                }

                Spacer()

                // Days passed
                VStack(alignment: .trailing, spacing: 2) {
                    Text("Дней в пути")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                    Text("\(engine.currentDay)")
                        .font(.caption)
                        .fontWeight(.bold)
                }
            }
            .padding(.horizontal)

            // Tension progress bar
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    Rectangle()
                        .fill(Color.gray.opacity(0.2))
                        .frame(height: 4)

                    Rectangle()
                        .fill(tensionColor)
                        .frame(
                            width: geometry.size.width * CGFloat(engine.worldTension) / 100,
                            height: 4
                        )
                }
            }
            .frame(height: 4)
            .padding(.horizontal)
        }
        .padding(.vertical, 8)
        .background(Color(UIColor.systemBackground))
    }

    var tensionColor: Color {
        switch engine.worldTension {
        case 0..<30: return .green
        case 30..<60: return .yellow
        case 60..<80: return .orange
        default: return .red
        }
    }

    var balanceColor: Color {
        switch engine.lightDarkBalance {
        case 0..<30: return .purple      // Тьма
        case 30..<70: return .gray       // Нейтрально
        case 70...100: return .yellow    // Свет
        default: return .gray
        }
    }
}

// MARK: - Region Card View

struct RegionCardView: View {
    let region: Region
    let isCurrentLocation: Bool

    var body: some View {
        HStack(spacing: 12) {
            // Icon
            ZStack {
                Circle()
                    .fill(stateColor.opacity(0.2))
                    .frame(width: 60, height: 60)

                Image(systemName: region.type.icon)
                    .font(.title2)
                    .foregroundColor(stateColor)
            }

            // Info
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(region.name)
                        .font(.headline)
                        .fontWeight(.bold)

                    if isCurrentLocation {
                        Image(systemName: "location.fill")
                            .font(.caption)
                            .foregroundColor(.blue)
                    }
                }

                HStack(spacing: 8) {
                    Text(region.state.emoji)
                        .font(.caption)
                    Text(region.state.displayName)
                        .font(.caption)
                        .foregroundColor(.secondary)

                    Spacer()

                    Text(region.type.displayName)
                        .font(.caption2)
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(Color.gray.opacity(0.2))
                        .cornerRadius(4)
                }

                // Anchor info
                if let anchor = region.anchor {
                    HStack(spacing: 4) {
                        Image(systemName: anchor.type.icon)
                            .font(.caption2)
                            .foregroundColor(.orange)
                        Text(anchor.name)
                            .font(.caption2)
                            .foregroundColor(.secondary)
                        Spacer()
                        Text("\(anchor.integrity)%")
                            .font(.caption2)
                            .fontWeight(.bold)
                            .foregroundColor(anchorIntegrityColor(anchor.integrity))
                    }
                }

                // Reputation
                if region.reputation != 0 {
                    HStack(spacing: 4) {
                        Image(systemName: region.reputation > 0 ? "hand.thumbsup.fill" : "hand.thumbsdown.fill")
                            .font(.caption2)
                            .foregroundColor(region.reputation > 0 ? .green : .red)
                        Text("Репутация: \(region.reputation > 0 ? "+" : "")\(region.reputation)")
                            .font(.caption2)
                            .foregroundColor(.secondary)
                    }
                }
            }

            Spacer()

            // Arrow
            Image(systemName: "chevron.right")
                .font(.caption)
                .foregroundColor(.gray)
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(UIColor.secondarySystemBackground))
                .shadow(color: isCurrentLocation ? .blue.opacity(0.3) : .clear, radius: 4)
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(isCurrentLocation ? Color.blue : Color.clear, lineWidth: 2)
        )
    }

    var stateColor: Color {
        switch region.state {
        case .stable: return .green
        case .borderland: return .orange
        case .breach: return .red
        }
    }

    func anchorIntegrityColor(_ integrity: Int) -> Color {
        switch integrity {
        case 70...100: return .green
        case 30..<70: return .orange
        default: return .red
        }
    }
}

// MARK: - Region Detail View

struct RegionDetailView: View {
    let region: Region
    @ObservedObject var worldState: WorldState
    @ObservedObject var player: Player
    @ObservedObject var engine: TwilightGameEngine  // Audit v1.1 Issue #4
    let onDismiss: () -> Void
    @State private var showingActionConfirmation = false
    @State private var selectedAction: RegionAction?
    @State private var eventToShow: GameEvent?
    @State private var showingNoEventsAlert = false

    // Card received notification
    @State private var showingCardNotification = false
    @State private var receivedCardNames: [String] = []

    enum RegionAction {
        case travel
        case rest
        case trade
        case strengthenAnchor
        case explore
    }

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 20) {
                    // Region header
                    regionHeader

                    // Risk display for non-stable regions
                    if region.state != .stable {
                        riskInfoSection
                    }

                    Divider()

                    // Anchor section
                    if let anchor = region.anchor {
                        anchorSection(anchor: anchor)
                        Divider()
                    }

                    // Available actions
                    actionsSection

                    Divider()

                    // Quest info
                    if !region.activeQuests.isEmpty {
                        questsSection
                    }
                }
                .padding()
            }
            .navigationTitle(region.name)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Закрыть") {
                        onDismiss()
                    }
                }
            }
            .sheet(item: $eventToShow) { event in
                EventView(
                    event: event,
                    player: player,
                    worldState: worldState,
                    regionId: region.id,
                    onChoiceSelected: { choice in
                        handleEventChoice(choice, event: event)
                    },
                    onDismiss: {
                        eventToShow = nil
                    }
                )
            }
            .alert(actionConfirmationTitle, isPresented: $showingActionConfirmation) {
                Button("Подтвердить") {
                    if let action = selectedAction {
                        performAction(action)
                    }
                }
                Button("Отмена", role: .cancel) { }
            } message: {
                Text(actionConfirmationMessage)
            }
            .alert("Ничего не найдено", isPresented: $showingNoEventsAlert) {
                Button("OK", role: .cancel) { }
            } message: {
                Text("В этом регионе сейчас нет доступных событий для исследования.")
            }
            .overlay {
                // Card received notification overlay
                if showingCardNotification && !receivedCardNames.isEmpty {
                    legacyCardReceivedNotificationView
                }
            }
        }
    }

    // MARK: - Legacy Card Received Notification View

    var legacyCardReceivedNotificationView: some View {
        ZStack {
            Color.black.opacity(0.5)
                .ignoresSafeArea()
                .onTapGesture {
                    withAnimation(.easeOut(duration: 0.3)) {
                        showingCardNotification = false
                    }
                }

            VStack(spacing: 20) {
                VStack(spacing: 8) {
                    Text("🃏")
                        .font(.system(size: 48))
                    Text("Получены карты!")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.white)
                    Text("Добавлены в вашу колоду")
                        .font(.subheadline)
                        .foregroundColor(.white.opacity(0.8))
                }

                VStack(spacing: 12) {
                    ForEach(receivedCardNames, id: \.self) { cardName in
                        HStack {
                            Image(systemName: "rectangle.stack.badge.plus")
                                .foregroundColor(.yellow)
                            Text(cardName)
                                .fontWeight(.semibold)
                                .foregroundColor(.white)
                        }
                        .padding(.horizontal, 16)
                        .padding(.vertical, 10)
                        .background(
                            RoundedRectangle(cornerRadius: 8)
                                .fill(Color.purple.opacity(0.6))
                        )
                    }
                }

                Button(action: {
                    withAnimation(.easeOut(duration: 0.3)) {
                        showingCardNotification = false
                    }
                }) {
                    Text("Отлично!")
                        .font(.headline)
                        .foregroundColor(.white)
                        .frame(minWidth: 120)
                        .padding()
                        .background(Color.blue)
                        .cornerRadius(12)
                }
            }
            .padding(24)
            .background(
                RoundedRectangle(cornerRadius: 20)
                    .fill(Color(UIColor.systemBackground).opacity(0.95))
                    .shadow(radius: 20)
            )
            .transition(.scale.combined(with: .opacity))
        }
    }

    // MARK: - Region Header

    var regionHeader: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Image(systemName: region.type.icon)
                    .font(.largeTitle)
                    .foregroundColor(stateColor)

                VStack(alignment: .leading) {
                    Text(region.type.displayName)
                        .font(.subheadline)
                        .foregroundColor(.secondary)

                    HStack {
                        Text(region.state.emoji)
                        Text(region.state.displayName)
                            .font(.title3)
                            .fontWeight(.bold)
                            .foregroundColor(stateColor)
                    }
                }

                Spacer()

                // Индикатор текущей локации
                if isPlayerHere {
                    HStack(spacing: 4) {
                        Image(systemName: "person.fill")
                        Text("Вы здесь")
                    }
                    .font(.caption)
                    .fontWeight(.bold)
                    .foregroundColor(.white)
                    .padding(.horizontal, 10)
                    .padding(.vertical, 6)
                    .background(Color.blue)
                    .cornerRadius(12)
                }
            }

            Text(regionDescription)
                .font(.body)
                .foregroundColor(.secondary)
        }
    }

    var regionDescription: String {
        switch region.state {
        case .stable:
            return "Регион спокоен. Влияние Нави минимально. Здесь безопасно отдыхать и торговать."
        case .borderland:
            return "Регион балансирует между Явью и Навью. Повышенная опасность, но и больше возможностей."
        case .breach:
            return "Навь активно проникает в регион. Очень опасно. Требуется восстановление якоря."
        }
    }

    // MARK: - Risk Info Section

    var riskInfoSection: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Image(systemName: "exclamationmark.triangle.fill")
                    .foregroundColor(region.state == .breach ? .red : .orange)
                Text("Модификаторы боя")
                    .font(.caption)
                    .fontWeight(.bold)
            }

            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text("Сила врагов:")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("+\(region.state.enemyPowerBonus)")
                        .font(.caption)
                        .fontWeight(.bold)
                        .foregroundColor(.red)
                }

                HStack {
                    Text("Защита врагов:")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("+\(region.state.enemyDefenseBonus)")
                        .font(.caption)
                        .fontWeight(.bold)
                        .foregroundColor(.red)
                }

                HStack {
                    Text("Здоровье врагов:")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("+\(region.state.enemyHealthBonus)")
                        .font(.caption)
                        .fontWeight(.bold)
                        .foregroundColor(.red)
                }
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(region.state == .breach ? Color.red.opacity(0.1) : Color.orange.opacity(0.1))
        )
    }

    // MARK: - Anchor Section

    func anchorSection(anchor: Anchor) -> some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Якорь Яви")
                .font(.headline)

            HStack(spacing: 12) {
                Image(systemName: anchor.type.icon)
                    .font(.title)
                    .foregroundColor(.orange)
                    .frame(width: 50, height: 50)
                    .background(Circle().fill(Color.orange.opacity(0.2)))

                VStack(alignment: .leading, spacing: 4) {
                    Text(anchor.name)
                        .font(.subheadline)
                        .fontWeight(.bold)

                    Text(anchor.type.displayName)
                        .font(.caption)
                        .foregroundColor(.secondary)

                    // Integrity bar
                    HStack(spacing: 4) {
                        Text("Целостность:")
                            .font(.caption2)
                        GeometryReader { geometry in
                            ZStack(alignment: .leading) {
                                Rectangle()
                                    .fill(Color.gray.opacity(0.2))
                                    .frame(height: 6)

                                Rectangle()
                                    .fill(anchorIntegrityColor(anchor.integrity))
                                    .frame(
                                        width: geometry.size.width * CGFloat(anchor.integrity) / 100,
                                        height: 6
                                    )
                            }
                        }
                        .frame(height: 6)

                        Text("\(anchor.integrity)%")
                            .font(.caption2)
                            .fontWeight(.bold)
                            .foregroundColor(anchorIntegrityColor(anchor.integrity))
                    }

                    // Influence
                    HStack(spacing: 4) {
                        Text("Влияние:")
                            .font(.caption2)
                        Text(influenceText(anchor.influence))
                            .font(.caption2)
                            .fontWeight(.bold)
                            .foregroundColor(influenceColor(anchor.influence))
                    }
                }
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(Color(UIColor.tertiarySystemBackground))
            )
        }
    }

    func influenceText(_ influence: CardBalance) -> String {
        switch influence {
        case .light: return "Свет"
        case .neutral: return "Нейтрально"
        case .dark: return "Тьма"
        }
    }

    func influenceColor(_ influence: CardBalance) -> Color {
        switch influence {
        case .light: return .yellow
        case .neutral: return .gray
        case .dark: return .purple
        }
    }

    // MARK: - Actions Section

    /// Проверка, находится ли игрок в этом регионе
    var isPlayerHere: Bool {
        region.id == worldState.currentRegionId
    }

    var actionsSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Доступные действия")
                .font(.headline)

            VStack(spacing: 8) {
                // Travel action - только если игрок НЕ здесь
                if !isPlayerHere {
                    let travelCost = worldState.calculateTravelCost(to: region.id)
                    let dayWord = travelCost == 1 ? "день" : "дня"
                    let canTravel = region.isNeighbor(worldState.currentRegionId ?? UUID())

                    actionButton(
                        title: canTravel ? "Отправиться (\(travelCost) \(dayWord))" : "Регион далеко",
                        icon: canTravel ? "arrow.right.circle.fill" : "xmark.circle",
                        color: canTravel ? .blue : .gray,
                        enabled: canTravel
                    ) {
                        selectedAction = .travel
                        showingActionConfirmation = true
                    }

                    // Сообщение о необходимости переместиться
                    if canTravel {
                        HStack {
                            Image(systemName: "info.circle")
                                .foregroundColor(.secondary)
                            Text("Переместитесь в регион, чтобы взаимодействовать с ним")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        .padding(.vertical, 8)
                    } else {
                        HStack {
                            Image(systemName: "map")
                                .foregroundColor(.orange)
                            Text("Регион недоступен напрямую - сначала идите в соседний регион")
                                .font(.caption)
                                .foregroundColor(.orange)
                        }
                        .padding(.vertical, 8)
                    }
                }

                // Действия доступны ТОЛЬКО если игрок находится в регионе
                if isPlayerHere {
                    // Rest action
                    actionButton(
                        title: "Отдохнуть (+5 ❤️)",
                        icon: "bed.double.fill",
                        color: .green,
                        enabled: region.canRest
                    ) {
                        selectedAction = .rest
                        showingActionConfirmation = true
                    }

                    // Trade action
                    actionButton(
                        title: "Торговать",
                        icon: "cart.fill",
                        color: .orange,
                        enabled: region.canTrade
                    ) {
                        selectedAction = .trade
                        showingActionConfirmation = true
                    }

                    // Strengthen anchor
                    if region.anchor != nil {
                        actionButton(
                            title: "Укрепить якорь (-10 ✨, +20%)",
                            icon: "hammer.fill",
                            color: .purple,
                            enabled: player.faith >= 10
                        ) {
                            selectedAction = .strengthenAnchor
                            showingActionConfirmation = true
                        }
                    }

                    // Explore (only if events available)
                    let hasEvents = worldState.getAvailableEvents(for: region).count > 0
                    actionButton(
                        title: "Исследовать",
                        icon: "magnifyingglass",
                        color: .cyan,
                        enabled: hasEvents
                    ) {
                        triggerExploration()
                    }
                }
            }
        }
    }

    func actionButton(
        title: String,
        icon: String,
        color: Color,
        enabled: Bool,
        action: @escaping () -> Void
    ) -> some View {
        Button(action: action) {
            HStack {
                Image(systemName: icon)
                    .font(.body)
                Text(title)
                    .font(.body)
                Spacer()
            }
            .padding()
            .foregroundColor(enabled ? .white : .gray)
            .background(enabled ? color : Color.gray.opacity(0.3))
            .cornerRadius(10)
        }
        .disabled(!enabled)
    }

    // MARK: - Quests Section

    var questsSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Активные квесты в регионе")
                .font(.headline)

            ForEach(region.activeQuests, id: \.self) { questId in
                if let quest = worldState.activeQuests.first(where: { $0.id.uuidString == questId }) {
                    questView(quest)
                }
            }
        }
    }

    func questView(_ quest: Quest) -> some View {
        VStack(alignment: .leading, spacing: 8) {
            // Quest title
            HStack {
                Image(systemName: quest.questType == .main ? "star.fill" : "scroll.fill")
                    .foregroundColor(quest.questType == .main ? .yellow : .blue)
                Text(quest.title)
                    .font(.headline)
                    .foregroundColor(.primary)
            }

            // Quest description
            Text(quest.description)
                .font(.caption)
                .foregroundColor(.secondary)
                .lineLimit(2)

            // Objectives
            VStack(alignment: .leading, spacing: 4) {
                ForEach(quest.objectives) { objective in
                    HStack(spacing: 8) {
                        Image(systemName: objective.completed ? "checkmark.circle.fill" : "circle")
                            .foregroundColor(objective.completed ? .green : .gray)
                            .font(.caption)
                        Text(objective.description)
                            .font(.caption)
                            .foregroundColor(objective.completed ? .secondary : .primary)
                            .strikethrough(objective.completed)
                    }
                }
            }
            .padding(.leading, 8)

            // Progress indicator
            let completedCount = quest.objectives.filter { $0.completed }.count
            let totalCount = quest.objectives.count
            if totalCount > 0 {
                HStack(spacing: 4) {
                    Text("Прогресс:")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                    Text("\(completedCount)/\(totalCount)")
                        .font(.caption2)
                        .fontWeight(.bold)
                        .foregroundColor(completedCount == totalCount ? .green : .orange)
                }
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(quest.questType == .main ? Color.yellow.opacity(0.15) : Color.blue.opacity(0.1))
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(quest.questType == .main ? Color.yellow.opacity(0.5) : Color.blue.opacity(0.3), lineWidth: 1)
        )
    }

    // MARK: - Helpers

    var stateColor: Color {
        switch region.state {
        case .stable: return .green
        case .borderland: return .orange
        case .breach: return .red
        }
    }

    func anchorIntegrityColor(_ integrity: Int) -> Color {
        switch integrity {
        case 70...100: return .green
        case 30..<70: return .orange
        default: return .red
        }
    }

    // MARK: - Event Handling

    func triggerExploration() {
        // Get available events for this region (with tension and flag filtering)
        let availableEvents = worldState.getAvailableEvents(for: region)

        print("DEBUG: Region: \(region.name), Type: \(region.type), State: \(region.state)")
        print("DEBUG: World tension: \(worldState.worldTension)")
        print("DEBUG: Available events count: \(availableEvents.count)")
        for event in availableEvents {
            print("DEBUG: - Event: \(event.title) (weight: \(event.weight))")
        }

        // Weighted random selection
        if let selectedEvent = worldState.selectWeightedRandomEvent(from: availableEvents) {
            eventToShow = selectedEvent
        } else {
            // No events available - show alert
            showingNoEventsAlert = true
        }
    }

    func handleEventChoice(_ choice: EventChoice, event: GameEvent) {
        // Check for card rewards before processing
        var cardsToNotify: [String] = []
        if let cardIDs = choice.consequences.addCards {
            for cardID in cardIDs {
                if let card = TwilightMarchesCards.getCardByID(cardID) {
                    cardsToNotify.append(card.name)
                }
            }
        }

        // Apply consequences
        worldState.applyConsequences(
            choice.consequences,
            to: player,
            in: region.id
        )

        // Check quest objectives based on event completion
        worldState.checkQuestObjectivesByEvent(
            eventTitle: event.title,
            choiceText: choice.text,
            player: player
        )

        // Mark event as completed if it's one-time
        if event.oneTime {
            worldState.markEventCompleted(event.id)
        }

        // Записать событие в журнал
        let logType: EventLogType = event.eventType == .combat ? .combat : .exploration
        let outcomeMessage = choice.consequences.message ?? "Выбор сделан"
        worldState.logEvent(
            regionName: region.name,
            eventTitle: event.title,
            choiceMade: choice.text,
            outcome: outcomeMessage,
            type: logType
        )

        // Исследование события тратит день (кроме instant событий)
        if !event.instant {
            worldState.advanceDayForUI()
        }

        // Show card received notification if cards were gained
        if !cardsToNotify.isEmpty {
            receivedCardNames = cardsToNotify
            // Delay slightly to allow event sheet to dismiss first
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                    showingCardNotification = true
                }
            }
        }
    }

    // MARK: - Action Handling

    var actionConfirmationTitle: String {
        guard let action = selectedAction else { return "Подтверждение" }
        switch action {
        case .travel: return "Отправиться в регион"
        case .rest: return "Отдохнуть"
        case .trade: return "Торговать"
        case .strengthenAnchor: return "Укрепить якорь"
        case .explore: return "Исследовать"
        }
    }

    var actionConfirmationMessage: String {
        guard let action = selectedAction else { return "" }
        switch action {
        case .travel:
            let cost = worldState.calculateTravelCost(to: region.id)
            let dayWord = cost == 1 ? "день" : "дня"
            return "Отправиться в регион '\(region.name)'? Это займёт \(cost) \(dayWord) пути."
        case .rest:
            return "Отдохнуть в этом месте? Вы восстановите 5 здоровья."
        case .trade:
            return "Торговая система пока не реализована."
        case .strengthenAnchor:
            return "Укрепить якорь? Это стоит 10 веры и добавит 20% целостности."
        case .explore:
            return "Исследовать регион? Это займёт день."
        }
    }

    // MARK: - Actions via Engine (Audit v1.1 Issue #4)

    func performAction(_ action: RegionAction) {
        switch action {
        case .travel:
            // Use Engine for travel (Audit v1.1)
            let fromRegion = worldState.getCurrentRegion()?.name ?? "Неизвестно"
            let result = engine.performAction(.travel(toRegionId: region.id))

            if result.success {
                // Log travel (legacy logging still supported)
                let cost = worldState.calculateTravelCost(to: region.id)
                worldState.logTravel(from: fromRegion, to: region.name, days: cost)
                worldState.checkQuestObjectivesByRegion(regionId: region.id, player: player)
            }
            onDismiss()

        case .rest:
            // Use Engine for rest (Audit v1.1)
            let result = engine.performAction(.rest)

            if result.success {
                worldState.logEvent(
                    regionName: region.name,
                    eventTitle: "Отдых",
                    choiceMade: "Решил отдохнуть",
                    outcome: "Восстановлено здоровье",
                    type: .exploration
                )
            }

        case .trade:
            // Phase 4: Implement trade/market view
            break

        case .strengthenAnchor:
            // Use Engine for strengthen anchor (Audit v1.1)
            let result = engine.performAction(.strengthenAnchor)

            if result.success {
                worldState.logEvent(
                    regionName: region.name,
                    eventTitle: "Укрепление якоря",
                    choiceMade: "Потрачено вера",
                    outcome: "Якорь укреплён",
                    type: .worldChange
                )
            }

        case .explore:
            // This is handled separately by triggerExploration()
            break
        }
    }
}

// MARK: - Event Log View

struct EventLogView: View {
    @ObservedObject var worldState: WorldState
    @Environment(\.dismiss) var dismiss

    var body: some View {
        NavigationView {
            List {
                if worldState.eventLog.isEmpty {
                    Text("Журнал пуст. Ваши приключения ещё впереди...")
                        .foregroundColor(.secondary)
                        .padding()
                } else {
                    ForEach(worldState.eventLog.reversed()) { entry in
                        EventLogEntryView(entry: entry)
                    }
                }
            }
            .navigationTitle("Журнал")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Закрыть") {
                        dismiss()
                    }
                }
            }
        }
    }
}

struct EventLogEntryView: View {
    let entry: EventLogEntry

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // Header
            HStack {
                Image(systemName: entry.type.icon)
                    .foregroundColor(typeColor)

                Text("День \(entry.dayNumber)")
                    .font(.caption)
                    .fontWeight(.bold)

                Spacer()

                Text(entry.regionName)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }

            // Event title
            Text(entry.eventTitle)
                .font(.subheadline)
                .fontWeight(.semibold)

            // Choice made
            HStack {
                Image(systemName: "arrow.turn.down.right")
                    .font(.caption2)
                    .foregroundColor(.secondary)
                Text(entry.choiceMade)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }

            // Outcome
            Text(entry.outcome)
                .font(.caption)
                .italic()
        }
        .padding(.vertical, 4)
    }

    var typeColor: Color {
        switch entry.type {
        case .combat: return .red
        case .exploration: return .blue
        case .choice: return .orange
        case .quest: return .purple
        case .travel: return .green
        case .worldChange: return .yellow
        }
    }
}

// MARK: - Engine-First Region Card View

struct EngineRegionCardView: View {
    let region: EngineRegionState
    let isCurrentLocation: Bool

    var body: some View {
        HStack(spacing: 12) {
            // Icon
            ZStack {
                Circle()
                    .fill(stateColor.opacity(0.2))
                    .frame(width: 60, height: 60)

                Image(systemName: region.type.icon)
                    .font(.title2)
                    .foregroundColor(stateColor)
            }

            // Info
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(region.name)
                        .font(.headline)
                        .fontWeight(.bold)

                    if isCurrentLocation {
                        Image(systemName: "location.fill")
                            .font(.caption)
                            .foregroundColor(.blue)
                    }
                }

                HStack(spacing: 8) {
                    Text(region.state.emoji)
                        .font(.caption)
                    Text(region.state.displayName)
                        .font(.caption)
                        .foregroundColor(.secondary)

                    Spacer()

                    Text(region.type.displayName)
                        .font(.caption2)
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(Color.gray.opacity(0.2))
                        .cornerRadius(4)
                }

                // Anchor info
                if let anchor = region.anchor {
                    HStack(spacing: 4) {
                        Image(systemName: "flame")
                            .font(.caption2)
                            .foregroundColor(.orange)
                        Text(anchor.name)
                            .font(.caption2)
                            .foregroundColor(.secondary)
                        Spacer()
                        Text("\(anchor.integrity)%")
                            .font(.caption2)
                            .fontWeight(.bold)
                            .foregroundColor(anchorIntegrityColor(anchor.integrity))
                    }
                }

                // Reputation
                if region.reputation != 0 {
                    HStack(spacing: 4) {
                        Image(systemName: region.reputation > 0 ? "hand.thumbsup.fill" : "hand.thumbsdown.fill")
                            .font(.caption2)
                            .foregroundColor(region.reputation > 0 ? .green : .red)
                        Text("Репутация: \(region.reputation > 0 ? "+" : "")\(region.reputation)")
                            .font(.caption2)
                            .foregroundColor(.secondary)
                    }
                }
            }

            Spacer()

            // Arrow
            Image(systemName: "chevron.right")
                .font(.caption)
                .foregroundColor(.gray)
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(UIColor.secondarySystemBackground))
                .shadow(color: isCurrentLocation ? .blue.opacity(0.3) : .clear, radius: 4)
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(isCurrentLocation ? Color.blue : Color.clear, lineWidth: 2)
        )
    }

    var stateColor: Color {
        switch region.state {
        case .stable: return .green
        case .borderland: return .orange
        case .breach: return .red
        }
    }

    func anchorIntegrityColor(_ integrity: Int) -> Color {
        switch integrity {
        case 70...100: return .green
        case 30..<70: return .orange
        default: return .red
        }
    }
}

// MARK: - Engine-First Region Detail View

struct EngineRegionDetailView: View {
    let region: EngineRegionState
    @ObservedObject var engine: TwilightGameEngine
    let onDismiss: () -> Void
    var onRegionChange: ((EngineRegionState?) -> Void)? = nil

    @State private var showingActionConfirmation = false
    @State private var selectedAction: EngineRegionAction?
    @State private var eventToShow: GameEvent?
    @State private var showingNoEventsAlert = false
    @State private var showingActionError = false
    @State private var actionErrorMessage = ""

    // Card received notification
    @State private var showingCardNotification = false
    @State private var receivedCardNames: [String] = []

    enum EngineRegionAction {
        case travel
        case rest
        case trade
        case strengthenAnchor
        case explore
    }

    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Hero Panel (persistent, consistent design across all screens)
                HeroPanel(engine: engine)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)

                ScrollView {
                    VStack(alignment: .leading, spacing: 20) {
                        // Region header
                        regionHeader

                        // Risk display for non-stable regions
                        if region.state != .stable {
                            riskInfoSection
                        }

                        Divider()

                        // Anchor section
                        if let anchor = region.anchor {
                            anchorSection(anchor: anchor)
                            Divider()
                        }

                        // Available actions
                        actionsSection
                    }
                    .padding()
                }
            }
            .navigationTitle(region.name)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Закрыть") {
                        onDismiss()
                    }
                }
            }
            .alert(actionConfirmationTitle, isPresented: $showingActionConfirmation) {
                Button("Подтвердить") {
                    if let action = selectedAction {
                        performAction(action)
                    }
                }
                Button("Отмена", role: .cancel) { }
            } message: {
                Text(actionConfirmationMessage)
            }
            .alert("Ничего не найдено", isPresented: $showingNoEventsAlert) {
                Button("Понятно", role: .cancel) { }
            } message: {
                Text("В этом регионе сейчас нечего исследовать. Попробуйте позже или посетите другой регион.")
            }
            .alert("Действие невозможно", isPresented: $showingActionError) {
                Button("Понятно", role: .cancel) { }
            } message: {
                Text(actionErrorMessage)
            }
            .sheet(item: $eventToShow) { event in
                EventView(
                    engine: engine,
                    event: event,
                    regionId: region.id,
                    onChoiceSelected: { choice in
                        handleEventChoice(choice, event: event)
                    },
                    onDismiss: {
                        eventToShow = nil
                        // Dismiss current event in engine
                        engine.performAction(.dismissCurrentEvent)
                    }
                )
            }
            .onChange(of: engine.currentEvent?.id) { _ in
                // When engine triggers an event, show it
                if let event = engine.currentEvent {
                    eventToShow = event
                }
            }
            .overlay {
                // Card received notification overlay
                if showingCardNotification && !receivedCardNames.isEmpty {
                    cardReceivedNotificationView
                }
            }
        }
    }

    // MARK: - Card Received Notification View

    var cardReceivedNotificationView: some View {
        ZStack {
            // Semi-transparent background
            Color.black.opacity(0.5)
                .ignoresSafeArea()
                .onTapGesture {
                    withAnimation(.easeOut(duration: 0.3)) {
                        showingCardNotification = false
                    }
                }

            VStack(spacing: 20) {
                // Header
                VStack(spacing: 8) {
                    Text("🃏")
                        .font(.system(size: 48))

                    Text("Получены карты!")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.white)

                    Text("Добавлены в вашу колоду")
                        .font(.subheadline)
                        .foregroundColor(.white.opacity(0.8))
                }

                // Cards list
                VStack(spacing: 12) {
                    ForEach(receivedCardNames, id: \.self) { cardName in
                        HStack {
                            Image(systemName: "rectangle.stack.badge.plus")
                                .foregroundColor(.yellow)
                            Text(cardName)
                                .fontWeight(.semibold)
                                .foregroundColor(.white)
                        }
                        .padding(.horizontal, 16)
                        .padding(.vertical, 10)
                        .background(
                            RoundedRectangle(cornerRadius: 8)
                                .fill(Color.purple.opacity(0.6))
                        )
                    }
                }

                // Dismiss button
                Button(action: {
                    withAnimation(.easeOut(duration: 0.3)) {
                        showingCardNotification = false
                    }
                }) {
                    Text("Отлично!")
                        .font(.headline)
                        .foregroundColor(.white)
                        .frame(minWidth: 120)
                        .padding()
                        .background(Color.blue)
                        .cornerRadius(12)
                }
            }
            .padding(24)
            .background(
                RoundedRectangle(cornerRadius: 20)
                    .fill(Color(UIColor.systemBackground).opacity(0.95))
                    .shadow(radius: 20)
            )
            .transition(.scale.combined(with: .opacity))
        }
    }

    // MARK: - Region Header

    var regionHeader: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Image(systemName: region.type.icon)
                    .font(.largeTitle)
                    .foregroundColor(stateColor)

                VStack(alignment: .leading) {
                    Text(region.type.displayName)
                        .font(.subheadline)
                        .foregroundColor(.secondary)

                    HStack {
                        Text(region.state.emoji)
                        Text(region.state.displayName)
                            .font(.title3)
                            .fontWeight(.bold)
                            .foregroundColor(stateColor)
                    }
                }

                Spacer()

                // Current location indicator
                if isPlayerHere {
                    HStack(spacing: 4) {
                        Image(systemName: "person.fill")
                        Text("Вы здесь")
                    }
                    .font(.caption)
                    .fontWeight(.bold)
                    .foregroundColor(.white)
                    .padding(.horizontal, 10)
                    .padding(.vertical, 6)
                    .background(Color.blue)
                    .cornerRadius(12)
                }
            }

            Text(regionDescription)
                .font(.body)
                .foregroundColor(.secondary)
        }
    }

    var regionDescription: String {
        switch region.state {
        case .stable:
            return "Регион спокоен. Влияние Нави минимально. Здесь безопасно отдыхать и торговать."
        case .borderland:
            return "Регион балансирует между Явью и Навью. Повышенная опасность, но и больше возможностей."
        case .breach:
            return "Навь активно проникает в регион. Очень опасно. Требуется восстановление якоря."
        }
    }

    // MARK: - Risk Info Section

    var riskInfoSection: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Image(systemName: "exclamationmark.triangle.fill")
                    .foregroundColor(region.state == .breach ? .red : .orange)
                Text("Предупреждение")
                    .font(.caption)
                    .fontWeight(.bold)
            }

            Text("В этом регионе повышенная опасность. Будьте осторожны!")
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(region.state == .breach ? Color.red.opacity(0.1) : Color.orange.opacity(0.1))
        )
    }

    // MARK: - Anchor Section

    func anchorSection(anchor: EngineAnchorState) -> some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Якорь Яви")
                .font(.headline)

            HStack(spacing: 12) {
                Image(systemName: "flame")
                    .font(.title)
                    .foregroundColor(.orange)
                    .frame(width: 50, height: 50)
                    .background(Circle().fill(Color.orange.opacity(0.2)))

                VStack(alignment: .leading, spacing: 4) {
                    Text(anchor.name)
                        .font(.subheadline)
                        .fontWeight(.bold)

                    // Integrity bar
                    HStack(spacing: 4) {
                        Text("Целостность:")
                            .font(.caption2)
                        GeometryReader { geometry in
                            ZStack(alignment: .leading) {
                                Rectangle()
                                    .fill(Color.gray.opacity(0.2))
                                    .frame(height: 6)

                                Rectangle()
                                    .fill(anchorIntegrityColor(anchor.integrity))
                                    .frame(
                                        width: geometry.size.width * CGFloat(anchor.integrity) / 100,
                                        height: 6
                                    )
                            }
                        }
                        .frame(height: 6)

                        Text("\(anchor.integrity)%")
                            .font(.caption2)
                            .fontWeight(.bold)
                            .foregroundColor(anchorIntegrityColor(anchor.integrity))
                    }
                }
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(Color(UIColor.tertiarySystemBackground))
            )
        }
    }

    // MARK: - Actions Section

    var isPlayerHere: Bool {
        region.id == engine.currentRegionId
    }

    var actionsSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Доступные действия")
                .font(.headline)

            VStack(spacing: 8) {
                // Travel action - only if player is NOT here
                if !isPlayerHere {
                    let canTravel = engine.canTravelTo(regionId: region.id)
                    let routingHint = engine.getRoutingHint(to: region.id)
                    let travelCost = engine.calculateTravelCost(to: region.id)
                    let dayWord = travelCost == 1 ? "день" : "дня"

                    actionButton(
                        title: canTravel ? "Отправиться (\(travelCost) \(dayWord))" : "Регион далеко",
                        icon: canTravel ? "arrow.right.circle.fill" : "xmark.circle",
                        color: canTravel ? .blue : .gray,
                        enabled: canTravel
                    ) {
                        selectedAction = .travel
                        showingActionConfirmation = true
                    }

                    if canTravel {
                        HStack {
                            Image(systemName: "info.circle")
                                .foregroundColor(.secondary)
                            Text("Переместитесь в регион, чтобы взаимодействовать с ним")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        .padding(.vertical, 8)
                    } else {
                        // Show routing hint for distant regions
                        HStack {
                            Image(systemName: "map")
                                .foregroundColor(.orange)
                            if !routingHint.isEmpty {
                                Text("Сначала идите через: \(routingHint.joined(separator: ", "))")
                                    .font(.caption)
                                    .foregroundColor(.orange)
                            } else {
                                Text("Регион недоступен напрямую")
                                    .font(.caption)
                                    .foregroundColor(.orange)
                            }
                        }
                        .padding(.vertical, 8)
                    }
                }

                // Actions available ONLY if player is in the region
                if isPlayerHere {
                    // Rest action
                    actionButton(
                        title: "Отдохнуть (+3 ❤️)",
                        icon: "bed.double.fill",
                        color: .green,
                        enabled: region.canRest
                    ) {
                        selectedAction = .rest
                        showingActionConfirmation = true
                    }

                    // Trade action
                    actionButton(
                        title: "Торговать",
                        icon: "cart.fill",
                        color: .orange,
                        enabled: region.canTrade
                    ) {
                        selectedAction = .trade
                        showingActionConfirmation = true
                    }

                    // Strengthen anchor
                    if region.anchor != nil {
                        actionButton(
                            title: "Укрепить якорь (-5 ✨, +20%)",
                            icon: "hammer.fill",
                            color: .purple,
                            enabled: engine.canAffordFaith(5)
                        ) {
                            selectedAction = .strengthenAnchor
                            showingActionConfirmation = true
                        }
                    }

                    // Explore (only if events available)
                    let hasEvents = engine.hasAvailableEventsInCurrentRegion()
                    actionButton(
                        title: "Исследовать",
                        icon: "magnifyingglass",
                        color: .cyan,
                        enabled: hasEvents
                    ) {
                        selectedAction = .explore
                        showingActionConfirmation = true
                    }
                }
            }
        }
    }

    func actionButton(
        title: String,
        icon: String,
        color: Color,
        enabled: Bool,
        action: @escaping () -> Void
    ) -> some View {
        Button(action: action) {
            HStack {
                Image(systemName: icon)
                    .font(.body)
                Text(title)
                    .font(.body)
                Spacer()
            }
            .padding()
            .foregroundColor(enabled ? .white : .gray)
            .background(enabled ? color : Color.gray.opacity(0.3))
            .cornerRadius(10)
        }
        .disabled(!enabled)
    }

    // MARK: - Helpers

    var stateColor: Color {
        switch region.state {
        case .stable: return .green
        case .borderland: return .orange
        case .breach: return .red
        }
    }

    func anchorIntegrityColor(_ integrity: Int) -> Color {
        switch integrity {
        case 70...100: return .green
        case 30..<70: return .orange
        default: return .red
        }
    }

    // MARK: - Action Handling

    var actionConfirmationTitle: String {
        guard let action = selectedAction else { return "Подтверждение" }
        switch action {
        case .travel: return "Отправиться в регион"
        case .rest: return "Отдохнуть"
        case .trade: return "Торговать"
        case .strengthenAnchor: return "Укрепить якорь"
        case .explore: return "Исследовать"
        }
    }

    var actionConfirmationMessage: String {
        guard let action = selectedAction else { return "" }
        switch action {
        case .travel:
            let days = engine.calculateTravelCost(to: region.id)
            let dayWord = days == 1 ? "день" : "дня"
            return "Отправиться в регион '\(region.name)'? Это займёт \(days) \(dayWord) пути."
        case .rest:
            return "Отдохнуть в этом месте? Вы восстановите 3 здоровья."
        case .trade:
            return "Торговая система пока не реализована."
        case .strengthenAnchor:
            return "Укрепить якорь? Это стоит 5 веры и добавит 20% целостности."
        case .explore:
            return "Исследовать регион? Это займёт день."
        }
    }

    // MARK: - Actions via Engine

    func performAction(_ action: EngineRegionAction) {
        switch action {
        case .travel:
            let result = engine.performAction(.travel(toRegionId: region.id))
            if result.success {
                engine.addLogEntry(
                    regionName: region.name,
                    eventTitle: "Путешествие",
                    choiceMade: "Отправился в путь",
                    outcome: "Прибыл в \(region.name)",
                    type: .travel
                )
                // После перемещения показываем новый регион (текущую локацию)
                if let newRegion = engine.regionsArray.first(where: { $0.id == engine.currentRegionId }) {
                    onRegionChange?(newRegion)
                } else {
                    onDismiss()
                }
            } else {
                // Show error to user
                actionErrorMessage = errorMessage(for: result.error)
                showingActionError = true
            }

        case .rest:
            let result = engine.performAction(.rest)
            if result.success {
                engine.addLogEntry(
                    regionName: region.name,
                    eventTitle: "Отдых",
                    choiceMade: "Решил отдохнуть",
                    outcome: "Восстановлено здоровье",
                    type: .exploration
                )
            }

        case .trade:
            // Phase 4: Implement trade/market view
            break

        case .strengthenAnchor:
            let result = engine.performAction(.strengthenAnchor)
            if result.success {
                engine.addLogEntry(
                    regionName: region.name,
                    eventTitle: "Укрепление якоря",
                    choiceMade: "Потрачена вера",
                    outcome: "Якорь укреплён",
                    type: .worldChange
                )
            }

        case .explore:
            let result = engine.performAction(.explore)
            if result.success {
                // Check if an event was triggered
                if result.currentEvent == nil {
                    // No event available - show alert
                    showingNoEventsAlert = true
                    engine.addLogEntry(
                        regionName: region.name,
                        eventTitle: "Исследование",
                        choiceMade: "Исследовал регион",
                        outcome: "Ничего интересного не найдено",
                        type: .exploration
                    )
                }
                // If event was triggered, it will be shown via onChange of engine.currentEvent
            }
        }
    }

    // MARK: - Error Messages

    func errorMessage(for error: ActionError?) -> String {
        guard let error = error else { return "Неизвестная ошибка" }
        switch error {
        case .regionNotNeighbor:
            return "Этот регион слишком далеко. Сначала переместитесь в соседний регион."
        case .regionNotAccessible:
            return "Этот регион недоступен."
        case .healthTooLow:
            return "У вас слишком мало здоровья для этого действия."
        case .insufficientResources(let resource, let required, let available):
            return "Недостаточно \(resource): нужно \(required), есть \(available)."
        case .invalidAction(let reason):
            return reason
        case .combatInProgress:
            return "Невозможно во время боя."
        case .eventInProgress:
            return "Сначала завершите текущее событие."
        default:
            return "Действие невозможно: \(error)"
        }
    }

    // MARK: - Event Choice Handling

    func handleEventChoice(_ choice: EventChoice, event: GameEvent) {
        // Check for card rewards before processing
        var cardsToNotify: [String] = []
        if let cardIDs = choice.consequences.addCards {
            for cardID in cardIDs {
                if let card = TwilightMarchesCards.getCardByID(cardID) {
                    cardsToNotify.append(card.name)
                }
            }
        }

        // Execute choice via engine
        if let choiceIndex = event.choices.firstIndex(where: { $0.id == choice.id }) {
            let result = engine.performAction(.chooseEventOption(eventId: event.id, choiceIndex: choiceIndex))

            if result.success {
                // Log the event
                let logType: EventLogType = event.eventType == .combat ? .combat : .exploration
                let outcomeMessage = choice.consequences.message ?? "Выбор сделан"
                engine.addLogEntry(
                    regionName: region.name,
                    eventTitle: event.title,
                    choiceMade: choice.text,
                    outcome: outcomeMessage,
                    type: logType
                )
            }
        }

        // Dismiss event view
        eventToShow = nil
        engine.performAction(.dismissCurrentEvent)

        // Show card received notification if cards were gained
        if !cardsToNotify.isEmpty {
            receivedCardNames = cardsToNotify
            // Delay slightly to allow event sheet to dismiss first
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                    showingCardNotification = true
                }
            }
        }
    }
}

// MARK: - Engine-First Event Log View

struct EngineEventLogView: View {
    @ObservedObject var engine: TwilightGameEngine
    @Environment(\.dismiss) var dismiss

    var body: some View {
        NavigationView {
            List {
                if engine.publishedEventLog.isEmpty {
                    Text("Журнал пуст. Ваши приключения ещё впереди...")
                        .foregroundColor(.secondary)
                        .padding()
                } else {
                    ForEach(engine.publishedEventLog.reversed()) { entry in
                        EventLogEntryView(entry: entry)
                    }
                }
            }
            .navigationTitle("Журнал")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Закрыть") {
                        dismiss()
                    }
                }
            }
        }
    }
}


// ==========================================
// FILE: Views/Components/HeroPanel.swift
// ==========================================

import SwiftUI

/// Unified Hero Panel - displays hero stats consistently across all screens
/// Inspired by Arkham Horror LCG investigator cards but with unique Twilight Marches style
/// Engine-First Architecture: reads all data from TwilightGameEngine
struct HeroPanel: View {
    @ObservedObject var engine: TwilightGameEngine

    /// Compact mode for screens with limited space (like combat header)
    var compact: Bool = false

    /// Show hero portrait/avatar
    var showAvatar: Bool = true

    var body: some View {
        if compact {
            compactPanel
        } else {
            fullPanel
        }
    }

    // MARK: - Full Panel (for main screens like WorldMap, RegionDetail)

    var fullPanel: some View {
        HStack(spacing: 12) {
            // Hero Avatar
            if showAvatar {
                heroAvatar
            }

            // Hero Info
            VStack(alignment: .leading, spacing: 4) {
                // Name and class
                HStack {
                    Text(engine.playerName)
                        .font(.headline)
                        .fontWeight(.bold)
                    Text(heroClass)
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(Color.gray.opacity(0.2))
                        .cornerRadius(4)
                }

                // Stats row
                HStack(spacing: 12) {
                    // Health
                    statBadge(
                        icon: "heart.fill",
                        value: "\(engine.playerHealth)/\(engine.playerMaxHealth)",
                        color: healthColor,
                        label: nil
                    )

                    // Faith
                    statBadge(
                        icon: "sparkles",
                        value: "\(engine.playerFaith)",
                        color: .yellow,
                        label: nil
                    )

                    // Strength
                    statBadge(
                        icon: "hand.raised.fill",
                        value: "\(engine.legacyPlayer?.strength ?? 1)",
                        color: .orange,
                        label: nil
                    )

                    // Balance indicator
                    balanceIndicator
                }
            }

            Spacer()
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 10)
        .background(heroPanelBackground)
    }

    // MARK: - Compact Panel (for combat, events with limited space)

    var compactPanel: some View {
        HStack(spacing: 8) {
            // Mini avatar
            if showAvatar {
                ZStack {
                    Circle()
                        .fill(balanceGradient)
                        .frame(width: 32, height: 32)

                    Text(heroInitials)
                        .font(.caption)
                        .fontWeight(.bold)
                        .foregroundColor(.white)
                }
            }

            // Compact stats
            HStack(spacing: 8) {
                // Health
                HStack(spacing: 2) {
                    Image(systemName: "heart.fill")
                        .font(.caption2)
                        .foregroundColor(.red)
                    Text("\(engine.playerHealth)")
                        .font(.caption)
                        .fontWeight(.semibold)
                }

                // Faith
                HStack(spacing: 2) {
                    Image(systemName: "sparkles")
                        .font(.caption2)
                        .foregroundColor(.yellow)
                    Text("\(engine.playerFaith)")
                        .font(.caption)
                        .fontWeight(.semibold)
                }

                // Balance (small icon only)
                Image(systemName: balanceIcon)
                    .font(.caption2)
                    .foregroundColor(balanceColor)
            }

            Spacer()
        }
        .padding(.horizontal, 8)
        .padding(.vertical, 6)
        .background(Color(UIColor.secondarySystemBackground).opacity(0.9))
        .cornerRadius(8)
    }

    // MARK: - Hero Avatar

    var heroAvatar: some View {
        ZStack {
            // Background circle with balance gradient
            Circle()
                .fill(balanceGradient)
                .frame(width: 50, height: 50)

            // Inner circle
            Circle()
                .fill(Color(UIColor.systemBackground))
                .frame(width: 44, height: 44)

            // Hero initials or icon
            Text(heroInitials)
                .font(.title3)
                .fontWeight(.bold)
                .foregroundColor(balanceColor)
        }
    }

    // MARK: - Stat Badge

    func statBadge(icon: String, value: String, color: Color, label: String?) -> some View {
        HStack(spacing: 4) {
            Image(systemName: icon)
                .font(.caption)
                .foregroundColor(color)

            VStack(alignment: .leading, spacing: 0) {
                Text(value)
                    .font(.subheadline)
                    .fontWeight(.semibold)

                if let label = label {
                    Text(label)
                        .font(.system(size: 9))
                        .foregroundColor(.secondary)
                }
            }
        }
        .padding(.horizontal, 8)
        .padding(.vertical, 4)
        .background(color.opacity(0.15))
        .cornerRadius(6)
    }

    // MARK: - Balance Indicator

    var balanceIndicator: some View {
        HStack(spacing: 4) {
            Image(systemName: balanceIcon)
                .font(.caption)
                .foregroundColor(balanceColor)

            Text(balanceText)
                .font(.caption)
                .fontWeight(.medium)
                .foregroundColor(balanceColor)
        }
        .padding(.horizontal, 8)
        .padding(.vertical, 4)
        .background(balanceColor.opacity(0.15))
        .cornerRadius(6)
    }

    // MARK: - Background

    var heroPanelBackground: some View {
        ZStack {
            // Base background
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(UIColor.secondarySystemBackground))

            // Subtle balance-colored border
            RoundedRectangle(cornerRadius: 12)
                .stroke(balanceColor.opacity(0.3), lineWidth: 1)
        }
    }

    // MARK: - Computed Properties

    var heroClass: String {
        // Get hero class from legacy player or default
        // HeroClass uses rawValue as the display name (already in Russian)
        if let heroClass = engine.legacyPlayer?.heroClass {
            return heroClass.rawValue
        }
        return "Странник"
    }

    var heroInitials: String {
        let name = engine.playerName
        let words = name.split(separator: " ")
        if words.count >= 2 {
            return String(words[0].prefix(1)) + String(words[1].prefix(1))
        }
        return String(name.prefix(2)).uppercased()
    }

    var healthColor: Color {
        let percentage = Double(engine.playerHealth) / Double(max(engine.playerMaxHealth, 1))
        if percentage > 0.6 {
            return .green
        } else if percentage > 0.3 {
            return .orange
        } else {
            return .red
        }
    }

    var balanceIcon: String {
        let balance = engine.playerBalance
        if balance >= 70 {
            return "sun.max.fill"      // Light path (70-100)
        } else if balance <= 30 {
            return "moon.fill"          // Dark path (0-30)
        } else {
            return "circle.lefthalf.filled"  // Neutral (30-70)
        }
    }

    var balanceColor: Color {
        let balance = engine.playerBalance
        if balance >= 70 {
            return .yellow              // Light path
        } else if balance <= 30 {
            return .purple              // Dark path
        } else {
            return .gray                // Neutral
        }
    }

    var balanceText: String {
        let balance = engine.playerBalance
        if balance >= 70 {
            return "Свет"
        } else if balance <= 30 {
            return "Тьма"
        } else {
            return "Равновесие"
        }
    }

    var balanceGradient: LinearGradient {
        let balance = engine.playerBalance
        if balance >= 70 {
            return LinearGradient(
                colors: [.yellow.opacity(0.8), .orange.opacity(0.6)],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        } else if balance <= 30 {
            return LinearGradient(
                colors: [.purple.opacity(0.8), .indigo.opacity(0.6)],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        } else {
            return LinearGradient(
                colors: [.gray.opacity(0.6), .gray.opacity(0.4)],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        }
    }
}

// MARK: - Preview

struct HeroPanel_Previews: PreviewProvider {
    static var previews: some View {
        VStack(spacing: 20) {
            // Full panel
            HeroPanel(engine: previewEngine)
                .padding()

            // Compact panel
            HeroPanel(engine: previewEngine, compact: true)
                .padding()

            // Full panel without avatar
            HeroPanel(engine: previewEngine, showAvatar: false)
                .padding()
        }
        .background(Color(UIColor.systemBackground))
    }

    static var previewEngine: TwilightGameEngine {
        let engine = TwilightGameEngine()
        // Preview data would be set here
        return engine
    }
}


// ==========================================
// FILE: Engine/Core/CoreGameEngine.swift
// ==========================================

import Foundation
import Combine

// MARK: - Core Game Engine

/// Content-agnostic game engine that loads all configuration from Content Packs
/// This is the generic engine that can run ANY content pack, not just Twilight Marches.
///
/// Usage:
/// 1. Load a content pack into ContentRegistry
/// 2. Create CoreGameEngine with the registry
/// 3. Initialize game with initializeNewGame()
///
/// All game-specific content (regions, events, balance) comes from the loaded pack.
final class CoreGameEngine: ObservableObject {

    // MARK: - Published State (for UI binding)

    @Published private(set) var currentDay: Int = 0
    @Published private(set) var worldTension: Int = 0
    @Published private(set) var currentRegionId: String?
    @Published private(set) var isGameOver: Bool = false
    @Published private(set) var gameResult: GameEndResult?

    @Published private(set) var currentEventId: String?
    @Published private(set) var isInCombat: Bool = false
    @Published private(set) var lastActionResult: ActionResult?

    /// All regions with their current state
    @Published private(set) var regions: [String: CoreRegionState] = [:]

    /// Player stats
    @Published private(set) var playerHealth: Int = 10
    @Published private(set) var playerMaxHealth: Int = 10
    @Published private(set) var playerFaith: Int = 3
    @Published private(set) var playerMaxFaith: Int = 10
    @Published private(set) var playerBalance: Int = 50
    @Published private(set) var playerName: String = "Hero"

    /// World flags for quest/event conditions
    @Published private(set) var worldFlags: [String: Bool] = [:]

    /// Current event being displayed
    @Published private(set) var currentEvent: EventDefinition?

    /// Active quests
    @Published private(set) var activeQuests: [QuestDefinition] = []

    /// Light/Dark balance of the world
    @Published private(set) var lightDarkBalance: Int = 50

    // MARK: - Content Source

    /// Content registry - source of all game content
    private let contentRegistry: ContentRegistry

    /// Balance configuration from loaded pack
    private var balanceConfig: BalanceConfiguration

    // MARK: - Internal State

    private var completedEventIds: Set<String> = []
    private var completedQuestIds: Set<String> = []
    private var questStages: [String: Int] = [:]
    private var eventLog: [CoreEventLogEntry] = []

    // MARK: - Computed Properties

    /// Get regions as sorted array for UI
    var regionsArray: [CoreRegionState] {
        regions.values.sorted { $0.name < $1.name }
    }

    /// Get current region
    var currentRegion: CoreRegionState? {
        guard let id = currentRegionId else { return nil }
        return regions[id]
    }

    /// Check if player can afford faith cost
    func canAffordFaith(_ cost: Int) -> Bool {
        return playerFaith >= cost
    }

    /// Check if region is neighbor to current region
    func isNeighbor(regionId: String) -> Bool {
        guard let current = currentRegion else { return false }
        return current.neighborIds.contains(regionId)
    }

    // MARK: - Initialization

    /// Create engine with content registry
    /// - Parameter registry: Content registry with loaded packs
    init(registry: ContentRegistry = .shared) {
        self.contentRegistry = registry
        self.balanceConfig = registry.getBalanceConfig() ?? .default
    }

    // MARK: - Game Initialization

    /// Initialize a new game from loaded content packs
    /// - Parameters:
    ///   - playerName: Name of the player character
    ///   - startingRegionId: Optional override for starting region
    func initializeNewGame(playerName: String = "Hero", startingRegionId: String? = nil) {
        // Reset state
        isGameOver = false
        gameResult = nil
        currentEventId = nil
        currentEvent = nil
        isInCombat = false

        // Load balance config from pack
        balanceConfig = contentRegistry.getBalanceConfig() ?? .default

        // Setup player from balance config
        self.playerName = playerName
        playerHealth = balanceConfig.resources.startingHealth
        playerMaxHealth = balanceConfig.resources.maxHealth
        playerFaith = balanceConfig.resources.startingFaith
        playerMaxFaith = balanceConfig.resources.maxFaith
        playerBalance = 50

        // Setup world from balance config
        currentDay = 0
        worldTension = balanceConfig.pressure.startingPressure
        lightDarkBalance = 50
        worldFlags = [:]
        completedEventIds = []
        completedQuestIds = []
        eventLog = []

        // Load regions from content registry
        setupRegionsFromRegistry(startingRegionId: startingRegionId)

        // Load initial quests
        setupInitialQuests()
    }

    /// Setup regions from content registry
    private func setupRegionsFromRegistry(startingRegionId: String?) {
        let regionDefs = contentRegistry.getAllRegions()
        var newRegions: [String: CoreRegionState] = [:]

        for def in regionDefs {
            let anchor = contentRegistry.getAnchor(forRegion: def.id)
            let anchorState: CoreAnchorState? = anchor.map {
                CoreAnchorState(
                    id: $0.id,
                    name: $0.title.localized,
                    integrity: $0.initialIntegrity
                )
            }

            let regionState = CoreRegionState(
                id: def.id,
                name: def.title.localized,
                state: def.initialState,
                anchor: anchorState,
                neighborIds: def.neighborIds,
                canTrade: def.initialState == .stable
            )
            newRegions[def.id] = regionState
        }

        regions = newRegions

        // Set starting region
        if let startId = startingRegionId, regions[startId] != nil {
            currentRegionId = startId
        } else {
            // Use first loaded pack's entry region or first available region
            currentRegionId = contentRegistry.loadedPacks.values.first?.manifest.entryRegionId
                ?? regions.keys.first
        }
    }

    /// Setup initial quests from content registry
    private func setupInitialQuests() {
        // Load quests marked as auto-start
        let allQuests = contentRegistry.getAllQuests()
        activeQuests = allQuests.filter { $0.autoStart }
    }

    // MARK: - Actions

    /// Perform a game action
    @discardableResult
    func performAction(_ action: CoreGameAction) -> CoreActionResult {
        guard !isGameOver else {
            return CoreActionResult(success: false, error: .gameNotInProgress)
        }

        // Validate action
        if let error = validateAction(action) {
            return CoreActionResult(success: false, error: error)
        }

        // Execute action
        var stateChanges: [CoreStateChange] = []

        // Advance time if action costs time
        let timeCost = action.timeCost
        if timeCost > 0 {
            let timeChanges = advanceTime(by: timeCost)
            stateChanges.append(contentsOf: timeChanges)
        }

        // Execute action-specific logic
        switch action {
        case .travel(let toRegionId):
            let changes = executeTravel(to: toRegionId)
            stateChanges.append(contentsOf: changes)

        case .rest:
            let changes = executeRest()
            stateChanges.append(contentsOf: changes)

        case .explore:
            let changes = executeExplore()
            stateChanges.append(contentsOf: changes)

        case .strengthenAnchor:
            let changes = executeStrengthenAnchor()
            stateChanges.append(contentsOf: changes)

        case .chooseEventOption(let eventId, let choiceIndex):
            let changes = executeEventChoice(eventId: eventId, choiceIndex: choiceIndex)
            stateChanges.append(contentsOf: changes)

        case .dismissEvent:
            currentEvent = nil
            currentEventId = nil

        case .skipTurn:
            break
        }

        // Check quest progress
        checkQuestProgress()

        // Check end conditions
        if let endResult = checkEndConditions() {
            isGameOver = true
            gameResult = endResult
            return CoreActionResult(success: true, stateChanges: stateChanges, gameEnded: endResult)
        }

        return CoreActionResult(success: true, stateChanges: stateChanges)
    }

    // MARK: - Validation

    private func validateAction(_ action: CoreGameAction) -> CoreActionError? {
        switch action {
        case .travel(let toRegionId):
            guard let current = currentRegion else {
                return .invalidAction(reason: "No current region")
            }
            if !current.neighborIds.contains(toRegionId) {
                return .regionNotNeighbor(regionId: toRegionId)
            }
            if playerHealth <= 0 {
                return .healthTooLow
            }

        case .rest:
            guard let region = currentRegion else {
                return .invalidAction(reason: "No current region")
            }
            if region.state == .breach {
                return .actionNotAvailableInRegion(action: "rest", regionState: "breach")
            }

        case .strengthenAnchor:
            guard let region = currentRegion else {
                return .invalidAction(reason: "No current region")
            }
            if region.anchor == nil {
                return .actionNotAvailableInRegion(action: "strengthen anchor", regionState: "no anchor")
            }
            let cost = balanceConfig.anchor.strengthenCost
            if playerFaith < cost {
                return .insufficientResources(resource: "faith", required: cost, available: playerFaith)
            }

        default:
            break
        }
        return nil
    }

    // MARK: - Time

    private func advanceTime(by days: Int) -> [CoreStateChange] {
        var changes: [CoreStateChange] = []

        for _ in 0..<days {
            currentDay += 1
            changes.append(.dayAdvanced(newDay: currentDay))

            // Check tension tick
            let interval = balanceConfig.pressure.thresholds.warning > 0 ? 3 : 1
            if currentDay > 0 && currentDay % interval == 0 {
                let tensionIncrease = calculateTensionIncrease()
                worldTension = min(balanceConfig.pressure.maxPressure, worldTension + tensionIncrease)
                changes.append(.tensionChanged(delta: tensionIncrease, newValue: worldTension))

                // World degradation
                let degradationChanges = processWorldDegradation()
                changes.append(contentsOf: degradationChanges)
            }
        }

        return changes
    }

    private func calculateTensionIncrease() -> Int {
        let base = balanceConfig.pressure.pressurePerTurn
        let escalationBonus = currentDay / 10
        return base + escalationBonus
    }

    private func processWorldDegradation() -> [CoreStateChange] {
        var changes: [CoreStateChange] = []

        // Get degradation chance based on tension level
        let degradationChance: Double
        if worldTension >= balanceConfig.pressure.thresholds.critical {
            degradationChance = balanceConfig.pressure.degradation.criticalChance
        } else if worldTension >= balanceConfig.pressure.thresholds.warning {
            degradationChance = balanceConfig.pressure.degradation.warningChance
        } else {
            return changes
        }

        // Find regions that can degrade
        let degradableRegions = regions.values.filter { $0.state != .breach }
        guard !degradableRegions.isEmpty else { return changes }

        // Deterministic random check using WorldRNG (not Double.random)
        let roll = WorldRNG.shared.nextDouble()
        if roll < degradationChance {
            // Pick a borderland region to degrade using deterministic selection
            let borderlands = degradableRegions.filter { $0.state == .borderland }
            if let regionToDemote = WorldRNG.shared.randomElement(from: Array(borderlands)) {
                if var region = regions[regionToDemote.id] {
                    region.state = .breach
                    regions[regionToDemote.id] = region
                    changes.append(.regionStateChanged(regionId: regionToDemote.id, newState: .breach))
                }
            }
        }

        return changes
    }

    // MARK: - Action Execution

    private func executeTravel(to regionId: String) -> [CoreStateChange] {
        var changes: [CoreStateChange] = []

        currentRegionId = regionId
        changes.append(.regionChanged(regionId: regionId))

        // Mark region as visited
        if var region = regions[regionId] {
            region.visited = true
            regions[regionId] = region
        }

        // Generate travel event
        if let event = generateEvent(for: regionId, trigger: .arrival) {
            currentEventId = event.id
            currentEvent = event
            changes.append(.eventTriggered(eventId: event.id))
        }

        return changes
    }

    private func executeRest() -> [CoreStateChange] {
        var changes: [CoreStateChange] = []

        let healAmount = 3  // Could come from balance config
        let newHealth = min(playerMaxHealth, playerHealth + healAmount)
        let delta = newHealth - playerHealth
        playerHealth = newHealth
        changes.append(.healthChanged(delta: delta, newValue: newHealth))

        return changes
    }

    private func executeExplore() -> [CoreStateChange] {
        var changes: [CoreStateChange] = []

        guard let regionId = currentRegionId else { return changes }

        // Generate exploration event
        if let event = generateEvent(for: regionId, trigger: .exploration) {
            currentEventId = event.id
            currentEvent = event
            changes.append(.eventTriggered(eventId: event.id))
        }

        return changes
    }

    private func executeStrengthenAnchor() -> [CoreStateChange] {
        var changes: [CoreStateChange] = []

        guard let regionId = currentRegionId,
              var region = regions[regionId],
              var anchor = region.anchor else {
            return changes
        }

        // Spend faith (from balance config)
        let cost = balanceConfig.anchor.strengthenCost
        playerFaith -= cost
        changes.append(.faithChanged(delta: -cost, newValue: playerFaith))

        // Strengthen anchor
        let strengthAmount = balanceConfig.anchor.strengthenAmount
        let newIntegrity = min(balanceConfig.anchor.maxIntegrity, anchor.integrity + strengthAmount)
        let delta = newIntegrity - anchor.integrity
        anchor.integrity = newIntegrity
        region.anchor = anchor
        regions[regionId] = region

        changes.append(.anchorIntegrityChanged(anchorId: anchor.id, delta: delta, newValue: newIntegrity))

        return changes
    }

    private func executeEventChoice(eventId: String, choiceIndex: Int) -> [CoreStateChange] {
        var changes: [CoreStateChange] = []

        guard let event = currentEvent,
              choiceIndex < event.choices.count else {
            return changes
        }

        let choice = event.choices[choiceIndex]

        // Apply resource changes
        for (resource, delta) in choice.consequences.resourceChanges {
            switch resource {
            case "health":
                playerHealth = max(0, min(playerMaxHealth, playerHealth + delta))
                changes.append(.healthChanged(delta: delta, newValue: playerHealth))
            case "faith":
                playerFaith = max(0, playerFaith + delta)
                changes.append(.faithChanged(delta: delta, newValue: playerFaith))
            case "tension":
                worldTension = max(0, min(100, worldTension + delta))
                changes.append(.tensionChanged(delta: delta, newValue: worldTension))
            default:
                break
            }
        }

        // Apply balance change
        if choice.consequences.balanceDelta != 0 {
            lightDarkBalance = max(0, min(100, lightDarkBalance + choice.consequences.balanceDelta))
            changes.append(.balanceChanged(delta: choice.consequences.balanceDelta, newValue: lightDarkBalance))
        }

        // Set flags (setFlags is an array of flag names, all set to true)
        for flag in choice.consequences.setFlags {
            worldFlags[flag] = true
            changes.append(.flagSet(key: flag, value: true))
        }

        // Clear flags
        for flag in choice.consequences.clearFlags {
            worldFlags[flag] = false
            changes.append(.flagSet(key: flag, value: false))
        }

        // Mark event completed if one-time
        if event.isOneTime {
            completedEventIds.insert(eventId)
        }

        currentEventId = nil
        currentEvent = nil
        changes.append(.eventCompleted(eventId: eventId))

        return changes
    }

    // MARK: - Event Generation

    private func generateEvent(for regionId: String, trigger: CoreEventTrigger) -> EventDefinition? {
        let availableEvents = contentRegistry.getAvailableEvents(
            forRegion: regionId,
            pressure: worldTension
        ).filter { event in
            // Filter out completed one-time events
            if event.isOneTime && completedEventIds.contains(event.id) {
                return false
            }
            return true
        }

        // Use deterministic selection via WorldRNG (not randomElement)
        return WorldRNG.shared.randomElement(from: availableEvents)
    }

    // MARK: - Quest Progress

    private func checkQuestProgress() {
        // Check quest conditions and update stages
        for quest in activeQuests {
            // Check if quest objectives are completed
            // For simplicity, check if all objectives with flagSet condition have their flags set
            var allObjectivesComplete = true
            for objective in quest.objectives {
                switch objective.completionCondition {
                case .flagSet(let flagName):
                    if worldFlags[flagName] != true {
                        allObjectivesComplete = false
                    }
                case .visitRegion(let regionId):
                    // Would need to track visited regions
                    if regions[regionId]?.visited != true {
                        allObjectivesComplete = false
                    }
                default:
                    // For other conditions, assume incomplete unless explicitly marked
                    break
                }
            }

            if allObjectivesComplete && !quest.objectives.isEmpty {
                completedQuestIds.insert(quest.id)
            }
        }

        // Remove completed quests from active
        activeQuests = activeQuests.filter { !completedQuestIds.contains($0.id) }
    }

    // MARK: - End Conditions

    private func checkEndConditions() -> GameEndResult? {
        // Defeat: tension at max
        if let pressureLoss = balanceConfig.endConditions.pressureLoss,
           worldTension >= pressureLoss {
            return .defeat(reason: "World tension reached maximum")
        }

        // Defeat: health 0
        if playerHealth <= 0 {
            return .defeat(reason: "Hero died")
        }

        // Victory: check victory quests
        for questId in balanceConfig.endConditions.victoryQuests {
            if completedQuestIds.contains(questId) {
                return .victory(endingId: "standard")
            }
        }

        return nil
    }
}

// MARK: - Core Game Action

/// Actions that can be performed in the game
enum CoreGameAction {
    case travel(toRegionId: String)
    case rest
    case explore
    case strengthenAnchor
    case chooseEventOption(eventId: String, choiceIndex: Int)
    case dismissEvent
    case skipTurn

    var timeCost: Int {
        switch self {
        case .travel: return 1
        case .rest: return 1
        case .explore: return 1
        case .strengthenAnchor: return 1
        case .chooseEventOption, .dismissEvent, .skipTurn: return 0
        }
    }
}

// MARK: - Core Action Result

struct CoreActionResult {
    let success: Bool
    let error: CoreActionError?
    let stateChanges: [CoreStateChange]
    let gameEnded: GameEndResult?

    init(success: Bool, error: CoreActionError? = nil, stateChanges: [CoreStateChange] = [], gameEnded: GameEndResult? = nil) {
        self.success = success
        self.error = error
        self.stateChanges = stateChanges
        self.gameEnded = gameEnded
    }
}

// MARK: - Core Action Error

enum CoreActionError: Error {
    case gameNotInProgress
    case regionNotNeighbor(regionId: String)
    case healthTooLow
    case actionNotAvailableInRegion(action: String, regionState: String)
    case insufficientResources(resource: String, required: Int, available: Int)
    case invalidAction(reason: String)
}

// MARK: - Core State Change

enum CoreStateChange {
    case dayAdvanced(newDay: Int)
    case tensionChanged(delta: Int, newValue: Int)
    case regionChanged(regionId: String)
    case regionStateChanged(regionId: String, newState: RegionStateType)
    case healthChanged(delta: Int, newValue: Int)
    case faithChanged(delta: Int, newValue: Int)
    case balanceChanged(delta: Int, newValue: Int)
    case anchorIntegrityChanged(anchorId: String, delta: Int, newValue: Int)
    case flagSet(key: String, value: Bool)
    case eventTriggered(eventId: String)
    case eventCompleted(eventId: String)
    case questCompleted(questId: String)
}

// MARK: - Core Event Trigger

enum CoreEventTrigger {
    case arrival
    case exploration
    case combat
    case quest
    case time
}

// MARK: - Core Region State

/// Runtime state of a region (combines definition + runtime data)
struct CoreRegionState {
    let id: String
    let name: String
    var state: RegionStateType
    var anchor: CoreAnchorState?
    let neighborIds: [String]
    var canTrade: Bool
    var visited: Bool = false
    var reputation: Int = 0

    var canRest: Bool {
        state == .stable
    }
}

// MARK: - Core Anchor State

/// Runtime state of an anchor
struct CoreAnchorState {
    let id: String
    let name: String
    var integrity: Int
}

// MARK: - Core Event Log Entry

struct CoreEventLogEntry {
    let dayNumber: Int
    let regionName: String
    let eventTitle: String
    let choiceMade: String
    let outcome: String
}


// ==========================================
// FILE: Engine/Core/EconomyManager.swift
// ==========================================

import Foundation

// MARK: - Economy Manager Implementation
// Handles all resource transactions in a consistent way.

/// Default implementation of EconomyManagerProtocol
final class EconomyManager: EconomyManagerProtocol {
    // MARK: - Properties

    /// Track transaction history for debugging/analytics
    private var transactionHistory: [TransactionRecord] = []

    /// Maximum history size
    private let maxHistorySize: Int

    // MARK: - Initialization

    init(maxHistorySize: Int = 100) {
        self.maxHistorySize = maxHistorySize
    }

    // MARK: - EconomyManagerProtocol

    /// Check if a transaction can be afforded
    func canAfford(_ transaction: Transaction, resources: [String: Int]) -> Bool {
        for (resource, cost) in transaction.costs {
            let available = resources[resource] ?? 0
            if available < cost {
                return false
            }
        }
        return true
    }

    /// Process a transaction, modifying resources
    /// Returns true if successful, false if cannot afford
    func process(_ transaction: Transaction, resources: inout [String: Int]) -> Bool {
        // First check if affordable
        guard canAfford(transaction, resources: resources) else {
            return false
        }

        // Apply costs
        for (resource, cost) in transaction.costs {
            let current = resources[resource] ?? 0
            resources[resource] = current - cost
        }

        // Apply gains
        for (resource, gain) in transaction.gains {
            let current = resources[resource] ?? 0
            resources[resource] = current + gain
        }

        // Record transaction
        recordTransaction(transaction, success: true)

        return true
    }

    // MARK: - Extended Methods

    /// Process transaction with caps (e.g., max health)
    func processWithCaps(
        _ transaction: Transaction,
        resources: inout [String: Int],
        caps: [String: Int]
    ) -> Bool {
        guard process(transaction, resources: &resources) else {
            return false
        }

        // Apply caps
        for (resource, maxValue) in caps {
            if let current = resources[resource], current > maxValue {
                resources[resource] = maxValue
            }
        }

        return true
    }

    /// Preview transaction result without applying
    func preview(
        _ transaction: Transaction,
        resources: [String: Int]
    ) -> [String: Int]? {
        guard canAfford(transaction, resources: resources) else {
            return nil
        }

        var result = resources

        // Apply costs
        for (resource, cost) in transaction.costs {
            let current = result[resource] ?? 0
            result[resource] = current - cost
        }

        // Apply gains
        for (resource, gain) in transaction.gains {
            let current = result[resource] ?? 0
            result[resource] = current + gain
        }

        return result
    }

    /// Calculate net change from a transaction
    func netChange(_ transaction: Transaction) -> [String: Int] {
        var net: [String: Int] = [:]

        for (resource, cost) in transaction.costs {
            net[resource] = (net[resource] ?? 0) - cost
        }

        for (resource, gain) in transaction.gains {
            net[resource] = (net[resource] ?? 0) + gain
        }

        return net
    }

    // MARK: - History

    private func recordTransaction(_ transaction: Transaction, success: Bool) {
        let record = TransactionRecord(
            transaction: transaction,
            timestamp: Date(),
            success: success
        )

        transactionHistory.append(record)

        // Trim history if needed
        if transactionHistory.count > maxHistorySize {
            transactionHistory.removeFirst(transactionHistory.count - maxHistorySize)
        }
    }

    /// Get recent transaction history
    func getHistory(limit: Int = 10) -> [TransactionRecord] {
        return Array(transactionHistory.suffix(limit))
    }

    /// Clear history
    func clearHistory() {
        transactionHistory.removeAll()
    }
}

// MARK: - Transaction Record

/// Record of a processed transaction
struct TransactionRecord {
    let transaction: Transaction
    let timestamp: Date
    let success: Bool
}

// MARK: - Transaction Extensions

extension Transaction {
    /// Create a simple cost-only transaction
    static func cost(_ resource: String, amount: Int, description: String = "") -> Transaction {
        Transaction(costs: [resource: amount], description: description)
    }

    /// Create a simple gain-only transaction
    static func gain(_ resource: String, amount: Int, description: String = "") -> Transaction {
        Transaction(gains: [resource: amount], description: description)
    }

    /// Create a trade transaction (exchange one resource for another)
    static func trade(
        spend resource1: String,
        amount1: Int,
        gain resource2: String,
        amount2: Int,
        description: String = ""
    ) -> Transaction {
        Transaction(
            costs: [resource1: amount1],
            gains: [resource2: amount2],
            description: description
        )
    }

    /// Combine two transactions
    func combined(with other: Transaction) -> Transaction {
        var newCosts = self.costs
        var newGains = self.gains

        for (resource, cost) in other.costs {
            newCosts[resource] = (newCosts[resource] ?? 0) + cost
        }

        for (resource, gain) in other.gains {
            newGains[resource] = (newGains[resource] ?? 0) + gain
        }

        return Transaction(
            costs: newCosts,
            gains: newGains,
            description: "\(self.description); \(other.description)"
        )
    }
}

// MARK: - Standard Resource Types

/// Common resource identifiers (games can define their own)
enum StandardResource: String {
    case health
    case maxHealth
    case energy
    case faith
    case gold
    case experience
    case reputation

    var id: String { rawValue }
}


// ==========================================
// FILE: Engine/Core/EngineProtocols.swift
// ==========================================

import Foundation

// MARK: - Game Engine v1.0 Core Protocols
// Setting-agnostic contracts for the game engine.
// The engine is the "processor", the game content is the "cartridge".

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - 1. Time System
// ═══════════════════════════════════════════════════════════════════════════════

/// Delegate for time progression events
protocol TimeSystemDelegate: AnyObject {
    /// Called when time advances by one tick
    func onTimeTick(currentTime: Int, delta: Int)

    /// Called when a time threshold is crossed (e.g., every 3 days)
    func onTimeThreshold(currentTime: Int, threshold: Int)
}

/// Contract for time-consuming actions
protocol TimedAction {
    /// Cost in time units (0 = instant)
    var timeCost: Int { get }
}

/// Time engine protocol - manages game time progression
protocol TimeEngineProtocol {
    var currentTime: Int { get }
    var delegate: TimeSystemDelegate? { get set }

    /// Advance time by a cost. Invariant: cost > 0 (except instant actions)
    func advance(cost: Int)

    /// Check if a threshold interval has been reached
    func checkThreshold(_ interval: Int) -> Bool
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - 2. Pressure System
// ═══════════════════════════════════════════════════════════════════════════════

/// Defines the rules for pressure/tension escalation
protocol PressureRuleSet {
    var maxPressure: Int { get }
    var initialPressure: Int { get }

    /// Calculate pressure increase based on current state
    func calculateEscalation(currentPressure: Int, currentTime: Int) -> Int

    /// Check what effects trigger at current pressure level
    func checkThresholds(pressure: Int) -> [WorldEffect]

    /// Interval (in time units) for automatic pressure increase
    var escalationInterval: Int { get }

    /// Amount of pressure added per interval
    var escalationAmount: Int { get }
}

/// Effects that can be applied to the world
enum WorldEffect: Equatable {
    case regionDegradation(probability: Double)
    case globalEvent(eventId: String)
    case phaseChange(newPhase: String)
    case anchorWeakening(amount: Int)
    case custom(id: String, parameters: [String: Any])

    static func == (lhs: WorldEffect, rhs: WorldEffect) -> Bool {
        switch (lhs, rhs) {
        case (.regionDegradation(let p1), .regionDegradation(let p2)):
            return p1 == p2
        case (.globalEvent(let e1), .globalEvent(let e2)):
            return e1 == e2
        case (.phaseChange(let ph1), .phaseChange(let ph2)):
            return ph1 == ph2
        case (.anchorWeakening(let a1), .anchorWeakening(let a2)):
            return a1 == a2
        case (.custom(let id1, _), .custom(let id2, _)):
            return id1 == id2
        default:
            return false
        }
    }
}

/// Pressure engine protocol
protocol PressureEngineProtocol {
    var currentPressure: Int { get }
    var rules: PressureRuleSet { get }

    /// Escalate pressure based on rules
    func escalate(at currentTime: Int)

    /// Manually adjust pressure
    func adjust(by delta: Int)

    /// Get current threshold effects
    func currentEffects() -> [WorldEffect]
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - 3. Event System
// ═══════════════════════════════════════════════════════════════════════════════

/// Abstract event definition protocol (setting-agnostic)
/// Concrete implementation: Engine/Data/Definitions/EventDefinition.swift
protocol EventDefinitionProtocol {
    associatedtype ChoiceType: ChoiceDefinitionProtocol

    var id: String { get }
    var title: String { get }
    var description: String { get }
    var choices: [ChoiceType] { get }

    /// Whether this event consumes time
    var isInstant: Bool { get }

    /// Whether this event can only occur once
    var isOneTime: Bool { get }

    /// Check if event can occur given current context
    func canOccur(in context: EventContext) -> Bool
}

/// Abstract choice definition protocol
/// Concrete implementation: Engine/Data/Definitions/EventDefinition.swift (ChoiceDefinition struct)
protocol ChoiceDefinitionProtocol {
    associatedtype RequirementsType: RequirementsDefinitionProtocol
    associatedtype ConsequencesType: ConsequencesDefinitionProtocol

    var id: String { get }
    var text: String { get }
    var requirements: RequirementsType? { get }
    var consequences: ConsequencesType { get }
}

/// Abstract requirements protocol (gating conditions)
protocol RequirementsDefinitionProtocol {
    func canMeet(with resources: ResourceProvider) -> Bool
}

/// Abstract consequences protocol (outcomes)
protocol ConsequencesDefinitionProtocol {
    /// Resource changes (positive or negative)
    var resourceChanges: [String: Int] { get }

    /// Flags to set
    var flagsToSet: [String: Bool] { get }

    /// Custom effects
    var customEffects: [String] { get }
}

/// Context for event evaluation
struct EventContext {
    let currentLocation: String
    let locationState: String
    let pressure: Int
    let flags: [String: Bool]
    let resources: [String: Int]
    let completedEvents: Set<String>
}

/// Provider for checking resources
protocol ResourceProvider {
    func getValue(for resource: String) -> Int
    func hasFlag(_ flag: String) -> Bool
}

/// Event system protocol
protocol EventSystemProtocol {
    associatedtype Event: EventDefinitionProtocol

    /// Get available events for current context
    func getAvailableEvents(in context: EventContext) -> [Event]

    /// Mark event as completed
    func markCompleted(eventId: String)

    /// Check if event was completed
    func isCompleted(eventId: String) -> Bool
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - 4. Resolution System (Conflicts)
// ═══════════════════════════════════════════════════════════════════════════════

/// Types of challenges/conflicts
enum ChallengeType: String, Codable {
    case combat
    case skillCheck
    case socialEncounter
    case puzzle
    case tradeOff
    case sacrifice
}

/// Abstract challenge definition
protocol ChallengeDefinition {
    var type: ChallengeType { get }
    var difficulty: Int { get }
    var context: Any? { get }
}

/// Result of challenge resolution
enum ResolutionResult<Reward, Penalty> {
    case success(Reward)
    case failure(Penalty)
    case partial(reward: Reward, penalty: Penalty)
    case cancelled
}

/// Conflict resolver protocol - pluggable resolution mechanics
protocol ConflictResolverProtocol {
    associatedtype Challenge: ChallengeDefinition
    associatedtype Actor
    associatedtype Reward
    associatedtype Penalty

    /// Resolve a challenge. Can be async for animations/UI.
    func resolve(
        challenge: Challenge,
        actor: Actor
    ) async -> ResolutionResult<Reward, Penalty>
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - 5. Progression System
// ═══════════════════════════════════════════════════════════════════════════════

/// Player path/alignment tracking
protocol ProgressionPathProtocol {
    associatedtype PathType

    var currentPath: PathType { get }
    var pathValue: Int { get }

    /// Shift path by delta
    func shift(by delta: Int)

    /// Get unlocked capabilities for current path
    func unlockedCapabilities() -> [String]

    /// Get locked options for current path
    func lockedOptions() -> [String]
}

/// Progression tracker
protocol ProgressionTrackerProtocol {
    /// Track capability unlock
    func unlock(capability: String)

    /// Track capability lock (path trade-off)
    func lock(capability: String)

    /// Check if capability is available
    func isUnlocked(_ capability: String) -> Bool
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - 6. Victory/Defeat System
// ═══════════════════════════════════════════════════════════════════════════════

/// End condition types
enum EndConditionType: String, Codable {
    case objectiveBased    // Complete specific goals
    case pressureBased     // Pressure reaches threshold
    case resourceBased     // Resource hits 0 or max
    case pathBased         // Player path determines ending
    case timeBased         // Time limit reached
}

/// End condition definition
protocol EndConditionDefinition {
    var type: EndConditionType { get }
    var id: String { get }
    var isVictory: Bool { get }

    /// Check if condition is met
    func isMet(pressure: Int, resources: [String: Int], flags: [String: Bool], time: Int) -> Bool
}

/// Victory/Defeat checker protocol
protocol EndGameCheckerProtocol {
    associatedtype Condition: EndConditionDefinition

    var conditions: [Condition] { get }

    /// Check all conditions, return first met (or nil)
    func checkConditions(
        pressure: Int,
        resources: [String: Int],
        flags: [String: Bool],
        time: Int
    ) -> Condition?
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - 7. Economy System
// ═══════════════════════════════════════════════════════════════════════════════

/// Transaction for resource changes
struct Transaction {
    let costs: [String: Int]
    let gains: [String: Int]
    let description: String

    init(costs: [String: Int] = [:], gains: [String: Int] = [:], description: String = "") {
        self.costs = costs
        self.gains = gains
        self.description = description
    }
}

/// Economy manager protocol
protocol EconomyManagerProtocol {
    /// Check if transaction is affordable
    func canAfford(_ transaction: Transaction, resources: [String: Int]) -> Bool

    /// Process transaction, returns new resource values
    func process(_ transaction: Transaction, resources: inout [String: Int]) -> Bool
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - 8. World State System
// ═══════════════════════════════════════════════════════════════════════════════

/// Location state (abstract)
protocol LocationStateProtocol {
    var id: String { get }
    var name: String { get }
    var currentState: String { get }

    /// Can player rest here?
    var canRest: Bool { get }

    /// Can player trade here?
    var canTrade: Bool { get }

    /// Neighbor location IDs
    var neighborIds: [String] { get }
}

/// World state manager protocol
protocol WorldStateManagerProtocol {
    associatedtype Location: LocationStateProtocol

    var locations: [Location] { get }
    var currentLocationId: String? { get }
    var flags: [String: Bool] { get }

    /// Move to location
    func moveTo(locationId: String) -> Int // Returns time cost

    /// Set flag
    func setFlag(_ flag: String, value: Bool)

    /// Get flag
    func hasFlag(_ flag: String) -> Bool

    /// Degrade location
    func degradeLocation(_ locationId: String)

    /// Improve location
    func improveLocation(_ locationId: String)
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - 9. Quest System
// ═══════════════════════════════════════════════════════════════════════════════

/// Quest objective
protocol QuestObjectiveProtocol {
    var id: String { get }
    var description: String { get }
    var isCompleted: Bool { get }

    /// Check if objective is complete based on flags
    func checkCompletion(flags: [String: Bool]) -> Bool
}

/// Quest definition
protocol QuestDefinitionProtocol {
    associatedtype Objective: QuestObjectiveProtocol

    var id: String { get }
    var title: String { get }
    var isMain: Bool { get }
    var objectives: [Objective] { get }
    var isCompleted: Bool { get }

    /// Rewards on completion
    var rewardTransaction: Transaction { get }
}

/// Quest manager protocol
protocol QuestManagerProtocol {
    associatedtype Quest: QuestDefinitionProtocol

    var activeQuests: [Quest] { get }
    var completedQuests: [String] { get }

    /// Check quest progress based on flags
    func checkProgress(flags: [String: Bool])

    /// Complete a quest
    func completeQuest(_ questId: String) -> Transaction?
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - 10. Core Engine Protocol
// ═══════════════════════════════════════════════════════════════════════════════

/// Main game engine orchestrator protocol
protocol GameEngineProtocol {
    associatedtype PlayerState
    associatedtype WorldManager: WorldStateManagerProtocol
    associatedtype EventSystem: EventSystemProtocol
    associatedtype Resolver: ConflictResolverProtocol
    associatedtype QuestManager: QuestManagerProtocol
    associatedtype EndChecker: EndGameCheckerProtocol

    // Subsystems
    var timeEngine: any TimeEngineProtocol { get }
    var pressureEngine: any PressureEngineProtocol { get }
    var worldManager: WorldManager { get }
    var eventSystem: EventSystem { get }
    var resolver: Resolver { get }
    var questManager: QuestManager { get }
    var endChecker: EndChecker { get }
    var economyManager: any EconomyManagerProtocol { get }

    // State
    var playerState: PlayerState { get }
    var isGameOver: Bool { get }
    var isVictory: Bool { get }

    // Core Loop
    func performAction(_ action: any TimedAction) async
    func worldTick()
    func checkEndConditions()
    func save()
}


// ==========================================
// FILE: Engine/Core/EngineSave.swift
// ==========================================

import Foundation

// MARK: - Engine Save Structure
// Сериализуемое состояние для save/load (Engine-First Architecture)

/// Полное состояние игры для сохранения
/// Engine сохраняет/загружает через эту структуру, а не через WorldState
struct EngineSave: Codable {
    // MARK: - Metadata
    let version: Int
    let savedAt: Date
    let gameDuration: TimeInterval

    // MARK: - Pack Compatibility (Audit 2.0 Requirement)
    /// Core engine version for compatibility checking
    let coreVersion: String
    /// Active pack set with versions (packId → version string)
    let activePackSet: [String: String]
    /// Save format version for migration
    let formatVersion: Int

    // MARK: - Player State
    let playerName: String
    let playerHealth: Int
    let playerMaxHealth: Int
    let playerFaith: Int
    let playerMaxFaith: Int
    let playerBalance: Int

    // MARK: - Deck State
    let deckCardIds: [UUID]
    let handCardIds: [UUID]
    let discardCardIds: [UUID]

    // MARK: - World State
    let currentDay: Int
    let worldTension: Int
    let lightDarkBalance: Int
    let currentRegionId: UUID?

    // MARK: - Regions State
    let regions: [RegionSaveState]

    // MARK: - Quest State
    let mainQuestStage: Int
    let activeQuestIds: [String]
    let completedQuestIds: [String]
    let questStages: [String: Int]

    // MARK: - Events State
    let completedEventIds: [UUID]
    let eventLog: [EventLogEntrySave]

    // MARK: - World Flags
    let worldFlags: [String: Bool]

    // MARK: - RNG State
    let rngSeed: UInt64?

    // MARK: - Current Version
    static let currentVersion = 1
    static let currentFormatVersion = 1
    static let currentCoreVersion = "1.2.0"

    // MARK: - Pack Compatibility Validation

    /// Check if save is compatible with current engine and loaded packs
    func validateCompatibility(with registry: ContentRegistry) -> SaveCompatibilityResult {
        var warnings: [String] = []
        var errors: [String] = []

        // Check core version
        if coreVersion != EngineSave.currentCoreVersion {
            warnings.append("Save was created with core version \(coreVersion), current is \(EngineSave.currentCoreVersion)")
        }

        // Check format version
        if formatVersion > EngineSave.currentFormatVersion {
            errors.append("Save format version \(formatVersion) is newer than supported \(EngineSave.currentFormatVersion)")
        }

        // Check pack versions
        for (packId, savedVersion) in activePackSet {
            if let loadedPack = registry.loadedPacks[packId] {
                let loadedVersion = loadedPack.manifest.version.description
                if loadedVersion != savedVersion {
                    warnings.append("Pack '\(packId)' version mismatch: save has \(savedVersion), loaded is \(loadedVersion)")
                }
            } else {
                errors.append("Required pack '\(packId)' (version \(savedVersion)) is not loaded")
            }
        }

        if !errors.isEmpty {
            return .incompatible(errors: errors)
        } else if !warnings.isEmpty {
            return .compatible(warnings: warnings)
        } else {
            return .fullyCompatible
        }
    }
}

/// Result of save compatibility validation
enum SaveCompatibilityResult {
    case fullyCompatible
    case compatible(warnings: [String])
    case incompatible(errors: [String])

    var isLoadable: Bool {
        switch self {
        case .fullyCompatible, .compatible:
            return true
        case .incompatible:
            return false
        }
    }
}

// MARK: - Region Save State

/// Состояние региона для сохранения
struct RegionSaveState: Codable {
    let id: UUID
    let name: String
    let type: String  // RegionType.rawValue
    let state: String  // RegionState.rawValue
    let anchor: AnchorSaveState?
    let neighborIds: [UUID]
    let canTrade: Bool
    let visited: Bool
    let reputation: Int

    init(from region: EngineRegionState) {
        self.id = region.id
        self.name = region.name
        self.type = region.type.rawValue
        self.state = region.state.rawValue
        self.anchor = region.anchor.map { AnchorSaveState(from: $0) }
        self.neighborIds = region.neighborIds
        self.canTrade = region.canTrade
        self.visited = region.visited
        self.reputation = region.reputation
    }

    func toEngineRegionState() -> EngineRegionState {
        EngineRegionState(
            id: id,
            name: name,
            type: RegionType(rawValue: type) ?? .wilderness,
            state: RegionState(rawValue: state) ?? .stable,
            anchor: anchor?.toEngineAnchorState(),
            neighborIds: neighborIds,
            canTrade: canTrade,
            visited: visited,
            reputation: reputation
        )
    }
}

// MARK: - Anchor Save State

/// Состояние якоря для сохранения
struct AnchorSaveState: Codable {
    let id: UUID
    let name: String
    let integrity: Int

    init(from anchor: EngineAnchorState) {
        self.id = anchor.id
        self.name = anchor.name
        self.integrity = anchor.integrity
    }

    func toEngineAnchorState() -> EngineAnchorState {
        EngineAnchorState(id: id, name: name, integrity: integrity)
    }
}

// MARK: - Event Log Entry Save

/// Запись лога событий для сохранения
struct EventLogEntrySave: Codable {
    let id: UUID
    let dayNumber: Int
    let timestamp: Date
    let regionName: String
    let eventTitle: String
    let choiceMade: String
    let outcome: String
    let type: String  // EventLogType.rawValue

    init(from entry: EventLogEntry) {
        self.id = entry.id
        self.dayNumber = entry.dayNumber
        self.timestamp = entry.timestamp
        self.regionName = entry.regionName
        self.eventTitle = entry.eventTitle
        self.choiceMade = entry.choiceMade
        self.outcome = entry.outcome
        self.type = entry.type.rawValue
    }

    func toEventLogEntry() -> EventLogEntry {
        EventLogEntry(
            id: id,
            dayNumber: dayNumber,
            timestamp: timestamp,
            regionName: regionName,
            eventTitle: eventTitle,
            choiceMade: choiceMade,
            outcome: outcome,
            type: EventLogType(rawValue: type) ?? .exploration
        )
    }
}

// MARK: - TwilightGameEngine Save/Load Extension

extension TwilightGameEngine {

    /// Create save state from current engine state
    func createSave(gameDuration: TimeInterval = 0) -> EngineSave {
        // Collect loaded pack versions for compatibility checking
        var packVersions: [String: String] = [:]
        for (packId, pack) in contentRegistry.loadedPacks {
            packVersions[packId] = pack.manifest.version.description
        }

        return EngineSave(
            version: EngineSave.currentVersion,
            savedAt: Date(),
            gameDuration: gameDuration,
            coreVersion: EngineSave.currentCoreVersion,
            activePackSet: packVersions,
            formatVersion: EngineSave.currentFormatVersion,
            playerName: playerName,
            playerHealth: playerHealth,
            playerMaxHealth: playerMaxHealth,
            playerFaith: playerFaith,
            playerMaxFaith: playerMaxFaith,
            playerBalance: playerBalance,
            deckCardIds: [],  // Phase 4: Card system migration
            handCardIds: [],
            discardCardIds: [],
            currentDay: currentDay,
            worldTension: worldTension,
            lightDarkBalance: lightDarkBalance,
            currentRegionId: currentRegionId,
            regions: publishedRegions.values.map { RegionSaveState(from: $0) },
            mainQuestStage: mainQuestStage,
            activeQuestIds: publishedActiveQuests.map { $0.id },
            completedQuestIds: Array(getCompletedQuestIds()),
            questStages: getQuestStages(),
            completedEventIds: Array(getCompletedEventIds()),
            eventLog: publishedEventLog.map { EventLogEntrySave(from: $0) },
            worldFlags: publishedWorldFlags,
            rngSeed: nil  // Phase 4: RNG state persistence
        )
    }

    /// Load state from save
    func loadFromSave(_ save: EngineSave) {
        // Player state
        playerName = save.playerName
        playerHealth = save.playerHealth
        playerMaxHealth = save.playerMaxHealth
        playerFaith = save.playerFaith
        playerMaxFaith = save.playerMaxFaith
        playerBalance = save.playerBalance

        // World state
        currentDay = save.currentDay
        worldTension = save.worldTension
        lightDarkBalance = save.lightDarkBalance
        currentRegionId = save.currentRegionId

        // Reset game state
        isGameOver = false
        gameResult = nil
        currentEventId = nil
        currentEvent = nil
        lastDayEvent = nil
        isInCombat = false

        // Load regions
        var newRegions: [UUID: EngineRegionState] = [:]
        for regionSave in save.regions {
            let region = regionSave.toEngineRegionState()
            newRegions[region.id] = region
        }
        setRegions(newRegions)

        // Load flags
        setWorldFlags(save.worldFlags)

        // Load completed events
        setCompletedEventIds(Set(save.completedEventIds))

        // Load event log
        setEventLog(save.eventLog.map { $0.toEventLogEntry() })

        // Load quest state
        setMainQuestStage(save.mainQuestStage)
        setCompletedQuestIds(Set(save.completedQuestIds))
        setQuestStages(save.questStages)

        // Sync pressure engine
        pressureEngine.setPressure(worldTension)
        pressureEngine.syncTriggeredThresholdsFromPressure()

        // Update published state
        updatePublishedStateAfterLoad()
    }
}


// ==========================================
// FILE: Engine/Core/GameLoop.swift
// ==========================================

import Foundation

// MARK: - Game Loop / Engine Orchestrator
// The central coordinator that runs the game engine.
// This is the "processor" - specific games are the "cartridge".

/// Engine game phase enum (distinct from legacy GamePhase in Models/GameState.swift)
enum EngineGamePhase: String, Codable {
    case setup
    case playing
    case paused
    case ended
}

/// Game end result
enum GameEndResult: Equatable {
    case victory(endingId: String)
    case defeat(reason: String)
    case abandoned
}

// MARK: - Abstract Game Loop

/// Base class for game loop implementation
/// Subclass this for specific game implementations
class GameLoopBase: ObservableObject {
    // MARK: - Published State

    @Published private(set) var currentPhase: EngineGamePhase = .setup
    @Published private(set) var isGameOver: Bool = false
    @Published private(set) var endResult: GameEndResult?

    // MARK: - Core Subsystems

    let timeEngine: TimeEngine
    let pressureEngine: PressureEngine
    let economyManager: EconomyManager

    // MARK: - State

    /// Player resources (generic key-value store)
    @Published var playerResources: [String: Int] = [:]

    /// World flags
    @Published var worldFlags: [String: Bool] = [:]

    /// Completed event IDs
    private(set) var completedEvents: Set<String> = []

    // MARK: - Delegates

    weak var timeDelegate: TimeSystemDelegate? {
        didSet { timeEngine.delegate = timeDelegate }
    }

    // MARK: - Initialization

    init(
        pressureRules: PressureRuleSet,
        timeThresholdInterval: Int = 3
    ) {
        self.timeEngine = TimeEngine(thresholdInterval: timeThresholdInterval)
        self.pressureEngine = PressureEngine(rules: pressureRules)
        self.economyManager = EconomyManager()
    }

    // MARK: - Core Loop Methods

    /// Start a new game
    func startGame() {
        currentPhase = .playing
        isGameOver = false
        endResult = nil

        // Reset subsystems
        timeEngine.reset()
        pressureEngine.reset()
        economyManager.clearHistory()
        completedEvents.removeAll()

        // Subclass should override to set initial state
        setupInitialState()
    }

    /// Override in subclass to set initial player resources, world state, etc.
    func setupInitialState() {
        // Subclass implementation
    }

    /// Main action execution - the canonical core loop
    func performAction(_ action: any TimedAction) async {
        guard currentPhase == .playing else { return }

        // 1. Get time cost
        let cost = action.timeCost

        // 2. Advance time (triggers worldTick via delegate)
        timeEngine.advance(cost: cost)

        // 3. Check if time threshold crossed (every N days)
        if timeEngine.checkThreshold(pressureEngine.rules.escalationInterval) {
            // 4. Escalate pressure
            pressureEngine.escalate(at: timeEngine.currentTime)

            // 5. Apply world effects
            applyWorldEffects(pressureEngine.currentEffects())
        }

        // 6. Process action-specific logic (subclass)
        await processAction(action)

        // 7. Update quests (subclass)
        updateQuests()

        // 8. Check end conditions
        checkEndConditions()

        // 9. Auto-save (if configured)
        autoSave()
    }

    /// Override in subclass to handle specific actions
    func processAction(_ action: any TimedAction) async {
        // Subclass implementation
    }

    /// Override in subclass to update quest progress
    func updateQuests() {
        // Subclass implementation
    }

    /// Apply world effects from pressure thresholds
    func applyWorldEffects(_ effects: [WorldEffect]) {
        for effect in effects {
            applyWorldEffect(effect)
        }
    }

    /// Apply a single world effect - override in subclass for custom effects
    func applyWorldEffect(_ effect: WorldEffect) {
        switch effect {
        case .regionDegradation(let probability):
            // Subclass handles region degradation
            handleRegionDegradation(probability: probability)

        case .globalEvent(let eventId):
            // Trigger a global event
            triggerGlobalEvent(eventId)

        case .phaseChange(let newPhase):
            // Handle phase change
            handlePhaseChange(newPhase)

        case .anchorWeakening(let amount):
            // Weaken anchors
            weakenAnchors(amount: amount)

        case .custom(let id, let parameters):
            // Custom effect - subclass handles
            handleCustomEffect(id: id, parameters: parameters)
        }
    }

    // MARK: - Effect Handlers (Override in Subclass)

    func handleRegionDegradation(probability: Double) {
        // Subclass implementation
    }

    func triggerGlobalEvent(_ eventId: String) {
        // Subclass implementation
    }

    func handlePhaseChange(_ newPhase: String) {
        // Subclass implementation
    }

    func weakenAnchors(amount: Int) {
        // Subclass implementation
    }

    func handleCustomEffect(id: String, parameters: [String: Any]) {
        // Subclass implementation
    }

    // MARK: - End Conditions

    /// Check victory and defeat conditions
    func checkEndConditions() {
        // Check pressure-based defeat
        if pressureEngine.isAtMaximum {
            endGame(result: .defeat(reason: "pressure_maximum"))
            return
        }

        // Check resource-based defeat (e.g., health = 0)
        if let health = playerResources["health"], health <= 0 {
            endGame(result: .defeat(reason: "health_zero"))
            return
        }

        // Subclass should override for victory conditions
        checkVictoryConditions()
    }

    /// Override in subclass for game-specific victory conditions
    func checkVictoryConditions() {
        // Subclass implementation
    }

    /// End the game
    func endGame(result: GameEndResult) {
        currentPhase = .ended
        isGameOver = true
        endResult = result
    }

    // MARK: - Resource Management

    /// Get a resource value
    func getResource(_ key: String) -> Int {
        return playerResources[key] ?? 0
    }

    /// Set a resource value
    func setResource(_ key: String, value: Int) {
        playerResources[key] = value
    }

    /// Modify a resource by delta
    func modifyResource(_ key: String, by delta: Int) {
        let current = playerResources[key] ?? 0
        playerResources[key] = current + delta
    }

    /// Process a transaction
    func processTransaction(_ transaction: Transaction) -> Bool {
        return economyManager.process(transaction, resources: &playerResources)
    }

    // MARK: - Flag Management

    /// Set a world flag
    func setFlag(_ flag: String, value: Bool = true) {
        worldFlags[flag] = value
    }

    /// Check a world flag
    func hasFlag(_ flag: String) -> Bool {
        return worldFlags[flag] ?? false
    }

    // MARK: - Event Tracking

    /// Mark an event as completed
    func markEventCompleted(_ eventId: String) {
        completedEvents.insert(eventId)
    }

    /// Check if event was completed
    func isEventCompleted(_ eventId: String) -> Bool {
        return completedEvents.contains(eventId)
    }

    // MARK: - Save/Load

    func autoSave() {
        // Subclass implementation
    }

    func save() {
        // Subclass implementation
    }

    func load() {
        // Subclass implementation
    }

    // MARK: - Context Building

    /// Build event context for event filtering
    func buildEventContext(
        currentLocation: String,
        locationState: String
    ) -> EventContext {
        return EventContext(
            currentLocation: currentLocation,
            locationState: locationState,
            pressure: pressureEngine.currentPressure,
            flags: worldFlags,
            resources: playerResources,
            completedEvents: completedEvents
        )
    }
}

// MARK: - Action Types

/// Standard game actions
enum StandardAction: TimedAction {
    case travel(from: String, to: String, isNeighbor: Bool)
    case rest
    case explore(instant: Bool)
    case trade
    case interact(targetId: String)
    case combat(enemyId: String)
    case useAbility(abilityId: String)
    case custom(id: String, cost: Int)

    var timeCost: Int {
        switch self {
        case .travel(_, _, let isNeighbor):
            return isNeighbor ? 1 : 2
        case .rest:
            return 1
        case .explore(let instant):
            return instant ? 0 : 1
        case .trade:
            return 1
        case .interact:
            return 1
        case .combat:
            return 1
        case .useAbility:
            return 1
        case .custom(_, let cost):
            return cost
        }
    }
}


// ==========================================
// FILE: Engine/Core/PressureEngine.swift
// ==========================================

import Foundation

// MARK: - Pressure Engine Implementation
// Generic pressure/tension system that drives game escalation.

/// Default implementation of PressureEngineProtocol
final class PressureEngine: PressureEngineProtocol {
    // MARK: - Properties

    private(set) var currentPressure: Int
    let rules: PressureRuleSet

    /// Track which thresholds have been triggered
    private var triggeredThresholds: Set<Int> = []

    // MARK: - Initialization

    init(rules: PressureRuleSet) {
        self.rules = rules
        self.currentPressure = rules.initialPressure
    }

    // MARK: - PressureEngineProtocol

    /// Escalate pressure based on rules and current time
    func escalate(at currentTime: Int) {
        let delta = rules.calculateEscalation(currentPressure: currentPressure, currentTime: currentTime)
        adjust(by: delta)
    }

    /// Manually adjust pressure (can be positive or negative)
    func adjust(by delta: Int) {
        let newPressure = currentPressure + delta
        currentPressure = min(max(0, newPressure), rules.maxPressure)
    }

    /// Get effects that should trigger at current pressure level
    func currentEffects() -> [WorldEffect] {
        return rules.checkThresholds(pressure: currentPressure)
    }

    // MARK: - Utility

    /// Reset pressure (for new game)
    func reset() {
        currentPressure = rules.initialPressure
        triggeredThresholds.removeAll()
    }

    /// Set pressure directly (for save/load)
    func setPressure(_ value: Int) {
        currentPressure = min(max(0, value), rules.maxPressure)
    }

    // MARK: - Save/Load Support

    /// Get triggered thresholds for save
    func getTriggeredThresholds() -> Set<Int> {
        return triggeredThresholds
    }

    /// Restore triggered thresholds from save
    /// Call this after loading game to prevent duplicate threshold events
    func setTriggeredThresholds(_ thresholds: Set<Int>) {
        triggeredThresholds = thresholds
    }

    /// Reconstruct triggered thresholds from current pressure value
    /// Use this when loading a save that doesn't have explicit thresholds saved
    /// All thresholds below or equal to current pressure are marked as triggered
    func syncTriggeredThresholdsFromPressure() {
        triggeredThresholds.removeAll()
        // Use checkThresholds to find which effects would trigger at current pressure
        // Then mark standard threshold levels (10, 20, 30, etc.) as triggered
        // This is a heuristic - actual threshold levels depend on the rule set
        let standardThresholds = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
        for threshold in standardThresholds where threshold <= currentPressure {
            triggeredThresholds.insert(threshold)
        }
    }

    /// Get pressure as percentage (0.0 - 1.0)
    var pressurePercentage: Double {
        guard rules.maxPressure > 0 else { return 0 }
        return Double(currentPressure) / Double(rules.maxPressure)
    }

    /// Check if at maximum pressure (game over condition)
    var isAtMaximum: Bool {
        currentPressure >= rules.maxPressure
    }
}

// MARK: - Standard Pressure Rule Set

/// Basic pressure rules with configurable parameters
struct StandardPressureRules: PressureRuleSet {
    let maxPressure: Int
    let initialPressure: Int
    let escalationInterval: Int
    let escalationAmount: Int

    /// Thresholds that trigger effects [pressure: effects]
    let thresholds: [Int: [WorldEffect]]

    init(
        maxPressure: Int = 100,
        initialPressure: Int = 30,
        escalationInterval: Int = 3,
        escalationAmount: Int = 2,
        thresholds: [Int: [WorldEffect]] = [:]
    ) {
        self.maxPressure = maxPressure
        self.initialPressure = initialPressure
        self.escalationInterval = escalationInterval
        self.escalationAmount = escalationAmount
        self.thresholds = thresholds
    }

    func calculateEscalation(currentPressure: Int, currentTime: Int) -> Int {
        // Standard: add escalationAmount every escalationInterval
        return escalationAmount
    }

    func checkThresholds(pressure: Int) -> [WorldEffect] {
        var effects: [WorldEffect] = []

        for (threshold, thresholdEffects) in thresholds {
            if pressure >= threshold {
                effects.append(contentsOf: thresholdEffects)
            }
        }

        return effects
    }
}

// MARK: - Adaptive Pressure Rules

/// Pressure rules that adapt based on game state
struct AdaptivePressureRules: PressureRuleSet {
    let maxPressure: Int
    let initialPressure: Int
    let escalationInterval: Int
    let baseEscalationAmount: Int

    /// Multiplier based on current pressure (higher pressure = faster escalation)
    let accelerationFactor: Double

    /// Thresholds with effects
    let thresholds: [Int: [WorldEffect]]

    var escalationAmount: Int { baseEscalationAmount }

    init(
        maxPressure: Int = 100,
        initialPressure: Int = 30,
        escalationInterval: Int = 3,
        baseEscalationAmount: Int = 2,
        accelerationFactor: Double = 0.01,
        thresholds: [Int: [WorldEffect]] = [:]
    ) {
        self.maxPressure = maxPressure
        self.initialPressure = initialPressure
        self.escalationInterval = escalationInterval
        self.baseEscalationAmount = baseEscalationAmount
        self.accelerationFactor = accelerationFactor
        self.thresholds = thresholds
    }

    func calculateEscalation(currentPressure: Int, currentTime: Int) -> Int {
        // Adaptive: base amount + acceleration based on current pressure
        let acceleration = Int(Double(currentPressure) * accelerationFactor)
        return baseEscalationAmount + acceleration
    }

    func checkThresholds(pressure: Int) -> [WorldEffect] {
        var effects: [WorldEffect] = []

        for (threshold, thresholdEffects) in thresholds {
            if pressure >= threshold {
                effects.append(contentsOf: thresholdEffects)
            }
        }

        return effects
    }
}

// MARK: - Pressure Change Event

/// Event fired when pressure changes significantly
struct PressureChangeEvent {
    let oldValue: Int
    let newValue: Int
    let delta: Int
    let thresholdsCrossed: [Int]
    let effectsTriggered: [WorldEffect]
}


// ==========================================
// FILE: Engine/Core/RequirementsEvaluator.swift
// ==========================================

import Foundation

// MARK: - Requirements Evaluator
// Логика проверки требований, вынесенная из Definitions в Engine Core
// Definitions остаются "тупыми данными", а логика живёт здесь

/// Протокол для оценки требований
protocol RequirementsEvaluating {
    /// Проверяет, выполнены ли требования выбора
    func canMeet(
        requirements: ChoiceRequirements,
        resources: [String: Int],
        flags: Set<String>,
        balance: Int
    ) -> Bool

    /// Проверяет, доступен ли выбор в текущем контексте
    func isChoiceAvailable(
        choice: ChoiceDefinition,
        resources: [String: Int],
        flags: Set<String>,
        balance: Int
    ) -> Bool
}

/// Стандартный evaluator для проверки требований
struct RequirementsEvaluator: RequirementsEvaluating {

    /// Проверяет, выполнены ли требования
    func canMeet(
        requirements: ChoiceRequirements,
        resources: [String: Int],
        flags: Set<String>,
        balance: Int
    ) -> Bool {
        // Check resources
        for (resourceId, minValue) in requirements.minResources {
            if (resources[resourceId] ?? 0) < minValue {
                return false
            }
        }

        // Check required flags
        for flag in requirements.requiredFlags {
            if !flags.contains(flag) {
                return false
            }
        }

        // Check forbidden flags
        for flag in requirements.forbiddenFlags {
            if flags.contains(flag) {
                return false
            }
        }

        // Check balance range
        if let min = requirements.minBalance, balance < min {
            return false
        }
        if let max = requirements.maxBalance, balance > max {
            return false
        }

        return true
    }

    /// Проверяет, доступен ли выбор (если есть requirements - проверяет их)
    func isChoiceAvailable(
        choice: ChoiceDefinition,
        resources: [String: Int],
        flags: Set<String>,
        balance: Int
    ) -> Bool {
        guard let requirements = choice.requirements else {
            return true  // Нет требований = всегда доступен
        }
        return canMeet(
            requirements: requirements,
            resources: resources,
            flags: flags,
            balance: balance
        )
    }
}

// MARK: - Shared Instance

/// Глобальный evaluator для проверки требований
enum Requirements {
    static var evaluator: RequirementsEvaluating = RequirementsEvaluator()
}


// ==========================================
// FILE: Engine/Core/TimeEngine.swift
// ==========================================

import Foundation

// MARK: - Time Engine Implementation
// Generic time management system for turn-based games.

/// Default implementation of TimeEngineProtocol
final class TimeEngine: TimeEngineProtocol {
    // MARK: - Properties

    private(set) var currentTime: Int = 0
    weak var delegate: TimeSystemDelegate?

    /// Thresholds that have been triggered (to avoid re-triggering)
    private var triggeredThresholds: Set<Int> = []

    /// Configurable threshold intervals (e.g., [3, 6, 9] or just [3] for "every 3")
    private let thresholdInterval: Int

    // MARK: - Initialization

    /// Initialize with a threshold interval (e.g., 3 for "every 3 time units")
    init(thresholdInterval: Int = 3) {
        self.thresholdInterval = thresholdInterval
    }

    // MARK: - TimeEngineProtocol

    /// Advance time by cost units
    /// Invariant: Time cannot go backwards
    func advance(cost: Int) {
        guard cost > 0 else {
            // Instant actions (cost = 0) don't advance time
            return
        }

        let previousTime = currentTime
        currentTime += cost

        // Notify delegate of each tick
        delegate?.onTimeTick(currentTime: currentTime, delta: cost)

        // Check for threshold crossings
        checkThresholdCrossings(from: previousTime, to: currentTime)
    }

    /// Check if current time has passed a threshold interval
    func checkThreshold(_ interval: Int) -> Bool {
        guard interval > 0 else { return false }
        return currentTime % interval == 0 && currentTime > 0
    }

    // MARK: - Private Methods

    private func checkThresholdCrossings(from previousTime: Int, to newTime: Int) {
        guard thresholdInterval > 0 else { return }

        // Find all threshold crossings in the range
        let previousThreshold = previousTime / thresholdInterval
        let newThreshold = newTime / thresholdInterval

        if newThreshold > previousThreshold {
            for threshold in (previousThreshold + 1)...newThreshold {
                let thresholdTime = threshold * thresholdInterval
                delegate?.onTimeThreshold(currentTime: newTime, threshold: thresholdTime)
            }
        }
    }

    // MARK: - Utility

    /// Reset time (for new game)
    func reset() {
        currentTime = 0
        triggeredThresholds.removeAll()
    }

    /// Set time directly (for save/load)
    func setTime(_ time: Int) {
        currentTime = max(0, time)
    }
}

// MARK: - Time Cost Constants

/// Standard time costs for common actions
enum StandardTimeCost: Int, TimedAction {
    case instant = 0
    case quick = 1
    case standard = 2
    case extended = 3
    case long = 4

    var timeCost: Int { rawValue }
}

// MARK: - TimedAction Extensions

/// Simple timed action wrapper
struct SimpleTimedAction: TimedAction {
    let timeCost: Int
    let actionId: String

    init(cost: Int, id: String = "") {
        self.timeCost = cost
        self.actionId = id
    }
}

/// Travel action with variable cost
struct TravelAction: TimedAction {
    let fromLocation: String
    let toLocation: String
    let isNeighbor: Bool

    var timeCost: Int {
        isNeighbor ? 1 : 2
    }
}

/// Rest action
struct RestAction: TimedAction {
    let timeCost: Int = 1
}

/// Exploration action
struct ExploreAction: TimedAction {
    let isInstant: Bool
    var timeCost: Int { isInstant ? 0 : 1 }
}


// ==========================================
// FILE: Engine/Core/TwilightGameAction.swift
// ==========================================

import Foundation

// MARK: - Twilight Marches Game Actions
// All player actions go through these - UI never mutates state directly

/// All possible player actions in Twilight Marches
enum TwilightGameAction: TimedAction, Equatable {
    // MARK: - Movement
    /// Travel to another region
    case travel(toRegionId: UUID)

    // MARK: - Region Actions
    /// Rest in current region (heals, costs time)
    case rest

    /// Explore current region (triggers events)
    case explore

    /// Trade at market (if available)
    case trade

    /// Strengthen anchor in current region
    case strengthenAnchor

    // MARK: - Event Handling
    /// Choose an option in an event
    case chooseEventOption(eventId: UUID, choiceIndex: Int)

    /// Resolve a mini-game result
    case resolveMiniGame(input: MiniGameInput)

    // MARK: - Combat Setup
    /// Start combat with encounter
    case startCombat(encounterId: UUID)

    /// Initialize combat: shuffle deck and draw initial hand
    case combatInitialize

    // MARK: - Combat Actions
    /// Perform basic attack in combat
    case combatAttack(bonusDice: Int, bonusDamage: Int, isFirstAttack: Bool)

    /// Play a card in combat
    case playCard(cardId: UUID, targetId: UUID?)

    /// Apply card ability effect
    case combatApplyEffect(effect: CombatActionEffect)

    /// End combat turn (goes to enemy phase)
    case endCombatTurn

    /// Perform enemy attack
    case combatEnemyAttack(damage: Int)

    /// End turn phase: discard hand, draw new cards, restore faith
    case combatEndTurnPhase

    /// Flee from combat
    case combatFlee

    /// Finish combat with result
    case combatFinish(victory: Bool)

    // MARK: - UI Actions
    /// Dismiss current event (after UI handles it)
    case dismissCurrentEvent

    /// Dismiss day event notification
    case dismissDayEvent

    // MARK: - Special
    /// Skip/pass turn
    case skipTurn

    /// Custom action for extensibility
    case custom(id: String, timeCost: Int)

    // MARK: - TimedAction Conformance

    var timeCost: Int {
        switch self {
        case .travel:
            // Travel cost determined by engine based on distance
            // Default to 1, actual cost calculated in engine
            return 1

        case .rest:
            return 1

        case .explore:
            return 1

        case .trade:
            return 0  // Trading doesn't cost time

        case .strengthenAnchor:
            return 1

        case .chooseEventOption:
            return 0  // Events are part of explore/travel

        case .resolveMiniGame:
            return 0  // Mini-game is part of event

        case .startCombat:
            return 0  // Combat is part of event

        case .combatInitialize:
            return 0  // Setup, no time cost

        case .combatAttack:
            return 0  // Within combat turn

        case .playCard:
            return 0  // Cards are within combat turn

        case .combatApplyEffect:
            return 0  // Effect application

        case .endCombatTurn:
            return 0  // Turn management

        case .combatEnemyAttack:
            return 0  // Enemy phase

        case .combatEndTurnPhase:
            return 0  // End of turn

        case .combatFlee:
            return 0  // Escape

        case .combatFinish:
            return 0  // Combat end

        case .dismissCurrentEvent:
            return 0  // UI action, no time cost

        case .dismissDayEvent:
            return 0  // UI action, no time cost

        case .skipTurn:
            return 1

        case .custom(_, let cost):
            return cost
        }
    }
}

// MARK: - Mini-Game Input

/// Input data for resolving a mini-game action
/// Different from MiniGameResult in MiniGameChallengeDefinition.swift (serializable state diff)
struct MiniGameInput: Equatable {
    let challengeId: UUID
    let success: Bool
    let score: Int?
    let bonusRewards: [String: Int]

    init(challengeId: UUID, success: Bool, score: Int? = nil, bonusRewards: [String: Int] = [:]) {
        self.challengeId = challengeId
        self.success = success
        self.score = score
        self.bonusRewards = bonusRewards
    }
}

// MARK: - Combat Effect

/// Effect to apply during combat (from cards or abilities)
enum CombatActionEffect: Equatable {
    /// Heal player
    case heal(amount: Int)

    /// Deal damage to enemy
    case damageEnemy(amount: Int)

    /// Draw cards
    case drawCards(count: Int)

    /// Gain faith
    case gainFaith(amount: Int)

    /// Spend faith
    case spendFaith(amount: Int)

    /// Take damage (sacrifice)
    case takeDamage(amount: Int)

    /// Remove curse
    case removeCurse(type: String?)

    /// Shift balance
    case shiftBalance(towards: String, amount: Int)

    /// Add bonus dice for next attack
    case addBonusDice(count: Int)

    /// Add bonus damage for next attack
    case addBonusDamage(amount: Int)

    /// Summon spirit to attack enemy
    case summonSpirit(power: Int, realm: String)
}

// MARK: - Action Result

/// Result of performing a game action
struct ActionResult: Equatable {
    /// Whether the action succeeded
    let success: Bool

    /// Error if action failed
    let error: ActionError?

    /// State changes that occurred
    let stateChanges: [StateChange]

    /// Events triggered by this action
    let triggeredEvents: [UUID]

    /// New current event (if any)
    let currentEvent: UUID?

    /// Combat started (if any)
    let combatStarted: Bool

    /// Game ended (if any)
    let gameEnded: GameEndResult?

    // MARK: - Convenience Initializers

    static func success(
        changes: [StateChange] = [],
        triggeredEvents: [UUID] = [],
        currentEvent: UUID? = nil,
        combatStarted: Bool = false
    ) -> ActionResult {
        ActionResult(
            success: true,
            error: nil,
            stateChanges: changes,
            triggeredEvents: triggeredEvents,
            currentEvent: currentEvent,
            combatStarted: combatStarted,
            gameEnded: nil
        )
    }

    static func failure(_ error: ActionError) -> ActionResult {
        ActionResult(
            success: false,
            error: error,
            stateChanges: [],
            triggeredEvents: [],
            currentEvent: nil,
            combatStarted: false,
            gameEnded: nil
        )
    }

    static func gameOver(_ result: GameEndResult) -> ActionResult {
        ActionResult(
            success: true,
            error: nil,
            stateChanges: [],
            triggeredEvents: [],
            currentEvent: nil,
            combatStarted: false,
            gameEnded: result
        )
    }
}

// MARK: - Action Error

/// Errors that can occur when performing actions
enum ActionError: Error, Equatable {
    // Validation errors
    case invalidAction(reason: String)
    case regionNotAccessible(regionId: UUID)
    case regionNotNeighbor(regionId: UUID)
    case actionNotAvailableInRegion(action: String, regionType: String)

    // Resource errors
    case insufficientResources(resource: String, required: Int, available: Int)
    case healthTooLow

    // State errors
    case gameNotInProgress
    case combatInProgress
    case eventInProgress
    case noActiveEvent
    case noActiveCombat

    // Event errors
    case eventNotFound(eventId: UUID)
    case invalidChoiceIndex(index: Int, maxIndex: Int)
    case choiceRequirementsNotMet(reason: String)

    // Combat errors
    case cardNotInHand(cardId: UUID)
    case notEnoughActions
    case invalidTarget

    var localizedDescription: String {
        switch self {
        case .invalidAction(let reason):
            return "Invalid action: \(reason)"
        case .regionNotAccessible(let id):
            return "Region \(id) is not accessible"
        case .regionNotNeighbor(let id):
            return "Region \(id) is not a neighbor"
        case .actionNotAvailableInRegion(let action, let type):
            return "\(action) not available in \(type) region"
        case .insufficientResources(let resource, let required, let available):
            return "Need \(required) \(resource), have \(available)"
        case .healthTooLow:
            return "Health too low for this action"
        case .gameNotInProgress:
            return "Game is not in progress"
        case .combatInProgress:
            return "Cannot perform this action during combat"
        case .eventInProgress:
            return "Must resolve current event first"
        case .noActiveEvent:
            return "No active event"
        case .noActiveCombat:
            return "No active combat"
        case .eventNotFound(let id):
            return "Event \(id) not found"
        case .invalidChoiceIndex(let index, let max):
            return "Choice \(index) invalid (max: \(max))"
        case .choiceRequirementsNotMet(let reason):
            return "Cannot choose: \(reason)"
        case .cardNotInHand(let id):
            return "Card \(id) not in hand"
        case .notEnoughActions:
            return "Not enough actions remaining"
        case .invalidTarget:
            return "Invalid target"
        }
    }
}

// MARK: - State Change

/// A single state change from an action
enum StateChange: Equatable {
    // Player changes
    case healthChanged(delta: Int, newValue: Int)
    case faithChanged(delta: Int, newValue: Int)
    case balanceChanged(delta: Int, newValue: Int)
    case strengthChanged(delta: Int, newValue: Int)

    // World changes
    case tensionChanged(delta: Int, newValue: Int)
    case dayAdvanced(newDay: Int)
    case regionChanged(regionId: UUID)
    case regionStateChanged(regionId: UUID, newState: String)
    case anchorIntegrityChanged(anchorId: UUID, delta: Int, newValue: Int)

    // Flags and progress
    case flagSet(key: String, value: Bool)
    case questProgressed(questId: String, newStage: Int)
    case eventCompleted(eventId: UUID)

    // Cards and deck
    case cardAdded(cardId: UUID, zone: String)
    case cardRemoved(cardId: UUID, zone: String)
    case cardMoved(cardId: UUID, fromZone: String, toZone: String)

    // Combat
    case enemyDamaged(enemyId: UUID, damage: Int, newHealth: Int)
    case enemyDefeated(enemyId: UUID)
    case combatEnded(victory: Bool)

    // Custom
    case custom(key: String, description: String)
}


// ==========================================
// FILE: Engine/Core/TwilightGameEngine.swift
// ==========================================

import Foundation
import Combine

// MARK: - Twilight Marches Game Engine
// The central game orchestrator - ALL game actions go through here

/// Main game engine for Twilight Marches
/// UI should NEVER mutate state directly - always go through performAction()
final class TwilightGameEngine: ObservableObject {

    // MARK: - Published State (for UI binding)
    // Audit v1.1 Issue #1, #8: UI reads directly from Engine, not WorldState

    @Published private(set) var currentDay: Int = 0
    @Published private(set) var worldTension: Int = 30
    @Published private(set) var currentRegionId: UUID?
    @Published private(set) var isGameOver: Bool = false
    @Published private(set) var gameResult: GameEndResult?

    @Published private(set) var currentEventId: UUID?
    @Published private(set) var isInCombat: Bool = false

    @Published private(set) var lastActionResult: ActionResult?

    // MARK: - Published State for UI (Engine-First Architecture)

    /// All regions with their current state - UI reads this directly
    @Published private(set) var publishedRegions: [UUID: EngineRegionState] = [:]

    /// Player stats - UI reads these directly instead of Player model
    @Published private(set) var playerHealth: Int = 10
    @Published private(set) var playerMaxHealth: Int = 10
    @Published private(set) var playerFaith: Int = 3
    @Published private(set) var playerMaxFaith: Int = 10
    @Published private(set) var playerBalance: Int = 50
    @Published private(set) var playerName: String = "Герой"

    /// World flags - for quest/event conditions
    @Published private(set) var publishedWorldFlags: [String: Bool] = [:]

    /// Current event being displayed to player
    @Published private(set) var currentEvent: GameEvent?

    /// Day event notification (tension increase, degradation, etc.)
    @Published private(set) var lastDayEvent: DayEvent?

    /// Active quests
    @Published private(set) var publishedActiveQuests: [Quest] = []

    /// Event log (last 100 entries)
    @Published private(set) var publishedEventLog: [EventLogEntry] = []

    /// Light/Dark balance of the world
    @Published private(set) var lightDarkBalance: Int = 50

    /// Main quest stage (1-5)
    @Published private(set) var mainQuestStage: Int = 1

    // MARK: - UI Convenience Accessors (Engine-First Architecture)

    /// Get regions as sorted array for UI iteration
    var regionsArray: [EngineRegionState] {
        publishedRegions.values.sorted { $0.name < $1.name }
    }

    /// Get current region
    var currentRegion: EngineRegionState? {
        guard let id = currentRegionId else { return nil }
        return publishedRegions[id]
    }

    /// Check if player can afford faith cost
    func canAffordFaith(_ cost: Int) -> Bool {
        return playerFaith >= cost
    }

    /// Check if region is neighbor to current region
    func isNeighbor(regionId: UUID) -> Bool {
        guard let current = currentRegion else { return false }
        return current.neighborIds.contains(regionId)
    }

    /// Calculate travel cost to target region (1 = neighbor, 2 = distant)
    func calculateTravelCost(to targetId: UUID) -> Int {
        return isNeighbor(regionId: targetId) ? 1 : 2
    }

    /// Check if travel to region is allowed (only neighbors allowed)
    func canTravelTo(regionId: UUID) -> Bool {
        guard regionId != currentRegionId else { return false }
        return isNeighbor(regionId: regionId)
    }

    /// Get neighboring region names that connect to target (for routing hints)
    func getRoutingHint(to targetId: UUID) -> [String] {
        guard let current = currentRegion else { return [] }

        // If already neighbor, no hint needed
        if current.neighborIds.contains(targetId) { return [] }

        // Find which neighbors connect to target
        var connectingNeighbors: [String] = []
        for neighborId in current.neighborIds {
            guard let neighbor = regions[neighborId] else { continue }
            if neighbor.neighborIds.contains(targetId) {
                connectingNeighbors.append(neighbor.name)
            }
        }

        return connectingNeighbors
    }

    /// Player balance description for UI
    var playerBalanceDescription: String {
        switch playerBalance {
        case 70...100: return "Свет"
        case 31..<70: return "Равновесие"
        default: return "Тьма"
        }
    }

    /// World balance description
    var worldBalanceDescription: String {
        switch lightDarkBalance {
        case 70...100: return "Явь сильна"
        case 31..<70: return "Сумрак"
        default: return "Навь наступает"
        }
    }

    /// Check if region can rest
    func canRestInCurrentRegion() -> Bool {
        guard let region = currentRegion else { return false }
        return region.state == .stable
    }

    /// Check if region can trade
    func canTradeInCurrentRegion() -> Bool {
        guard let region = currentRegion else { return false }
        return region.canTrade
    }

    /// Check if exploration can find events in current region
    func hasAvailableEventsInCurrentRegion() -> Bool {
        guard let regionId = currentRegionId,
              let region = publishedRegions[regionId] else { return false }

        // Check via legacy adapter if available
        if let worldState = worldStateAdapter?.worldState,
           let legacyRegion = worldState.regions.first(where: { $0.id == regionId }) {
            let events = worldState.getAvailableEvents(for: legacyRegion)
            return !events.isEmpty
        }

        // Fallback: check content registry for events in this region type
        let events = contentRegistry.getAvailableEvents(
            forRegion: region.type.rawValue,
            pressure: worldTension
        )
        return !events.isEmpty
    }

    // MARK: - Core Subsystems

    private let timeEngine: TimeEngine
    private let pressureEngine: PressureEngine
    private let economyManager: EconomyManager

    // MARK: - State Adapters

    /// Adapter to sync with legacy WorldState (during migration)
    /// Engine owns these adapters (not weak to prevent immediate deallocation)
    private var worldStateAdapter: WorldStateEngineAdapter?

    /// Player adapter
    private var playerAdapter: PlayerEngineAdapter?

    // MARK: - Internal State

    private var regions: [UUID: EngineRegionState] = [:]
    private var completedEventIds: Set<UUID> = []
    private var worldFlags: [String: Bool] = [:]
    private var questStages: [String: Int] = [:]

    /// All events in the game (from ContentProvider)
    private var allEvents: [GameEvent] = []

    /// Active quests
    private var activeQuests: [Quest] = []

    /// Completed quest IDs
    private var completedQuestIds: Set<String> = []

    /// Event log
    private var eventLog: [EventLogEntry] = []

    /// Player deck (for save/load)
    private var playerDeck: [Card] = []
    /// Player's hand cards (Published for UI binding)
    @Published private(set) var playerHand: [Card] = []
    private var playerDiscard: [Card] = []

    // MARK: - Combat State

    /// Current enemy card in combat
    @Published private(set) var combatEnemy: Card?

    /// Enemy current health
    @Published private(set) var combatEnemyHealth: Int = 0

    /// Combat actions remaining this turn
    @Published private(set) var combatActionsRemaining: Int = 3

    /// Combat turn number
    @Published private(set) var combatTurnNumber: Int = 1

    /// Bonus dice for next attack (from cards)
    private var combatBonusDice: Int = 0

    /// Bonus damage for next attack (from cards)
    private var combatBonusDamage: Int = 0

    /// Is this the first attack in this combat (for abilities)
    private var combatIsFirstAttack: Bool = true

    // MARK: - Content Registry

    /// Content registry for loading content packs
    private let contentRegistry: ContentRegistry

    /// Balance configuration from content pack
    private var balanceConfig: BalanceConfiguration

    // MARK: - Configuration Constants (Legacy - migrate to balanceConfig)

    private var tensionTickInterval: Int { 3 }  // Could come from balanceConfig.pressure
    private var restHealAmount: Int { 3 }  // Could come from balanceConfig
    private var anchorStrengthenCost: Int { balanceConfig.anchor.strengthenCost }
    private var anchorStrengthenAmount: Int { balanceConfig.anchor.strengthenAmount }

    // MARK: - Initialization

    init(registry: ContentRegistry = .shared) {
        self.contentRegistry = registry
        self.balanceConfig = registry.getBalanceConfig() ?? .default
        self.timeEngine = TimeEngine(thresholdInterval: 3)
        self.pressureEngine = PressureEngine(rules: TwilightPressureRules())
        self.economyManager = EconomyManager()
    }

    // MARK: - Setup

    /// Connect to legacy WorldState for bidirectional sync
    func connectToLegacy(worldState: WorldState, player: Player) {
        // Reset critical game state flags when connecting (supports new game flow)
        resetGameState()

        self.worldStateAdapter = WorldStateEngineAdapter(worldState: worldState, engine: self)
        self.playerAdapter = PlayerEngineAdapter(player: player, engine: self)

        // Initial sync from legacy
        syncFromLegacy()
    }

    /// Reset critical game state flags (called when starting new game or loading save)
    func resetGameState() {
        isGameOver = false
        gameResult = nil
        currentEventId = nil
        currentEvent = nil
        lastDayEvent = nil
        isInCombat = false
        combatEnemy = nil
        combatEnemyHealth = 0
        combatTurnNumber = 0
    }

    /// Sync engine state from legacy models
    func syncFromLegacy() {
        guard let adapter = worldStateAdapter else { return }

        currentDay = adapter.worldState.daysPassed
        worldTension = adapter.worldState.worldTension
        currentRegionId = adapter.worldState.currentRegionId

        // Sync regions (both internal and published)
        var newRegions: [UUID: EngineRegionState] = [:]
        for region in adapter.worldState.regions {
            newRegions[region.id] = EngineRegionState(from: region)
        }
        regions = newRegions
        publishedRegions = newRegions  // Audit v1.1: publish for UI

        // Sync flags (both internal and published)
        worldFlags = adapter.worldState.worldFlags
        publishedWorldFlags = worldFlags  // Audit v1.1: publish for UI

        // Sync completed events from GameEvent.completed
        for event in adapter.worldState.allEvents where event.completed {
            completedEventIds.insert(event.id)
        }

        // Sync player stats (Audit v1.1: publish for UI)
        if let player = playerAdapter?.player {
            playerHealth = player.health
            playerMaxHealth = player.maxHealth
            playerFaith = player.faith
            playerBalance = player.balance
            playerHand = player.hand
        }

        // CRITICAL: Sync pressure engine state to prevent duplicate threshold events
        // PressureEngine tracks which thresholds have fired to avoid repeats
        // After load, we reconstruct this from the current pressure value
        pressureEngine.setPressure(worldTension)
        pressureEngine.syncTriggeredThresholdsFromPressure()

        // Sync additional state for Engine-First architecture
        lightDarkBalance = adapter.worldState.lightDarkBalance
        mainQuestStage = adapter.worldState.mainQuestStage
        allEvents = adapter.worldState.allEvents
        activeQuests = adapter.worldState.activeQuests
        eventLog = adapter.worldState.eventLog
        publishedActiveQuests = activeQuests
        publishedEventLog = eventLog
    }

    /// Sync player hand from legacy Player model
    /// Call this after modifying player.hand directly (e.g., in CombatView)
    func syncPlayerHand() {
        if let player = playerAdapter?.player {
            playerHand = player.hand
        }
    }

    // MARK: - Engine-First Initialization

    /// Initialize a new game without legacy WorldState
    /// This is the Engine-First way to start a game
    func initializeNewGame(playerName: String = "Герой") {
        // Reset state
        isGameOver = false
        gameResult = nil
        currentEventId = nil
        currentEvent = nil
        lastDayEvent = nil
        isInCombat = false

        // Load balance config from content registry
        balanceConfig = contentRegistry.getBalanceConfig() ?? .default

        // Setup player from balance config
        self.playerName = playerName
        playerHealth = balanceConfig.resources.startingHealth
        playerMaxHealth = balanceConfig.resources.maxHealth
        playerFaith = balanceConfig.resources.startingFaith
        playerMaxFaith = balanceConfig.resources.maxFaith
        playerBalance = 50

        // Setup world from balance config
        currentDay = 0
        worldTension = balanceConfig.pressure.startingPressure
        lightDarkBalance = 50
        mainQuestStage = 1
        worldFlags = [:]
        completedEventIds = []
        completedQuestIds = []
        eventLog = []

        // Load regions from ContentRegistry
        setupRegionsFromRegistry()

        // Load events
        allEvents = createInitialEvents()

        // Load quests and start main quest
        let initialQuests = createInitialQuests()
        if let mainQuest = initialQuests.first(where: { $0.questType == .main }) {
            activeQuests = [mainQuest]
        }

        // Setup pressure engine
        pressureEngine.setPressure(worldTension)
        pressureEngine.syncTriggeredThresholdsFromPressure()

        // Update all published state
        updatePublishedState()
    }

    /// Setup regions from ContentProvider
    private func setupRegionsFromProvider(_ provider: ContentProvider) {
        let regionDefs = provider.getAllRegionDefinitions()
        var newRegions: [UUID: EngineRegionState] = [:]
        var stringToUUID: [String: UUID] = [:]  // Map string IDs to UUIDs

        // Determine entry region from manifest (no hardcoded "village")
        let entryRegionId = contentRegistry.loadedPacks.values.first?.manifest.entryRegionId

        // First pass: create regions and map IDs
        for def in regionDefs {
            let regionUUID = UUID()
            stringToUUID[def.id] = regionUUID

            let anchor = createEngineAnchor(from: provider.getAnchorDefinition(forRegion: def.id))
            let regionType = mapRegionType(fromString: def.regionType)
            let regionState = mapRegionState(def.initialState)

            let engineRegion = EngineRegionState(
                id: regionUUID,
                name: def.title.localized,
                type: regionType,
                state: regionState,
                anchor: anchor,
                neighborIds: [],  // Will be set in second pass
                canTrade: regionState == .stable && regionType == .settlement
            )
            newRegions[regionUUID] = engineRegion

            // Set starting region from manifest entryRegionId
            if def.id == entryRegionId {
                currentRegionId = regionUUID
            }
        }

        // Second pass: resolve neighbor IDs
        for def in regionDefs {
            guard let regionUUID = stringToUUID[def.id],
                  var region = newRegions[regionUUID] else { continue }

            let neighborUUIDs = def.neighborIds.compactMap { stringToUUID[$0] }
            region = EngineRegionState(
                id: region.id,
                name: region.name,
                type: region.type,
                state: region.state,
                anchor: region.anchor,
                neighborIds: neighborUUIDs,
                canTrade: region.canTrade,
                visited: region.visited,
                reputation: region.reputation
            )
            newRegions[regionUUID] = region
        }

        regions = newRegions
        publishedRegions = newRegions
    }

    /// Setup regions from ContentRegistry (Engine-First architecture)
    private func setupRegionsFromRegistry() {
        let regionDefs = contentRegistry.getAllRegions()
        var newRegions: [UUID: EngineRegionState] = [:]
        var stringToUUID: [String: UUID] = [:]  // Map string IDs to UUIDs

        // Determine entry region from loaded pack manifest (no hardcoded fallback)
        let entryRegionId = contentRegistry.loadedPacks.values.first?.manifest.entryRegionId

        // First pass: create regions and map IDs
        for def in regionDefs {
            let regionUUID = UUID()
            stringToUUID[def.id] = regionUUID

            let anchor = contentRegistry.getAnchor(forRegion: def.id).map { anchorDef in
                EngineAnchorState(
                    id: UUID(),
                    name: anchorDef.title.localized,
                    integrity: anchorDef.initialIntegrity
                )
            }

            let regionType = mapRegionType(fromString: def.regionType)
            let regionState = mapRegionState(def.initialState)

            let engineRegion = EngineRegionState(
                id: regionUUID,
                name: def.title.localized,
                type: regionType,
                state: regionState,
                anchor: anchor,
                neighborIds: [],  // Will be set in second pass
                canTrade: regionState == .stable && regionType == .settlement
            )
            newRegions[regionUUID] = engineRegion

            // Set starting region
            if def.id == entryRegionId {
                currentRegionId = regionUUID
            }
        }

        // Second pass: resolve neighbor IDs
        for def in regionDefs {
            guard let regionUUID = stringToUUID[def.id],
                  var region = newRegions[regionUUID] else { continue }

            let neighborUUIDs = def.neighborIds.compactMap { stringToUUID[$0] }
            region = EngineRegionState(
                id: region.id,
                name: region.name,
                type: region.type,
                state: region.state,
                anchor: region.anchor,
                neighborIds: neighborUUIDs,
                canTrade: region.canTrade,
                visited: region.visited,
                reputation: region.reputation
            )
            newRegions[regionUUID] = region
        }

        regions = newRegions
        publishedRegions = newRegions

        // Set first region as current if none set
        if currentRegionId == nil {
            currentRegionId = newRegions.keys.first
        }
    }

    /// Create EngineAnchorState from AnchorDefinition
    private func createEngineAnchor(from def: AnchorDefinition?) -> EngineAnchorState? {
        guard let def = def else { return nil }
        return EngineAnchorState(
            id: UUID(),
            name: TwilightMarchesCodeContentProvider.anchorName(for: def.id),
            integrity: def.initialIntegrity
        )
    }

    /// Resolve neighbor region IDs from string IDs to UUIDs
    private func resolveNeighborIds(_ neighborStringIds: [String], from defs: [RegionDefinition]) -> [UUID] {
        // This would need to be implemented properly with a mapping
        // For now, return empty - neighbors will be set up separately
        return []
    }

    /// Map region type string from ContentPack to RegionType enum
    /// The type comes from JSON/manifest, not hardcoded IDs
    private func mapRegionType(fromString typeString: String) -> RegionType {
        switch typeString.lowercased() {
        case "settlement": return .settlement
        case "forest": return .forest
        case "swamp": return .swamp
        case "wasteland": return .wasteland
        case "sacred": return .sacred
        case "mountain": return .mountain
        case "water": return .water
        default: return .forest
        }
    }

    /// Map RegionStateType to RegionState
    private func mapRegionState(_ stateType: RegionStateType) -> RegionState {
        switch stateType {
        case .stable: return .stable
        case .borderland: return .borderland
        case .breach: return .breach
        }
    }

    /// Create initial events (simplified - would load from ContentProvider)
    private func createInitialEvents() -> [GameEvent] {
        // Phase 5: Load from ContentProvider/JSON
        return []
    }

    /// Create initial quests (simplified - would load from ContentProvider)
    private func createInitialQuests() -> [Quest] {
        // Phase 5: Load from ContentProvider/JSON
        return []
    }

    // MARK: - Main Action Entry Point

    /// Perform a game action - THE ONLY WAY to change game state
    /// Returns result with all state changes
    @discardableResult
    func performAction(_ action: TwilightGameAction) -> ActionResult {
        // 0. Pre-validation
        guard !isGameOver else {
            return .failure(.gameNotInProgress)
        }

        // 1. Validate action
        let validationResult = validateAction(action)
        if let error = validationResult {
            return .failure(error)
        }

        // 2. Calculate actual time cost
        let timeCost = calculateTimeCost(for: action)

        // 3. Execute action and collect state changes
        var stateChanges: [StateChange] = []
        var triggeredEvents: [UUID] = []
        var newCurrentEvent: UUID? = nil
        var combatStarted = false

        // 4. Advance time (if action costs time)
        if timeCost > 0 {
            let timeChanges = advanceTime(by: timeCost)
            stateChanges.append(contentsOf: timeChanges)
        }

        // 5. Execute action-specific logic
        switch action {
        case .travel(let toRegionId):
            let (changes, events) = executeTravel(to: toRegionId)
            stateChanges.append(contentsOf: changes)
            triggeredEvents.append(contentsOf: events)
            if let event = events.first {
                newCurrentEvent = event
            }

        case .rest:
            let changes = executeRest()
            stateChanges.append(contentsOf: changes)

        case .explore:
            let (changes, events) = executeExplore()
            stateChanges.append(contentsOf: changes)
            triggeredEvents.append(contentsOf: events)
            if let event = events.first {
                newCurrentEvent = event
            }

        case .trade:
            // Trade handled by UI directly for now (market system)
            break

        case .strengthenAnchor:
            let changes = executeStrengthenAnchor()
            stateChanges.append(contentsOf: changes)

        case .chooseEventOption(let eventId, let choiceIndex):
            let changes = executeEventChoice(eventId: eventId, choiceIndex: choiceIndex)
            stateChanges.append(contentsOf: changes)
            currentEventId = nil

        case .resolveMiniGame(let input):
            let changes = executeMiniGameInput(input)
            stateChanges.append(contentsOf: changes)

        case .startCombat:
            combatStarted = true
            isInCombat = true
            combatTurnNumber = 1
            combatActionsRemaining = 3
            combatBonusDice = 0
            combatBonusDamage = 0
            combatIsFirstAttack = true
            // Enemy setup done when combat view appears

        case .combatInitialize:
            // Shuffle deck and draw initial hand
            if let player = playerAdapter?.player {
                player.shuffleDeck()
                player.drawCards(count: player.maxHandSize)
                playerHand = player.hand
            }
            combatActionsRemaining = 3

        case .combatAttack(let bonusDice, let bonusDamage, let isFirstAttack):
            guard combatActionsRemaining > 0 else { break }
            combatActionsRemaining -= 1
            let changes = executeCombatAttack(bonusDice: bonusDice, bonusDamage: bonusDamage, isFirstAttack: isFirstAttack)
            stateChanges.append(contentsOf: changes)
            combatIsFirstAttack = false
            // Check if enemy defeated
            if combatEnemyHealth <= 0 {
                // Victory will be handled by combatFinish
            }

        case .playCard(let cardId, _):
            guard combatActionsRemaining > 0 else { break }
            if let player = playerAdapter?.player,
               let cardIndex = player.hand.firstIndex(where: { $0.id == cardId }) {
                let card = player.hand[cardIndex]
                // Check faith cost
                if let cost = card.cost, cost > 0 {
                    guard player.faith >= cost else { break }
                    _ = player.spendFaith(cost)
                    playerFaith = player.faith
                    stateChanges.append(.faithChanged(delta: -cost, newValue: playerFaith))
                }
                combatActionsRemaining -= 1
                player.playCard(card)
                playerHand = player.hand
            }

        case .combatApplyEffect(let effect):
            let changes = executeCombatEffect(effect)
            stateChanges.append(contentsOf: changes)

        case .endCombatTurn:
            // Player ended their turn, enemy attacks next
            break

        case .combatEnemyAttack(let damage):
            // Enemy deals damage to player
            if let player = playerAdapter?.player {
                let healthBefore = player.health
                player.takeDamageWithCurses(damage)
                let actualDamage = healthBefore - player.health
                playerHealth = player.health
                stateChanges.append(.healthChanged(delta: -actualDamage, newValue: playerHealth))
            }

        case .combatEndTurnPhase:
            // End of turn: discard hand, draw new cards, restore faith
            if let player = playerAdapter?.player {
                // Discard hand
                while !player.hand.isEmpty {
                    player.playCard(player.hand[0])
                }
                // Draw new hand
                player.drawCards(count: player.maxHandSize)
                playerHand = player.hand
                // Restore faith
                player.gainFaith(1)
                playerFaith = player.faith
                stateChanges.append(.faithChanged(delta: 1, newValue: playerFaith))
                // Ability: extra faith at end of turn
                if player.shouldGainFaithEndOfTurn {
                    player.gainFaith(1)
                    playerFaith = player.faith
                    stateChanges.append(.faithChanged(delta: 1, newValue: playerFaith))
                }
            }
            // Reset for next turn
            combatTurnNumber += 1
            combatActionsRemaining = 3
            combatBonusDice = 0
            combatBonusDamage = 0

        case .combatFlee:
            isInCombat = false
            combatEnemy = nil
            stateChanges.append(.combatEnded(victory: false))

        case .combatFinish(let victory):
            isInCombat = false
            combatEnemy = nil
            stateChanges.append(.combatEnded(victory: victory))
            if victory {
                stateChanges.append(.enemyDefeated(enemyId: UUID()))
            }

        case .dismissCurrentEvent:
            currentEvent = nil
            currentEventId = nil

        case .dismissDayEvent:
            lastDayEvent = nil

        case .skipTurn:
            // Just time passes
            break

        case .custom:
            // Custom action handling
            break
        }

        // 6. Check quest progress
        let questChanges = checkQuestProgress()
        stateChanges.append(contentsOf: questChanges)

        // 7. Check end conditions
        if let endResult = checkEndConditions() {
            isGameOver = true
            gameResult = endResult
            return .gameOver(endResult)
        }

        // 8. Sync to legacy (during migration period)
        syncToLegacy(changes: stateChanges)

        // 9. Update published state for UI (Audit v1.1)
        updatePublishedState()

        // 10. Build and return result
        let result = ActionResult(
            success: true,
            error: nil,
            stateChanges: stateChanges,
            triggeredEvents: triggeredEvents,
            currentEvent: newCurrentEvent,
            combatStarted: combatStarted,
            gameEnded: nil
        )

        lastActionResult = result
        return result
    }

    // MARK: - Validation

    private func validateAction(_ action: TwilightGameAction) -> ActionError? {
        switch action {
        case .travel(let toRegionId):
            return validateTravel(to: toRegionId)

        case .rest:
            return validateRest()

        case .explore:
            if isInCombat { return .combatInProgress }
            return nil

        case .trade:
            return validateTrade()

        case .strengthenAnchor:
            return validateStrengthenAnchor()

        case .chooseEventOption(let eventId, let choiceIndex):
            return validateEventChoice(eventId: eventId, choiceIndex: choiceIndex)

        case .startCombat:
            if isInCombat { return .combatInProgress }
            return nil

        case .playCard, .endCombatTurn:
            if !isInCombat { return .noActiveCombat }
            return nil

        default:
            return nil
        }
    }

    private func validateTravel(to regionId: UUID) -> ActionError? {
        guard let currentId = currentRegionId,
              let currentRegion = regions[currentId] else {
            return .invalidAction(reason: "No current region")
        }

        // Check if target is neighbor
        if !currentRegion.neighborIds.contains(regionId) {
            return .regionNotNeighbor(regionId: regionId)
        }

        // Check if player can travel (health > 0, etc.)
        if let player = playerAdapter?.player, player.health <= 0 {
            return .healthTooLow
        }

        return nil
    }

    private func validateRest() -> ActionError? {
        guard let currentId = currentRegionId,
              let region = regions[currentId] else {
            return .invalidAction(reason: "No current region")
        }

        // Check if region allows rest
        if region.state == .breach {
            return .actionNotAvailableInRegion(action: "rest", regionType: "breach")
        }

        return nil
    }

    private func validateTrade() -> ActionError? {
        guard let currentId = currentRegionId,
              let region = regions[currentId] else {
            return .invalidAction(reason: "No current region")
        }

        if !region.canTrade {
            return .actionNotAvailableInRegion(action: "trade", regionType: region.type.rawValue)
        }

        return nil
    }

    private func validateStrengthenAnchor() -> ActionError? {
        guard let currentId = currentRegionId,
              let region = regions[currentId] else {
            return .invalidAction(reason: "No current region")
        }

        if region.anchor == nil {
            return .actionNotAvailableInRegion(action: "strengthen anchor", regionType: "no anchor")
        }

        // Check resource cost
        let cost = anchorStrengthenCost
        if let player = playerAdapter?.player, player.faith < cost {
            return .insufficientResources(resource: "faith", required: cost, available: player.faith)
        }

        return nil
    }

    private func validateEventChoice(eventId: UUID, choiceIndex: Int) -> ActionError? {
        guard currentEventId == eventId else {
            return .eventNotFound(eventId: eventId)
        }

        // Additional choice validation would go here
        return nil
    }

    // MARK: - Time Cost Calculation

    private func calculateTimeCost(for action: TwilightGameAction) -> Int {
        switch action {
        case .travel(let toRegionId):
            guard let currentId = currentRegionId,
                  let currentRegion = regions[currentId] else {
                return 1
            }
            // Neighbor = 1 day, far = 2 days
            return currentRegion.neighborIds.contains(toRegionId) ? 1 : 2

        default:
            return action.timeCost
        }
    }

    // MARK: - Time Advancement

    private func advanceTime(by days: Int) -> [StateChange] {
        var changes: [StateChange] = []

        for _ in 0..<days {
            currentDay += 1
            changes.append(.dayAdvanced(newDay: currentDay))

            // Check tension tick (every 3 days)
            if currentDay > 0 && currentDay % tensionTickInterval == 0 {
                let tensionIncrease = calculateTensionIncrease()
                worldTension = min(100, worldTension + tensionIncrease)
                changes.append(.tensionChanged(delta: tensionIncrease, newValue: worldTension))

                // World degradation
                let degradationChanges = processWorldDegradation()
                changes.append(contentsOf: degradationChanges)
            }
        }

        return changes
    }

    private func calculateTensionIncrease() -> Int {
        // Use TwilightPressureRules as single source of truth (Audit v1.1 Issue #6)
        return TwilightPressureRules.calculateTensionIncrease(daysPassed: currentDay)
    }

    private func processWorldDegradation() -> [StateChange] {
        var changes: [StateChange] = []

        // Degradation probability increases with world tension
        // (probability logic can be used when implementing random degradation checks)

        // Select region to degrade based on weights
        let degradableRegions = regions.values.filter {
            $0.state == .borderland || $0.state == .breach
        }

        guard !degradableRegions.isEmpty else { return changes }

        // Weighted selection using WorldRNG
        let weights = degradableRegions.map { DegradationRules.current.selectionWeight(for: $0.state) }
        let totalWeight = weights.reduce(0, +)

        if totalWeight > 0 {
            let roll = WorldRNG.shared.nextInt(in: 0..<totalWeight)
            var cumulative = 0
            for (index, weight) in weights.enumerated() {
                cumulative += weight
                if roll < cumulative {
                    let region = Array(degradableRegions)[index]

                    // Check anchor resistance using probability
                    let anchorIntegrity = region.anchor?.integrity ?? 0
                    let resistProb = DegradationRules.current.resistanceProbability(anchorIntegrity: anchorIntegrity)
                    let resistRoll = Double(WorldRNG.shared.nextInt(in: 0..<100)) / 100.0

                    if resistRoll >= resistProb {
                        // Anchor failed to resist - degrade region
                        if var mutableRegion = regions[region.id] {
                            let newState = degradeState(mutableRegion.state)
                            mutableRegion.state = newState
                            regions[region.id] = mutableRegion
                            changes.append(.regionStateChanged(regionId: region.id, newState: newState.rawValue))
                        }
                    }
                    break
                }
            }
        }

        return changes
    }

    private func degradeState(_ state: RegionState) -> RegionState {
        switch state {
        case .stable: return .borderland
        case .borderland: return .breach
        case .breach: return .breach  // Can't degrade further
        }
    }

    // MARK: - Action Execution

    private func executeTravel(to regionId: UUID) -> ([StateChange], [UUID]) {
        var changes: [StateChange] = []
        let events: [UUID] = []

        // Update current region
        currentRegionId = regionId
        changes.append(.regionChanged(regionId: regionId))

        // Note: Events are NOT auto-generated on arrival.
        // Player must explicitly choose to Explore to trigger events.
        // This allows player to Rest, Trade, or Strengthen Anchor first.

        return (changes, events)
    }

    private func executeRest() -> [StateChange] {
        var changes: [StateChange] = []

        // Heal player
        if let player = playerAdapter?.player {
            let healAmount = restHealAmount
            let newHealth = min(player.maxHealth, player.health + healAmount)
            let delta = newHealth - player.health
            playerAdapter?.updateHealth(newHealth)
            changes.append(.healthChanged(delta: delta, newValue: newHealth))
        }

        return changes
    }

    private func executeExplore() -> ([StateChange], [UUID]) {
        let changes: [StateChange] = []
        var events: [UUID] = []

        guard let regionId = currentRegionId else {
            return (changes, events)
        }

        // Generate exploration event
        if let event = generateEvent(for: regionId, trigger: .exploration) {
            events.append(event)
            currentEventId = event
        }

        return (changes, events)
    }

    private func executeStrengthenAnchor() -> [StateChange] {
        var changes: [StateChange] = []

        guard let regionId = currentRegionId,
              var region = regions[regionId],
              var anchor = region.anchor else {
            return changes
        }

        // Spend faith
        let cost = anchorStrengthenCost
        if let player = playerAdapter?.player {
            let newFaith = player.faith - cost
            playerAdapter?.updateFaith(newFaith)
            changes.append(.faithChanged(delta: -cost, newValue: newFaith))
        }

        // Strengthen anchor
        let strengthAmount = anchorStrengthenAmount
        let newIntegrity = min(100, anchor.integrity + strengthAmount)
        let delta = newIntegrity - anchor.integrity
        anchor.integrity = newIntegrity
        region.anchor = anchor
        regions[regionId] = region

        changes.append(.anchorIntegrityChanged(anchorId: anchor.id, delta: delta, newValue: newIntegrity))

        return changes
    }

    private func executeEventChoice(eventId: UUID, choiceIndex: Int) -> [StateChange] {
        var changes: [StateChange] = []

        // Get event and choice consequences from adapter
        if let consequences = worldStateAdapter?.getEventConsequences(eventId: eventId, choiceIndex: choiceIndex) {
            // Apply consequences
            changes.append(contentsOf: applyConsequences(consequences))
        }

        // Mark event completed if oneTime
        completedEventIds.insert(eventId)
        changes.append(.eventCompleted(eventId: eventId))

        currentEventId = nil

        return changes
    }

    private func executeMiniGameInput(_ input: MiniGameInput) -> [StateChange] {
        var changes: [StateChange] = []

        // Apply bonus rewards
        for (resource, amount) in input.bonusRewards {
            switch resource {
            case "health":
                if let player = playerAdapter?.player {
                    let newHealth = min(player.maxHealth, player.health + amount)
                    playerAdapter?.updateHealth(newHealth)
                    changes.append(.healthChanged(delta: amount, newValue: newHealth))
                }
            case "faith":
                if let player = playerAdapter?.player {
                    let newFaith = player.faith + amount
                    playerAdapter?.updateFaith(newFaith)
                    changes.append(.faithChanged(delta: amount, newValue: newFaith))
                }
            default:
                break
            }
        }

        return changes
    }

    // MARK: - Consequences

    private func applyConsequences(_ consequences: EventConsequences) -> [StateChange] {
        var changes: [StateChange] = []

        if let player = playerAdapter?.player {
            // Health
            if let healthDelta = consequences.healthChange, healthDelta != 0 {
                let newHealth = max(0, min(player.maxHealth, player.health + healthDelta))
                playerAdapter?.updateHealth(newHealth)
                changes.append(.healthChanged(delta: healthDelta, newValue: newHealth))
            }

            // Faith
            if let faithDelta = consequences.faithChange, faithDelta != 0 {
                let newFaith = max(0, player.faith + faithDelta)
                playerAdapter?.updateFaith(newFaith)
                changes.append(.faithChanged(delta: faithDelta, newValue: newFaith))
            }

            // Balance
            if let balanceDelta = consequences.balanceChange, balanceDelta != 0 {
                let newBalance = max(0, min(100, player.balance + balanceDelta))
                playerAdapter?.updateBalance(newBalance)
                changes.append(.balanceChanged(delta: balanceDelta, newValue: newBalance))
            }
        }

        // Tension
        if let tensionDelta = consequences.tensionChange, tensionDelta != 0 {
            worldTension = max(0, min(100, worldTension + tensionDelta))
            changes.append(.tensionChanged(delta: tensionDelta, newValue: worldTension))
        }

        // Flags (setFlags is [String: Bool]?)
        if let flagsToSet = consequences.setFlags {
            for (flag, value) in flagsToSet {
                worldFlags[flag] = value
                changes.append(.flagSet(key: flag, value: value))
            }
        }

        return changes
    }

    // MARK: - Event Generation

    private func generateEvent(for regionId: UUID, trigger: EventTrigger) -> UUID? {
        // Delegate to WorldState adapter for now (uses existing event system)
        return worldStateAdapter?.generateEvent(for: regionId, trigger: trigger)
    }

    // MARK: - Quest Progress

    private func checkQuestProgress() -> [StateChange] {
        // Delegate to WorldState adapter
        return worldStateAdapter?.checkQuestProgress() ?? []
    }

    // MARK: - End Conditions

    private func checkEndConditions() -> GameEndResult? {
        // Defeat: tension 100%
        if worldTension >= 100 {
            return .defeat(reason: "Напряжение мира достигло максимума")
        }

        // Defeat: health 0
        if let player = playerAdapter?.player, player.health <= 0 {
            return .defeat(reason: "Герой погиб")
        }

        // Victory: main quest completed (check flags)
        if worldFlags["act1_completed"] == true {
            return .victory(endingId: "act1_standard")
        }

        return nil
    }

    // MARK: - Legacy Sync

    private func syncToLegacy(changes: [StateChange]) {
        worldStateAdapter?.applyChanges(changes)
        playerAdapter?.syncFromEngine()
    }

    // MARK: - Published State Update (Engine-First Architecture)

    /// Update all published properties from internal state
    /// Called after actions to keep UI in sync
    private func updatePublishedState() {
        // Update regions
        publishedRegions = regions

        // Update flags
        publishedWorldFlags = worldFlags

        // Update quests and log
        publishedActiveQuests = activeQuests
        publishedEventLog = Array(eventLog.suffix(100))

        // Update current event from ID (Bridge UUID to GameEvent object)
        if let eventId = currentEventId,
           let event = worldStateAdapter?.worldState.allEvents.first(where: { $0.id == eventId }) {
            currentEvent = event
        } else if currentEventId == nil {
            currentEvent = nil
        }

        // Update player stats from adapter (legacy mode)
        if let player = playerAdapter?.player {
            playerHealth = player.health
            playerMaxHealth = player.maxHealth
            playerFaith = player.faith
            playerBalance = player.balance
        }
        // In Engine-First mode, player stats are updated directly
    }

    // MARK: - Event Log

    /// Add entry to event log
    func addLogEntry(
        regionName: String,
        eventTitle: String,
        choiceMade: String,
        outcome: String,
        type: EventLogType
    ) {
        let entry = EventLogEntry(
            dayNumber: currentDay,
            regionName: regionName,
            eventTitle: eventTitle,
            choiceMade: choiceMade,
            outcome: outcome,
            type: type
        )
        eventLog.append(entry)

        // Trim log to 100 entries
        if eventLog.count > 100 {
            eventLog.removeFirst(eventLog.count - 100)
        }

        publishedEventLog = eventLog
    }

    // MARK: - Day Events

    /// Trigger day event (tension increase, degradation, etc.)
    private func triggerDayEvent(_ event: DayEvent) {
        lastDayEvent = event
    }

    // MARK: - Combat Helper Methods

    /// Execute a combat attack with bonus dice and damage
    private func executeCombatAttack(bonusDice: Int, bonusDamage: Int, isFirstAttack: Bool) -> [StateChange] {
        var changes: [StateChange] = []

        guard let enemy = combatEnemy,
              let player = playerAdapter?.player else {
            return changes
        }

        let monsterDef = enemy.defense ?? 10
        let monsterCurrentHP = combatEnemyHealth
        let monsterMaxHP = enemy.health ?? 10

        // Use CombatCalculator for attack calculation
        let result = CombatCalculator.calculatePlayerAttack(
            player: player,
            monsterDefense: monsterDef,
            monsterCurrentHP: monsterCurrentHP,
            monsterMaxHP: monsterMaxHP,
            bonusDice: bonusDice + combatBonusDice,
            bonusDamage: bonusDamage + combatBonusDamage,
            isFirstAttack: isFirstAttack
        )

        if result.isHit, let damageCalc = result.damageCalculation {
            let damage = damageCalc.total
            combatEnemyHealth = max(0, combatEnemyHealth - damage)
            changes.append(.enemyDamaged(enemyId: enemy.id, damage: damage, newHealth: combatEnemyHealth))
        }

        // Reset bonuses after attack
        combatBonusDice = 0
        combatBonusDamage = 0

        return changes
    }

    /// Execute a combat effect from card or ability
    private func executeCombatEffect(_ effect: CombatActionEffect) -> [StateChange] {
        var changes: [StateChange] = []

        switch effect {
        case .heal(let amount):
            if let player = playerAdapter?.player {
                let newHealth = min(player.maxHealth, player.health + amount)
                let delta = newHealth - player.health
                playerAdapter?.updateHealth(newHealth)
                playerHealth = newHealth
                changes.append(.healthChanged(delta: delta, newValue: newHealth))
            }

        case .damageEnemy(let amount):
            if let player = playerAdapter?.player, let enemy = combatEnemy {
                let actualDamage = player.calculateDamageDealt(amount)
                combatEnemyHealth = max(0, combatEnemyHealth - actualDamage)
                changes.append(.enemyDamaged(enemyId: enemy.id, damage: actualDamage, newHealth: combatEnemyHealth))
            }

        case .drawCards(let count):
            if let player = playerAdapter?.player {
                player.drawCards(count: count)
                playerHand = player.hand
            }

        case .gainFaith(let amount):
            if let player = playerAdapter?.player {
                player.gainFaith(amount)
                playerFaith = player.faith
                changes.append(.faithChanged(delta: amount, newValue: playerFaith))
            }

        case .spendFaith(let amount):
            if let player = playerAdapter?.player {
                _ = player.spendFaith(amount)
                playerFaith = player.faith
                changes.append(.faithChanged(delta: -amount, newValue: playerFaith))
            }

        case .takeDamage(let amount):
            if let player = playerAdapter?.player {
                let healthBefore = player.health
                player.takeDamage(amount)
                let actualDamage = healthBefore - player.health
                playerHealth = player.health
                changes.append(.healthChanged(delta: -actualDamage, newValue: playerHealth))
            }

        case .removeCurse(let type):
            if let player = playerAdapter?.player {
                // Convert String to CurseType
                let curseType: CurseType? = type.flatMap { CurseType(rawValue: $0) }
                player.removeCurse(type: curseType)
            }

        case .shiftBalance(let towards, let amount):
            if let player = playerAdapter?.player {
                let direction: CardBalance
                switch towards.lowercased() {
                case "light", "свет": direction = .light
                case "dark", "тьма": direction = .dark
                default: direction = .neutral
                }
                player.shiftBalance(towards: direction, amount: amount)
                playerBalance = player.balance
                changes.append(.balanceChanged(delta: amount, newValue: playerBalance))
            }

        case .addBonusDice(let count):
            combatBonusDice += count

        case .addBonusDamage(let amount):
            combatBonusDamage += amount

        case .summonSpirit(let power, _):
            // Spirit attacks enemy immediately
            if let enemy = combatEnemy {
                combatEnemyHealth = max(0, combatEnemyHealth - power)
                changes.append(.enemyDamaged(enemyId: enemy.id, damage: power, newHealth: combatEnemyHealth))
            }
        }

        return changes
    }

    // MARK: - Combat Setup Methods

    /// Setup enemy for combat
    func setupCombatEnemy(_ enemy: Card) {
        combatEnemy = enemy
        combatEnemyHealth = enemy.health ?? 10
        combatTurnNumber = 1
        combatActionsRemaining = 3
        combatBonusDice = 0
        combatBonusDamage = 0
        combatIsFirstAttack = true
        isInCombat = true
    }

    /// Get current combat state for UI
    var combatState: CombatState? {
        guard isInCombat, let enemy = combatEnemy else { return nil }
        return CombatState(
            enemy: enemy,
            enemyHealth: combatEnemyHealth,
            turnNumber: combatTurnNumber,
            actionsRemaining: combatActionsRemaining,
            bonusDice: combatBonusDice,
            bonusDamage: combatBonusDamage,
            isFirstAttack: combatIsFirstAttack,
            playerHand: playerAdapter?.player.hand ?? []
        )
    }

    /// Access to legacy player for UI compatibility
    var legacyPlayer: Player? {
        playerAdapter?.player
    }

    // MARK: - Save/Load Support Methods

    /// Get completed quest IDs for save
    func getCompletedQuestIds() -> Set<String> {
        return completedQuestIds
    }

    /// Get quest stages for save
    func getQuestStages() -> [String: Int] {
        return questStages
    }

    /// Get completed event IDs for save
    func getCompletedEventIds() -> Set<UUID> {
        return completedEventIds
    }

    /// Set regions from save
    func setRegions(_ newRegions: [UUID: EngineRegionState]) {
        regions = newRegions
        publishedRegions = newRegions
    }

    /// Set world flags from save
    func setWorldFlags(_ newFlags: [String: Bool]) {
        worldFlags = newFlags
        publishedWorldFlags = newFlags
    }

    /// Set completed event IDs from save
    func setCompletedEventIds(_ ids: Set<UUID>) {
        completedEventIds = ids
    }

    /// Set event log from save
    func setEventLog(_ log: [EventLogEntry]) {
        eventLog = log
        publishedEventLog = Array(log.suffix(100))
    }

    /// Set main quest stage from save
    func setMainQuestStage(_ stage: Int) {
        mainQuestStage = stage
    }

    /// Set completed quest IDs from save
    func setCompletedQuestIds(_ ids: Set<String>) {
        completedQuestIds = ids
    }

    /// Set quest stages from save
    func setQuestStages(_ stages: [String: Int]) {
        questStages = stages
    }

    /// Update published state after loading
    func updatePublishedStateAfterLoad() {
        updatePublishedState()
    }
}

// MARK: - Event Trigger

enum EventTrigger {
    case arrival
    case exploration
    case combat
    case quest
    case time
}

// MARK: - Engine Region State (Bridge from Legacy)

/// Объединённое состояние региона для UI (Audit v1.1 Issue #9)
///
/// Это ПРЕДПОЧТИТЕЛЬНАЯ модель для UI:
/// - Создаётся из legacy Region через TwilightGameEngine.syncFromLegacy()
/// - Публикуется через engine.publishedRegions
/// - UI должен использовать engine.regionsArray или engine.currentRegion
///
/// Архитектура моделей:
/// - `RegionDefinition` - статические данные (ContentProvider)
/// - `RegionRuntimeState` - изменяемое состояние (WorldRuntimeState)
/// - `EngineRegionState` - объединённое для UI (этот struct)
/// - `Region` (legacy) - persistence и совместимость
struct EngineRegionState: Identifiable {
    let id: UUID
    let name: String
    let type: RegionType
    var state: RegionState
    var anchor: EngineAnchorState?
    let neighborIds: [UUID]
    var canTrade: Bool
    var visited: Bool = false
    var reputation: Int = 0

    /// Create from legacy Region (for migration)
    init(from region: Region) {
        self.id = region.id
        self.name = region.name
        self.type = region.type
        self.state = region.state
        self.anchor = region.anchor.map { EngineAnchorState(from: $0) }
        self.neighborIds = region.neighborIds
        self.canTrade = region.canTrade
        self.visited = region.visited
        self.reputation = region.reputation
    }

    /// Create directly (Engine-First)
    init(
        id: UUID = UUID(),
        name: String,
        type: RegionType,
        state: RegionState,
        anchor: EngineAnchorState? = nil,
        neighborIds: [UUID] = [],
        canTrade: Bool = false,
        visited: Bool = false,
        reputation: Int = 0
    ) {
        self.id = id
        self.name = name
        self.type = type
        self.state = state
        self.anchor = anchor
        self.neighborIds = neighborIds
        self.canTrade = canTrade
        self.visited = visited
        self.reputation = reputation
    }

    /// Can rest in this region
    var canRest: Bool {
        state == .stable && (type == .settlement || type == .sacred)
    }
}

// MARK: - Engine Anchor State (Bridge from Legacy)

/// Internal state for engine anchor tracking (bridges from legacy Anchor model)
struct EngineAnchorState {
    let id: UUID
    let name: String
    var integrity: Int

    /// Create from legacy Anchor (for migration)
    init(from anchor: Anchor) {
        self.id = anchor.id
        self.name = anchor.name
        self.integrity = anchor.integrity
    }

    /// Create directly (Engine-First)
    init(id: UUID = UUID(), name: String, integrity: Int) {
        self.id = id
        self.name = name
        self.integrity = max(0, min(100, integrity))
    }
}

// MARK: - Combat State (for UI)

/// Read-only combat state for UI binding
struct CombatState {
    let enemy: Card
    let enemyHealth: Int
    let turnNumber: Int
    let actionsRemaining: Int
    let bonusDice: Int
    let bonusDamage: Int
    let isFirstAttack: Bool
    let playerHand: [Card]

    var enemyMaxHealth: Int {
        enemy.health ?? 10
    }

    var enemyDefense: Int {
        enemy.defense ?? 10
    }

    var enemyPower: Int {
        enemy.power ?? 3
    }
}


// ==========================================
// FILE: Engine/Combat/CombatCalculator.swift
// ==========================================

import Foundation

/// Результат атаки с полной разбивкой факторов
struct CombatResult {
    let isHit: Bool
    let attackRoll: AttackRoll
    let defenseValue: Int
    let damageCalculation: DamageCalculation?
    let specialEffects: [CombatEffect]

    /// Текстовое описание для лога
    var logDescription: String {
        var lines: [String] = []

        // Заголовок результата
        if isHit {
            lines.append("✅ ПОПАДАНИЕ!")
        } else {
            lines.append("❌ ПРОМАХ!")
        }

        // Бросок атаки
        lines.append("📊 Атака: \(attackRoll.total) vs Защита: \(defenseValue)")

        // Разбивка атаки
        var attackParts: [String] = []
        attackParts.append("Сила \(attackRoll.baseStrength)")

        if attackRoll.diceRolls.count == 1 {
            attackParts.append("🎲\(attackRoll.diceRolls[0])")
        } else {
            let diceStr = attackRoll.diceRolls.map { "🎲\($0)" }.joined(separator: "+")
            attackParts.append("(\(diceStr)=\(attackRoll.diceTotal))")
        }

        if attackRoll.bonusDice > 0 {
            attackParts.append("+\(attackRoll.bonusDice) бонус кубиков")
        }
        if attackRoll.bonusDamage > 0 {
            attackParts.append("+\(attackRoll.bonusDamage) бонус урона")
        }

        lines.append("   = \(attackParts.joined(separator: " + "))")

        // Модификаторы
        for effect in attackRoll.modifiers {
            lines.append("   \(effect.icon) \(effect.description): \(effect.value > 0 ? "+" : "")\(effect.value)")
        }

        // Расчёт урона (если попадание)
        if isHit, let damage = damageCalculation {
            lines.append("💥 Урон: \(damage.total)")
            lines.append("   Базовый: \(damage.base) (атака - защита + 2)")

            for modifier in damage.modifiers {
                lines.append("   \(modifier.icon) \(modifier.description): \(modifier.value > 0 ? "+" : "")\(modifier.value)")
            }
        }

        // Спецэффекты
        for effect in specialEffects {
            lines.append("\(effect.icon) \(effect.description)")
        }

        return lines.joined(separator: "\n")
    }
}

/// Бросок атаки
struct AttackRoll {
    let baseStrength: Int
    let diceRolls: [Int]
    let bonusDice: Int
    let bonusDamage: Int
    let modifiers: [CombatModifier]

    var diceTotal: Int {
        diceRolls.reduce(0, +)
    }

    var total: Int {
        baseStrength + diceTotal + bonusDamage + modifiers.reduce(0) { $0 + $1.value }
    }
}

/// Расчёт урона
struct DamageCalculation {
    let base: Int
    let modifiers: [CombatModifier]

    var total: Int {
        max(1, base + modifiers.reduce(0) { $0 + $1.value })
    }
}

/// Модификатор боя
struct CombatModifier {
    let source: ModifierSource
    let value: Int
    let description: String

    var icon: String {
        switch source {
        case .heroAbility: return "⭐"
        case .curse: return "💀"
        case .card: return "🃏"
        case .equipment: return "🛡️"
        case .buff: return "✨"
        case .debuff: return "⚡"
        case .spirit: return "👻"
        case .environment: return "🌍"
        }
    }
}

/// Источник модификатора
enum ModifierSource {
    case heroAbility
    case curse
    case card
    case equipment
    case buff
    case debuff
    case spirit
    case environment
}

/// Боевой эффект (события в бою)
struct CombatEffect {
    let icon: String
    let description: String
    let type: CombatEffectType
}

/// Тип боевого эффекта
enum CombatEffectType {
    case damage
    case heal
    case buff
    case debuff
    case summon
    case special
}

/// Калькулятор боя - вычисляет результат атаки с полной разбивкой
struct CombatCalculator {

    /// Рассчитать атаку игрока по монстру
    static func calculatePlayerAttack(
        player: Player,
        monsterDefense: Int,
        monsterCurrentHP: Int,
        monsterMaxHP: Int,
        bonusDice: Int,
        bonusDamage: Int,
        isFirstAttack: Bool
    ) -> CombatResult {

        var modifiers: [CombatModifier] = []
        var damageModifiers: [CombatModifier] = []
        let specialEffects: [CombatEffect] = []

        let isTargetFullHP = monsterCurrentHP == monsterMaxHP

        // Бросок кубиков
        var totalDice = 1 + bonusDice

        // Способность Следопыта: +1 кубик при первой атаке
        let rangerBonus = player.getHeroClassBonusDice(isFirstAttack: isFirstAttack)
        if rangerBonus > 0 {
            totalDice += rangerBonus
            modifiers.append(CombatModifier(
                source: .heroAbility,
                value: 0,  // Не добавляет к атаке напрямую, только кубик
                description: "Выслеживание (+\(rangerBonus) кубик)"
            ))
        }

        var diceRolls: [Int] = []
        for _ in 0..<totalDice {
            diceRolls.append(WorldRNG.shared.nextInt(in: 1...6))
        }

        // Создаём бросок атаки
        let attackRoll = AttackRoll(
            baseStrength: player.strength,
            diceRolls: diceRolls,
            bonusDice: bonusDice,
            bonusDamage: bonusDamage,
            modifiers: modifiers
        )

        let isHit = attackRoll.total >= monsterDefense

        var damageCalculation: DamageCalculation? = nil

        if isHit {
            let baseDamage = max(1, attackRoll.total - monsterDefense + 2)

            // Модификаторы урона от проклятий
            if player.hasCurse(.weakness) {
                damageModifiers.append(CombatModifier(
                    source: .curse,
                    value: -1,
                    description: "Слабость"
                ))
            }

            if player.hasCurse(.shadowOfNav) {
                damageModifiers.append(CombatModifier(
                    source: .curse,
                    value: +3,
                    description: "Тень Нави"
                ))
            }

            // Способность Воина: +2 при HP < 50%
            let warriorBonus = player.heroClass == .warrior && player.health < player.maxHealth / 2
            if warriorBonus {
                damageModifiers.append(CombatModifier(
                    source: .heroAbility,
                    value: +2,
                    description: "Ярость (HP < 50%)"
                ))
            }

            // Способность Тени: +3 по полным HP
            let shadowBonus = player.heroClass == .shadow && isTargetFullHP
            if shadowBonus {
                damageModifiers.append(CombatModifier(
                    source: .heroAbility,
                    value: +3,
                    description: "Засада (враг на полном HP)"
                ))
            }

            damageCalculation = DamageCalculation(
                base: baseDamage,
                modifiers: damageModifiers
            )
        }

        return CombatResult(
            isHit: isHit,
            attackRoll: attackRoll,
            defenseValue: monsterDefense,
            damageCalculation: damageCalculation,
            specialEffects: specialEffects
        )
    }
}


// ==========================================
// FILE: Engine/Config/DegradationRules.swift
// ==========================================

import Foundation

// MARK: - Degradation Rules
// Правила деградации регионов, вынесенные из WorldState в Engine Config
// Позволяет настраивать поведение деградации без изменения кода

/// Протокол правил деградации для разных конфигураций игры
protocol DegradationRuleSet {
    /// Вес региона для выбора кандидата на деградацию
    func selectionWeight(for regionState: RegionState) -> Int

    /// Вероятность сопротивления якоря (0.0 - 1.0)
    /// Возвращает вероятность того, что якорь сопротивляется деградации
    func resistanceProbability(anchorIntegrity: Int) -> Double

    /// Урон якорю при деградации
    var degradationAmount: Int { get }

    /// Минимальный Tension для запуска деградации
    var minimumTensionForDegradation: Int { get }
}

/// Правила деградации для "Сумрачных Пределов" (Twilight Marches)
struct TwilightDegradationRules: DegradationRuleSet {

    /// Веса выбора региона:
    /// - Stable (70-100%): 0 — не деградирует напрямую
    /// - Borderland (30-69%): 1 — умеренный приоритет
    /// - Breach (0-29%): 2 — высокий приоритет (уже слабые регионы ухудшаются быстрее)
    func selectionWeight(for regionState: RegionState) -> Int {
        switch regionState {
        case .stable:
            return 0
        case .borderland:
            return 1
        case .breach:
            return 2
        }
    }

    /// Вероятность сопротивления: чем выше integrity, тем больше шанс сопротивляться
    /// Формула: P(resist) = integrity / 100
    /// - integrity 100% → 100% сопротивление
    /// - integrity 50% → 50% сопротивление
    /// - integrity 0% → 0% сопротивление
    func resistanceProbability(anchorIntegrity: Int) -> Double {
        return Double(anchorIntegrity) / 100.0
    }

    /// Урон якорю при деградации: -20% integrity
    let degradationAmount: Int = 20

    /// Деградация происходит только при Tension >= 0 (всегда возможна)
    let minimumTensionForDegradation: Int = 0
}

// MARK: - Shared Instance

/// Глобальные правила деградации (по умолчанию TwilightDegradationRules)
enum DegradationRules {
    static var current: DegradationRuleSet = TwilightDegradationRules()

    /// Сбросить на дефолтные правила
    static func reset() {
        current = TwilightDegradationRules()
    }
}


// ==========================================
// FILE: Engine/Config/TwilightMarchesConfig.swift
// ==========================================

import Foundation

// MARK: - Twilight Marches Configuration
// Game-specific configuration for "Сумрачные Пределы" (Twilight Marches)
// This is the "cartridge" that configures the generic engine.

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - Resources
// ═══════════════════════════════════════════════════════════════════════════════

/// Resources used in Twilight Marches
enum TwilightResource: String, CaseIterable {
    case health
    case maxHealth
    case faith
    case maxFaith
    case balance  // 0 = Dark, 100 = Light

    var id: String { rawValue }

    /// Default starting values
    var defaultValue: Int {
        switch self {
        case .health: return 10
        case .maxHealth: return 10
        case .faith: return 3
        case .maxFaith: return 10
        case .balance: return 50
        }
    }
}

/// Build initial resources dictionary
func twilightInitialResources() -> [String: Int] {
    var resources: [String: Int] = [:]
    for resource in TwilightResource.allCases {
        resources[resource.id] = resource.defaultValue
    }
    return resources
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - Pressure Rules (WorldTension)
// ═══════════════════════════════════════════════════════════════════════════════

/// Twilight Marches pressure (WorldTension) rules
/// SINGLE SOURCE OF TRUTH for tension escalation formula (Audit v1.1 Issue #6)
struct TwilightPressureRules: PressureRuleSet {
    let maxPressure: Int = 100
    let initialPressure: Int = 30
    let escalationInterval: Int = 3  // Every 3 days
    let escalationAmount: Int = 3    // Base +3 tension (increased for balance)

    /// Thresholds and their effects
    var thresholds: [Int: [WorldEffect]] {
        return [
            50: [.regionDegradation(probability: 0.3)],
            75: [.regionDegradation(probability: 0.5), .globalEvent(eventId: "world_shift_warning")],
            90: [.regionDegradation(probability: 0.7), .anchorWeakening(amount: 10)]
        ]
    }

    /// Canonical escalation formula: base + (daysPassed / 10)
    /// - Day 1-9: +3
    /// - Day 10-19: +4
    /// - Day 20-29: +5
    /// Creates increasing urgency as game progresses
    func calculateEscalation(currentPressure: Int, currentTime: Int) -> Int {
        let escalationBonus = currentTime / 10
        return escalationAmount + escalationBonus
    }

    /// Static helper for use outside of PressureEngine context
    /// Both WorldState and TwilightGameEngine should use this
    static func calculateTensionIncrease(daysPassed: Int) -> Int {
        let base = 3  // escalationAmount
        let escalationBonus = daysPassed / 10
        return base + escalationBonus
    }

    func checkThresholds(pressure: Int) -> [WorldEffect] {
        var effects: [WorldEffect] = []

        for (threshold, thresholdEffects) in thresholds {
            if pressure >= threshold {
                effects.append(contentsOf: thresholdEffects)
            }
        }

        return effects
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - Region Configuration
// ═══════════════════════════════════════════════════════════════════════════════

/// Region states in Twilight Marches
enum TwilightRegionState: String, Codable, CaseIterable {
    case stable
    case borderland
    case breach

    /// Degradation weight (higher = degrades faster)
    var degradationWeight: Int {
        switch self {
        case .stable: return 0
        case .borderland: return 1
        case .breach: return 2
        }
    }

    /// Can player rest in this state?
    var canRest: Bool {
        self == .stable
    }

    /// Can player trade in this state?
    var canTrade: Bool {
        self == .stable
    }

    /// Combat modifier
    var combatModifier: Int {
        switch self {
        case .stable: return 0
        case .borderland: return 1
        case .breach: return 2
        }
    }

    /// Next degraded state
    var degraded: TwilightRegionState? {
        switch self {
        case .stable: return .borderland
        case .borderland: return .breach
        case .breach: return nil
        }
    }

    /// Previous improved state
    var improved: TwilightRegionState? {
        switch self {
        case .stable: return nil
        case .borderland: return .stable
        case .breach: return .borderland
        }
    }
}

/// Region type
enum TwilightRegionType: String, Codable, CaseIterable {
    case village
    case forest
    case fortress
    case swamp
    case ruins
    case sanctuary
    case cursedLand
}

/// Region definition (static data)
struct TwilightRegionDefinition: Codable {
    let id: String
    let name: String
    let type: TwilightRegionType
    let initialState: TwilightRegionState
    let neighborIds: [String]
    let hasAnchor: Bool
    let anchorName: String?

    /// Initial anchor integrity (if has anchor)
    var initialAnchorIntegrity: Int { hasAnchor ? 100 : 0 }
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - Curse Configuration
// ═══════════════════════════════════════════════════════════════════════════════

/// Curse types in Twilight Marches
enum TwilightCurseType: String, Codable, CaseIterable {
    case weakness
    case fear
    case exhaustion
    case greed
    case shadowOfNav
    case bloodCurse
    case sealOfNav
}

/// Curse definition (static data)
struct TwilightCurseDefinition {
    let type: TwilightCurseType
    let name: String
    let description: String
    let removalCost: Int
    let damageModifier: Int      // Modifier to damage dealt
    let damageTakenModifier: Int // Modifier to damage received
    let actionModifier: Int      // Modifier to actions per turn
    let specialEffect: String?   // ID of special effect

    static let definitions: [TwilightCurseType: TwilightCurseDefinition] = [
        .weakness: TwilightCurseDefinition(
            type: .weakness,
            name: "Слабость",
            description: "Уменьшает наносимый урон",
            removalCost: 2,
            damageModifier: -1,
            damageTakenModifier: 0,
            actionModifier: 0,
            specialEffect: nil
        ),
        .fear: TwilightCurseDefinition(
            type: .fear,
            name: "Страх",
            description: "Увеличивает получаемый урон",
            removalCost: 2,
            damageModifier: 0,
            damageTakenModifier: 1,
            actionModifier: 0,
            specialEffect: nil
        ),
        .exhaustion: TwilightCurseDefinition(
            type: .exhaustion,
            name: "Истощение",
            description: "Уменьшает количество действий",
            removalCost: 3,
            damageModifier: 0,
            damageTakenModifier: 0,
            actionModifier: -1,
            specialEffect: nil
        ),
        .greed: TwilightCurseDefinition(
            type: .greed,
            name: "Алчность",
            description: "Тянет к тьме",
            removalCost: 4,
            damageModifier: 0,
            damageTakenModifier: 0,
            actionModifier: 0,
            specialEffect: "balance_shift_dark"
        ),
        .shadowOfNav: TwilightCurseDefinition(
            type: .shadowOfNav,
            name: "Тень Нави",
            description: "Увеличивает урон, но сдвигает к тьме",
            removalCost: 5,
            damageModifier: 3,
            damageTakenModifier: 0,
            actionModifier: 0,
            specialEffect: "balance_shift_dark_on_combat"
        ),
        .bloodCurse: TwilightCurseDefinition(
            type: .bloodCurse,
            name: "Кровавое проклятие",
            description: "Лечит при убийстве, но сдвигает к тьме",
            removalCost: 6,
            damageModifier: 0,
            damageTakenModifier: 0,
            actionModifier: 0,
            specialEffect: "heal_on_kill_dark"
        ),
        .sealOfNav: TwilightCurseDefinition(
            type: .sealOfNav,
            name: "Печать Нави",
            description: "Блокирует Sustain карты",
            removalCost: 8,
            damageModifier: 0,
            damageTakenModifier: 0,
            actionModifier: 0,
            specialEffect: "block_sustain_cards"
        )
    ]

    static func get(_ type: TwilightCurseType) -> TwilightCurseDefinition? {
        return definitions[type]
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - Balance (Light/Dark) Configuration
// ═══════════════════════════════════════════════════════════════════════════════

/// Balance state classification
enum TwilightBalanceState: String {
    case light
    case neutral
    case dark

    static func classify(balance: Int) -> TwilightBalanceState {
        if balance >= 70 { return .light }
        if balance <= 30 { return .dark }
        return .neutral
    }
}

/// Balance thresholds
struct TwilightBalanceConfig {
    static let min = 0
    static let max = 100
    static let initial = 50
    static let lightThreshold = 70
    static let darkThreshold = 30
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - Combat Configuration
// ═══════════════════════════════════════════════════════════════════════════════

/// Combat configuration for Twilight Marches
struct TwilightCombatConfig {
    /// Dice type (e.g., d6)
    static let diceMax = 6

    /// Base damage bonus
    static let baseDamageBonus = 2

    /// Actions per combat turn
    static let actionsPerTurn = 3

    /// Cards drawn at turn start
    static let cardsDrawnPerTurn = 5

    /// Maximum hand size
    static let maxHandSize = 7

    /// Calculate damage: playerPower + diceRoll - enemyDefense + bonus
    static func calculateDamage(
        playerPower: Int,
        diceRoll: Int,
        enemyDefense: Int,
        curseModifier: Int,
        regionModifier: Int
    ) -> Int {
        let baseDamage = playerPower + diceRoll - enemyDefense + baseDamageBonus
        let modifiedDamage = baseDamage + curseModifier
        return max(1, modifiedDamage) // Minimum 1 damage
    }

    /// Roll dice (deterministic via WorldRNG)
    static func rollDice() -> Int {
        return WorldRNG.shared.nextInt(in: 1...diceMax)
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - Anchor Configuration
// ═══════════════════════════════════════════════════════════════════════════════

/// Anchor integrity thresholds
struct TwilightAnchorConfig {
    static let maxIntegrity = 100
    static let stableThreshold = 70   // Above = region stable
    static let breachThreshold = 30   // Below = region breach

    static let strengthenAmount = 20
    static let degradeAmount = 20

    /// Determine region state based on anchor integrity
    static func regionStateForIntegrity(_ integrity: Int) -> TwilightRegionState {
        if integrity >= stableThreshold { return .stable }
        if integrity > breachThreshold { return .borderland }
        return .breach
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - Time Configuration
// ═══════════════════════════════════════════════════════════════════════════════

/// Time-related configuration
struct TwilightTimeConfig {
    /// Days for tension increase
    static let tensionIncreaseInterval = 3

    /// Tension increase amount (increased from 2 to 3 for balance)
    static let tensionIncreaseAmount = 3

    /// Travel costs
    static let neighborTravelCost = 1
    static let distantTravelCost = 2

    /// Action costs
    static let restCost = 1
    static let strengthenAnchorCost = 1
    static let exploreCost = 1
    static let instantCost = 0
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - Victory/Defeat Conditions
// ═══════════════════════════════════════════════════════════════════════════════

/// Victory conditions for Twilight Marches
struct TwilightVictoryConfig {
    /// Main quest completion flag
    static let mainQuestCompleteFlag = "act5_completed"

    /// Main quest final stage
    static let mainQuestFinalStage = 5
}

/// Defeat conditions for Twilight Marches
struct TwilightDefeatConfig {
    /// Health defeat threshold
    static let healthDefeatThreshold = 0

    /// Tension defeat threshold
    static let tensionDefeatThreshold = 100

    /// Critical anchor destruction flag
    static let criticalAnchorDestroyedFlag = "critical_anchor_destroyed"
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - Factory
// ═══════════════════════════════════════════════════════════════════════════════

/// Factory for creating Twilight Marches game components
enum TwilightMarchesFactory {
    /// Create pressure rules
    static func createPressureRules() -> TwilightPressureRules {
        return TwilightPressureRules()
    }

    /// Create initial player resources
    static func createInitialResources() -> [String: Int] {
        return twilightInitialResources()
    }

    /// Create resource caps
    static func createResourceCaps() -> [String: Int] {
        return [
            TwilightResource.health.id: TwilightResource.maxHealth.defaultValue,
            TwilightResource.faith.id: TwilightResource.maxFaith.defaultValue,
            TwilightResource.balance.id: TwilightBalanceConfig.max
        ]
    }
}


// ==========================================
// FILE: Engine/Heroes/HeroAbility.swift
// ==========================================

import Foundation

/// Способность героя
/// Определяет уникальные действия и пассивные эффекты героя
struct HeroAbility: Codable, Equatable {
    /// Уникальный идентификатор способности
    let id: String

    /// Название способности
    let name: String

    /// Описание для UI
    let description: String

    /// Иконка (SF Symbol или emoji)
    let icon: String

    /// Тип способности
    let type: HeroAbilityType

    /// Триггер активации (для пассивных)
    let trigger: AbilityTrigger

    /// Условие активации
    let condition: AbilityCondition?

    /// Эффекты способности
    let effects: [HeroAbilityEffect]

    /// Кулдаун (в ходах, 0 = нет кулдауна)
    let cooldown: Int

    /// Стоимость активации (для активных способностей)
    let cost: AbilityCost?
}

/// Тип способности героя
enum HeroAbilityType: String, Codable {
    /// Пассивная - работает автоматически
    case passive

    /// Активная - требует ручной активации
    case active

    /// Реактивная - срабатывает в ответ на событие
    case reactive

    /// Ультимейт - мощная способность с долгим кулдауном
    case ultimate
}

/// Триггер активации способности
enum AbilityTrigger: String, Codable {
    /// Всегда активна
    case always

    /// В начале хода
    case turnStart

    /// В конце хода
    case turnEnd

    /// При атаке
    case onAttack

    /// При получении урона
    case onDamageReceived

    /// При нанесении урона
    case onDamageDealt

    /// При использовании карты
    case onCardPlayed

    /// При входе в бой
    case onCombatStart

    /// При выходе из боя
    case onCombatEnd

    /// При исследовании
    case onExplore

    /// Ручная активация
    case manual
}

/// Условие активации способности
struct AbilityCondition: Codable, Equatable {
    let type: AbilityConditionType
    let value: Int?
    let stringValue: String?

    init(type: AbilityConditionType, value: Int? = nil, stringValue: String? = nil) {
        self.type = type
        self.value = value
        self.stringValue = stringValue
    }
}

/// Тип условия
enum AbilityConditionType: String, Codable {
    /// HP ниже процента
    case hpBelowPercent

    /// HP выше процента
    case hpAbovePercent

    /// Цель на полном HP
    case targetFullHP

    /// Первая атака в бою
    case firstAttack

    /// Источник урона - тьма
    case damageSourceDark

    /// Источник урона - свет
    case damageSourceLight

    /// Есть определённое проклятие
    case hasCurse

    /// Баланс выше значения
    case balanceAbove

    /// Баланс ниже значения
    case balanceBelow

    /// Есть карта в руке
    case hasCardInHand
}

/// Эффект способности героя
struct HeroAbilityEffect: Codable, Equatable {
    let type: HeroAbilityEffectType
    let value: Int
    let description: String?

    init(type: HeroAbilityEffectType, value: Int, description: String? = nil) {
        self.type = type
        self.value = value
        self.description = description
    }
}

/// Тип эффекта способности
enum HeroAbilityEffectType: String, Codable {
    /// Бонус к урону
    case bonusDamage

    /// Снижение получаемого урона
    case damageReduction

    /// Дополнительный кубик атаки
    case bonusDice

    /// Восстановление HP
    case heal

    /// Восстановление веры
    case gainFaith

    /// Потеря веры
    case loseFaith

    /// Сдвиг баланса к Свету
    case shiftLight

    /// Сдвиг баланса к Тьме
    case shiftDark

    /// Взять карту
    case drawCard

    /// Сбросить карту
    case discardCard

    /// Применить проклятие к врагу
    case applyCurseToEnemy

    /// Снять проклятие с себя
    case removeCurse

    /// Бонус к защите
    case bonusDefense

    /// Вызов духа
    case summonSpirit

    /// Бонус к следующей атаке
    case bonusNextAttack

    /// Перебросить кубик
    case rerollDice
}

/// Стоимость активации способности
struct AbilityCost: Codable, Equatable {
    let type: AbilityCostType
    let value: Int
}

/// Тип стоимости
enum AbilityCostType: String, Codable {
    case health
    case faith
    case card
    case action
}

// MARK: - Предустановленные способности классов

extension HeroAbility {

    /// Ярость Воина: +2 урона при HP < 50%
    static let warriorRage = HeroAbility(
        id: "warrior_rage",
        name: "Ярость",
        description: "+2 к урону при HP ниже 50%",
        icon: "🔥",
        type: .passive,
        trigger: .onDamageDealt,
        condition: AbilityCondition(type: .hpBelowPercent, value: 50),
        effects: [HeroAbilityEffect(type: .bonusDamage, value: 2)],
        cooldown: 0,
        cost: nil
    )

    /// Медитация Мага: +1 вера в конце хода
    static let mageMeditation = HeroAbility(
        id: "mage_meditation",
        name: "Медитация",
        description: "+1 вера в конце каждого хода",
        icon: "🧘",
        type: .passive,
        trigger: .turnEnd,
        condition: nil,
        effects: [HeroAbilityEffect(type: .gainFaith, value: 1)],
        cooldown: 0,
        cost: nil
    )

    /// Выслеживание Следопыта: +1 кубик при первой атаке
    static let rangerTracking = HeroAbility(
        id: "ranger_tracking",
        name: "Выслеживание",
        description: "+1 кубик атаки при первой атаке в бою",
        icon: "🎯",
        type: .passive,
        trigger: .onAttack,
        condition: AbilityCondition(type: .firstAttack),
        effects: [HeroAbilityEffect(type: .bonusDice, value: 1)],
        cooldown: 0,
        cost: nil
    )

    /// Благословение Жреца: -1 урон от тёмных источников
    static let priestBlessing = HeroAbility(
        id: "priest_blessing",
        name: "Благословение",
        description: "-1 урон от тёмных источников",
        icon: "✨",
        type: .passive,
        trigger: .onDamageReceived,
        condition: AbilityCondition(type: .damageSourceDark),
        effects: [HeroAbilityEffect(type: .damageReduction, value: 1)],
        cooldown: 0,
        cost: nil
    )

    /// Засада Тени: +3 урона по целям с полным HP
    static let shadowAmbush = HeroAbility(
        id: "shadow_ambush",
        name: "Засада",
        description: "+3 урона по врагам с полным здоровьем",
        icon: "🗡️",
        type: .passive,
        trigger: .onDamageDealt,
        condition: AbilityCondition(type: .targetFullHP),
        effects: [HeroAbilityEffect(type: .bonusDamage, value: 3)],
        cooldown: 0,
        cost: nil
    )

    /// Получить способность по классу героя
    static func forHeroClass(_ heroClass: HeroClass) -> HeroAbility {
        switch heroClass {
        case .warrior: return .warriorRage
        case .mage: return .mageMeditation
        case .ranger: return .rangerTracking
        case .priest: return .priestBlessing
        case .shadow: return .shadowAmbush
        }
    }
}


// ==========================================
// FILE: Engine/Heroes/HeroClass.swift
// ==========================================

import Foundation

/// Класс героя определяет начальные характеристики и стиль игры
/// Документация: GAME_DESIGN_DOCUMENT.md
enum HeroClass: String, CaseIterable, Codable {
    case warrior = "Воин"           // Высокая сила, много HP
    case mage = "Маг"               // Высокий интеллект, много веры
    case ranger = "Следопыт"        // Высокая ловкость, сбалансирован
    case priest = "Жрец"            // Высокая мудрость, исцеление
    case shadow = "Тень"            // Скрытность, тёмная магия

    /// Описание класса для UI
    var description: String {
        switch self {
        case .warrior:
            return "Мастер ближнего боя. Высокая сила и живучесть."
        case .mage:
            return "Владеет магией. Сильные заклинания, но хрупок."
        case .ranger:
            return "Следопыт и охотник. Сбалансированные характеристики."
        case .priest:
            return "Служитель Света. Исцеление и защита от тьмы."
        case .shadow:
            return "Агент Нави. Тёмная магия и скрытность."
        }
    }

    /// Иконка класса
    var icon: String {
        switch self {
        case .warrior: return "⚔️"
        case .mage: return "🔮"
        case .ranger: return "🏹"
        case .priest: return "✝️"
        case .shadow: return "🗡️"
        }
    }

    /// Начальные характеристики
    var baseStats: HeroStats {
        switch self {
        case .warrior:
            return HeroStats(
                health: 12,
                maxHealth: 12,
                strength: 7,
                dexterity: 3,
                constitution: 5,
                intelligence: 1,
                wisdom: 2,
                charisma: 2,
                faith: 2,
                maxFaith: 8,
                startingBalance: 50
            )
        case .mage:
            return HeroStats(
                health: 7,
                maxHealth: 7,
                strength: 2,
                dexterity: 3,
                constitution: 2,
                intelligence: 7,
                wisdom: 4,
                charisma: 2,
                faith: 5,
                maxFaith: 15,
                startingBalance: 50
            )
        case .ranger:
            return HeroStats(
                health: 10,
                maxHealth: 10,
                strength: 4,
                dexterity: 6,
                constitution: 4,
                intelligence: 3,
                wisdom: 3,
                charisma: 2,
                faith: 3,
                maxFaith: 10,
                startingBalance: 50
            )
        case .priest:
            return HeroStats(
                health: 9,
                maxHealth: 9,
                strength: 3,
                dexterity: 2,
                constitution: 3,
                intelligence: 4,
                wisdom: 6,
                charisma: 4,
                faith: 5,
                maxFaith: 12,
                startingBalance: 70  // Склонен к Свету
            )
        case .shadow:
            return HeroStats(
                health: 8,
                maxHealth: 8,
                strength: 4,
                dexterity: 5,
                constitution: 3,
                intelligence: 5,
                wisdom: 2,
                charisma: 1,
                faith: 4,
                maxFaith: 10,
                startingBalance: 30  // Склонен к Тьме
            )
        }
    }

    /// Особая способность класса
    var specialAbility: String {
        switch self {
        case .warrior:
            return "Ярость: +2 к урону при HP ниже 50%"
        case .mage:
            return "Медитация: +1 вера в конце хода"
        case .ranger:
            return "Выслеживание: +1 кубик при первой атаке"
        case .priest:
            return "Благословение: -1 урон от тьмы"
        case .shadow:
            return "Засада: +3 урона по полным HP"
        }
    }

    /// Стартовая колода зависит от класса
    var startingDeckType: DeckPath {
        switch self {
        case .warrior: return .balance
        case .mage: return .balance
        case .ranger: return .balance
        case .priest: return .light
        case .shadow: return .dark
        }
    }
}

/// Структура с характеристиками героя
struct HeroStats: Codable {
    let health: Int
    let maxHealth: Int
    let strength: Int
    let dexterity: Int
    let constitution: Int
    let intelligence: Int
    let wisdom: Int
    let charisma: Int
    let faith: Int
    let maxFaith: Int
    let startingBalance: Int
}


// ==========================================
// FILE: Engine/Heroes/HeroDefinition.swift
// ==========================================

import Foundation

/// Протокол определения героя (Data Layer)
/// Описывает статические данные героя, которые не меняются во время игры
protocol HeroDefinition {
    /// Уникальный идентификатор
    var id: String { get }

    /// Локализованное имя
    var name: String { get }

    /// Класс героя
    var heroClass: HeroClass { get }

    /// Описание героя для UI
    var description: String { get }

    /// Иконка героя (SF Symbol или emoji)
    var icon: String { get }

    /// Базовые характеристики
    var baseStats: HeroStats { get }

    /// Особая способность героя
    var specialAbility: HeroAbility { get }

    /// Стартовая колода (ID карт)
    var startingDeckCardIDs: [String] { get }

    /// Доступность героя (для DLC/разблокировки)
    var availability: HeroAvailability { get }
}

/// Доступность героя
enum HeroAvailability: Codable, Equatable {
    case alwaysAvailable
    case requiresUnlock(condition: String)
    case dlc(packID: String)
}

/// Дефолтная реализация для базовых героев
struct StandardHeroDefinition: HeroDefinition, Codable {
    let id: String
    let name: String
    let heroClass: HeroClass
    let description: String
    let icon: String
    let baseStats: HeroStats
    let specialAbility: HeroAbility
    let startingDeckCardIDs: [String]
    let availability: HeroAvailability

    init(
        id: String,
        name: String,
        heroClass: HeroClass,
        description: String,
        icon: String,
        baseStats: HeroStats,
        specialAbility: HeroAbility,
        startingDeckCardIDs: [String] = [],
        availability: HeroAvailability = .alwaysAvailable
    ) {
        self.id = id
        self.name = name
        self.heroClass = heroClass
        self.description = description
        self.icon = icon
        self.baseStats = baseStats
        self.specialAbility = specialAbility
        self.startingDeckCardIDs = startingDeckCardIDs
        self.availability = availability
    }
}


// ==========================================
// FILE: Engine/Heroes/HeroRegistry.swift
// ==========================================

import Foundation

/// Реестр героев - централизованное хранилище всех определений героев
/// Позволяет легко добавлять, удалять и модифицировать героев
/// без изменения основного кода игры
final class HeroRegistry {

    // MARK: - Singleton

    static let shared = HeroRegistry()

    // MARK: - Storage

    /// Зарегистрированные определения героев
    private var definitions: [String: HeroDefinition] = [:]

    /// Порядок отображения героев в UI
    private var displayOrder: [String] = []

    /// Источники данных героев (для модульности)
    private var dataSources: [HeroDataSource] = []

    // MARK: - Init

    private init() {
        registerBuiltInHeroes()
    }

    // MARK: - Registration

    /// Зарегистрировать определение героя
    func register(_ definition: HeroDefinition) {
        definitions[definition.id] = definition
        if !displayOrder.contains(definition.id) {
            displayOrder.append(definition.id)
        }
    }

    /// Зарегистрировать несколько героев
    func registerAll(_ definitions: [HeroDefinition]) {
        for definition in definitions {
            register(definition)
        }
    }

    /// Удалить героя из реестра
    func unregister(id: String) {
        definitions.removeValue(forKey: id)
        displayOrder.removeAll { $0 == id }
    }

    /// Очистить реестр
    func clear() {
        definitions.removeAll()
        displayOrder.removeAll()
    }

    /// Перезагрузить реестр из источников данных
    func reload() {
        clear()
        registerBuiltInHeroes()
        for source in dataSources {
            registerAll(source.loadHeroes())
        }
    }

    // MARK: - Data Sources

    /// Добавить источник данных героев
    func addDataSource(_ source: HeroDataSource) {
        dataSources.append(source)
        registerAll(source.loadHeroes())
    }

    /// Удалить источник данных
    func removeDataSource(_ source: HeroDataSource) {
        if let index = dataSources.firstIndex(where: { $0.id == source.id }) {
            let source = dataSources.remove(at: index)
            for hero in source.loadHeroes() {
                unregister(id: hero.id)
            }
        }
    }

    // MARK: - Queries

    /// Получить героя по ID
    func hero(id: String) -> HeroDefinition? {
        return definitions[id]
    }

    /// Получить героя по классу
    func hero(forClass heroClass: HeroClass) -> HeroDefinition? {
        return definitions.values.first { $0.heroClass == heroClass }
    }

    /// Все доступные герои
    var allHeroes: [HeroDefinition] {
        return displayOrder.compactMap { definitions[$0] }
    }

    /// Доступные герои (не заблокированные)
    func availableHeroes(unlockedConditions: Set<String> = [], ownedDLCs: Set<String> = []) -> [HeroDefinition] {
        return allHeroes.filter { hero in
            switch hero.availability {
            case .alwaysAvailable:
                return true
            case .requiresUnlock(let condition):
                return unlockedConditions.contains(condition)
            case .dlc(let packID):
                return ownedDLCs.contains(packID)
            }
        }
    }

    /// Герои определённого класса
    func heroes(ofClass heroClass: HeroClass) -> [HeroDefinition] {
        return allHeroes.filter { $0.heroClass == heroClass }
    }

    /// Количество зарегистрированных героев
    var count: Int {
        return definitions.count
    }

    // MARK: - Built-in Heroes

    /// Регистрация встроенных героев
    private func registerBuiltInHeroes() {
        // Воин - Рагнар
        register(StandardHeroDefinition(
            id: "warrior_ragnar",
            name: "Рагнар",
            heroClass: .warrior,
            description: "Бывший командир королевской гвардии. Его ярость в бою легендарна.",
            icon: "⚔️",
            baseStats: HeroClass.warrior.baseStats,
            specialAbility: .warriorRage,
            startingDeckCardIDs: ["strike_basic", "strike_basic", "defend_basic", "rage_strike"],
            availability: .alwaysAvailable
        ))

        // Маг - Эльвира
        register(StandardHeroDefinition(
            id: "mage_elvira",
            name: "Эльвира",
            heroClass: .mage,
            description: "Мастер арканных искусств. Черпает силу из обоих источников.",
            icon: "🔮",
            baseStats: HeroClass.mage.baseStats,
            specialAbility: .mageMeditation,
            startingDeckCardIDs: ["arcane_bolt", "arcane_bolt", "shield_spell", "meditation"],
            availability: .alwaysAvailable
        ))

        // Следопыт - Торин
        register(StandardHeroDefinition(
            id: "ranger_thorin",
            name: "Торин",
            heroClass: .ranger,
            description: "Охотник на чудовищ из северных лесов. Никогда не промахивается.",
            icon: "🏹",
            baseStats: HeroClass.ranger.baseStats,
            specialAbility: .rangerTracking,
            startingDeckCardIDs: ["precise_shot", "precise_shot", "trap", "tracking"],
            availability: .alwaysAvailable
        ))

        // Жрец - Аврелий
        register(StandardHeroDefinition(
            id: "priest_aurelius",
            name: "Аврелий",
            heroClass: .priest,
            description: "Преданный служитель Света. Его благословения защищают союзников.",
            icon: "✝️",
            baseStats: HeroClass.priest.baseStats,
            specialAbility: .priestBlessing,
            startingDeckCardIDs: ["holy_light", "holy_light", "blessing", "smite"],
            availability: .alwaysAvailable
        ))

        // Тень - Умбра
        register(StandardHeroDefinition(
            id: "shadow_umbra",
            name: "Умбра",
            heroClass: .shadow,
            description: "Агент Нави. Наносит удар из тени, когда враг не ожидает.",
            icon: "🗡️",
            baseStats: HeroClass.shadow.baseStats,
            specialAbility: .shadowAmbush,
            startingDeckCardIDs: ["backstab", "backstab", "shadow_step", "poison_blade"],
            availability: .alwaysAvailable
        ))
    }
}

// MARK: - Hero Data Source Protocol

/// Протокол источника данных героев
/// Позволяет загружать героев из разных источников (JSON, сервер, DLC)
protocol HeroDataSource {
    /// Уникальный идентификатор источника
    var id: String { get }

    /// Название источника (для отладки)
    var name: String { get }

    /// Загрузить героев из источника
    func loadHeroes() -> [HeroDefinition]
}

// MARK: - JSON Data Source

/// Загрузчик героев из JSON файла
struct JSONHeroDataSource: HeroDataSource {
    let id: String
    let name: String
    let fileURL: URL

    func loadHeroes() -> [HeroDefinition] {
        guard let data = try? Data(contentsOf: fileURL) else {
            print("HeroRegistry: Failed to load JSON from \(fileURL)")
            return []
        }

        do {
            let decoded = try JSONDecoder().decode([JSONHeroDefinition].self, from: data)
            return decoded.map { $0.toStandard() }
        } catch {
            print("HeroRegistry: Failed to decode heroes: \(error)")
            return []
        }
    }
}

/// JSON-совместимое определение героя
struct JSONHeroDefinition: Codable {
    let id: String
    let name: String
    let heroClass: HeroClass
    let description: String
    let icon: String
    let startingDeckCardIDs: [String]
    let availability: HeroAvailability?

    func toStandard() -> StandardHeroDefinition {
        return StandardHeroDefinition(
            id: id,
            name: name,
            heroClass: heroClass,
            description: description,
            icon: icon,
            baseStats: heroClass.baseStats,
            specialAbility: .forHeroClass(heroClass),
            startingDeckCardIDs: startingDeckCardIDs,
            availability: availability ?? .alwaysAvailable
        )
    }
}

// MARK: - DLC Data Source

/// Источник героев из DLC пакета
struct DLCHeroDataSource: HeroDataSource {
    let id: String
    let name: String
    let packID: String
    let heroes: [HeroDefinition]

    func loadHeroes() -> [HeroDefinition] {
        return heroes
    }
}


// ==========================================
// FILE: Engine/Cards/CardDefinition.swift
// ==========================================

import Foundation

/// Протокол определения карты (Data Layer)
/// Описывает статические данные карты, которые не меняются во время игры
protocol CardDefinition {
    /// Уникальный идентификатор карты
    var id: String { get }

    /// Локализованное название
    var name: String { get }

    /// Тип карты
    var cardType: CardType { get }

    /// Редкость
    var rarity: CardRarity { get }

    /// Описание для UI
    var description: String { get }

    /// Иконка карты (SF Symbol или emoji)
    var icon: String { get }

    /// Набор/дополнение
    var expansionSet: ExpansionSet { get }

    /// Принадлежность карты (кому доступна)
    var ownership: CardOwnership { get }

    /// Эффекты карты
    var abilities: [CardAbility] { get }

    /// Стоимость веры для покупки
    var faithCost: Int { get }

    /// Баланс Свет/Тьма
    var balance: CardBalance? { get }

    /// Роль карты в кампании
    var role: CardRole? { get }
}

/// Принадлежность карты - определяет кто может использовать карту
/// Аналог системы сигнатурных карт из Arkham Horror LCG
enum CardOwnership: Codable, Equatable {
    /// Базовая карта - доступна всем
    case universal

    /// Карта класса - доступна только герою определённого класса
    case classSpecific(heroClass: HeroClass)

    /// Сигнатурная карта героя - привязана к конкретному герою
    /// Как в Arkham Horror LCG, где у каждого следователя есть свои уникальные карты
    case heroSignature(heroID: String)

    /// Карта набора/дополнения - требует владения DLC
    case expansion(setID: String)

    /// Карта с требованием разблокировки
    case requiresUnlock(condition: String)

    /// Карта с несколькими условиями (все должны выполняться)
    case composite([CardOwnership])
}

/// Стандартная реализация определения карты
struct StandardCardDefinition: CardDefinition, Codable {
    let id: String
    let name: String
    let cardType: CardType
    let rarity: CardRarity
    let description: String
    let icon: String
    let expansionSet: ExpansionSet
    let ownership: CardOwnership
    let abilities: [CardAbility]
    let faithCost: Int
    let balance: CardBalance?
    let role: CardRole?

    // Дополнительные параметры
    let power: Int?
    let defense: Int?
    let health: Int?
    let realm: Realm?
    let curseType: CurseType?

    init(
        id: String,
        name: String,
        cardType: CardType,
        rarity: CardRarity = .common,
        description: String,
        icon: String = "🃏",
        expansionSet: ExpansionSet = .baseSet,
        ownership: CardOwnership = .universal,
        abilities: [CardAbility] = [],
        faithCost: Int = 3,
        balance: CardBalance? = nil,
        role: CardRole? = nil,
        power: Int? = nil,
        defense: Int? = nil,
        health: Int? = nil,
        realm: Realm? = nil,
        curseType: CurseType? = nil
    ) {
        self.id = id
        self.name = name
        self.cardType = cardType
        self.rarity = rarity
        self.description = description
        self.icon = icon
        self.expansionSet = expansionSet
        self.ownership = ownership
        self.abilities = abilities
        self.faithCost = faithCost
        self.balance = balance
        self.role = role
        self.power = power
        self.defense = defense
        self.health = health
        self.realm = realm
        self.curseType = curseType
    }

    /// Конвертация в игровую Card
    func toCard() -> Card {
        return Card(
            id: UUID(),
            name: name,
            type: cardType,
            rarity: rarity,
            description: description,
            power: power,
            defense: defense,
            health: health,
            abilities: abilities,
            balance: balance,
            realm: realm,
            curseType: curseType,
            expansionSet: expansionSet.rawValue,
            role: role,
            faithCost: faithCost
        )
    }
}

// MARK: - Card Ownership Extensions

extension CardOwnership {
    /// Проверить, доступна ли карта для героя
    func isAvailable(
        forHeroID heroID: String?,
        heroClass: HeroClass?,
        ownedExpansions: Set<String> = [],
        unlockedConditions: Set<String> = []
    ) -> Bool {
        switch self {
        case .universal:
            return true

        case .classSpecific(let requiredClass):
            return heroClass == requiredClass

        case .heroSignature(let requiredHeroID):
            return heroID == requiredHeroID

        case .expansion(let setID):
            return ownedExpansions.contains(setID)

        case .requiresUnlock(let condition):
            return unlockedConditions.contains(condition)

        case .composite(let requirements):
            return requirements.allSatisfy { requirement in
                requirement.isAvailable(
                    forHeroID: heroID,
                    heroClass: heroClass,
                    ownedExpansions: ownedExpansions,
                    unlockedConditions: unlockedConditions
                )
            }
        }
    }

    /// Описание условий доступа для UI
    var accessDescription: String {
        switch self {
        case .universal:
            return "Доступна всем"

        case .classSpecific(let heroClass):
            return "Только для класса: \(heroClass.rawValue)"

        case .heroSignature(let heroID):
            return "Сигнатурная карта героя: \(heroID)"

        case .expansion(let setID):
            return "Требуется дополнение: \(setID)"

        case .requiresUnlock(let condition):
            return "Требуется: \(condition)"

        case .composite(let requirements):
            let descriptions = requirements.map { $0.accessDescription }
            return descriptions.joined(separator: " + ")
        }
    }
}

// MARK: - Signature Card Set

/// Набор сигнатурных карт героя
/// Каждый герой может иметь уникальные карты, которые начинают в его колоде
/// или могут быть добавлены только этому герою
struct HeroSignatureCards {
    /// ID героя
    let heroID: String

    /// Обязательные сигнатурные карты (начинают в колоде)
    let requiredCards: [CardDefinition]

    /// Опциональные сигнатурные карты (можно добавить во время кампании)
    let optionalCards: [CardDefinition]

    /// Слабость героя (негативная сигнатурная карта)
    /// Как в Arkham Horror LCG, где у каждого следователя есть своя слабость
    let weakness: CardDefinition?

    /// Все карты ID
    var allCardIDs: [String] {
        var ids = requiredCards.map { $0.id }
        ids.append(contentsOf: optionalCards.map { $0.id })
        if let weakness = weakness {
            ids.append(weakness.id)
        }
        return ids
    }
}

// MARK: - Class Card Pool

/// Пул карт класса героя
/// Карты, доступные всем героям определённого класса
struct ClassCardPool {
    /// Класс героя
    let heroClass: HeroClass

    /// Стартовые карты класса (добавляются в начальную колоду)
    let startingCards: [CardDefinition]

    /// Карты для покупки (доступны в магазине только этому классу)
    let purchasableCards: [CardDefinition]

    /// Карты улучшения (замена базовых карт на улучшенные)
    let upgradeCards: [CardDefinition]

    /// Все карты ID
    var allCardIDs: [String] {
        var ids = startingCards.map { $0.id }
        ids.append(contentsOf: purchasableCards.map { $0.id })
        ids.append(contentsOf: upgradeCards.map { $0.id })
        return ids
    }
}


// ==========================================
// FILE: Engine/Cards/CardRegistry.swift
// ==========================================

import Foundation

/// Реестр карт - централизованное хранилище всех определений карт
/// Поддерживает:
/// - Универсальные карты (доступны всем)
/// - Класс-специфичные карты (только для определённого класса героя)
/// - Сигнатурные карты героя (уникальные карты конкретного персонажа)
/// - DLC/Expansion карты
final class CardRegistry {

    // MARK: - Singleton

    static let shared = CardRegistry()

    // MARK: - Storage

    /// Все зарегистрированные карты
    private var definitions: [String: CardDefinition] = [:]

    /// Пулы карт классов
    private var classPools: [HeroClass: ClassCardPool] = [:]

    /// Сигнатурные карты героев
    private var signatureCards: [String: HeroSignatureCards] = [:]

    /// Источники данных карт
    private var dataSources: [CardDataSource] = []

    // MARK: - Init

    private init() {
        registerBuiltInCards()
    }

    // MARK: - Registration

    /// Зарегистрировать определение карты
    func register(_ definition: CardDefinition) {
        definitions[definition.id] = definition
    }

    /// Зарегистрировать несколько карт
    func registerAll(_ definitions: [CardDefinition]) {
        for definition in definitions {
            register(definition)
        }
    }

    /// Зарегистрировать пул карт класса
    func registerClassPool(_ pool: ClassCardPool) {
        classPools[pool.heroClass] = pool
        registerAll(pool.startingCards)
        registerAll(pool.purchasableCards)
        registerAll(pool.upgradeCards)
    }

    /// Зарегистрировать сигнатурные карты героя
    func registerSignatureCards(_ cards: HeroSignatureCards) {
        signatureCards[cards.heroID] = cards
        registerAll(cards.requiredCards)
        registerAll(cards.optionalCards)
        if let weakness = cards.weakness {
            register(weakness)
        }
    }

    /// Удалить карту из реестра
    func unregister(id: String) {
        definitions.removeValue(forKey: id)
    }

    /// Очистить реестр
    func clear() {
        definitions.removeAll()
        classPools.removeAll()
        signatureCards.removeAll()
    }

    /// Перезагрузить реестр
    func reload() {
        clear()
        registerBuiltInCards()
        for source in dataSources {
            registerAll(source.loadCards())
        }
    }

    // MARK: - Data Sources

    /// Добавить источник данных
    func addDataSource(_ source: CardDataSource) {
        dataSources.append(source)
        registerAll(source.loadCards())
    }

    /// Удалить источник данных
    func removeDataSource(_ source: CardDataSource) {
        if let index = dataSources.firstIndex(where: { $0.id == source.id }) {
            let source = dataSources.remove(at: index)
            for card in source.loadCards() {
                unregister(id: card.id)
            }
        }
    }

    // MARK: - Queries

    /// Получить карту по ID
    func card(id: String) -> CardDefinition? {
        return definitions[id]
    }

    /// Все карты
    var allCards: [CardDefinition] {
        return Array(definitions.values)
    }

    /// Карты доступные для героя
    func availableCards(
        forHeroID heroID: String?,
        heroClass: HeroClass?,
        ownedExpansions: Set<String> = [],
        unlockedConditions: Set<String> = []
    ) -> [CardDefinition] {
        return allCards.filter { card in
            card.ownership.isAvailable(
                forHeroID: heroID,
                heroClass: heroClass,
                ownedExpansions: ownedExpansions,
                unlockedConditions: unlockedConditions
            )
        }
    }

    /// Универсальные карты (доступны всем)
    var universalCards: [CardDefinition] {
        return allCards.filter { card in
            if case .universal = card.ownership { return true }
            return false
        }
    }

    /// Карты определённого класса
    func cards(forClass heroClass: HeroClass) -> [CardDefinition] {
        return allCards.filter { card in
            if case .classSpecific(let requiredClass) = card.ownership {
                return requiredClass == heroClass
            }
            return false
        }
    }

    /// Сигнатурные карты героя
    func cards(forHeroID heroID: String) -> HeroSignatureCards? {
        return signatureCards[heroID]
    }

    /// Пул карт класса
    func classPool(for heroClass: HeroClass) -> ClassCardPool? {
        return classPools[heroClass]
    }

    /// Стартовая колода для героя
    func startingDeck(forHeroID heroID: String, heroClass: HeroClass) -> [Card] {
        var deck: [Card] = []

        // 1. Базовые универсальные карты
        let basicCards = universalCards.filter { $0.rarity == .common }
        for cardDef in basicCards.prefix(5) {
            if let def = cardDef as? StandardCardDefinition {
                deck.append(def.toCard())
            }
        }

        // 2. Карты класса
        if let pool = classPools[heroClass] {
            for cardDef in pool.startingCards {
                if let def = cardDef as? StandardCardDefinition {
                    deck.append(def.toCard())
                }
            }
        }

        // 3. Сигнатурные карты героя
        if let signature = signatureCards[heroID] {
            for cardDef in signature.requiredCards {
                if let def = cardDef as? StandardCardDefinition {
                    deck.append(def.toCard())
                }
            }
            // Добавляем слабость
            if let weakness = signature.weakness as? StandardCardDefinition {
                deck.append(weakness.toCard())
            }
        }

        return deck
    }

    /// Карты для магазина (с учётом доступности)
    func shopCards(
        forHeroID heroID: String?,
        heroClass: HeroClass?,
        ownedExpansions: Set<String> = [],
        unlockedConditions: Set<String> = [],
        maxRarity: CardRarity = .epic
    ) -> [CardDefinition] {
        return availableCards(
            forHeroID: heroID,
            heroClass: heroClass,
            ownedExpansions: ownedExpansions,
            unlockedConditions: unlockedConditions
        ).filter { card in
            // Исключаем сигнатурные карты из магазина
            if case .heroSignature = card.ownership { return false }
            // Исключаем легендарные (добываются только из данжей)
            if card.rarity == .legendary { return false }
            return card.rarity.order <= maxRarity.order
        }
    }

    /// Количество карт в реестре
    var count: Int {
        return definitions.count
    }

    // MARK: - Built-in Cards

    private func registerBuiltInCards() {
        // Базовые универсальные карты
        registerBaseCards()

        // Карты классов
        registerWarriorCards()
        registerMageCards()
        registerRangerCards()
        registerPriestCards()
        registerShadowCards()

        // Сигнатурные карты героев
        registerSignatureCardsForBuiltInHeroes()
    }

    private func registerBaseCards() {
        // Базовый удар
        register(StandardCardDefinition(
            id: "strike_basic",
            name: "Удар",
            cardType: .attack,
            rarity: .common,
            description: "Нанести 3 урона",
            icon: "⚔️",
            abilities: [CardAbility(
                name: "Удар",
                description: "Нанести 3 урона",
                effect: .damage(amount: 3, type: .physical)
            )],
            faithCost: 1,
            balance: .neutral
        ))

        // Базовая защита
        register(StandardCardDefinition(
            id: "defend_basic",
            name: "Защита",
            cardType: .defense,
            rarity: .common,
            description: "Получить 3 защиты",
            icon: "🛡️",
            abilities: [],
            faithCost: 1,
            balance: .neutral,
            defense: 3
        ))

        // Восстановление
        register(StandardCardDefinition(
            id: "heal_basic",
            name: "Лечение",
            cardType: .spell,
            rarity: .common,
            description: "Восстановить 2 HP",
            icon: "💚",
            abilities: [CardAbility(
                name: "Исцеление",
                description: "Восстановить 2 HP",
                effect: .heal(amount: 2)
            )],
            faithCost: 2,
            balance: .light,
            role: .sustain
        ))

        // Взять карты
        register(StandardCardDefinition(
            id: "draw_basic",
            name: "Подготовка",
            cardType: .special,
            rarity: .common,
            description: "Взять 2 карты",
            icon: "📜",
            abilities: [CardAbility(
                name: "Подготовка",
                description: "Взять 2 карты",
                effect: .drawCards(count: 2)
            )],
            faithCost: 2,
            balance: .neutral,
            role: .utility
        ))
    }

    private func registerWarriorCards() {
        let classCards: [CardDefinition] = [
            StandardCardDefinition(
                id: "warrior_rage_strike",
                name: "Яростный удар",
                cardType: .attack,
                rarity: .uncommon,
                description: "Нанести 5 урона. +2 если HP < 50%",
                icon: "🔥",
                ownership: .classSpecific(heroClass: .warrior),
                abilities: [CardAbility(
                    name: "Ярость",
                    description: "Нанести 5 урона. +2 если HP < 50%",
                    effect: .damage(amount: 5, type: .physical)
                )],
                faithCost: 3,
                balance: .neutral,
                power: 5
            ),
            StandardCardDefinition(
                id: "warrior_battlecry",
                name: "Боевой клич",
                cardType: .special,
                rarity: .rare,
                description: "+1 кубик атаки на 2 хода",
                icon: "📢",
                ownership: .classSpecific(heroClass: .warrior),
                abilities: [CardAbility(
                    name: "Боевой клич",
                    description: "+1 кубик атаки",
                    effect: .addDice(count: 1)
                )],
                faithCost: 4,
                balance: .neutral,
                role: .power
            )
        ]

        registerClassPool(ClassCardPool(
            heroClass: .warrior,
            startingCards: [classCards[0]],
            purchasableCards: classCards,
            upgradeCards: []
        ))
    }

    private func registerMageCards() {
        let classCards: [CardDefinition] = [
            StandardCardDefinition(
                id: "mage_arcane_bolt",
                name: "Арканный снаряд",
                cardType: .spell,
                rarity: .common,
                description: "Нанести 4 магического урона",
                icon: "✨",
                ownership: .classSpecific(heroClass: .mage),
                abilities: [CardAbility(
                    name: "Арканный снаряд",
                    description: "Нанести 4 магического урона",
                    effect: .damage(amount: 4, type: .arcane)
                )],
                faithCost: 2,
                balance: .neutral,
                power: 4
            ),
            StandardCardDefinition(
                id: "mage_meditation",
                name: "Глубокая медитация",
                cardType: .special,
                rarity: .uncommon,
                description: "Получить 3 веры",
                icon: "🧘",
                ownership: .classSpecific(heroClass: .mage),
                abilities: [CardAbility(
                    name: "Медитация",
                    description: "Получить 3 веры",
                    effect: .gainFaith(amount: 3)
                )],
                faithCost: 2,
                balance: .neutral,
                role: .utility
            )
        ]

        registerClassPool(ClassCardPool(
            heroClass: .mage,
            startingCards: [classCards[0]],
            purchasableCards: classCards,
            upgradeCards: []
        ))
    }

    private func registerRangerCards() {
        let classCards: [CardDefinition] = [
            StandardCardDefinition(
                id: "ranger_precise_shot",
                name: "Точный выстрел",
                cardType: .attack,
                rarity: .common,
                description: "Нанести 3 урона. Можно перебросить 1 кубик",
                icon: "🎯",
                ownership: .classSpecific(heroClass: .ranger),
                abilities: [CardAbility(
                    name: "Точный выстрел",
                    description: "Нанести урон с перебросом",
                    effect: .reroll
                )],
                faithCost: 2,
                balance: .neutral,
                power: 3
            ),
            StandardCardDefinition(
                id: "ranger_trap",
                name: "Ловушка",
                cardType: .special,
                rarity: .uncommon,
                description: "Следующий враг получает -2 к защите",
                icon: "🪤",
                ownership: .classSpecific(heroClass: .ranger),
                abilities: [],
                faithCost: 3,
                balance: .neutral,
                role: .control
            )
        ]

        registerClassPool(ClassCardPool(
            heroClass: .ranger,
            startingCards: [classCards[0]],
            purchasableCards: classCards,
            upgradeCards: []
        ))
    }

    private func registerPriestCards() {
        let classCards: [CardDefinition] = [
            StandardCardDefinition(
                id: "priest_holy_light",
                name: "Святой свет",
                cardType: .spell,
                rarity: .common,
                description: "Восстановить 4 HP или нанести 4 урона нежити",
                icon: "☀️",
                ownership: .classSpecific(heroClass: .priest),
                abilities: [CardAbility(
                    name: "Святой свет",
                    description: "Исцеление или урон нежити",
                    effect: .heal(amount: 4)
                )],
                faithCost: 3,
                balance: .light,
                role: .sustain
            ),
            StandardCardDefinition(
                id: "priest_blessing",
                name: "Благословение",
                cardType: .spell,
                rarity: .uncommon,
                description: "Снять проклятие или +2 к защите",
                icon: "🙏",
                ownership: .classSpecific(heroClass: .priest),
                abilities: [CardAbility(
                    name: "Благословение",
                    description: "Снять проклятие",
                    effect: .removeCurse(type: nil)
                )],
                faithCost: 4,
                balance: .light,
                role: .sustain
            )
        ]

        registerClassPool(ClassCardPool(
            heroClass: .priest,
            startingCards: [classCards[0]],
            purchasableCards: classCards,
            upgradeCards: []
        ))
    }

    private func registerShadowCards() {
        let classCards: [CardDefinition] = [
            StandardCardDefinition(
                id: "shadow_backstab",
                name: "Удар в спину",
                cardType: .attack,
                rarity: .common,
                description: "Нанести 2 урона. +4 если цель на полном HP",
                icon: "🗡️",
                ownership: .classSpecific(heroClass: .shadow),
                abilities: [CardAbility(
                    name: "Засада",
                    description: "Урон с бонусом по полному HP",
                    effect: .damage(amount: 2, type: .physical)
                )],
                faithCost: 2,
                balance: .dark,
                power: 2
            ),
            StandardCardDefinition(
                id: "shadow_poison_blade",
                name: "Отравленный клинок",
                cardType: .attack,
                rarity: .uncommon,
                description: "Нанести 3 урона. Наложить Слабость",
                icon: "🐍",
                ownership: .classSpecific(heroClass: .shadow),
                abilities: [CardAbility(
                    name: "Яд",
                    description: "Наложить Слабость",
                    effect: .applyCurse(type: .weakness, duration: 2)
                )],
                faithCost: 4,
                balance: .dark,
                role: .control,
                power: 3
            )
        ]

        registerClassPool(ClassCardPool(
            heroClass: .shadow,
            startingCards: [classCards[0]],
            purchasableCards: classCards,
            upgradeCards: []
        ))
    }

    private func registerSignatureCardsForBuiltInHeroes() {
        // Рагнар - Воин
        registerSignatureCards(HeroSignatureCards(
            heroID: "warrior_ragnar",
            requiredCards: [
                StandardCardDefinition(
                    id: "ragnar_ancestral_axe",
                    name: "Топор предков",
                    cardType: .weapon,
                    rarity: .rare,
                    description: "Легендарное оружие Рагнара. +2 к урону, +1 кубик",
                    icon: "🪓",
                    ownership: .heroSignature(heroID: "warrior_ragnar"),
                    abilities: [CardAbility(
                        name: "Наследие",
                        description: "+1 кубик атаки",
                        effect: .addDice(count: 1)
                    )],
                    faithCost: 0,
                    balance: .neutral,
                    power: 2
                )
            ],
            optionalCards: [],
            weakness: StandardCardDefinition(
                id: "ragnar_blood_rage",
                name: "Кровавая ярость",
                cardType: .curse,
                rarity: .rare,
                description: "Слабость Рагнара. При HP < 25% атакует ближайшую цель",
                icon: "💢",
                ownership: .heroSignature(heroID: "warrior_ragnar"),
                abilities: [],
                faithCost: 0,
                balance: .dark,
                curseType: .bloodCurse
            )
        ))

        // Умбра - Тень
        registerSignatureCards(HeroSignatureCards(
            heroID: "shadow_umbra",
            requiredCards: [
                StandardCardDefinition(
                    id: "umbra_shadow_cloak",
                    name: "Плащ теней",
                    cardType: .armor,
                    rarity: .rare,
                    description: "Артефакт Умбры. Невидимость на 1 ход после убийства",
                    icon: "🌑",
                    ownership: .heroSignature(heroID: "shadow_umbra"),
                    abilities: [],
                    faithCost: 0,
                    balance: .dark,
                    defense: 1
                )
            ],
            optionalCards: [],
            weakness: StandardCardDefinition(
                id: "umbra_dark_pact",
                name: "Тёмный договор",
                cardType: .curse,
                rarity: .rare,
                description: "Слабость Умбры. Каждые 3 убийства: баланс -10 к Тьме",
                icon: "📜",
                ownership: .heroSignature(heroID: "shadow_umbra"),
                abilities: [CardAbility(
                    name: "Договор",
                    description: "Сдвиг к Тьме",
                    effect: .shiftBalance(towards: .dark, amount: 10)
                )],
                faithCost: 0,
                balance: .dark
            )
        ))
    }
}

// MARK: - Card Data Source Protocol

/// Протокол источника данных карт
protocol CardDataSource {
    var id: String { get }
    var name: String { get }
    func loadCards() -> [CardDefinition]
}

// MARK: - JSON Data Source

/// Загрузчик карт из JSON
struct JSONCardDataSource: CardDataSource {
    let id: String
    let name: String
    let fileURL: URL

    func loadCards() -> [CardDefinition] {
        guard let data = try? Data(contentsOf: fileURL) else {
            print("CardRegistry: Failed to load JSON from \(fileURL)")
            return []
        }

        do {
            let decoded = try JSONDecoder().decode([JSONCardDefinition].self, from: data)
            return decoded.map { $0.toStandard() }
        } catch {
            print("CardRegistry: Failed to decode cards: \(error)")
            return []
        }
    }
}

/// JSON-совместимое определение карты
struct JSONCardDefinition: Codable {
    let id: String
    let name: String
    let cardType: CardType
    let rarity: CardRarity
    let description: String
    let icon: String?
    let expansionSet: ExpansionSet?
    let faithCost: Int
    let balance: CardBalance?
    let role: CardRole?
    let power: Int?
    let defense: Int?
    let health: Int?
    // Simplified ownership for JSON
    let ownershipType: String?  // "universal", "class:warrior", "hero:warrior_ragnar"

    func toStandard() -> StandardCardDefinition {
        let ownership: CardOwnership
        if let ownershipType = ownershipType {
            if ownershipType == "universal" {
                ownership = .universal
            } else if ownershipType.hasPrefix("class:") {
                let className = String(ownershipType.dropFirst(6))
                if let heroClass = HeroClass(rawValue: className) {
                    ownership = .classSpecific(heroClass: heroClass)
                } else {
                    ownership = .universal
                }
            } else if ownershipType.hasPrefix("hero:") {
                let heroID = String(ownershipType.dropFirst(5))
                ownership = .heroSignature(heroID: heroID)
            } else {
                ownership = .universal
            }
        } else {
            ownership = .universal
        }

        return StandardCardDefinition(
            id: id,
            name: name,
            cardType: cardType,
            rarity: rarity,
            description: description,
            icon: icon ?? "🃏",
            expansionSet: expansionSet ?? .baseSet,
            ownership: ownership,
            faithCost: faithCost,
            balance: balance,
            role: role,
            power: power,
            defense: defense,
            health: health
        )
    }
}

// MARK: - CardRarity Extension

extension CardRarity {
    /// Порядок редкости для сравнения
    var order: Int {
        switch self {
        case .common: return 0
        case .uncommon: return 1
        case .rare: return 2
        case .epic: return 3
        case .legendary: return 4
        }
    }
}


// ==========================================
// FILE: Engine/Runtime/EventRuntimeState.swift
// ==========================================

import Foundation

// MARK: - Event Runtime State
// Reference: Docs/EVENT_MODULE_ARCHITECTURE.md, Section 5
// Reference: Docs/MIGRATION_PLAN.md, Feature A2

/// Mutable runtime state for the event system.
/// Tracks which events have been completed, cooldowns, etc.
struct EventRuntimeState: Codable, Equatable {
    // MARK: - Completion Tracking

    /// Set of completed one-time event IDs
    var completedOneTimeEvents: Set<String>

    /// Count of times each event has occurred
    var eventOccurrenceCount: [String: Int]

    // MARK: - Cooldowns

    /// Cooldown remaining for each event (turns until available)
    var eventCooldowns: [String: Int]

    // MARK: - Current Event

    /// Currently active event ID (nil if no event active)
    var activeEventId: String?

    /// Currently active mini-game challenge (nil if no mini-game active)
    var activeMiniGameId: String?

    // MARK: - Selection State

    /// Last used random seed for deterministic replay
    var lastSelectionSeed: UInt64

    // MARK: - Initialization

    init(
        completedOneTimeEvents: Set<String> = [],
        eventOccurrenceCount: [String: Int] = [:],
        eventCooldowns: [String: Int] = [:],
        activeEventId: String? = nil,
        activeMiniGameId: String? = nil,
        lastSelectionSeed: UInt64 = 0
    ) {
        self.completedOneTimeEvents = completedOneTimeEvents
        self.eventOccurrenceCount = eventOccurrenceCount
        self.eventCooldowns = eventCooldowns
        self.activeEventId = activeEventId
        self.activeMiniGameId = activeMiniGameId
        self.lastSelectionSeed = lastSelectionSeed
    }

    // MARK: - Completion Operations

    /// Mark an event as completed
    mutating func markCompleted(_ eventId: String, isOneTime: Bool) {
        eventOccurrenceCount[eventId, default: 0] += 1
        if isOneTime {
            completedOneTimeEvents.insert(eventId)
        }
    }

    /// Check if a one-time event is completed
    func isOneTimeCompleted(_ eventId: String) -> Bool {
        return completedOneTimeEvents.contains(eventId)
    }

    /// Get occurrence count for an event
    func occurrenceCount(for eventId: String) -> Int {
        return eventOccurrenceCount[eventId] ?? 0
    }

    // MARK: - Cooldown Operations

    /// Set cooldown for an event
    mutating func setCooldown(_ eventId: String, turns: Int) {
        if turns > 0 {
            eventCooldowns[eventId] = turns
        }
    }

    /// Check if event is on cooldown
    func isOnCooldown(_ eventId: String) -> Bool {
        return (eventCooldowns[eventId] ?? 0) > 0
    }

    /// Tick all cooldowns (call each turn)
    mutating func tickCooldowns() {
        for (eventId, remaining) in eventCooldowns {
            if remaining > 1 {
                eventCooldowns[eventId] = remaining - 1
            } else {
                eventCooldowns.removeValue(forKey: eventId)
            }
        }
    }

    // MARK: - Active Event Operations

    /// Start an event
    mutating func startEvent(_ eventId: String) {
        activeEventId = eventId
    }

    /// End the current event
    mutating func endEvent() {
        activeEventId = nil
        activeMiniGameId = nil
    }

    /// Start a mini-game within current event
    mutating func startMiniGame(_ challengeId: String) {
        activeMiniGameId = challengeId
    }

    /// End the current mini-game
    mutating func endMiniGame() {
        activeMiniGameId = nil
    }
}


// ==========================================
// FILE: Engine/Runtime/GameRuntimeState.swift
// ==========================================

import Foundation

// MARK: - Game Runtime State
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.2
// Reference: Docs/MIGRATION_PLAN.md, Feature A2

/// Combined runtime state for the entire game.
/// This is the single source of truth for game state.
/// All changes go through GameEngine.performAction().
struct GameRuntimeState: Codable, Equatable {
    // MARK: - Component States

    /// World state (regions, anchors, flags, pressure, time)
    var world: WorldRuntimeState

    /// Player state (resources, deck, balance, curses)
    var player: PlayerRuntimeState

    /// Event state (completion tracking, cooldowns)
    var events: EventRuntimeState

    /// Quest state (progress, completion)
    var quests: QuestRuntimeState

    // MARK: - Game Meta

    /// Current game phase
    var phase: EngineGamePhase

    /// Random seed for this playthrough
    let playthroughSeed: UInt64

    /// Save slot identifier
    var saveSlot: Int?

    // MARK: - Initialization

    init(
        world: WorldRuntimeState,
        player: PlayerRuntimeState,
        events: EventRuntimeState = EventRuntimeState(),
        quests: QuestRuntimeState = QuestRuntimeState(),
        phase: EngineGamePhase = .playing,
        playthroughSeed: UInt64 = 0,
        saveSlot: Int? = nil
    ) {
        self.world = world
        self.player = player
        self.events = events
        self.quests = quests
        self.phase = phase
        self.playthroughSeed = playthroughSeed
        self.saveSlot = saveSlot
    }

    // MARK: - Convenience Accessors

    /// Current region ID
    var currentRegionId: String {
        return world.currentRegionId
    }

    /// Current time (days)
    var currentTime: Int {
        return world.currentTime
    }

    /// Current pressure
    var currentPressure: Int {
        return world.pressure
    }

    /// Check game over conditions
    var isGameOver: Bool {
        // Pressure maximum
        if world.isPressureMaximum {
            return true
        }
        // Player death (health <= 0)
        if player.getResource("health") <= 0 {
            return true
        }
        return false
    }

    /// Get combined flags (world + player)
    func getAllFlags() -> Set<String> {
        var allFlags = Set<String>()
        for (key, value) in world.flags where value {
            allFlags.insert(key)
        }
        for (key, value) in player.flags where value {
            allFlags.insert(key)
        }
        return allFlags
    }
}

// MARK: - Factory Methods

extension GameRuntimeState {
    /// Create a new game state with default values
    static func newGame(
        startingRegionId: String,
        startingResources: [String: Int],
        startingDeck: [String],
        seed: UInt64? = nil
    ) -> GameRuntimeState {
        let actualSeed = seed ?? UInt64.random(in: 0...UInt64.max)

        let world = WorldRuntimeState(
            currentRegionId: startingRegionId,
            currentTime: 0,
            pressure: 0
        )

        let player = PlayerRuntimeState(
            resources: startingResources,
            balance: 0,
            drawPile: startingDeck
        )

        return GameRuntimeState(
            world: world,
            player: player,
            playthroughSeed: actualSeed
        )
    }
}

// MARK: - Snapshot for Regression Testing

extension GameRuntimeState {
    /// Create a snapshot for comparison
    struct Snapshot: Equatable {
        let pressure: Int
        let time: Int
        let health: Int
        let faith: Int
        let balance: Int
        let currentRegionId: String
        let visitedRegionsCount: Int
        let completedEventsCount: Int
        let activeQuestsCount: Int
        let deckSize: Int
        let flagCount: Int
    }

    /// Generate snapshot for testing
    func snapshot() -> Snapshot {
        let visitedCount = world.regionsState.values.filter { $0.visitCount > 0 }.count

        return Snapshot(
            pressure: world.pressure,
            time: world.currentTime,
            health: player.getResource("health"),
            faith: player.getResource("faith"),
            balance: player.balance,
            currentRegionId: world.currentRegionId,
            visitedRegionsCount: visitedCount,
            completedEventsCount: events.completedOneTimeEvents.count,
            activeQuestsCount: quests.activeQuests.count,
            deckSize: player.totalCardCount,
            flagCount: getAllFlags().count
        )
    }
}


// ==========================================
// FILE: Engine/Runtime/PlayerRuntimeState.swift
// ==========================================

import Foundation

// MARK: - Player Runtime State
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.2
// Reference: Docs/MIGRATION_PLAN.md, Feature A2

/// Mutable runtime state of the player.
/// Tracks resources, deck, balance, curses, etc.
struct PlayerRuntimeState: Codable, Equatable {
    // MARK: - Resources

    /// Player resources (health, faith, etc.)
    var resources: [String: Int]

    // MARK: - Balance/Path

    /// Balance between Nav and Prav (-100 to +100)
    /// Negative = Nav (chaos), Positive = Prav (order)
    var balance: Int

    // MARK: - Deck State

    /// Cards in draw pile (by card ID)
    var drawPile: [String]

    /// Cards in hand
    var hand: [String]

    /// Cards in discard pile
    var discardPile: [String]

    /// Cards in exile (removed from game)
    var exilePile: [String]

    // MARK: - Curses

    /// Active curse IDs
    var activeCurses: Set<String>

    // MARK: - Player Flags

    /// Player-specific flags
    var flags: [String: Bool]

    // MARK: - Initialization

    init(
        resources: [String: Int] = [:],
        balance: Int = 0,
        drawPile: [String] = [],
        hand: [String] = [],
        discardPile: [String] = [],
        exilePile: [String] = [],
        activeCurses: Set<String> = [],
        flags: [String: Bool] = [:]
    ) {
        self.resources = resources
        self.balance = balance
        self.drawPile = drawPile
        self.hand = hand
        self.discardPile = discardPile
        self.exilePile = exilePile
        self.activeCurses = activeCurses
        self.flags = flags
    }

    // MARK: - Resource Operations

    /// Get resource value (0 if not set)
    func getResource(_ resourceId: String) -> Int {
        return resources[resourceId] ?? 0
    }

    /// Set resource value
    mutating func setResource(_ resourceId: String, value: Int) {
        resources[resourceId] = value
    }

    /// Modify resource by delta
    mutating func modifyResource(_ resourceId: String, by delta: Int) {
        resources[resourceId] = (resources[resourceId] ?? 0) + delta
    }

    /// Check if player can afford a cost
    func canAfford(_ costs: [String: Int]) -> Bool {
        for (resourceId, cost) in costs {
            if getResource(resourceId) < cost {
                return false
            }
        }
        return true
    }

    // MARK: - Balance Operations

    /// Shift balance (clamped to -100...100)
    mutating func shiftBalance(by delta: Int) {
        balance = max(-100, min(100, balance + delta))
    }

    /// Check if balance is within range
    func isBalanceInRange(_ range: ClosedRange<Int>) -> Bool {
        return range.contains(balance)
    }

    /// Balance alignment
    var alignment: BalanceAlignment {
        if balance < -30 {
            return .nav
        } else if balance > 30 {
            return .prav
        } else {
            return .neutral
        }
    }

    // MARK: - Deck Operations

    /// Total cards in deck (all zones)
    var totalCardCount: Int {
        return drawPile.count + hand.count + discardPile.count + exilePile.count
    }

    /// Add card to draw pile
    mutating func addCardToDrawPile(_ cardId: String) {
        drawPile.append(cardId)
    }

    /// Add card to discard pile
    mutating func addCardToDiscard(_ cardId: String) {
        discardPile.append(cardId)
    }

    /// Move card from hand to discard
    mutating func discardFromHand(_ cardId: String) -> Bool {
        if let index = hand.firstIndex(of: cardId) {
            hand.remove(at: index)
            discardPile.append(cardId)
            return true
        }
        return false
    }

    /// Exile a card (remove from game)
    mutating func exileCard(_ cardId: String, from zone: DeckZone) -> Bool {
        switch zone {
        case .draw:
            if let index = drawPile.firstIndex(of: cardId) {
                drawPile.remove(at: index)
                exilePile.append(cardId)
                return true
            }
        case .hand:
            if let index = hand.firstIndex(of: cardId) {
                hand.remove(at: index)
                exilePile.append(cardId)
                return true
            }
        case .discard:
            if let index = discardPile.firstIndex(of: cardId) {
                discardPile.remove(at: index)
                exilePile.append(cardId)
                return true
            }
        case .exile:
            return false // Already exiled
        }
        return false
    }

    /// Shuffle discard into draw pile
    mutating func shuffleDiscardIntoDraw() {
        drawPile.append(contentsOf: discardPile)
        discardPile.removeAll()
        drawPile.shuffle()
    }

    // MARK: - Curse Operations

    /// Add a curse
    mutating func addCurse(_ curseId: String) {
        activeCurses.insert(curseId)
    }

    /// Remove a curse
    mutating func removeCurse(_ curseId: String) {
        activeCurses.remove(curseId)
    }

    /// Check if player has a curse
    func hasCurse(_ curseId: String) -> Bool {
        return activeCurses.contains(curseId)
    }
}

// MARK: - Supporting Types

/// Deck zones
enum DeckZone: String, Codable, Hashable {
    case draw
    case hand
    case discard
    case exile
}

/// Balance alignment
enum BalanceAlignment: String, Codable, Hashable {
    case nav      // Chaos side
    case neutral
    case prav     // Order side
}


// ==========================================
// FILE: Engine/Runtime/QuestRuntimeState.swift
// ==========================================

import Foundation

// MARK: - Quest Runtime State
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.2
// Reference: Docs/MIGRATION_PLAN.md, Feature A2

/// Mutable runtime state for the quest system.
/// Tracks quest progress, completion, etc.
struct QuestRuntimeState: Codable, Equatable {
    // MARK: - Quest Tracking

    /// State of each quest (keyed by quest definition ID)
    var questStates: [String: SingleQuestState]

    // MARK: - Initialization

    init(questStates: [String: SingleQuestState] = [:]) {
        self.questStates = questStates
    }

    // MARK: - Quest Operations

    /// Get state for a specific quest
    func getQuestState(_ questId: String) -> SingleQuestState? {
        return questStates[questId]
    }

    /// Start a new quest
    mutating func startQuest(_ questId: String, firstObjectiveId: String) {
        questStates[questId] = SingleQuestState(
            definitionId: questId,
            status: .active,
            currentObjectiveId: firstObjectiveId
        )
    }

    /// Update quest state
    mutating func updateQuest(_ questId: String, update: (inout SingleQuestState) -> Void) {
        if var state = questStates[questId] {
            update(&state)
            questStates[questId] = state
        }
    }

    /// Get all active quests
    var activeQuests: [SingleQuestState] {
        return questStates.values.filter { $0.status == .active }
    }

    /// Get all completed quests
    var completedQuests: [SingleQuestState] {
        return questStates.values.filter { $0.status == .completed }
    }
}

// MARK: - Single Quest State

/// Runtime state of a single quest.
struct SingleQuestState: Codable, Equatable {
    /// Reference to quest definition
    let definitionId: String

    /// Current quest status
    var status: QuestStatus

    /// Current objective ID (nil if completed or failed)
    var currentObjectiveId: String?

    /// Completed objective IDs
    var completedObjectiveIds: Set<String>

    /// Failed objective IDs
    var failedObjectiveIds: Set<String>

    /// Quest-specific flags
    var flags: [String: Bool]

    /// Progress values for objectives (e.g., "kill_count": 3)
    var progressValues: [String: Int]

    init(
        definitionId: String,
        status: QuestStatus = .locked,
        currentObjectiveId: String? = nil,
        completedObjectiveIds: Set<String> = [],
        failedObjectiveIds: Set<String> = [],
        flags: [String: Bool] = [:],
        progressValues: [String: Int] = [:]
    ) {
        self.definitionId = definitionId
        self.status = status
        self.currentObjectiveId = currentObjectiveId
        self.completedObjectiveIds = completedObjectiveIds
        self.failedObjectiveIds = failedObjectiveIds
        self.flags = flags
        self.progressValues = progressValues
    }

    // MARK: - Objective Operations

    /// Complete current objective and move to next
    mutating func completeCurrentObjective(nextObjectiveId: String?) {
        if let currentId = currentObjectiveId {
            completedObjectiveIds.insert(currentId)
        }
        currentObjectiveId = nextObjectiveId

        // If no next objective, quest is complete
        if nextObjectiveId == nil {
            status = .completed
        }
    }

    /// Fail current objective
    mutating func failCurrentObjective() {
        if let currentId = currentObjectiveId {
            failedObjectiveIds.insert(currentId)
        }
        status = .failed
        currentObjectiveId = nil
    }

    /// Increment progress for a key
    mutating func incrementProgress(_ key: String, by amount: Int = 1) {
        progressValues[key, default: 0] += amount
    }

    /// Check progress against target
    func checkProgress(_ key: String, target: Int) -> Bool {
        return (progressValues[key] ?? 0) >= target
    }
}

// MARK: - Quest Status

/// Possible statuses for a quest
enum QuestStatus: String, Codable, Hashable {
    /// Quest not yet available/visible
    case locked

    /// Quest available but not started
    case available

    /// Quest in progress
    case active

    /// Quest successfully completed
    case completed

    /// Quest failed
    case failed
}


// ==========================================
// FILE: Engine/Runtime/WorldRuntimeState.swift
// ==========================================

import Foundation

// MARK: - World Runtime State
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.2
// Reference: Docs/MIGRATION_PLAN.md, Feature A2

/// Mutable runtime state of the game world.
/// References Definitions by ID, never stores Definition data.
struct WorldRuntimeState: Codable, Equatable {
    // MARK: - Current Position

    /// Current region ID
    var currentRegionId: String

    // MARK: - Time

    /// Current game time (days passed)
    var currentTime: Int

    // MARK: - Pressure

    /// Current world tension/pressure (0-100)
    var pressure: Int

    /// Days since last pressure escalation
    var daysSinceEscalation: Int

    // MARK: - Regions State

    /// Runtime state of each region (keyed by definition ID)
    var regionsState: [String: RegionRuntimeState]

    // MARK: - Anchors State

    /// Runtime state of each anchor (keyed by definition ID)
    var anchorsState: [String: AnchorRuntimeState]

    // MARK: - World Flags

    /// Global world flags
    var flags: [String: Bool]

    // MARK: - Initialization

    init(
        currentRegionId: String,
        currentTime: Int = 0,
        pressure: Int = 0,
        daysSinceEscalation: Int = 0,
        regionsState: [String: RegionRuntimeState] = [:],
        anchorsState: [String: AnchorRuntimeState] = [:],
        flags: [String: Bool] = [:]
    ) {
        self.currentRegionId = currentRegionId
        self.currentTime = currentTime
        self.pressure = pressure
        self.daysSinceEscalation = daysSinceEscalation
        self.regionsState = regionsState
        self.anchorsState = anchorsState
        self.flags = flags
    }

    // MARK: - Flag Operations

    mutating func setFlag(_ flag: String, value: Bool = true) {
        flags[flag] = value
    }

    func hasFlag(_ flag: String) -> Bool {
        return flags[flag] ?? false
    }

    // MARK: - Region Operations

    func getRegionState(_ regionId: String) -> RegionRuntimeState? {
        return regionsState[regionId]
    }

    mutating func updateRegion(_ regionId: String, update: (inout RegionRuntimeState) -> Void) {
        if var state = regionsState[regionId] {
            update(&state)
            regionsState[regionId] = state
        }
    }

    // MARK: - Pressure Operations

    /// Check if pressure is at maximum (game over condition)
    var isPressureMaximum: Bool {
        return pressure >= 100
    }
}

// MARK: - Region Runtime State

/// Mutable runtime state of a single region.
struct RegionRuntimeState: Codable, Equatable {
    /// Reference to the region definition
    let definitionId: String

    /// Current state (stable/borderland/breach)
    var currentState: RegionStateType

    /// Number of times player has visited
    var visitCount: Int

    /// Whether region is discovered/visible on map
    var isDiscovered: Bool

    /// Region-specific flags
    var flags: [String: Bool]

    init(
        definitionId: String,
        currentState: RegionStateType = .stable,
        visitCount: Int = 0,
        isDiscovered: Bool = false,
        flags: [String: Bool] = [:]
    ) {
        self.definitionId = definitionId
        self.currentState = currentState
        self.visitCount = visitCount
        self.isDiscovered = isDiscovered
        self.flags = flags
    }

    // MARK: - Operations

    mutating func visit() {
        visitCount += 1
        isDiscovered = true
    }

    mutating func degrade() -> Bool {
        guard let newState = currentState.degraded else { return false }
        currentState = newState
        return true
    }

    mutating func restore() -> Bool {
        guard let newState = currentState.restored else { return false }
        currentState = newState
        return true
    }
}

// MARK: - Anchor Runtime State

/// Mutable runtime state of a single anchor.
struct AnchorRuntimeState: Codable, Equatable {
    /// Reference to the anchor definition
    let definitionId: String

    /// Current integrity (0-100)
    var integrity: Int

    /// Whether anchor is active/usable
    var isActive: Bool

    init(
        definitionId: String,
        integrity: Int = 50,
        isActive: Bool = true
    ) {
        self.definitionId = definitionId
        self.integrity = integrity
        self.isActive = isActive
    }

    // MARK: - Operations

    mutating func strengthen(amount: Int, maxIntegrity: Int) {
        integrity = min(maxIntegrity, integrity + amount)
    }

    mutating func weaken(amount: Int) {
        integrity = max(0, integrity - amount)
        if integrity == 0 {
            isActive = false
        }
    }

    /// Calculate resistance chance (0.0 to 1.0)
    func resistanceChance(divisor: Int = 100) -> Double {
        guard isActive else { return 0 }
        return Double(integrity) / Double(divisor)
    }
}


// ==========================================
// FILE: Engine/Events/EventPipeline.swift
// ==========================================

import Foundation

// MARK: - Event Pipeline
// Handles the complete flow: Selection → Resolution → Consequences

/// Main event processing pipeline
final class EventPipeline {
    // MARK: - Dependencies

    private let selector: EventSelector
    private let resolver: EventResolver

    // MARK: - Initialization

    init(
        selector: EventSelector = EventSelector(),
        resolver: EventResolver = EventResolver()
    ) {
        self.selector = selector
        self.resolver = resolver
    }

    // MARK: - Pipeline Methods

    /// Process a trigger and return available events
    func getAvailableEvents(
        for context: EventContext,
        from events: [GameEvent]
    ) -> [GameEvent] {
        return selector.selectAvailableEvents(from: events, context: context)
    }

    /// Select a single event based on weights
    func selectEvent(
        from events: [GameEvent],
        context: EventContext
    ) -> GameEvent? {
        let available = selector.selectAvailableEvents(from: events, context: context)
        return selector.weightedSelect(from: available)
    }

    /// Resolve an event choice and return state changes
    func resolveChoice(
        event: GameEvent,
        choiceIndex: Int,
        context: EventResolutionContext
    ) -> EventResolutionResult {
        return resolver.resolve(event: event, choiceIndex: choiceIndex, context: context)
    }

    /// Check if a choice is available
    func canChoose(
        event: GameEvent,
        choiceIndex: Int,
        context: EventContext
    ) -> (available: Bool, reason: String?) {
        guard choiceIndex < event.choices.count else {
            return (false, "Invalid choice index")
        }

        let choice = event.choices[choiceIndex]

        // Check requirements if present
        guard let requirements = choice.requirements else {
            return (true, nil)  // No requirements = always available
        }

        // Check minimum faith
        if let minFaith = requirements.minimumFaith {
            let currentFaith = context.resources["faith"] ?? 0
            if currentFaith < minFaith {
                return (false, "Недостаточно веры (нужно \(minFaith))")
            }
        }

        // Check minimum health
        if let minHealth = requirements.minimumHealth {
            let currentHealth = context.resources["health"] ?? 0
            if currentHealth < minHealth {
                return (false, "Недостаточно здоровья (нужно \(minHealth))")
            }
        }

        // Check required flags
        if let requiredFlags = requirements.requiredFlags {
            for flag in requiredFlags {
                if context.flags[flag] != true {
                    return (false, "Требуется флаг: \(flag)")
                }
            }
        }

        return (true, nil)
    }
}

// MARK: - Event Selector

/// Handles event filtering and weighted selection
final class EventSelector {
    // MARK: - Selection

    /// Filter events by availability criteria
    func selectAvailableEvents(
        from events: [GameEvent],
        context: EventContext
    ) -> [GameEvent] {
        return events.filter { event in
            isEventAvailable(event, context: context)
        }
    }

    /// Check if single event is available based on GameEvent's actual properties
    func isEventAvailable(_ event: GameEvent, context: EventContext) -> Bool {
        // Check if already completed (for oneTime events)
        if event.oneTime && event.completed {
            return false
        }

        // Also check against context's completed set
        if event.oneTime && context.completedEvents.contains(event.id.uuidString) {
            return false
        }

        // Check region type requirements (empty = any region)
        if !event.regionTypes.isEmpty {
            guard let regionType = RegionType(rawValue: context.currentLocation) else {
                return false
            }
            if !event.regionTypes.contains(regionType) {
                return false
            }
        }

        // Check region state requirements (empty = any state)
        if !event.regionStates.isEmpty {
            guard let regionState = RegionState(rawValue: context.locationState) else {
                return false
            }
            if !event.regionStates.contains(regionState) {
                return false
            }
        }

        // Check event's required flags against context flags
        if let eventRequiredFlags = event.requiredFlags {
            for flag in eventRequiredFlags where context.flags[flag] != true {
                return false
            }
        }

        // Check event's forbidden flags
        if let forbiddenFlags = event.forbiddenFlags {
            for flag in forbiddenFlags where context.flags[flag] == true {
                return false
            }
        }

        return true
    }

    /// Select event using weighted random selection
    func weightedSelect(from events: [GameEvent]) -> GameEvent? {
        guard !events.isEmpty else { return nil }

        let totalWeight = events.reduce(0) { $0 + $1.weight }

        guard totalWeight > 0 else {
            // If all weights are 0, select randomly
            let index = WorldRNG.shared.nextInt(in: 0..<events.count)
            return events[index]
        }

        let roll = WorldRNG.shared.nextInt(in: 0..<totalWeight)
        var cumulative = 0

        for event in events {
            cumulative += event.weight
            if roll < cumulative {
                return event
            }
        }

        // Fallback (shouldn't reach here)
        return events.last
    }
}

// MARK: - Event Resolver

/// Handles event resolution and consequence calculation
final class EventResolver {
    // MARK: - Resolution

    /// Resolve an event choice
    func resolve(
        event: GameEvent,
        choiceIndex: Int,
        context: EventResolutionContext
    ) -> EventResolutionResult {
        guard choiceIndex < event.choices.count else {
            return EventResolutionResult(
                success: false,
                error: "Invalid choice index",
                stateChanges: [],
                triggeredCombat: nil,
                triggeredMiniGame: nil,
                narrativeText: nil
            )
        }

        let choice = event.choices[choiceIndex]
        var stateChanges: [StateChange] = []

        // Apply consequences
        let consequences = choice.consequences

        // Health changes (optional Int?)
        if let healthDelta = consequences.healthChange, healthDelta != 0 {
            let newHealth = max(0, context.currentHealth + healthDelta)
            stateChanges.append(.healthChanged(
                delta: healthDelta,
                newValue: newHealth
            ))
        }

        // Faith changes (optional Int?)
        if let faithDelta = consequences.faithChange, faithDelta != 0 {
            let newFaith = max(0, context.currentFaith + faithDelta)
            stateChanges.append(.faithChanged(
                delta: faithDelta,
                newValue: newFaith
            ))
        }

        // Balance changes (optional Int?)
        if let balanceDelta = consequences.balanceChange, balanceDelta != 0 {
            let newBalance = max(0, min(100, context.currentBalance + balanceDelta))
            stateChanges.append(.balanceChanged(
                delta: balanceDelta,
                newValue: newBalance
            ))
        }

        // Tension changes (optional Int?)
        if let tensionDelta = consequences.tensionChange, tensionDelta != 0 {
            let newTension = max(0, min(100, context.currentTension + tensionDelta))
            stateChanges.append(.tensionChanged(
                delta: tensionDelta,
                newValue: newTension
            ))
        }

        // Set flags (optional dictionary)
        if let flagsToSet = consequences.setFlags {
            for (flag, value) in flagsToSet {
                stateChanges.append(.flagSet(key: flag, value: value))
            }
        }

        // Check for triggered combat (monster card in event)
        var triggeredCombat: UUID? = nil
        if event.monsterCard != nil {
            // Combat events have monsterCard, use event ID as combat trigger
            triggeredCombat = event.id
        }

        // Check for triggered mini-game (not directly in EventConsequences,
        // would be triggered through specific event types or flags)
        let triggeredMiniGame: UUID? = nil

        // Mark event as completed if oneTime
        if event.oneTime {
            stateChanges.append(.eventCompleted(eventId: event.id))
        }

        return EventResolutionResult(
            success: true,
            error: nil,
            stateChanges: stateChanges,
            triggeredCombat: triggeredCombat,
            triggeredMiniGame: triggeredMiniGame,
            narrativeText: consequences.message
        )
    }
}

// MARK: - Supporting Types
// Note: EventContext is defined in EngineProtocols.swift

/// Context for event resolution
struct EventResolutionContext {
    let currentHealth: Int
    let currentFaith: Int
    let currentBalance: Int
    let currentTension: Int
    let currentFlags: [String: Bool]
}

/// Result of event resolution
struct EventResolutionResult {
    let success: Bool
    let error: String?
    let stateChanges: [StateChange]
    let triggeredCombat: UUID?
    let triggeredMiniGame: UUID?
    let narrativeText: String?
}

/// Event filter criteria for selection (different from EventRequirements in ExplorationModels)
struct EventFilterCriteria {
    var location: String?
    var locationState: String?
    var pressureRange: ClosedRange<Int>?
    var requiredFlags: [String] = []
    var forbiddenFlags: [String] = []
    var minResources: [String: Int] = [:]

    static let none = EventFilterCriteria()
}

// MARK: - GameEvent Extension

extension GameEvent {
    /// Event filter criteria for engine filtering
    var filterCriteria: EventFilterCriteria {
        // Build filter criteria from event data
        // Note: Full implementation would extract criteria from regionTypes/regionStates
        let criteria = EventFilterCriteria()
        return criteria
    }
}

// Note: EventConsequences doesn't have triggeredEncounter or triggeredMiniGame
// Combat is triggered through GameEvent.monsterCard != nil
// Mini-games are triggered through specific event types or game logic


// ==========================================
// FILE: Engine/Events/MiniGameDispatcher.swift
// ==========================================

import Foundation

// MARK: - MiniGame Dispatcher
// Routes mini-game challenges to appropriate resolvers
// Returns result as StateChange diff (no direct state mutation)

/// Dispatches mini-game challenges to resolvers
final class MiniGameDispatcher {
    // MARK: - Resolvers

    private let combatResolver: CombatMiniGameResolver
    private let puzzleResolver: PuzzleMiniGameResolver
    private let skillCheckResolver: SkillCheckResolver

    // MARK: - Initialization

    init() {
        self.combatResolver = CombatMiniGameResolver()
        self.puzzleResolver = PuzzleMiniGameResolver()
        self.skillCheckResolver = SkillCheckResolver()
    }

    // MARK: - Dispatch

    /// Dispatch a mini-game challenge and return result
    func dispatch(
        challenge: MiniGameChallenge,
        context: MiniGameContext
    ) -> MiniGameDispatchResult {

        switch challenge.type {
        case .combat:
            return combatResolver.resolve(challenge: challenge, context: context)

        case .puzzle:
            return puzzleResolver.resolve(challenge: challenge, context: context)

        case .skillCheck:
            return skillCheckResolver.resolve(challenge: challenge, context: context)

        case .cardGame:
            // Card-based mini-game (future)
            return MiniGameDispatchResult.notImplemented(type: "cardGame")

        case .custom(let type):
            // Custom mini-game type
            return MiniGameDispatchResult.notImplemented(type: type)
        }
    }

    /// Check if challenge can be started
    func canStartChallenge(
        _ challenge: MiniGameChallenge,
        context: MiniGameContext
    ) -> (canStart: Bool, reason: String?) {

        // Check health minimum
        if context.playerHealth <= 0 {
            return (false, "Player health too low")
        }

        // Check type-specific requirements
        switch challenge.type {
        case .combat:
            // Combat requires health > 0
            return (true, nil)

        case .skillCheck:
            // Skill checks may require specific resources
            if let requiredResource = challenge.requirements["resource"],
               let required = challenge.requirements["amount"] as? Int,
               (context.playerResources[requiredResource as? String ?? ""] ?? 0) < required {
                return (false, "Insufficient \(requiredResource)")
            }
            return (true, nil)

        default:
            return (true, nil)
        }
    }
}

// MARK: - Mini-Game Challenge

/// Definition of a mini-game challenge
struct MiniGameChallenge {
    let id: UUID
    let type: MiniGameType
    let difficulty: Int
    let requirements: [String: Any]
    let rewards: MiniGameRewards
    let penalties: MiniGamePenalties

    init(
        id: UUID = UUID(),
        type: MiniGameType,
        difficulty: Int = 1,
        requirements: [String: Any] = [:],
        rewards: MiniGameRewards = MiniGameRewards(),
        penalties: MiniGamePenalties = MiniGamePenalties()
    ) {
        self.id = id
        self.type = type
        self.difficulty = difficulty
        self.requirements = requirements
        self.rewards = rewards
        self.penalties = penalties
    }
}

/// Types of mini-games
enum MiniGameType: Equatable {
    case combat
    case puzzle
    case skillCheck
    case cardGame
    case custom(String)
}

/// Rewards for completing mini-game
struct MiniGameRewards {
    var healthGain: Int = 0
    var faithGain: Int = 0
    var tensionReduction: Int = 0
    var flagsToSet: [String] = []
    var cardsToGain: [UUID] = []
}

/// Penalties for failing mini-game
struct MiniGamePenalties {
    var healthLoss: Int = 0
    var faithLoss: Int = 0
    var tensionIncrease: Int = 0
    var balanceShift: Int = 0
}

// MARK: - Mini-Game Context

/// Context for mini-game resolution
struct MiniGameContext {
    let playerHealth: Int
    let playerMaxHealth: Int
    let playerStrength: Int
    let playerFaith: Int
    let playerBalance: Int
    let playerResources: [String: Int]
    let worldTension: Int
    let currentFlags: [String: Bool]

    /// Build from Player and WorldState
    static func from(player: Player, worldState: WorldState) -> MiniGameContext {
        MiniGameContext(
            playerHealth: player.health,
            playerMaxHealth: player.maxHealth,
            playerStrength: player.strength,
            playerFaith: player.faith,
            playerBalance: player.balance,
            playerResources: ["faith": player.faith, "health": player.health],
            worldTension: worldState.worldTension,
            currentFlags: worldState.worldFlags
        )
    }
}

// MARK: - Mini-Game Dispatch Result

/// Result of mini-game dispatch
struct MiniGameDispatchResult {
    let success: Bool
    let completed: Bool
    let stateChanges: [StateChange]
    let narrativeText: String?
    let error: String?

    static func victory(changes: [StateChange], narrative: String? = nil) -> MiniGameDispatchResult {
        MiniGameDispatchResult(
            success: true,
            completed: true,
            stateChanges: changes,
            narrativeText: narrative,
            error: nil
        )
    }

    static func defeat(changes: [StateChange], narrative: String? = nil) -> MiniGameDispatchResult {
        MiniGameDispatchResult(
            success: true,
            completed: true,
            stateChanges: changes,
            narrativeText: narrative,
            error: nil
        )
    }

    static func inProgress(changes: [StateChange]) -> MiniGameDispatchResult {
        MiniGameDispatchResult(
            success: true,
            completed: false,
            stateChanges: changes,
            narrativeText: nil,
            error: nil
        )
    }

    static func notImplemented(type: String) -> MiniGameDispatchResult {
        MiniGameDispatchResult(
            success: false,
            completed: false,
            stateChanges: [],
            narrativeText: nil,
            error: "Mini-game type '\(type)' not implemented"
        )
    }

    static func failure(_ error: String) -> MiniGameDispatchResult {
        MiniGameDispatchResult(
            success: false,
            completed: false,
            stateChanges: [],
            narrativeText: nil,
            error: error
        )
    }
}

// MARK: - Combat Mini-Game Resolver

/// Resolves combat mini-games
final class CombatMiniGameResolver {
    func resolve(
        challenge: MiniGameChallenge,
        context: MiniGameContext
    ) -> MiniGameDispatchResult {

        var changes: [StateChange] = []

        // Simple combat resolution using WorldRNG
        let playerRoll = WorldRNG.shared.nextInt(in: 1...6) + context.playerStrength
        let enemyRoll = WorldRNG.shared.nextInt(in: 1...6) + challenge.difficulty

        if playerRoll >= enemyRoll {
            // Victory
            // Apply rewards
            if challenge.rewards.healthGain > 0 {
                let newHealth = min(context.playerMaxHealth, context.playerHealth + challenge.rewards.healthGain)
                changes.append(.healthChanged(delta: challenge.rewards.healthGain, newValue: newHealth))
            }

            if challenge.rewards.faithGain > 0 {
                let newFaith = context.playerFaith + challenge.rewards.faithGain
                changes.append(.faithChanged(delta: challenge.rewards.faithGain, newValue: newFaith))
            }

            for flag in challenge.rewards.flagsToSet {
                changes.append(.flagSet(key: flag, value: true))
            }

            return .victory(changes: changes, narrative: "Победа в бою!")
        } else {
            // Defeat
            // Apply penalties
            if challenge.penalties.healthLoss > 0 {
                let newHealth = max(0, context.playerHealth - challenge.penalties.healthLoss)
                changes.append(.healthChanged(delta: -challenge.penalties.healthLoss, newValue: newHealth))
            }

            if challenge.penalties.balanceShift != 0 {
                let newBalance = max(0, min(100, context.playerBalance + challenge.penalties.balanceShift))
                changes.append(.balanceChanged(delta: challenge.penalties.balanceShift, newValue: newBalance))
            }

            return .defeat(changes: changes, narrative: "Поражение в бою...")
        }
    }
}

// MARK: - Puzzle Mini-Game Resolver

/// Resolves puzzle mini-games
final class PuzzleMiniGameResolver {
    func resolve(
        challenge: MiniGameChallenge,
        context: MiniGameContext
    ) -> MiniGameDispatchResult {

        var changes: [StateChange] = []

        // Simple puzzle resolution based on faith/wisdom
        let successChance = min(90, 50 + context.playerFaith * 5)
        let roll = WorldRNG.shared.nextInt(in: 1...100)

        if roll <= successChance {
            // Success
            if challenge.rewards.faithGain > 0 {
                let newFaith = context.playerFaith + challenge.rewards.faithGain
                changes.append(.faithChanged(delta: challenge.rewards.faithGain, newValue: newFaith))
            }

            for flag in challenge.rewards.flagsToSet {
                changes.append(.flagSet(key: flag, value: true))
            }

            return .victory(changes: changes, narrative: "Загадка разгадана!")
        } else {
            // Failure
            if challenge.penalties.tensionIncrease > 0 {
                let newTension = min(100, context.worldTension + challenge.penalties.tensionIncrease)
                changes.append(.tensionChanged(delta: challenge.penalties.tensionIncrease, newValue: newTension))
            }

            return .defeat(changes: changes, narrative: "Загадка осталась неразгаданной...")
        }
    }
}

// MARK: - Skill Check Resolver

/// Resolves skill check mini-games
final class SkillCheckResolver {
    func resolve(
        challenge: MiniGameChallenge,
        context: MiniGameContext
    ) -> MiniGameDispatchResult {

        var changes: [StateChange] = []

        // Skill check based on relevant stat
        let targetNumber = challenge.difficulty * 3
        let roll = WorldRNG.shared.nextInt(in: 1...20) + context.playerStrength

        if roll >= targetNumber {
            // Success
            for flag in challenge.rewards.flagsToSet {
                changes.append(.flagSet(key: flag, value: true))
            }

            return .victory(changes: changes, narrative: "Проверка навыка пройдена!")
        } else {
            // Failure
            return .defeat(changes: changes, narrative: "Проверка навыка провалена...")
        }
    }
}


// ==========================================
// FILE: Engine/Modules/CombatModule.swift
// ==========================================

import Foundation

// MARK: - Combat Module
// Engine integration for combat system
// Wraps CombatCalculator and provides state change diffs

/// Combat module for engine integration
final class CombatModule {
    // MARK: - State

    private(set) var isInCombat: Bool = false
    private(set) var currentEncounter: CombatEncounter?
    private(set) var combatLog: [CombatLogEntry] = []
    private(set) var turnNumber: Int = 0
    private(set) var playerActionsRemaining: Int = 3

    // MARK: - Combat Entry

    /// Start combat with an encounter
    func startCombat(encounter: CombatEncounter) -> [StateChange] {
        isInCombat = true
        currentEncounter = encounter
        combatLog = []
        turnNumber = 1
        playerActionsRemaining = 3

        return [
            .custom(key: "combat_started", description: "Combat started with \(encounter.name)")
        ]
    }

    /// End combat
    func endCombat(victory: Bool) -> [StateChange] {
        let changes: [StateChange] = [
            .combatEnded(victory: victory)
        ]

        isInCombat = false
        currentEncounter = nil
        combatLog = []
        turnNumber = 0
        playerActionsRemaining = 0

        return changes
    }

    // MARK: - Combat Actions

    /// Execute player attack
    func executeAttack(
        player: Player,
        bonusDice: Int = 0,
        bonusDamage: Int = 0,
        isFirstAttack: Bool = false
    ) -> CombatActionResult {

        guard let encounter = currentEncounter else {
            return CombatActionResult.failure("No active encounter")
        }

        guard playerActionsRemaining > 0 else {
            return CombatActionResult.failure("No actions remaining")
        }

        playerActionsRemaining -= 1

        // Use CombatCalculator
        let result = CombatCalculator.calculatePlayerAttack(
            player: player,
            monsterDefense: encounter.defense,
            monsterCurrentHP: encounter.currentHP,
            monsterMaxHP: encounter.maxHP,
            bonusDice: bonusDice,
            bonusDamage: bonusDamage,
            isFirstAttack: isFirstAttack
        )

        var stateChanges: [StateChange] = []
        var logEntry = CombatLogEntry(
            turn: turnNumber,
            actor: .player,
            action: "Attack",
            result: result.isHit ? "Hit" : "Miss",
            details: result.logDescription
        )

        if result.isHit, let damage = result.damageCalculation {
            // Apply damage to encounter
            currentEncounter?.currentHP -= damage.total
            stateChanges.append(.enemyDamaged(
                enemyId: encounter.id,
                damage: damage.total,
                newHealth: currentEncounter?.currentHP ?? 0
            ))

            // Check if defeated
            if currentEncounter?.currentHP ?? 0 <= 0 {
                stateChanges.append(.enemyDefeated(enemyId: encounter.id))
                logEntry.result = "Defeat!"
            }
        }

        combatLog.append(logEntry)

        return CombatActionResult.success(
            stateChanges: stateChanges,
            combatResult: result,
            encounterDefeated: currentEncounter?.currentHP ?? 0 <= 0
        )
    }

    /// Execute player card play
    func playCard(
        cardId: UUID,
        player: Player,
        effects: [CardEffect]
    ) -> CombatActionResult {

        guard currentEncounter != nil else {
            return CombatActionResult.failure("No active encounter")
        }

        guard playerActionsRemaining > 0 else {
            return CombatActionResult.failure("No actions remaining")
        }

        playerActionsRemaining -= 1

        var stateChanges: [StateChange] = []

        // Apply card effects
        for effect in effects {
            switch effect {
            case .damage(let amount, _):
                currentEncounter?.currentHP -= amount
                if let encounter = currentEncounter {
                    stateChanges.append(.enemyDamaged(
                        enemyId: encounter.id,
                        damage: amount,
                        newHealth: encounter.currentHP
                    ))
                }

            case .heal(let amount):
                let newHealth = min(player.maxHealth, player.health + amount)
                stateChanges.append(.healthChanged(delta: amount, newValue: newHealth))

            case .drawCards(let count):
                stateChanges.append(.custom(key: "draw_cards", description: "Draw \(count) cards"))

            case .gainFaith(let amount):
                stateChanges.append(.faithChanged(delta: amount, newValue: player.faith + amount))

            case .bonusDice(let count):
                stateChanges.append(.custom(key: "bonus_dice", description: "Gained \(count) bonus dice"))

            case .bonusDamage(let amount):
                stateChanges.append(.custom(key: "bonus_damage", description: "Gained \(amount) bonus damage"))

            case .balanceShift(let amount):
                let newBalance = max(0, min(100, player.balance + amount))
                stateChanges.append(.balanceChanged(delta: amount, newValue: newBalance))
            }
        }

        // Check if encounter defeated
        if currentEncounter?.currentHP ?? 0 <= 0 {
            if let encounter = currentEncounter {
                stateChanges.append(.enemyDefeated(enemyId: encounter.id))
            }
        }

        let logEntry = CombatLogEntry(
            turn: turnNumber,
            actor: .player,
            action: "Card",
            result: "Applied",
            details: "Card effects applied"
        )
        combatLog.append(logEntry)

        return CombatActionResult.success(
            stateChanges: stateChanges,
            combatResult: nil,
            encounterDefeated: currentEncounter?.currentHP ?? 0 <= 0
        )
    }

    /// End player turn
    func endPlayerTurn(player: Player) -> CombatActionResult {
        guard let encounter = currentEncounter else {
            return CombatActionResult.failure("No active encounter")
        }

        var stateChanges: [StateChange] = []

        // Enemy attack
        let enemyAttack = calculateEnemyAttack(encounter: encounter, player: player)
        stateChanges.append(contentsOf: enemyAttack.stateChanges)

        // Check if player defeated
        let playerDefeated = player.health + (enemyAttack.healthChange) <= 0

        // Start new turn
        turnNumber += 1
        playerActionsRemaining = 3

        // Apply exhaustion curse if present
        if player.hasCurse(.exhaustion) {
            playerActionsRemaining -= 1
            stateChanges.append(.custom(key: "exhaustion", description: "Exhaustion: -1 action"))
        }

        let logEntry = CombatLogEntry(
            turn: turnNumber - 1,
            actor: .enemy,
            action: "Attack",
            result: enemyAttack.hit ? "Hit" : "Miss",
            details: enemyAttack.description
        )
        combatLog.append(logEntry)

        return CombatActionResult.success(
            stateChanges: stateChanges,
            combatResult: nil,
            encounterDefeated: false,
            playerDefeated: playerDefeated
        )
    }

    // MARK: - Enemy AI

    private func calculateEnemyAttack(
        encounter: CombatEncounter,
        player: Player
    ) -> (stateChanges: [StateChange], hit: Bool, healthChange: Int, description: String) {

        var stateChanges: [StateChange] = []

        // Enemy attack roll
        let attackRoll = WorldRNG.shared.nextInt(in: 1...6) + encounter.strength
        let playerDefense = 5 + (player.strength / 2)

        let hit = attackRoll >= playerDefense
        var healthChange = 0

        if hit {
            var damage = max(1, encounter.strength - 2)

            // Priest reduces dark damage
            if player.heroClass == .priest {
                damage = max(1, damage - 1)
            }

            healthChange = -damage
            stateChanges.append(.healthChanged(delta: -damage, newValue: player.health - damage))
        }

        let description = hit
            ? "Enemy hit for \(-healthChange) damage"
            : "Enemy missed"

        return (stateChanges, hit, healthChange, description)
    }
}

// MARK: - Combat Encounter

/// Combat encounter state
struct CombatEncounter {
    let id: UUID
    let name: String
    let maxHP: Int
    var currentHP: Int
    let strength: Int
    let defense: Int
    let isBoss: Bool

    init(
        id: UUID = UUID(),
        name: String,
        maxHP: Int,
        strength: Int,
        defense: Int,
        isBoss: Bool = false
    ) {
        self.id = id
        self.name = name
        self.maxHP = maxHP
        self.currentHP = maxHP
        self.strength = strength
        self.defense = defense
        self.isBoss = isBoss
    }

    /// Create from Card (monster)
    /// Maps Card stats: health -> maxHP, power -> strength, defense -> defense
    /// Boss detection: legendary rarity or "boss" trait
    static func from(card: Card) -> CombatEncounter {
        // Determine if card is a boss (legendary rarity or has boss trait)
        let isBoss = card.rarity == .legendary || card.traits.contains("boss")

        return CombatEncounter(
            id: card.id,
            name: card.name,
            maxHP: card.health ?? 10,
            strength: card.power ?? 3,
            defense: card.defense ?? 5,
            isBoss: isBoss
        )
    }
}

// MARK: - Combat Action Result

/// Result of combat action
struct CombatActionResult {
    let success: Bool
    let error: String?
    let stateChanges: [StateChange]
    let combatResult: CombatResult?
    let encounterDefeated: Bool
    let playerDefeated: Bool

    static func success(
        stateChanges: [StateChange],
        combatResult: CombatResult?,
        encounterDefeated: Bool,
        playerDefeated: Bool = false
    ) -> CombatActionResult {
        CombatActionResult(
            success: true,
            error: nil,
            stateChanges: stateChanges,
            combatResult: combatResult,
            encounterDefeated: encounterDefeated,
            playerDefeated: playerDefeated
        )
    }

    static func failure(_ error: String) -> CombatActionResult {
        CombatActionResult(
            success: false,
            error: error,
            stateChanges: [],
            combatResult: nil,
            encounterDefeated: false,
            playerDefeated: false
        )
    }
}

// MARK: - Combat Log Entry

/// Entry in combat log
struct CombatLogEntry {
    let turn: Int
    let actor: CombatActor
    var action: String
    var result: String
    let details: String
}

enum CombatActor {
    case player
    case enemy
}

// MARK: - Card Effect

/// Effects that cards can have in combat
enum CardEffect {
    case damage(amount: Int, type: CombatDamageKind)
    case heal(amount: Int)
    case drawCards(count: Int)
    case gainFaith(amount: Int)
    case bonusDice(count: Int)
    case bonusDamage(amount: Int)
    case balanceShift(amount: Int)
}

/// Simplified damage categories for combat resolution
/// Different from DamageType in CardType.swift (detailed card damage types)
enum CombatDamageKind {
    case physical
    case magical
    case light
    case dark
}


// ==========================================
// FILE: Engine/Data/Providers/CodeContentProvider.swift
// ==========================================

import Foundation

// MARK: - Code Content Provider
// Reference: Docs/MIGRATION_PLAN.md, Feature A3
// Adapter for existing TwilightMarchesConfig content

/// Content provider that loads definitions from Swift code.
/// This is an adapter for the existing TwilightMarchesConfig.swift content.
/// Will be replaced/augmented by JSONContentProvider in Phase 5.
class CodeContentProvider: ContentProvider {
    // MARK: - Cached Definitions

    private var regions: [String: RegionDefinition] = [:]
    private var anchors: [String: AnchorDefinition] = [:]
    private var events: [String: EventDefinition] = [:]
    private var quests: [String: QuestDefinition] = [:]
    private var miniGameChallenges: [String: MiniGameChallengeDefinition] = [:]

    // MARK: - Event Pool Index

    private var eventsByPool: [String: [EventDefinition]] = [:]
    private var eventsByRegion: [String: [EventDefinition]] = [:]

    // MARK: - Initialization

    init() {
        loadContent()
    }

    /// Load all content from code definitions
    private func loadContent() {
        loadRegions()
        loadAnchors()
        loadEvents()
        loadQuests()
        loadMiniGameChallenges()
        buildEventIndices()
    }

    // MARK: - Content Loading (Override in subclass for actual content)

    /// Load region definitions
    /// Subclass should override to provide actual regions
    func loadRegions() {
        // Default implementation - subclass overrides with actual content
        // Example region for testing (uses generic IDs, not game-specific):
        let testRegion = RegionDefinition(
            id: "test_region",
            title: LocalizedString(en: "Test Region", ru: "Тестовый Регион"),
            description: LocalizedString(en: "A test region", ru: "Тестовый регион"),
            regionType: "forest",
            neighborIds: ["test_neighbor"],
            initiallyDiscovered: true,
            anchorId: "test_anchor",
            eventPoolIds: ["pool_common"],
            initialState: .stable
        )
        regions[testRegion.id] = testRegion
    }

    /// Load anchor definitions
    func loadAnchors() {
        // Default implementation - subclass overrides (uses generic IDs, not game-specific)
        let testAnchor = AnchorDefinition(
            id: "test_anchor",
            title: LocalizedString(en: "Test Anchor", ru: "Тестовый Якорь"),
            description: LocalizedString(en: "A test anchor", ru: "Тестовый якорь"),
            regionId: "test_region"
        )
        anchors[testAnchor.id] = testAnchor
    }

    /// Load event definitions
    func loadEvents() {
        // Default implementation - subclass overrides
        let testEvent = EventDefinition(
            id: "event_test",
            title: LocalizedString(en: "Test Event", ru: "Тестовое Событие"),
            body: LocalizedString(en: "A test event", ru: "Тестовое событие"),
            eventKind: .inline,
            poolIds: ["pool_common"],
            choices: [
                ChoiceDefinition(
                    id: "choice_a",
                    label: LocalizedString(en: "Choice A", ru: "Выбор А"),
                    consequences: ChoiceConsequences(resourceChanges: ["faith": -2])
                ),
                ChoiceDefinition(
                    id: "choice_b",
                    label: LocalizedString(en: "Choice B", ru: "Выбор Б"),
                    consequences: ChoiceConsequences(resourceChanges: ["health": -3])
                )
            ]
        )
        events[testEvent.id] = testEvent
    }

    /// Load quest definitions
    func loadQuests() {
        // Default implementation - subclass overrides
        let testQuest = QuestDefinition(
            id: "quest_test",
            title: LocalizedString(en: "Test Quest", ru: "Тестовое Задание"),
            description: LocalizedString(en: "A test quest", ru: "Тестовое задание"),
            objectives: [
                ObjectiveDefinition(
                    id: "obj_1",
                    description: LocalizedString(en: "Objective 1", ru: "Цель 1"),
                    completionCondition: .manual,
                    nextObjectiveId: "obj_2"
                ),
                ObjectiveDefinition(
                    id: "obj_2",
                    description: LocalizedString(en: "Objective 2", ru: "Цель 2"),
                    completionCondition: .manual
                )
            ]
        )
        quests[testQuest.id] = testQuest
    }

    /// Load mini-game challenge definitions
    func loadMiniGameChallenges() {
        // Default implementation - subclass overrides
        let testCombat = MiniGameChallengeDefinition(
            id: "combat_test",
            challengeKind: .combat,
            difficulty: 5
        )
        miniGameChallenges[testCombat.id] = testCombat
    }

    /// Build event indices for fast lookup
    private func buildEventIndices() {
        eventsByPool.removeAll()
        eventsByRegion.removeAll()

        for event in events.values {
            // Index by pool
            for poolId in event.poolIds {
                eventsByPool[poolId, default: []].append(event)
            }

            // Index by region (from availability)
            if let regionIds = event.availability.regionIds {
                for regionId in regionIds {
                    eventsByRegion[regionId, default: []].append(event)
                }
            }
        }
    }

    // MARK: - Registration (for building content)

    func registerRegion(_ region: RegionDefinition) {
        regions[region.id] = region
    }

    func registerAnchor(_ anchor: AnchorDefinition) {
        anchors[anchor.id] = anchor
    }

    func registerEvent(_ event: EventDefinition) {
        events[event.id] = event
    }

    func registerQuest(_ quest: QuestDefinition) {
        quests[quest.id] = quest
    }

    func registerMiniGameChallenge(_ challenge: MiniGameChallengeDefinition) {
        miniGameChallenges[challenge.id] = challenge
    }

    func rebuildIndices() {
        buildEventIndices()
    }

    // MARK: - ContentProvider Implementation

    func getAllRegionDefinitions() -> [RegionDefinition] {
        return Array(regions.values)
    }

    func getRegionDefinition(id: String) -> RegionDefinition? {
        return regions[id]
    }

    func getAllAnchorDefinitions() -> [AnchorDefinition] {
        return Array(anchors.values)
    }

    func getAnchorDefinition(id: String) -> AnchorDefinition? {
        return anchors[id]
    }

    func getAnchorDefinition(forRegion regionId: String) -> AnchorDefinition? {
        return anchors.values.first { $0.regionId == regionId }
    }

    func getAllEventDefinitions() -> [EventDefinition] {
        return Array(events.values)
    }

    func getEventDefinition(id: String) -> EventDefinition? {
        return events[id]
    }

    func getEventDefinitions(forRegion regionId: String) -> [EventDefinition] {
        // Get events from region's pools
        guard let region = regions[regionId] else { return [] }

        var result: [EventDefinition] = []
        for poolId in region.eventPoolIds {
            result.append(contentsOf: eventsByPool[poolId] ?? [])
        }

        // Add events specifically for this region
        result.append(contentsOf: eventsByRegion[regionId] ?? [])

        // Remove duplicates while preserving order
        var seen = Set<String>()
        return result.filter { seen.insert($0.id).inserted }
    }

    func getEventDefinitions(forPool poolId: String) -> [EventDefinition] {
        return eventsByPool[poolId] ?? []
    }

    func getAllQuestDefinitions() -> [QuestDefinition] {
        return Array(quests.values)
    }

    func getQuestDefinition(id: String) -> QuestDefinition? {
        return quests[id]
    }

    func getAllMiniGameChallenges() -> [MiniGameChallengeDefinition] {
        return Array(miniGameChallenges.values)
    }

    func getMiniGameChallenge(id: String) -> MiniGameChallengeDefinition? {
        return miniGameChallenges[id]
    }

    func validate() -> [ContentValidationError] {
        let validator = ContentValidator(provider: self)
        return validator.validate()
    }
}


// ==========================================
// FILE: Engine/Data/Providers/ContentProvider.swift
// ==========================================

import Foundation

// MARK: - Content Provider Protocol
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.3
// Reference: Docs/MIGRATION_PLAN.md, Feature A3

/// Protocol for loading game content definitions.
/// Abstracts the source of content (code, JSON, database, etc.)
protocol ContentProvider {
    // MARK: - Regions

    /// Get all region definitions
    func getAllRegionDefinitions() -> [RegionDefinition]

    /// Get a specific region by ID
    func getRegionDefinition(id: String) -> RegionDefinition?

    // MARK: - Anchors

    /// Get all anchor definitions
    func getAllAnchorDefinitions() -> [AnchorDefinition]

    /// Get a specific anchor by ID
    func getAnchorDefinition(id: String) -> AnchorDefinition?

    /// Get anchor for a region
    func getAnchorDefinition(forRegion regionId: String) -> AnchorDefinition?

    // MARK: - Events

    /// Get all event definitions
    func getAllEventDefinitions() -> [EventDefinition]

    /// Get a specific event by ID
    func getEventDefinition(id: String) -> EventDefinition?

    /// Get events for a specific region
    func getEventDefinitions(forRegion regionId: String) -> [EventDefinition]

    /// Get events for a specific pool
    func getEventDefinitions(forPool poolId: String) -> [EventDefinition]

    // MARK: - Quests

    /// Get all quest definitions
    func getAllQuestDefinitions() -> [QuestDefinition]

    /// Get a specific quest by ID
    func getQuestDefinition(id: String) -> QuestDefinition?

    // MARK: - Mini-Game Challenges

    /// Get all mini-game challenge definitions
    func getAllMiniGameChallenges() -> [MiniGameChallengeDefinition]

    /// Get a specific challenge by ID
    func getMiniGameChallenge(id: String) -> MiniGameChallengeDefinition?

    // MARK: - Validation

    /// Validate all content for consistency
    func validate() -> [ContentValidationError]
}

// MARK: - Content Validation Error

/// Error found during content validation
struct ContentValidationError: Equatable, CustomStringConvertible {
    /// Type of validation error
    let type: ErrorType

    /// Affected definition ID
    let definitionId: String

    /// Detailed error message
    let message: String

    var description: String {
        return "[\(type.rawValue)] \(definitionId): \(message)"
    }

    enum ErrorType: String, Equatable {
        case duplicateId = "DUPLICATE_ID"
        case brokenReference = "BROKEN_REFERENCE"
        case invalidRange = "INVALID_RANGE"
        case missingRequired = "MISSING_REQUIRED"
        case emptyChoices = "EMPTY_CHOICES"
        case invalidLocalizationKey = "INVALID_KEY"
        case circularReference = "CIRCULAR_REF"
    }
}

// MARK: - Content Validator

/// Validates content from a provider
struct ContentValidator {
    let provider: ContentProvider

    init(provider: ContentProvider) {
        self.provider = provider
    }

    /// Run all validation checks
    func validate() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []

        errors.append(contentsOf: validateUniqueIds())
        errors.append(contentsOf: validateRegionReferences())
        errors.append(contentsOf: validateAnchorReferences())
        errors.append(contentsOf: validateEventReferences())
        errors.append(contentsOf: validateQuestReferences())
        errors.append(contentsOf: validateEventChoices())
        errors.append(contentsOf: validateRanges())

        return errors
    }

    // MARK: - Validation Checks

    /// Check for duplicate IDs within each type
    private func validateUniqueIds() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []

        // Regions
        let regionIds = provider.getAllRegionDefinitions().map { $0.id }
        for (id, count) in Dictionary(grouping: regionIds, by: { $0 }).filter({ $0.value.count > 1 }) {
            errors.append(ContentValidationError(
                type: .duplicateId,
                definitionId: id,
                message: "Region ID appears \(count.count) times"
            ))
        }

        // Events
        let eventIds = provider.getAllEventDefinitions().map { $0.id }
        for (id, count) in Dictionary(grouping: eventIds, by: { $0 }).filter({ $0.value.count > 1 }) {
            errors.append(ContentValidationError(
                type: .duplicateId,
                definitionId: id,
                message: "Event ID appears \(count.count) times"
            ))
        }

        // Quests
        let questIds = provider.getAllQuestDefinitions().map { $0.id }
        for (id, count) in Dictionary(grouping: questIds, by: { $0 }).filter({ $0.value.count > 1 }) {
            errors.append(ContentValidationError(
                type: .duplicateId,
                definitionId: id,
                message: "Quest ID appears \(count.count) times"
            ))
        }

        return errors
    }

    /// Check that region neighbor references exist
    private func validateRegionReferences() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []
        let allRegionIds = Set(provider.getAllRegionDefinitions().map { $0.id })

        for region in provider.getAllRegionDefinitions() {
            for neighborId in region.neighborIds {
                if !allRegionIds.contains(neighborId) {
                    errors.append(ContentValidationError(
                        type: .brokenReference,
                        definitionId: region.id,
                        message: "Neighbor '\(neighborId)' does not exist"
                    ))
                }
            }
        }

        return errors
    }

    /// Check that anchor region references exist
    private func validateAnchorReferences() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []
        let allRegionIds = Set(provider.getAllRegionDefinitions().map { $0.id })

        for anchor in provider.getAllAnchorDefinitions() {
            if !allRegionIds.contains(anchor.regionId) {
                errors.append(ContentValidationError(
                    type: .brokenReference,
                    definitionId: anchor.id,
                    message: "Region '\(anchor.regionId)' does not exist"
                ))
            }
        }

        return errors
    }

    /// Check event references
    private func validateEventReferences() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []
        let allEventIds = Set(provider.getAllEventDefinitions().map { $0.id })
        let allRegionIds = Set(provider.getAllRegionDefinitions().map { $0.id })

        for event in provider.getAllEventDefinitions() {
            // Check region references in availability
            if let regionIds = event.availability.regionIds {
                for regionId in regionIds {
                    if !allRegionIds.contains(regionId) {
                        errors.append(ContentValidationError(
                            type: .brokenReference,
                            definitionId: event.id,
                            message: "Region '\(regionId)' in availability does not exist"
                        ))
                    }
                }
            }

            // Check trigger event references
            for choice in event.choices {
                if let triggerId = choice.consequences.triggerEventId {
                    if !allEventIds.contains(triggerId) {
                        errors.append(ContentValidationError(
                            type: .brokenReference,
                            definitionId: event.id,
                            message: "Trigger event '\(triggerId)' in choice '\(choice.id)' does not exist"
                        ))
                    }
                }
            }
        }

        return errors
    }

    /// Check quest references
    private func validateQuestReferences() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []
        let allEventIds = Set(provider.getAllEventDefinitions().map { $0.id })
        let allRegionIds = Set(provider.getAllRegionDefinitions().map { $0.id })

        for quest in provider.getAllQuestDefinitions() {
            let objectiveIds = Set(quest.objectives.map { $0.id })

            for objective in quest.objectives {
                // Check next objective reference
                if let nextId = objective.nextObjectiveId, !objectiveIds.contains(nextId) {
                    errors.append(ContentValidationError(
                        type: .brokenReference,
                        definitionId: quest.id,
                        message: "Objective '\(objective.id)' references non-existent next '\(nextId)'"
                    ))
                }

                // Check completion condition references
                switch objective.completionCondition {
                case .eventCompleted(let eventId):
                    if !allEventIds.contains(eventId) {
                        errors.append(ContentValidationError(
                            type: .brokenReference,
                            definitionId: quest.id,
                            message: "Objective '\(objective.id)' references non-existent event '\(eventId)'"
                        ))
                    }
                case .visitRegion(let regionId):
                    if !allRegionIds.contains(regionId) {
                        errors.append(ContentValidationError(
                            type: .brokenReference,
                            definitionId: quest.id,
                            message: "Objective '\(objective.id)' references non-existent region '\(regionId)'"
                        ))
                    }
                case .choiceMade(let eventId, _):
                    if !allEventIds.contains(eventId) {
                        errors.append(ContentValidationError(
                            type: .brokenReference,
                            definitionId: quest.id,
                            message: "Objective '\(objective.id)' references non-existent event '\(eventId)'"
                        ))
                    }
                default:
                    break
                }
            }
        }

        return errors
    }

    /// Check that events have valid choices
    private func validateEventChoices() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []

        for event in provider.getAllEventDefinitions() {
            // Inline events should have at least 2 choices
            if case .inline = event.eventKind {
                if event.choices.isEmpty {
                    errors.append(ContentValidationError(
                        type: .emptyChoices,
                        definitionId: event.id,
                        message: "Inline event has no choices"
                    ))
                } else if event.choices.count < 2 {
                    errors.append(ContentValidationError(
                        type: .emptyChoices,
                        definitionId: event.id,
                        message: "Inline event should have at least 2 choices"
                    ))
                }
            }

            // Check for duplicate choice IDs within event
            let choiceIds = event.choices.map { $0.id }
            for (id, count) in Dictionary(grouping: choiceIds, by: { $0 }).filter({ $0.value.count > 1 }) {
                errors.append(ContentValidationError(
                    type: .duplicateId,
                    definitionId: event.id,
                    message: "Choice ID '\(id)' appears \(count.count) times"
                ))
            }
        }

        return errors
    }

    /// Check pressure/balance ranges are valid
    private func validateRanges() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []

        for event in provider.getAllEventDefinitions() {
            // Check pressure range
            if let min = event.availability.minPressure, let max = event.availability.maxPressure {
                if min > max {
                    errors.append(ContentValidationError(
                        type: .invalidRange,
                        definitionId: event.id,
                        message: "minPressure (\(min)) > maxPressure (\(max))"
                    ))
                }
            }

            // Check balance range
            if let min = event.availability.minBalance, let max = event.availability.maxBalance {
                if min > max {
                    errors.append(ContentValidationError(
                        type: .invalidRange,
                        definitionId: event.id,
                        message: "minBalance (\(min)) > maxBalance (\(max))"
                    ))
                }
            }

            // Check choice requirements
            for choice in event.choices {
                if let requirements = choice.requirements {
                    let minBal = requirements.minBalance ?? -100
                    let maxBal = requirements.maxBalance ?? 100
                    if minBal < -100 || maxBal > 100 {
                        errors.append(ContentValidationError(
                            type: .invalidRange,
                            definitionId: event.id,
                            message: "Choice '\(choice.id)' has balance range outside -100...100"
                        ))
                    }
                }
            }
        }

        return errors
    }
}


// ==========================================
// FILE: Engine/Data/Providers/JSONContentProvider.swift
// ==========================================

import Foundation

// MARK: - JSON Content Provider
// Reference: Docs/MIGRATION_PLAN.md, Feature A3 / EPIC D
// Phase 5 Implementation - Real cartridge-data-driven

/// Content provider that loads definitions from JSON files.
/// This is the "cartridge" approach - content as external data.
class JSONContentProvider: ContentProvider {
    // MARK: - Configuration

    /// Base path for content JSON files
    let contentPath: String

    /// Bundle containing content (nil = main bundle)
    let bundle: Bundle

    // MARK: - Cached Definitions (internal for @testable import)

    private(set) var regions: [String: RegionDefinition] = [:]
    private(set) var anchors: [String: AnchorDefinition] = [:]
    private(set) var events: [String: EventDefinition] = [:]
    private(set) var quests: [String: QuestDefinition] = [:]
    private(set) var miniGameChallenges: [String: MiniGameChallengeDefinition] = [:]

    // MARK: - Event Indices (internal for @testable import)

    private(set) var eventsByPool: [String: [EventDefinition]] = [:]
    private(set) var eventsByRegion: [String: [EventDefinition]] = [:]

    // MARK: - Loading State

    private(set) var isLoaded: Bool = false
    private(set) var loadErrors: [String] = []

    // MARK: - Initialization

    init(contentPath: String = "Content", bundle: Bundle? = nil) {
        self.contentPath = contentPath
        self.bundle = bundle ?? Bundle.main
    }

    /// Initialize and load content
    convenience init(loadImmediately: Bool, contentPath: String = "Content", bundle: Bundle? = nil) {
        self.init(contentPath: contentPath, bundle: bundle)
        if loadImmediately {
            do {
                try loadAllContent()
            } catch {
                loadErrors.append("Failed to load content: \(error.localizedDescription)")
            }
        }
    }

    // MARK: - Loading

    /// Load all content from JSON files
    func loadAllContent() throws {
        loadErrors.removeAll()

        // Load regions (files are at bundle root after Xcode copies them)
        if let regionsURL = bundle.url(forResource: "regions", withExtension: "json") {
            try loadRegions(from: regionsURL)
        } else {
            loadErrors.append("regions.json not found")
        }

        // Load anchors
        if let anchorsURL = bundle.url(forResource: "anchors", withExtension: "json") {
            try loadAnchors(from: anchorsURL)
        } else {
            loadErrors.append("anchors.json not found")
        }

        // Load quests
        if let questsURL = bundle.url(forResource: "quests", withExtension: "json") {
            try loadQuests(from: questsURL)
        } else {
            loadErrors.append("quests.json not found")
        }

        // Load challenges
        if let challengesURL = bundle.url(forResource: "challenges", withExtension: "json") {
            try loadChallenges(from: challengesURL)
        } else {
            loadErrors.append("challenges.json not found")
        }

        // Load event pools
        try loadEventPools()

        // Build indices
        buildEventIndices()

        isLoaded = true
    }

    /// Reload content (for development hot-reload)
    func reloadContent() throws {
        regions.removeAll()
        anchors.removeAll()
        events.removeAll()
        quests.removeAll()
        miniGameChallenges.removeAll()
        eventsByPool.removeAll()
        eventsByRegion.removeAll()
        isLoaded = false

        try loadAllContent()
    }

    // MARK: - Individual Loaders

    private func loadRegions(from url: URL) throws {
        let data = try Data(contentsOf: url)
        let container = try JSONDecoder().decode(RegionsContainer.self, from: data)
        for region in container.regions {
            regions[region.id] = region.toDefinition()
        }
    }

    private func loadAnchors(from url: URL) throws {
        let data = try Data(contentsOf: url)
        let container = try JSONDecoder().decode(AnchorsContainer.self, from: data)
        for anchor in container.anchors {
            anchors[anchor.id] = anchor.toDefinition()
        }
    }

    private func loadQuests(from url: URL) throws {
        let data = try Data(contentsOf: url)
        let container = try JSONDecoder().decode(QuestsContainer.self, from: data)
        for quest in container.quests {
            quests[quest.id] = quest.toDefinition()
        }
    }

    private func loadChallenges(from url: URL) throws {
        let data = try Data(contentsOf: url)
        let container = try JSONDecoder().decode(ChallengesContainer.self, from: data)
        for challenge in container.challenges {
            miniGameChallenges[challenge.id] = challenge.toDefinition()
        }
    }

    private func loadEventPools() throws {
        // Events are now in events.json with pool_ids field, not separate pool files
        // Load events.json which contains all events with their pool associations
        if let eventsURL = bundle.url(forResource: "events", withExtension: "json") {
            try loadEvents(from: eventsURL)
        } else {
            loadErrors.append("events.json not found")
        }
    }

    private func loadEvents(from url: URL) throws {
        let data = try Data(contentsOf: url)
        // events.json is a direct array, not wrapped in a container
        let eventArray = try JSONDecoder().decode([JSONEvent].self, from: data)
        for event in eventArray {
            let definition = event.toDefinition()
            events[definition.id] = definition
        }
    }

    private func loadEventPool(from url: URL) throws {
        let data = try Data(contentsOf: url)
        let container = try JSONDecoder().decode(EventPoolContainer.self, from: data)
        for event in container.events {
            let definition = event.toDefinition()
            events[definition.id] = definition
        }
    }

    private func buildEventIndices() {
        eventsByPool.removeAll()
        eventsByRegion.removeAll()

        for event in events.values {
            // Index by pool
            for poolId in event.poolIds {
                eventsByPool[poolId, default: []].append(event)
            }

            // Index by region (from availability)
            if let regionIds = event.availability.regionIds {
                for regionId in regionIds {
                    eventsByRegion[regionId, default: []].append(event)
                }
            }
        }
    }

    // MARK: - ContentProvider Implementation

    func getAllRegionDefinitions() -> [RegionDefinition] {
        return Array(regions.values)
    }

    func getRegionDefinition(id: String) -> RegionDefinition? {
        return regions[id]
    }

    func getAllAnchorDefinitions() -> [AnchorDefinition] {
        return Array(anchors.values)
    }

    func getAnchorDefinition(id: String) -> AnchorDefinition? {
        return anchors[id]
    }

    func getAnchorDefinition(forRegion regionId: String) -> AnchorDefinition? {
        return anchors.values.first { $0.regionId == regionId }
    }

    func getAllEventDefinitions() -> [EventDefinition] {
        return Array(events.values)
    }

    func getEventDefinition(id: String) -> EventDefinition? {
        return events[id]
    }

    func getEventDefinitions(forRegion regionId: String) -> [EventDefinition] {
        guard let region = regions[regionId] else { return [] }

        var result: [EventDefinition] = []
        for poolId in region.eventPoolIds {
            result.append(contentsOf: eventsByPool[poolId] ?? [])
        }
        result.append(contentsOf: eventsByRegion[regionId] ?? [])

        var seen = Set<String>()
        return result.filter { seen.insert($0.id).inserted }
    }

    func getEventDefinitions(forPool poolId: String) -> [EventDefinition] {
        return eventsByPool[poolId] ?? []
    }

    func getAllQuestDefinitions() -> [QuestDefinition] {
        return Array(quests.values)
    }

    func getQuestDefinition(id: String) -> QuestDefinition? {
        return quests[id]
    }

    func getAllMiniGameChallenges() -> [MiniGameChallengeDefinition] {
        return Array(miniGameChallenges.values)
    }

    func getMiniGameChallenge(id: String) -> MiniGameChallengeDefinition? {
        return miniGameChallenges[id]
    }

    func validate() -> [ContentValidationError] {
        let validator = ContentValidator(provider: self)
        return validator.validate()
    }
}

// MARK: - JSON Schema Containers

/// Container for regions.json
private struct RegionsContainer: Codable {
    let version: String?
    let description: String?
    let regions: [JSONRegion]
}

/// Container for anchors.json
private struct AnchorsContainer: Codable {
    let version: String?
    let description: String?
    let anchors: [JSONAnchor]
}

/// Container for quests.json
private struct QuestsContainer: Codable {
    let version: String?
    let description: String?
    let quests: [JSONQuest]
}

/// Container for challenges.json
private struct ChallengesContainer: Codable {
    let version: String?
    let description: String?
    let challenges: [JSONChallenge]
}

/// Container for event pool files
private struct EventPoolContainer: Codable {
    let version: String?
    let poolId: String?
    let description: String?
    let events: [JSONEvent]
}

// MARK: - JSON Schema Types

private struct JSONRegion: Codable {
    let id: String
    let title: LocalizedString
    let description: LocalizedString
    let regionType: String?
    let neighborIds: [String]
    let initiallyDiscovered: Bool?
    let anchorId: String?
    let eventPoolIds: [String]?
    let initialState: String?
    let degradationWeight: Int?

    enum CodingKeys: String, CodingKey {
        case id, title, description, neighborIds, initiallyDiscovered, anchorId
        case eventPoolIds, initialState, degradationWeight
        case regionType = "region_type"
    }

    func toDefinition() -> RegionDefinition {
        let state: RegionStateType
        switch initialState?.lowercased() {
        case "stable": state = .stable
        case "borderland": state = .borderland
        case "breach": state = .breach
        default: state = .stable
        }

        return RegionDefinition(
            id: id,
            title: title,
            description: description,
            regionType: regionType ?? "forest",
            neighborIds: neighborIds,
            initiallyDiscovered: initiallyDiscovered ?? false,
            anchorId: anchorId,
            eventPoolIds: eventPoolIds ?? [],
            initialState: state,
            degradationWeight: degradationWeight ?? 1
        )
    }
}

private struct JSONAnchor: Codable {
    let id: String
    let title: LocalizedString
    let description: LocalizedString
    let regionId: String
    let anchorType: String?
    let initialInfluence: String?
    let power: Int?
    let initialIntegrity: Int?

    func toDefinition() -> AnchorDefinition {
        let influence: AnchorInfluence
        switch initialInfluence?.lowercased() {
        case "light": influence = .light
        case "dark": influence = .dark
        default: influence = .neutral
        }

        return AnchorDefinition(
            id: id,
            title: title,
            description: description,
            regionId: regionId,
            anchorType: anchorType ?? "shrine",
            initialInfluence: influence,
            power: power ?? 5,
            initialIntegrity: initialIntegrity ?? 100
        )
    }
}

/// Represents event_kind which can be either a string "inline" or object {"mini_game": "combat"}
private enum JSONEventKind: Codable {
    case inline
    case miniGame(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()

        // Try string first (e.g., "inline")
        if let stringValue = try? container.decode(String.self) {
            if stringValue == "inline" {
                self = .inline
            } else {
                // Treat other strings as mini_game type
                self = .miniGame(stringValue)
            }
            return
        }

        // Try object (e.g., {"mini_game": "combat"})
        if let dictValue = try? container.decode([String: String].self),
           let miniGameType = dictValue["mini_game"] {
            self = .miniGame(miniGameType)
            return
        }

        // Default to inline
        self = .inline
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .inline:
            try container.encode("inline")
        case .miniGame(let type):
            try container.encode(["mini_game": type])
        }
    }

    func toEventKind() -> EventKind {
        switch self {
        case .inline:
            return .inline
        case .miniGame(let type):
            switch type.lowercased() {
            case "combat": return .miniGame(.combat)
            case "ritual": return .miniGame(.ritual)
            case "exploration": return .miniGame(.exploration)
            case "dialogue": return .miniGame(.dialogue)
            case "puzzle": return .miniGame(.puzzle)
            default: return .miniGame(.combat)
            }
        }
    }
}

private struct JSONEvent: Codable {
    let id: String
    let title: LocalizedString
    let body: LocalizedString
    let eventKind: JSONEventKind?
    let eventType: String?
    let poolIds: [String]?
    let availability: JSONAvailability?
    let weight: Int?
    let isOneTime: Bool?
    let isInstant: Bool?
    let cooldown: Int?
    let choices: [JSONChoice]?
    let combatData: JSONCombatData?
    let miniGameChallenge: JSONMiniGameChallenge?

    enum CodingKeys: String, CodingKey {
        case id, title, body, availability, weight, choices, combatData
        case eventKind = "event_kind"
        case eventType = "event_type"
        case poolIds = "pool_ids"
        case isOneTime = "is_one_time"
        case isInstant = "is_instant"
        case cooldown
        case miniGameChallenge = "mini_game_challenge"
    }

    func toDefinition() -> EventDefinition {
        let kind: EventKind
        // Prefer eventKind (can be string or object), fall back to eventType (legacy string)
        if let ek = eventKind {
            kind = ek.toEventKind()
        } else if let et = eventType {
            switch et.lowercased() {
            case "combat": kind = .miniGame(.combat)
            case "ritual": kind = .miniGame(.ritual)
            case "exploration": kind = .miniGame(.exploration)
            default: kind = .inline
            }
        } else {
            kind = .inline
        }

        let avail = availability?.toAvailability() ?? .always

        let choiceDefs = choices?.map { $0.toDefinition() } ?? []

        // Create MiniGameChallengeDefinition from JSON mini_game_challenge
        let challenge: MiniGameChallengeDefinition?
        if let json = miniGameChallenge, let enemyId = json.enemyId {
            challenge = MiniGameChallengeDefinition(
                id: "challenge_\(enemyId)",
                challengeKind: .combat,
                difficulty: json.difficulty ?? 1,
                enemyId: enemyId,
                victoryConsequences: json.rewards?.toConsequences() ?? .none,
                defeatConsequences: json.penalties?.toConsequences() ?? .none
            )
        } else {
            challenge = nil
        }

        return EventDefinition(
            id: id,
            title: title,
            body: body,
            eventKind: kind,
            availability: avail,
            poolIds: poolIds ?? [],
            weight: weight ?? 10,
            isOneTime: isOneTime ?? false,
            choices: choiceDefs,
            miniGameChallenge: challenge
        )
    }
}

private struct JSONAvailability: Codable {
    let regionStates: [String]?
    let regionIds: [String]?
    let minPressure: Int?
    let maxPressure: Int?
    let minBalance: Int?
    let maxBalance: Int?
    let requiredFlags: [String]?
    let forbiddenFlags: [String]?

    enum CodingKeys: String, CodingKey {
        case regionStates = "region_states"
        case regionIds = "region_ids"
        case minPressure = "min_pressure"
        case maxPressure = "max_pressure"
        case minBalance = "min_balance"
        case maxBalance = "max_balance"
        case requiredFlags = "required_flags"
        case forbiddenFlags = "forbidden_flags"
    }

    func toAvailability() -> Availability {
        return Availability(
            requiredFlags: requiredFlags ?? [],
            forbiddenFlags: forbiddenFlags ?? [],
            minPressure: minPressure,
            maxPressure: maxPressure,
            minBalance: minBalance,
            maxBalance: maxBalance,
            regionStates: regionStates,
            regionIds: regionIds
        )
    }
}

private struct JSONChoice: Codable {
    let id: String
    let label: LocalizedString
    let tooltip: LocalizedString?
    let requirements: JSONChoiceRequirements?
    let consequences: JSONChoiceConsequences?

    func toDefinition() -> ChoiceDefinition {
        let reqs = requirements?.toRequirements()
        let cons = consequences?.toConsequences() ?? .none

        return ChoiceDefinition(
            id: id,
            label: label,
            tooltip: tooltip,
            requirements: reqs,
            consequences: cons
        )
    }
}

private struct JSONChoiceRequirements: Codable {
    let minFaith: Int?
    let minHealth: Int?
    let minBalance: Int?
    let maxBalance: Int?
    let requiredFlags: [String]?
    let forbiddenFlags: [String]?

    func toRequirements() -> ChoiceRequirements {
        var minResources: [String: Int] = [:]
        if let faith = minFaith { minResources["faith"] = faith }
        if let health = minHealth { minResources["health"] = health }

        return ChoiceRequirements(
            minResources: minResources,
            requiredFlags: requiredFlags ?? [],
            forbiddenFlags: forbiddenFlags ?? [],
            minBalance: minBalance,
            maxBalance: maxBalance
        )
    }
}

private struct JSONChoiceConsequences: Codable {
    let resourceChanges: [String: Int]?
    let setFlags: [String: Bool]?
    let clearFlags: [String]?
    let balanceShift: Int?
    let tensionChange: Int?
    let reputationChange: Int?
    let anchorIntegrityChange: Int?
    let addCards: [String]?
    let addCurse: String?
    let giveArtifact: String?
    let startCombat: Bool?
    let startQuest: String?
    let messageKey: String?

    func toConsequences() -> ChoiceConsequences {
        let resources = resourceChanges ?? [:]

        // Convert flag dict to array
        let flags = setFlags?.filter { $0.value }.map { $0.key } ?? []
        let clear = clearFlags ?? []

        return ChoiceConsequences(
            resourceChanges: resources,
            setFlags: flags,
            clearFlags: clear,
            balanceDelta: balanceShift ?? 0,
            resultKey: messageKey
        )
    }
}

private struct JSONCombatData: Codable {
    let enemyId: String?
    let enemyName: String?
    let enemyPower: Int?
    let enemyDefense: Int?
    let enemyHealth: Int?
    let isBoss: Bool?
}

/// JSON representation of mini_game_challenge field in events
private struct JSONMiniGameChallenge: Codable {
    let enemyId: String?
    let difficulty: Int?
    let rewards: JSONChallengeConsequences?
    let penalties: JSONChallengeConsequences?

    enum CodingKeys: String, CodingKey {
        case enemyId = "enemy_id"
        case difficulty, rewards, penalties
    }
}

/// JSON representation of rewards/penalties in mini_game_challenge
private struct JSONChallengeConsequences: Codable {
    let resourceChanges: [String: Int]?
    let setFlags: [String]?
    let balanceShift: Int?

    enum CodingKeys: String, CodingKey {
        case resourceChanges = "resource_changes"
        case setFlags = "set_flags"
        case balanceShift = "balance_shift"
    }

    func toConsequences() -> ChoiceConsequences {
        return ChoiceConsequences(
            resourceChanges: resourceChanges ?? [:],
            setFlags: setFlags ?? [],
            clearFlags: [],
            balanceDelta: balanceShift ?? 0
        )
    }
}

private struct JSONQuest: Codable {
    let id: String
    let title: LocalizedString
    let description: LocalizedString
    let questType: String?
    let initialStatus: String?
    let objectives: [JSONObjective]?
    let rewards: JSONQuestRewards?

    func toDefinition() -> QuestDefinition {
        let objDefs = objectives?.map { $0.toDefinition() } ?? []

        return QuestDefinition(
            id: id,
            title: title,
            description: description,
            objectives: objDefs
        )
    }
}

private struct JSONObjective: Codable {
    let id: String
    let description: LocalizedString
    let hint: LocalizedString?
    let completionCondition: JSONCompletionCondition?
    let nextObjectiveId: String?

    func toDefinition() -> ObjectiveDefinition {
        let condition = completionCondition?.toCondition() ?? .manual

        return ObjectiveDefinition(
            id: id,
            description: description,
            hint: hint,
            completionCondition: condition,
            nextObjectiveId: nextObjectiveId
        )
    }
}

private struct JSONCompletionCondition: Codable {
    let type: String?
    let regionId: String?
    let eventId: String?
    let flag: String?
    let anchorIds: [String]?
    let threshold: Int?

    func toCondition() -> CompletionCondition {
        switch type?.lowercased() {
        case "visitregion":
            return .visitRegion(regionId ?? "")
        case "eventcompleted":
            return .eventCompleted(eventId ?? "")
        case "flagset":
            return .flagSet(flag ?? "")
        default:
            return .manual
        }
    }
}

private struct JSONQuestRewards: Codable {
    let resourceChanges: [String: Int]?
    let setFlags: [String: Bool]?
    let balanceShift: Int?
    let tensionChange: Int?
    let reputationChange: Int?
    let giveArtifact: String?
    let unlockRegions: [String]?
    let addCurse: String?
}

private struct JSONChallenge: Codable {
    let id: String
    let challengeKind: String?
    let difficulty: Int?
    let titleKey: String?
    let descriptionKey: String?
    let enemyData: JSONCombatData?
    let requirements: JSONChoiceRequirements?
    let rewards: JSONChallengeRewards?
    let penalties: JSONChallengePenalties?
    let isBoss: Bool?

    func toDefinition() -> MiniGameChallengeDefinition {
        let kind: MiniGameChallengeKind
        switch challengeKind?.lowercased() {
        case "combat": kind = .combat
        case "ritual": kind = .ritual
        case "exploration": kind = .exploration
        case "dialogue": kind = .dialogue
        case "puzzle": kind = .puzzle
        default: kind = .combat
        }

        return MiniGameChallengeDefinition(
            id: id,
            challengeKind: kind,
            difficulty: difficulty ?? 5,
            enemyId: enemyData?.enemyId
        )
    }
}

private struct JSONChallengeRewards: Codable {
    let victoryFaith: Int?
    let victoryBalance: Int?
    let setFlags: [String: Bool]?
    let discoverRegion: Bool?
    let findArtifact: Bool?
}

private struct JSONChallengePenalties: Codable {
    let defeatHealth: Int?
    let defeatTension: Int?
    let faithCost: Int?
    let healthCost: Int?
    let tensionGain: Int?
}


// ==========================================
// FILE: Engine/Data/Definitions/AnchorDefinition.swift
// ==========================================

import Foundation

// MARK: - Anchor Influence

/// Influence alignment of an anchor (maps to CardBalance in legacy models)
enum AnchorInfluence: String, Codable, Hashable {
    case light
    case neutral
    case dark
}

// MARK: - Anchor Definition
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.1
// Reference: Docs/EXPLORATION_CORE_DESIGN.md, Section 6

/// Immutable definition of an anchor point.
/// Anchors provide resistance to regional degradation.
/// Runtime state (current integrity, etc.) lives in AnchorRuntimeState.
struct AnchorDefinition: GameDefinition {
    // MARK: - Identity

    /// Unique anchor identifier (e.g., "anchor_forest_shrine")
    let id: String

    // MARK: - Localized Content

    /// Anchor name with all language variants
    let title: LocalizedString

    /// Anchor description with all language variants
    let description: LocalizedString

    // MARK: - Location

    /// ID of the region where this anchor is located
    let regionId: String

    // MARK: - Type & Influence (Twilight Marches specific)

    /// Anchor type (e.g., "chapel", "shrine", "sacred_tree")
    let anchorType: String

    /// Initial influence: "light", "neutral", or "dark"
    let initialInfluence: AnchorInfluence

    /// Power level (radius of influence, 1-10)
    let power: Int

    // MARK: - Mechanics

    /// Maximum integrity value (0-100)
    let maxIntegrity: Int

    /// Initial integrity value
    let initialIntegrity: Int

    /// Integrity gained per "strengthen" action
    let strengthenAmount: Int

    /// Resource cost to strengthen (e.g., ["faith": 5])
    let strengthenCost: ResourceTransaction

    // MARK: - Effects

    /// Resistance chance calculation: integrity / resistanceDivisor
    /// Default: 100 (so 50 integrity = 50% resistance)
    let resistanceDivisor: Int

    // MARK: - Initialization

    init(
        id: String,
        title: LocalizedString,
        description: LocalizedString,
        regionId: String,
        anchorType: String = "shrine",
        initialInfluence: AnchorInfluence = .neutral,
        power: Int = 5,
        maxIntegrity: Int = 100,
        initialIntegrity: Int = 50,
        strengthenAmount: Int = 15,
        strengthenCost: ResourceTransaction = .spend("faith", amount: 5),
        resistanceDivisor: Int = 100
    ) {
        self.id = id
        self.title = title
        self.description = description
        self.regionId = regionId
        self.anchorType = anchorType
        self.initialInfluence = initialInfluence
        self.power = power
        self.maxIntegrity = maxIntegrity
        self.initialIntegrity = initialIntegrity
        self.strengthenAmount = strengthenAmount
        self.strengthenCost = strengthenCost
        self.resistanceDivisor = resistanceDivisor
    }
}


// ==========================================
// FILE: Engine/Data/Definitions/EnemyDefinition.swift
// ==========================================

import Foundation

// MARK: - Enemy Definition
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.1
// Data-driven enemy definitions for combat events

/// Immutable definition of an enemy.
/// Used to create monster cards for combat events.
struct EnemyDefinition: GameDefinition {
    // MARK: - Identity

    /// Unique enemy identifier (e.g., "leshy", "wild_beast")
    let id: String

    // MARK: - Localized Content

    /// Enemy name with all language variants
    let name: LocalizedString

    /// Enemy description with all language variants
    let description: LocalizedString

    // MARK: - Stats

    /// Base health points
    let health: Int

    /// Base attack power
    let power: Int

    /// Base defense
    let defense: Int

    /// Difficulty rating (1-5, affects scaling)
    let difficulty: Int

    // MARK: - Classification

    /// Enemy type classification
    let enemyType: EnemyType

    /// Card rarity for loot/display
    let rarity: CardRarity

    // MARK: - Abilities

    /// Special abilities this enemy has
    let abilities: [EnemyAbility]

    // MARK: - Loot & Rewards

    /// Cards that can drop when defeated
    let lootCardIds: [String]

    /// Faith reward when defeated
    let faithReward: Int

    /// Balance change when defeated
    let balanceDelta: Int

    // MARK: - CodingKeys for JSON compatibility

    enum CodingKeys: String, CodingKey {
        case id
        case name
        case description
        case health
        case power
        case defense
        case difficulty
        case enemyType = "enemy_type"
        case rarity
        case abilities
        case lootCardIds = "loot_card_ids"
        case faithReward = "faith_reward"
        case balanceDelta = "balance_delta"
    }

    // MARK: - Initialization

    init(
        id: String,
        name: LocalizedString,
        description: LocalizedString,
        health: Int,
        power: Int,
        defense: Int,
        difficulty: Int = 1,
        enemyType: EnemyType = .beast,
        rarity: CardRarity = .common,
        abilities: [EnemyAbility] = [],
        lootCardIds: [String] = [],
        faithReward: Int = 0,
        balanceDelta: Int = 0
    ) {
        self.id = id
        self.name = name
        self.description = description
        self.health = health
        self.power = power
        self.defense = defense
        self.difficulty = difficulty
        self.enemyType = enemyType
        self.rarity = rarity
        self.abilities = abilities
        self.lootCardIds = lootCardIds
        self.faithReward = faithReward
        self.balanceDelta = balanceDelta
    }

    /// Convert to legacy Card (monster type) for UI compatibility
    func toCard() -> Card {
        return Card(
            id: UUID(uuidString: id.md5UUID) ?? UUID(),
            name: name.localized,
            type: .monster,
            rarity: rarity,
            description: description.localized,
            power: power,
            defense: defense,
            health: health
        )
    }
}

// MARK: - Enemy Type

enum EnemyType: String, Codable, Hashable {
    case beast       // Wild animals
    case spirit      // Forest spirits, leshy
    case undead      // Risen dead, ghosts
    case demon       // Navi creatures
    case human       // Bandits, cultists
    case boss        // Major enemies
}

// MARK: - Enemy Ability

struct EnemyAbility: Codable, Hashable, Identifiable {
    let id: String
    let name: LocalizedString
    let description: LocalizedString
    let effect: EnemyAbilityEffect

    init(
        id: String,
        name: LocalizedString,
        description: LocalizedString,
        effect: EnemyAbilityEffect
    ) {
        self.id = id
        self.name = name
        self.description = description
        self.effect = effect
    }
}

enum EnemyAbilityEffect: Codable, Hashable {
    /// Deal extra damage
    case bonusDamage(Int)

    /// Heal each turn
    case regeneration(Int)

    /// Reduce incoming damage
    case armor(Int)

    /// First strike - attacks before player
    case firstStrike

    /// Cannot be targeted by spells
    case spellImmune

    /// Applies curse on hit
    case applyCurse(String)

    /// Custom effect by ID
    case custom(String)

    // MARK: - Custom Codable for JSON compatibility

    enum CodingKeys: String, CodingKey {
        case bonusDamage = "bonus_damage"
        case regeneration
        case armor
        case firstStrike = "first_strike"
        case spellImmune = "spell_immune"
        case applyCurse = "apply_curse"
        case custom
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        if let value = try container.decodeIfPresent(Int.self, forKey: .bonusDamage) {
            self = .bonusDamage(value)
        } else if let value = try container.decodeIfPresent(Int.self, forKey: .regeneration) {
            self = .regeneration(value)
        } else if let value = try container.decodeIfPresent(Int.self, forKey: .armor) {
            self = .armor(value)
        } else if (try? container.decodeIfPresent(Bool.self, forKey: .firstStrike)) == true {
            self = .firstStrike
        } else if (try? container.decodeIfPresent(Bool.self, forKey: .spellImmune)) == true {
            self = .spellImmune
        } else if let value = try container.decodeIfPresent(String.self, forKey: .applyCurse) {
            self = .applyCurse(value)
        } else if let value = try container.decodeIfPresent(String.self, forKey: .custom) {
            self = .custom(value)
        } else {
            // Default to custom with empty string if no recognized key
            self = .custom("unknown")
        }
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        switch self {
        case .bonusDamage(let value):
            try container.encode(value, forKey: .bonusDamage)
        case .regeneration(let value):
            try container.encode(value, forKey: .regeneration)
        case .armor(let value):
            try container.encode(value, forKey: .armor)
        case .firstStrike:
            try container.encode(true, forKey: .firstStrike)
        case .spellImmune:
            try container.encode(true, forKey: .spellImmune)
        case .applyCurse(let value):
            try container.encode(value, forKey: .applyCurse)
        case .custom(let value):
            try container.encode(value, forKey: .custom)
        }
    }
}

// MARK: - String UUID Extension (reuse pattern)

private extension String {
    var md5UUID: String {
        var hash: UInt64 = 5381
        for char in self.utf8 {
            hash = ((hash << 5) &+ hash) &+ UInt64(char)
        }
        let hex = String(format: "%016llX", hash)
        let padded = hex.padding(toLength: 32, withPad: "0", startingAt: 0)
        let chars = Array(padded)
        return "\(String(chars[0..<8]))-\(String(chars[8..<12]))-\(String(chars[12..<16]))-\(String(chars[16..<20]))-\(String(chars[20..<32]))"
    }
}


// ==========================================
// FILE: Engine/Data/Definitions/EventDefinition.swift
// ==========================================

import Foundation

// MARK: - Event Definition
// Reference: Docs/EVENT_MODULE_ARCHITECTURE.md
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.1

/// Immutable definition of a game event.
/// Events can be Inline (resolve in flow) or Mini-Game (external module).
/// Runtime state (completion, cooldowns) lives in EventRuntimeState.
struct EventDefinition: GameDefinition {
    // MARK: - Identity

    /// Unique event identifier (e.g., "event_forest_whispers")
    let id: String

    // MARK: - Localized Content

    /// Event title with all language variants
    let title: LocalizedString

    /// Event body/narrative text with all language variants
    let body: LocalizedString

    // MARK: - Type Classification

    /// Event kind: inline or mini-game
    let eventKind: EventKind

    // MARK: - Availability

    /// Conditions for this event to appear
    let availability: Availability

    /// Event pool IDs this event belongs to
    let poolIds: [String]

    /// Weight for random selection (higher = more likely)
    let weight: Int

    // MARK: - Behavior Flags

    /// If true, event can only occur once per playthrough
    let isOneTime: Bool

    /// If true, event resolves instantly (0 time cost)
    let isInstant: Bool

    /// Cooldown in turns before event can reoccur (0 = no cooldown)
    let cooldown: Int

    // MARK: - Content

    /// Choices available in this event (for inline events)
    let choices: [ChoiceDefinition]

    /// Mini-game challenge (for mini-game events)
    let miniGameChallenge: MiniGameChallengeDefinition?

    // MARK: - Initialization

    init(
        id: String,
        title: LocalizedString,
        body: LocalizedString,
        eventKind: EventKind = .inline,
        availability: Availability = .always,
        poolIds: [String] = [],
        weight: Int = 10,
        isOneTime: Bool = false,
        isInstant: Bool = false,
        cooldown: Int = 0,
        choices: [ChoiceDefinition] = [],
        miniGameChallenge: MiniGameChallengeDefinition? = nil
    ) {
        self.id = id
        self.title = title
        self.body = body
        self.eventKind = eventKind
        self.availability = availability
        self.poolIds = poolIds
        self.weight = weight
        self.isOneTime = isOneTime
        self.isInstant = isInstant
        self.cooldown = cooldown
        self.choices = choices
        self.miniGameChallenge = miniGameChallenge
    }
}

// MARK: - Event Kind

/// Classification of event kinds (Engine-specific, distinct from legacy EventType)
/// Reference: Docs/EVENT_MODULE_ARCHITECTURE.md, Section 2
enum EventKind: Codable, Hashable {
    /// Inline event - resolves within main game flow
    case inline

    /// Mini-game event - dispatches to external module
    case miniGame(MiniGameKind)

    /// All mini-game kinds
    enum MiniGameKind: String, Codable, Hashable {
        case combat
        case ritual
        case exploration
        case dialogue
        case puzzle
    }

    // MARK: - Custom Codable

    /// Coding keys for JSON object format: {"mini_game": "combat"}
    private enum CodingKeys: String, CodingKey {
        case miniGame = "mini_game"
    }

    init(from decoder: Decoder) throws {
        // Try decoding as a simple string first: "inline"
        if let container = try? decoder.singleValueContainer(),
           let stringValue = try? container.decode(String.self) {
            if stringValue == "inline" {
                self = .inline
            } else if let miniGameKind = MiniGameKind(rawValue: stringValue) {
                // Handle direct mini-game string: "combat", "ritual", etc.
                self = .miniGame(miniGameKind)
            } else {
                throw DecodingError.dataCorruptedError(
                    in: container,
                    debugDescription: "Unknown event kind: \(stringValue)"
                )
            }
            return
        }

        // Try decoding as object: {"mini_game": "combat"}
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let miniGameString = try container.decode(String.self, forKey: .miniGame)
        if let miniGameKind = MiniGameKind(rawValue: miniGameString) {
            self = .miniGame(miniGameKind)
        } else {
            throw DecodingError.dataCorruptedError(
                forKey: .miniGame,
                in: container,
                debugDescription: "Unknown mini-game kind: \(miniGameString)"
            )
        }
    }

    func encode(to encoder: Encoder) throws {
        switch self {
        case .inline:
            var container = encoder.singleValueContainer()
            try container.encode("inline")
        case .miniGame(let kind):
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(kind.rawValue, forKey: .miniGame)
        }
    }
}

// MARK: - Choice Definition

/// Immutable definition of a choice within an event.
struct ChoiceDefinition: Codable, Hashable, Identifiable {
    // MARK: - Identity

    /// Unique choice identifier within the event
    let id: String

    // MARK: - Localized Content

    /// Choice button text with all language variants
    let label: LocalizedString

    /// Optional choice tooltip/description with all language variants
    let tooltip: LocalizedString?

    // MARK: - Requirements

    /// Conditions for this choice to be available
    let requirements: ChoiceRequirements?

    // MARK: - Consequences

    /// Outcomes when this choice is selected
    let consequences: ChoiceConsequences

    // MARK: - Initialization

    init(
        id: String,
        label: LocalizedString,
        tooltip: LocalizedString? = nil,
        requirements: ChoiceRequirements? = nil,
        consequences: ChoiceConsequences
    ) {
        self.id = id
        self.label = label
        self.tooltip = tooltip
        self.requirements = requirements
        self.consequences = consequences
    }
}

// MARK: - Choice Requirements

/// Requirements that must be met to select a choice
struct ChoiceRequirements: Codable, Hashable {
    /// Minimum resource values required
    let minResources: [String: Int]

    /// Flags that must be set
    let requiredFlags: [String]

    /// Flags that must NOT be set
    let forbiddenFlags: [String]

    /// Minimum balance required (nil = no minimum)
    let minBalance: Int?

    /// Maximum balance allowed (nil = no maximum)
    let maxBalance: Int?

    init(
        minResources: [String: Int] = [:],
        requiredFlags: [String] = [],
        forbiddenFlags: [String] = [],
        minBalance: Int? = nil,
        maxBalance: Int? = nil
    ) {
        self.minResources = minResources
        self.requiredFlags = requiredFlags
        self.forbiddenFlags = forbiddenFlags
        self.minBalance = minBalance
        self.maxBalance = maxBalance
    }

    /// Convenience initializer with balance range
    init(
        minResources: [String: Int] = [:],
        requiredFlags: [String] = [],
        forbiddenFlags: [String] = [],
        balanceRange: ClosedRange<Int>?
    ) {
        self.minResources = minResources
        self.requiredFlags = requiredFlags
        self.forbiddenFlags = forbiddenFlags
        self.minBalance = balanceRange?.lowerBound
        self.maxBalance = balanceRange?.upperBound
    }

    /// Check if requirements can be met with given context
    /// - Note: Prefer using `Requirements.evaluator.canMeet(requirements:...)` instead
    ///   for cleaner separation of data and logic (see ENGINE_ARCHITECTURE.md)
    @available(*, deprecated, message: "Use Requirements.evaluator.canMeet() instead")
    func canMeet(resources: [String: Int], flags: Set<String>, balance: Int) -> Bool {
        // Check resources
        for (resourceId, minValue) in minResources {
            if (resources[resourceId] ?? 0) < minValue {
                return false
            }
        }

        // Check required flags
        for flag in requiredFlags {
            if !flags.contains(flag) {
                return false
            }
        }

        // Check forbidden flags
        for flag in forbiddenFlags {
            if flags.contains(flag) {
                return false
            }
        }

        // Check balance range
        if let min = minBalance, balance < min {
            return false
        }
        if let max = maxBalance, balance > max {
            return false
        }

        return true
    }
}

// MARK: - Choice Consequences

/// Outcomes that occur when a choice is selected
struct ChoiceConsequences: Codable, Hashable {
    /// Resource changes (costs and gains)
    let resourceChanges: [String: Int]

    /// Flags to set
    let setFlags: [String]

    /// Flags to clear
    let clearFlags: [String]

    /// Balance change (-100 to +100)
    let balanceDelta: Int

    /// Region state change (if any)
    let regionStateChange: RegionStateChange?

    /// Quest progress trigger
    let questProgress: QuestProgressTrigger?

    /// Follow-up event to trigger (if any)
    let triggerEventId: String?

    /// Narrative result key (for UI display)
    let resultKey: String?

    init(
        resourceChanges: [String: Int] = [:],
        setFlags: [String] = [],
        clearFlags: [String] = [],
        balanceDelta: Int = 0,
        regionStateChange: RegionStateChange? = nil,
        questProgress: QuestProgressTrigger? = nil,
        triggerEventId: String? = nil,
        resultKey: String? = nil
    ) {
        self.resourceChanges = resourceChanges
        self.setFlags = setFlags
        self.clearFlags = clearFlags
        self.balanceDelta = balanceDelta
        self.regionStateChange = regionStateChange
        self.questProgress = questProgress
        self.triggerEventId = triggerEventId
        self.resultKey = resultKey
    }

    /// Empty consequences (no-op choice)
    static let none = ChoiceConsequences()
}

// MARK: - Supporting Types

/// Region state change triggered by choice
struct RegionStateChange: Codable, Hashable {
    /// Target region ID (nil = current region)
    let regionId: String?

    /// New state to set
    let newState: RegionStateType?

    /// State transition (degrade/restore)
    let transition: StateTransition?

    enum StateTransition: String, Codable, Hashable {
        case degrade
        case restore
    }
}

/// Quest progress trigger
struct QuestProgressTrigger: Codable, Hashable {
    let questId: String
    let objectiveId: String?
    let action: QuestAction

    enum QuestAction: String, Codable, Hashable {
        case advance      // Move to next objective
        case complete     // Complete specific objective
        case fail         // Fail the quest
        case unlock       // Unlock the quest
    }
}


// ==========================================
// FILE: Engine/Data/Definitions/GameDefinition.swift
// ==========================================

import Foundation

// MARK: - Base Definition Protocol
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.1
// Reference: Docs/MIGRATION_PLAN.md, Feature A1

/// Base protocol for all game content definitions.
/// Definitions are IMMUTABLE - they contain no runtime state.
/// All runtime data belongs in RuntimeState types.
///
/// **Invariants:**
/// - INV-D01: Definitions have no mutable properties
/// - INV-D02: All IDs are String (not UUID)
/// - INV-D03: All user-facing text uses localization keys (titleKey, bodyKey)
protocol GameDefinition: Codable, Identifiable, Hashable {
    /// Unique identifier for this definition.
    /// Must be unique within its type (regions, events, quests, etc.)
    var id: String { get }
}

// MARK: - Localization Key Validation

/// Helper to validate localization key format.
/// Keys should follow pattern: "type.id.field" (e.g., "region.forest.title")
enum LocalizationKeyValidator {
    static func isValidKey(_ key: String) -> Bool {
        // Key must contain at least one dot and no spaces
        return key.contains(".") && !key.contains(" ")
    }

    static func validateKeys(_ keys: [String]) -> [String] {
        return keys.filter { !isValidKey($0) }
    }
}

// MARK: - Common Types

/// Availability conditions for content (events, choices, etc.)
/// Reference: Docs/EVENT_MODULE_ARCHITECTURE.md, Section 2.3
struct Availability: Codable, Hashable {
    /// Required flags that must be set
    let requiredFlags: [String]

    /// Forbidden flags that must NOT be set
    let forbiddenFlags: [String]

    /// Minimum pressure/tension required
    let minPressure: Int?

    /// Maximum pressure/tension allowed
    let maxPressure: Int?

    /// Minimum balance value required
    let minBalance: Int?

    /// Maximum balance value allowed
    let maxBalance: Int?

    /// Specific region states where this is available
    let regionStates: [String]?

    /// Specific region IDs where this is available
    let regionIds: [String]?

    init(
        requiredFlags: [String] = [],
        forbiddenFlags: [String] = [],
        minPressure: Int? = nil,
        maxPressure: Int? = nil,
        minBalance: Int? = nil,
        maxBalance: Int? = nil,
        regionStates: [String]? = nil,
        regionIds: [String]? = nil
    ) {
        self.requiredFlags = requiredFlags
        self.forbiddenFlags = forbiddenFlags
        self.minPressure = minPressure
        self.maxPressure = maxPressure
        self.minBalance = minBalance
        self.maxBalance = maxBalance
        self.regionStates = regionStates
        self.regionIds = regionIds
    }

    /// Default availability (always available)
    static let always = Availability()
}

// MARK: - Resource Cost/Gain

/// Represents a resource change (cost or gain)
struct ResourceChange: Codable, Hashable {
    let resourceId: String
    let amount: Int

    /// Positive = gain, negative = cost
    var isGain: Bool { amount > 0 }
    var isCost: Bool { amount < 0 }
}

/// Collection of resource changes for a transaction
struct ResourceTransaction: Codable, Hashable {
    let changes: [ResourceChange]

    /// Convenience for single resource
    static func spend(_ resourceId: String, amount: Int) -> ResourceTransaction {
        ResourceTransaction(changes: [ResourceChange(resourceId: resourceId, amount: -abs(amount))])
    }

    static func gain(_ resourceId: String, amount: Int) -> ResourceTransaction {
        ResourceTransaction(changes: [ResourceChange(resourceId: resourceId, amount: abs(amount))])
    }

    static let none = ResourceTransaction(changes: [])
}


// ==========================================
// FILE: Engine/Data/Definitions/LocalizedString.swift
// ==========================================

import Foundation

// MARK: - Localized String
// Reference: Docs/ENGINE_ARCHITECTURE.md
// Supports runtime localization without app rebuild - "Cartridge" approach

/// A string with multiple language variants, loaded from JSON content.
/// This enables adding new content without rebuilding the app.
struct LocalizedString: Codable, Hashable {
    // MARK: - Supported Languages

    /// English text
    let en: String

    /// Russian text
    let ru: String

    // MARK: - Localized Access

    /// Returns the string for the current device locale.
    /// Falls back to English if the current locale is not supported.
    var localized: String {
        let languageCode = Locale.current.language.languageCode?.identifier ?? "en"
        switch languageCode {
        case "ru": return ru
        default: return en
        }
    }

    /// Returns the string for a specific language code.
    func localized(for languageCode: String) -> String {
        switch languageCode {
        case "ru": return ru
        default: return en
        }
    }

    // MARK: - Convenience Initializers

    /// Create with the same text for all languages (for testing/development)
    init(_ text: String) {
        self.en = text
        self.ru = text
    }

    /// Create with specific translations
    init(en: String, ru: String) {
        self.en = en
        self.ru = ru
    }
}

// MARK: - ExpressibleByStringLiteral

extension LocalizedString: ExpressibleByStringLiteral {
    init(stringLiteral value: String) {
        self.en = value
        self.ru = value
    }
}

// MARK: - CustomStringConvertible

extension LocalizedString: CustomStringConvertible {
    var description: String {
        localized
    }
}


// ==========================================
// FILE: Engine/Data/Definitions/MiniGameChallengeDefinition.swift
// ==========================================

import Foundation

// MARK: - Mini-Game Challenge Definition
// Reference: Docs/EVENT_MODULE_ARCHITECTURE.md, Section 4

/// Immutable definition of a mini-game challenge.
/// Describes what gets dispatched to external mini-game modules.
struct MiniGameChallengeDefinition: Codable, Hashable, Identifiable {
    // MARK: - Identity

    /// Unique challenge identifier
    let id: String

    // MARK: - Type

    /// Type of mini-game challenge
    let challengeKind: MiniGameChallengeKind

    // MARK: - Difficulty

    /// Base difficulty level (1-10)
    let difficulty: Int

    /// Difficulty scaling based on pressure
    let pressureScaling: Double

    // MARK: - Content Reference

    /// Enemy ID for combat challenges
    let enemyId: String?

    /// Puzzle ID for puzzle challenges
    let puzzleId: String?

    /// Dialogue tree ID for dialogue challenges
    let dialogueId: String?

    // MARK: - Outcomes

    /// Consequences on victory
    let victoryConsequences: ChoiceConsequences

    /// Consequences on defeat
    let defeatConsequences: ChoiceConsequences

    /// Consequences on retreat/escape (if allowed)
    let retreatConsequences: ChoiceConsequences?

    // MARK: - Options

    /// Whether retreat/escape is allowed
    let canRetreat: Bool

    /// Time limit in turns (0 = no limit)
    let turnLimit: Int

    // MARK: - Initialization

    init(
        id: String,
        challengeKind: MiniGameChallengeKind,
        difficulty: Int = 5,
        pressureScaling: Double = 0.1,
        enemyId: String? = nil,
        puzzleId: String? = nil,
        dialogueId: String? = nil,
        victoryConsequences: ChoiceConsequences = .none,
        defeatConsequences: ChoiceConsequences = .none,
        retreatConsequences: ChoiceConsequences? = nil,
        canRetreat: Bool = true,
        turnLimit: Int = 0
    ) {
        self.id = id
        self.challengeKind = challengeKind
        self.difficulty = difficulty
        self.pressureScaling = pressureScaling
        self.enemyId = enemyId
        self.puzzleId = puzzleId
        self.dialogueId = dialogueId
        self.victoryConsequences = victoryConsequences
        self.defeatConsequences = defeatConsequences
        self.retreatConsequences = retreatConsequences
        self.canRetreat = canRetreat
        self.turnLimit = turnLimit
    }

    /// Calculate effective difficulty based on current pressure
    func effectiveDifficulty(at pressure: Int) -> Int {
        let scaled = Double(difficulty) + (Double(pressure) * pressureScaling)
        return Int(scaled.rounded())
    }

    // MARK: - Custom Codable

    /// Coding keys for simplified JSON format from events.json
    private enum CodingKeys: String, CodingKey {
        case id
        case challengeKind = "challenge_kind"
        case difficulty
        case pressureScaling = "pressure_scaling"
        case enemyId = "enemy_id"
        case puzzleId = "puzzle_id"
        case dialogueId = "dialogue_id"
        case victoryConsequences = "victory_consequences"
        case defeatConsequences = "defeat_consequences"
        case retreatConsequences = "retreat_consequences"
        case canRetreat = "can_retreat"
        case turnLimit = "turn_limit"
        // Simplified format keys
        case rewards
        case penalties
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        // Try full format first, then simplified format
        if let id = try container.decodeIfPresent(String.self, forKey: .id) {
            self.id = id
        } else if let enemyId = try container.decodeIfPresent(String.self, forKey: .enemyId) {
            // Generate ID from enemy ID for simplified format
            self.id = "challenge_\(enemyId)"
        } else {
            self.id = "challenge_unknown"
        }

        // Challenge kind - default to combat for simplified format
        self.challengeKind = try container.decodeIfPresent(MiniGameChallengeKind.self, forKey: .challengeKind) ?? .combat

        // Difficulty
        self.difficulty = try container.decodeIfPresent(Int.self, forKey: .difficulty) ?? 5

        // Pressure scaling
        self.pressureScaling = try container.decodeIfPresent(Double.self, forKey: .pressureScaling) ?? 0.1

        // Content references
        self.enemyId = try container.decodeIfPresent(String.self, forKey: .enemyId)
        self.puzzleId = try container.decodeIfPresent(String.self, forKey: .puzzleId)
        self.dialogueId = try container.decodeIfPresent(String.self, forKey: .dialogueId)

        // Consequences - try full format first, then simplified
        if let victory = try container.decodeIfPresent(ChoiceConsequences.self, forKey: .victoryConsequences) {
            self.victoryConsequences = victory
        } else if let rewards = try container.decodeIfPresent(ChoiceConsequences.self, forKey: .rewards) {
            self.victoryConsequences = rewards
        } else {
            self.victoryConsequences = .none
        }

        if let defeat = try container.decodeIfPresent(ChoiceConsequences.self, forKey: .defeatConsequences) {
            self.defeatConsequences = defeat
        } else if let penalties = try container.decodeIfPresent(ChoiceConsequences.self, forKey: .penalties) {
            self.defeatConsequences = penalties
        } else {
            self.defeatConsequences = .none
        }

        self.retreatConsequences = try container.decodeIfPresent(ChoiceConsequences.self, forKey: .retreatConsequences)

        // Options
        self.canRetreat = try container.decodeIfPresent(Bool.self, forKey: .canRetreat) ?? true
        self.turnLimit = try container.decodeIfPresent(Int.self, forKey: .turnLimit) ?? 0
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(id, forKey: .id)
        try container.encode(challengeKind, forKey: .challengeKind)
        try container.encode(difficulty, forKey: .difficulty)
        try container.encode(pressureScaling, forKey: .pressureScaling)
        try container.encodeIfPresent(enemyId, forKey: .enemyId)
        try container.encodeIfPresent(puzzleId, forKey: .puzzleId)
        try container.encodeIfPresent(dialogueId, forKey: .dialogueId)
        try container.encode(victoryConsequences, forKey: .victoryConsequences)
        try container.encode(defeatConsequences, forKey: .defeatConsequences)
        try container.encodeIfPresent(retreatConsequences, forKey: .retreatConsequences)
        try container.encode(canRetreat, forKey: .canRetreat)
        try container.encode(turnLimit, forKey: .turnLimit)
    }
}

// MARK: - Mini-Game Challenge Kind

/// Types of mini-game challenges (Engine-specific, distinct from ChallengeType in EngineProtocols)
enum MiniGameChallengeKind: String, Codable, Hashable, CaseIterable {
    /// Combat encounter with deck-building mechanics
    case combat

    /// Ritual/prayer challenge (faith-based)
    case ritual

    /// Exploration challenge (resource management)
    case exploration

    /// Dialogue/negotiation challenge
    case dialogue

    /// Puzzle challenge
    case puzzle
}

// MARK: - Mini-Game Result

/// Result returned by a mini-game module
/// Reference: EVENT_MODULE_ARCHITECTURE.md, Section 4.2
struct MiniGameResult: Codable, Hashable {
    /// Outcome of the mini-game
    let outcome: MiniGameOutcome

    /// State diff to apply
    let diff: MiniGameDiff

    /// Additional data from the mini-game
    let metadata: [String: String]

    init(
        outcome: MiniGameOutcome,
        diff: MiniGameDiff,
        metadata: [String: String] = [:]
    ) {
        self.outcome = outcome
        self.diff = diff
        self.metadata = metadata
    }
}

/// Possible outcomes of a mini-game
enum MiniGameOutcome: String, Codable, Hashable {
    case victory
    case defeat
    case retreat
    case timeout
}

/// State changes from a mini-game (diff-only, no direct mutation)
/// Reference: EVENT_MODULE_ARCHITECTURE.md, Invariant #2
struct MiniGameDiff: Codable, Hashable {
    /// Resource changes
    let resourceChanges: [String: Int]

    /// Flags to set
    let flagsToSet: [String: Bool]

    /// Cards to add to deck
    let cardsToAdd: [String]

    /// Cards to remove from deck
    let cardsToRemove: [String]

    /// Balance change
    let balanceDelta: Int

    init(
        resourceChanges: [String: Int] = [:],
        flagsToSet: [String: Bool] = [:],
        cardsToAdd: [String] = [],
        cardsToRemove: [String] = [],
        balanceDelta: Int = 0
    ) {
        self.resourceChanges = resourceChanges
        self.flagsToSet = flagsToSet
        self.cardsToAdd = cardsToAdd
        self.cardsToRemove = cardsToRemove
        self.balanceDelta = balanceDelta
    }

    /// Empty diff (no changes)
    static let empty = MiniGameDiff()
}


// ==========================================
// FILE: Engine/Data/Definitions/QuestDefinition.swift
// ==========================================

import Foundation

// MARK: - Quest Definition
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.1
// Reference: Docs/EXPLORATION_CORE_DESIGN.md, Section 13

/// Immutable definition of a quest.
/// Runtime state (currentStage, completedObjectives) lives in QuestRuntimeState.
struct QuestDefinition: GameDefinition {
    // MARK: - Identity

    /// Unique quest identifier (e.g., "quest_main_act1")
    let id: String

    // MARK: - Localized Content

    /// Quest title with all language variants
    let title: LocalizedString

    /// Quest description with all language variants
    let description: LocalizedString

    // MARK: - Structure

    /// Ordered list of objectives (stages)
    let objectives: [ObjectiveDefinition]

    /// Quest kind classification
    let questKind: QuestKind

    // MARK: - Availability

    /// Conditions for this quest to become available
    let availability: Availability

    /// If true, quest starts automatically when available
    let autoStart: Bool

    // MARK: - Rewards

    /// Rewards given on quest completion
    let completionRewards: QuestCompletionRewards

    /// Penalties on quest failure
    let failurePenalties: QuestCompletionRewards

    // MARK: - Initialization

    init(
        id: String,
        title: LocalizedString,
        description: LocalizedString,
        objectives: [ObjectiveDefinition],
        questKind: QuestKind = .side,
        availability: Availability = .always,
        autoStart: Bool = false,
        completionRewards: QuestCompletionRewards = .none,
        failurePenalties: QuestCompletionRewards = .none
    ) {
        self.id = id
        self.title = title
        self.description = description
        self.objectives = objectives
        self.questKind = questKind
        self.availability = availability
        self.autoStart = autoStart
        self.completionRewards = completionRewards
        self.failurePenalties = failurePenalties
    }
}

// MARK: - Quest Kind

/// Quest kind classification (Engine-specific, distinct from legacy QuestType)
enum QuestKind: String, Codable, Hashable {
    case main           // Main storyline
    case side           // Optional side quest
    case exploration    // Discovery/exploration quest
    case challenge      // Optional challenge quest
}

// MARK: - Objective Definition

/// Immutable definition of a quest objective (stage).
struct ObjectiveDefinition: Codable, Hashable, Identifiable {
    // MARK: - Identity

    /// Unique objective identifier within the quest
    let id: String

    // MARK: - Localized Content

    /// Objective description with all language variants
    let description: LocalizedString

    /// Objective hint with all language variants (optional)
    let hint: LocalizedString?

    // MARK: - Completion Conditions

    /// Condition type for completion
    let completionCondition: CompletionCondition

    /// Target value for progress-based objectives
    let targetValue: Int

    // MARK: - Flow Control

    /// If true, this objective is optional
    let isOptional: Bool

    /// Next objective ID (nil = quest complete)
    let nextObjectiveId: String?

    /// Alternative objective IDs (for branching)
    let alternativeNextIds: [String]

    // MARK: - Initialization

    init(
        id: String,
        description: LocalizedString,
        hint: LocalizedString? = nil,
        completionCondition: CompletionCondition,
        targetValue: Int = 1,
        isOptional: Bool = false,
        nextObjectiveId: String? = nil,
        alternativeNextIds: [String] = []
    ) {
        self.id = id
        self.description = description
        self.hint = hint
        self.completionCondition = completionCondition
        self.targetValue = targetValue
        self.isOptional = isOptional
        self.nextObjectiveId = nextObjectiveId
        self.alternativeNextIds = alternativeNextIds
    }
}

// MARK: - Completion Condition

/// How an objective is completed
enum CompletionCondition: Codable, Hashable {
    /// Complete when specific flag is set
    case flagSet(String)

    /// Complete when visiting specific region
    case visitRegion(String)

    /// Complete when specific event is resolved
    case eventCompleted(String)

    /// Complete when specific choice is made
    case choiceMade(eventId: String, choiceId: String)

    /// Complete when resource threshold reached
    case resourceThreshold(resourceId: String, minValue: Int)

    /// Complete when defeating specific enemy
    case defeatEnemy(String)

    /// Complete when collecting specific item
    case collectItem(String)

    /// Complete manually (via quest progress trigger)
    case manual
}

// MARK: - Quest Completion Rewards

/// Rewards/penalties for quest completion (Engine-specific, distinct from legacy QuestRewards)
struct QuestCompletionRewards: Codable, Hashable {
    /// Resource changes
    let resourceChanges: [String: Int]

    /// Flags to set
    let setFlags: [String]

    /// Cards to add to deck
    let cardIds: [String]

    /// Balance change
    let balanceDelta: Int

    init(
        resourceChanges: [String: Int] = [:],
        setFlags: [String] = [],
        cardIds: [String] = [],
        balanceDelta: Int = 0
    ) {
        self.resourceChanges = resourceChanges
        self.setFlags = setFlags
        self.cardIds = cardIds
        self.balanceDelta = balanceDelta
    }

    /// No rewards
    static let none = QuestCompletionRewards()
}


// ==========================================
// FILE: Engine/Data/Definitions/RegionDefinition.swift
// ==========================================

import Foundation

// MARK: - Region Definition
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.1
// Reference: Docs/EXPLORATION_CORE_DESIGN.md, Section 5

/// Immutable definition of a region in the game world.
/// Runtime state (visitCount, currentState, etc.) lives in RegionRuntimeState.
struct RegionDefinition: GameDefinition {
    // MARK: - Identity

    /// Unique region identifier (e.g., "forest", "village_square")
    let id: String

    // MARK: - Localized Content

    /// Region name with all language variants
    let title: LocalizedString

    /// Region description with all language variants
    let description: LocalizedString

    // MARK: - Type

    /// Region type string (e.g., "forest", "settlement", "swamp")
    /// This determines visual representation and gameplay effects
    let regionType: String

    // MARK: - Connections

    /// IDs of neighboring regions (for travel)
    let neighborIds: [String]

    /// Whether this region is initially discovered
    let initiallyDiscovered: Bool

    // MARK: - Content

    /// ID of the anchor in this region (nil if no anchor)
    let anchorId: String?

    /// Event pool IDs for this region
    let eventPoolIds: [String]

    // MARK: - Initial State

    /// Initial region state: "stable", "borderland", or "breach"
    let initialState: RegionStateType

    /// Weight for random degradation selection (higher = more likely to degrade)
    let degradationWeight: Int

    // MARK: - Initialization

    init(
        id: String,
        title: LocalizedString,
        description: LocalizedString,
        regionType: String = "forest",
        neighborIds: [String],
        initiallyDiscovered: Bool = false,
        anchorId: String? = nil,
        eventPoolIds: [String] = [],
        initialState: RegionStateType = .stable,
        degradationWeight: Int = 1
    ) {
        self.id = id
        self.title = title
        self.description = description
        self.regionType = regionType
        self.neighborIds = neighborIds
        self.initiallyDiscovered = initiallyDiscovered
        self.anchorId = anchorId
        self.eventPoolIds = eventPoolIds
        self.initialState = initialState
        self.degradationWeight = degradationWeight
    }
}

// MARK: - Region State Types

/// Possible states for a region
enum RegionStateType: String, Codable, Hashable, CaseIterable {
    case stable = "stable"
    case borderland = "borderland"
    case breach = "breach"

    /// Degradation order: stable → borderland → breach
    var degraded: RegionStateType? {
        switch self {
        case .stable: return .borderland
        case .borderland: return .breach
        case .breach: return nil // Cannot degrade further
        }
    }

    /// Restoration order: breach → borderland → stable
    var restored: RegionStateType? {
        switch self {
        case .stable: return nil // Cannot restore further
        case .borderland: return .stable
        case .breach: return .borderland
        }
    }

    /// Weight for random selection during degradation
    var degradationSelectionWeight: Int {
        switch self {
        case .stable: return 0     // Stable regions not selected
        case .borderland: return 1
        case .breach: return 2     // Breach regions more likely
        }
    }
}

// MARK: - Region Type (Twilight Marches specific)

/// Specific region types for Twilight Marches setting
/// Note: This is game-specific, not engine-level
enum TwilightMarchesRegionType: String, Codable, Hashable {
    case settlement = "settlement"
    case wilderness = "wilderness"
    case sacred = "sacred"
    case corrupted = "corrupted"
    case threshold = "threshold"
}


// ==========================================
// FILE: Engine/Migration/EngineAdapters.swift
// ==========================================

import Foundation
import Combine

// MARK: - Engine Adapters
// Bridge between new Engine and legacy Models during migration
// NOTE: These adapters are still required for save/load compatibility
// They can be removed once EngineSave replaces GameSave completely

// MARK: - WorldState Engine Adapter

/// Bridges TwilightGameEngine with legacy WorldState
/// Provides bidirectional sync during migration period
final class WorldStateEngineAdapter {
    // MARK: - Properties

    let worldState: WorldState
    private weak var engine: TwilightGameEngine?
    private var cancellables = Set<AnyCancellable>()

    // MARK: - Initialization

    init(worldState: WorldState, engine: TwilightGameEngine) {
        self.worldState = worldState
        self.engine = engine

        // Note: We don't set up automatic sync here because
        // during Phase 3, all changes should go through Engine
        // Legacy sync is one-way: Engine -> WorldState
    }

    // MARK: - Apply Engine Changes to Legacy

    /// Apply state changes from engine to legacy WorldState
    func applyChanges(_ changes: [StateChange]) {
        for change in changes {
            applyChange(change)
        }
    }

    private func applyChange(_ change: StateChange) {
        switch change {
        case .dayAdvanced(let newDay):
            worldState.daysPassed = newDay

        case .tensionChanged(_, let newValue):
            worldState.worldTension = newValue

        case .regionChanged(let regionId):
            worldState.currentRegionId = regionId

        case .regionStateChanged(let regionId, let newState):
            if let index = worldState.regions.firstIndex(where: { $0.id == regionId }),
               let state = RegionState(rawValue: newState) {
                worldState.regions[index].state = state
            }

        case .anchorIntegrityChanged(let anchorId, _, let newValue):
            // Find region with this anchor and update
            for (index, region) in worldState.regions.enumerated() {
                if region.anchor?.id == anchorId {
                    worldState.regions[index].anchor?.integrity = newValue
                    break
                }
            }

        case .flagSet(let key, let value):
            worldState.worldFlags[key] = value

        case .eventCompleted(let eventId):
            // Mark event as completed in allEvents
            if let index = worldState.allEvents.firstIndex(where: { $0.id == eventId }) {
                worldState.allEvents[index].completed = true
            }

        case .questProgressed(let questId, let newStage):
            // Update quest stage in WorldState's activeQuests
            // questId is String, Quest.id is UUID - convert for comparison
            if let index = worldState.activeQuests.firstIndex(where: { $0.id.uuidString == questId }) {
                worldState.activeQuests[index].stage = newStage
            }

        default:
            // Other changes handled elsewhere or not applicable to WorldState
            break
        }
    }

    // MARK: - Query WorldState for Engine

    /// Get event consequences for a choice
    func getEventConsequences(eventId: UUID, choiceIndex: Int) -> EventConsequences? {
        // Find the event in current available events
        guard let region = worldState.getCurrentRegion() else { return nil }

        let events = worldState.getAvailableEvents(for: region)
        guard let event = events.first(where: { $0.id == eventId }),
              choiceIndex < event.choices.count else {
            return nil
        }

        return event.choices[choiceIndex].consequences
    }

    /// Generate event for region
    func generateEvent(for regionId: UUID, trigger: EventTrigger) -> UUID? {
        guard let region = worldState.getRegion(byId: regionId) else { return nil }

        let events = worldState.getAvailableEvents(for: region)

        // Weight-based selection using WorldRNG
        guard !events.isEmpty else { return nil }

        // Select event using weights
        let totalWeight = events.reduce(0) { $0 + $1.weight }
        guard totalWeight > 0 else { return events.first?.id }

        let roll = WorldRNG.shared.nextInt(in: 0..<totalWeight)
        var cumulative = 0
        for event in events {
            cumulative += event.weight
            if roll < cumulative {
                return event.id
            }
        }

        return events.first?.id
    }

    /// Check quest progress and return changes
    func checkQuestProgress() -> [StateChange] {
        var changes: [StateChange] = []

        // Delegate to WorldState's quest checking
        // This is a simplified version - full implementation would check all triggers
        for quest in worldState.activeQuests where !quest.completed {
            let previousStage = quest.stage
            worldState.checkQuestProgress(quest)

            if let updatedQuest = worldState.activeQuests.first(where: { $0.id == quest.id }),
               updatedQuest.stage != previousStage {
                changes.append(.questProgressed(questId: quest.id.uuidString, newStage: updatedQuest.stage))
            }
        }

        return changes
    }
}

// MARK: - Player Engine Adapter

/// Bridges TwilightGameEngine with legacy Player model
final class PlayerEngineAdapter {
    // MARK: - Properties

    let player: Player
    private weak var engine: TwilightGameEngine?

    // MARK: - Initialization

    init(player: Player, engine: TwilightGameEngine) {
        self.player = player
        self.engine = engine
    }

    // MARK: - Update Methods

    func updateHealth(_ newValue: Int) {
        player.health = newValue
    }

    func updateFaith(_ newValue: Int) {
        player.faith = newValue
    }

    func updateBalance(_ newValue: Int) {
        player.balance = newValue
    }

    func updateStrength(_ newValue: Int) {
        player.strength = newValue
    }

    // MARK: - Sync Methods

    /// Sync player state from engine resources
    func syncFromEngine() {
        // During migration, engine state is authoritative
        // Player model is updated to match
    }

    /// Sync engine resources from player
    func syncToEngine() {
        // This would push player state to engine
        // Used during initial setup
    }
}

// MARK: - Unused Adapters Removed
// GameStateEngineAdapter and EngineMigrationHelper were removed as part of Phase 4 cleanup.
// ContentView now uses Engine-First architecture directly.


// ==========================================
// FILE: Engine/Migration/EventDefinitionAdapter.swift
// ==========================================

import Foundation

// MARK: - Event Definition Adapter
// Converts EventDefinition (new data-driven) to GameEvent (legacy UI-compatible)
// This enables using content packs while maintaining compatibility with existing UI

extension EventDefinition {

    /// Convert EventDefinition to legacy GameEvent for UI compatibility
    /// - Parameter regionId: Optional region ID for context-specific conversion
    /// - Returns: GameEvent compatible with existing UI
    func toGameEvent(forRegion regionId: String? = nil) -> GameEvent {
        // Generate deterministic UUID from string ID for consistency
        let eventUUID = UUID(uuidString: id.md5UUID) ?? UUID()

        // Map event kind to legacy event type
        let eventType = mapEventKind(eventKind)

        // Map region states from availability
        let regionStates = mapRegionStates(availability.regionStates)

        // Map region types (infer from region IDs if needed)
        let regionTypes = mapRegionTypes(availability.regionIds)

        // Convert choices
        let eventChoices = choices.map { $0.toEventChoice() }

        // Create monster card for combat events
        let monsterCard = createMonsterCard(for: miniGameChallenge)

        return GameEvent(
            id: eventUUID,
            eventType: eventType,
            title: title.localized,
            description: body.localized,
            regionTypes: regionTypes,
            regionStates: regionStates,
            choices: eventChoices,
            questLinks: extractQuestLinks(),
            oneTime: isOneTime,
            completed: false,
            monsterCard: monsterCard,
            instant: isInstant,
            weight: weight,
            minTension: availability.minPressure,
            maxTension: availability.maxPressure,
            requiredFlags: availability.requiredFlags.isEmpty ? nil : availability.requiredFlags,
            forbiddenFlags: availability.forbiddenFlags.isEmpty ? nil : availability.forbiddenFlags
        )
    }

    // MARK: - Private Mapping Helpers

    private func mapEventKind(_ kind: EventKind) -> EventType {
        switch kind {
        case .inline:
            return .narrative
        case .miniGame(let miniGameKind):
            switch miniGameKind {
            case .combat:
                return .combat
            case .ritual:
                return .ritual
            case .exploration:
                return .exploration
            case .dialogue:
                return .narrative
            case .puzzle:
                return .ritual
            }
        }
    }

    private func mapRegionStates(_ stateStrings: [String]?) -> [RegionState] {
        guard let states = stateStrings else {
            return [.stable, .borderland, .breach] // Default: all states
        }

        return states.compactMap { stateString in
            switch stateString.lowercased() {
            case "stable": return .stable
            case "borderland": return .borderland
            case "breach": return .breach
            default: return nil
            }
        }
    }

    private func mapRegionTypes(_ regionIds: [String]?) -> [RegionType] {
        guard let ids = regionIds else {
            return [] // Empty = any region type
        }

        // Look up region types from ContentRegistry (no hardcoded ID mapping)
        var types = Set<RegionType>()
        for regionId in ids {
            if let regionDef = ContentRegistry.shared.getRegion(id: regionId) {
                // Map regionType string from definition to RegionType enum
                let regionType = mapRegionTypeString(regionDef.regionType)
                types.insert(regionType)
            }
        }
        return Array(types)
    }

    private func mapRegionTypeString(_ typeString: String) -> RegionType {
        switch typeString.lowercased() {
        case "settlement": return .settlement
        case "forest": return .forest
        case "swamp": return .swamp
        case "wasteland": return .wasteland
        case "sacred": return .sacred
        case "mountain": return .mountain
        case "water": return .water
        default: return .forest
        }
    }

    private func extractQuestLinks() -> [String] {
        // Extract quest links from choice consequences
        var links: [String] = []
        for choice in choices {
            if let questProgress = choice.consequences.questProgress {
                links.append(questProgress.questId)
            }
        }
        return links
    }

    private func createMonsterCard(for challenge: MiniGameChallengeDefinition?) -> Card? {
        guard let challenge = challenge,
              let enemyId = challenge.enemyId else { return nil }

        // First, try to get enemy from ContentRegistry
        if let enemy = ContentRegistry.shared.getEnemy(id: enemyId) {
            return enemy.toCard()
        }

        // Fallback: Create from hardcoded stats
        let enemyStats = getEnemyStats(for: enemyId, difficulty: challenge.difficulty)

        return Card(
            id: UUID(),
            name: enemyId.replacingOccurrences(of: "_", with: " ").capitalized,
            type: .monster,
            rarity: difficultyToRarity(challenge.difficulty),
            description: "Enemy: \(enemyId)",
            power: enemyStats.power,
            defense: enemyStats.defense,
            health: enemyStats.health
        )
    }

    private func getEnemyStats(for enemyId: String, difficulty: Int) -> (health: Int, power: Int, defense: Int) {
        // Base stats scaled by difficulty
        let baseHealth = 5 + (difficulty * 3)
        let basePower = 2 + difficulty
        let baseDefense = 1 + (difficulty / 2)

        // Enemy-specific adjustments
        switch enemyId {
        case "wild_beast":
            return (health: baseHealth, power: basePower + 1, defense: baseDefense)
        case "leshy":
            return (health: baseHealth + 2, power: basePower, defense: baseDefense + 1)
        case "mountain_spirit":
            return (health: baseHealth + 3, power: basePower + 1, defense: baseDefense + 2)
        case "leshy_guardian_boss":
            return (health: baseHealth + 10, power: basePower + 3, defense: baseDefense + 3)
        default:
            return (health: baseHealth, power: basePower, defense: baseDefense)
        }
    }

    private func difficultyToRarity(_ difficulty: Int) -> CardRarity {
        switch difficulty {
        case 1: return .common
        case 2: return .uncommon
        case 3: return .rare
        case 4...5: return .epic
        default: return .legendary
        }
    }
}

// MARK: - Choice Definition to Event Choice

extension ChoiceDefinition {

    /// Convert ChoiceDefinition to legacy EventChoice
    func toEventChoice() -> EventChoice {
        return EventChoice(
            id: id,
            text: label.localized,
            requirements: requirements?.toEventRequirements(),
            consequences: consequences.toEventConsequences()
        )
    }
}

// MARK: - Choice Requirements Conversion

extension ChoiceRequirements {

    /// Convert to legacy EventRequirements
    func toEventRequirements() -> EventRequirements {
        var requirements = EventRequirements()

        // Map resource requirements
        if let faith = minResources["faith"] {
            requirements.minimumFaith = faith
        }
        if let health = minResources["health"] {
            requirements.minimumHealth = health
        }

        // Map balance requirements
        if let minBal = minBalance {
            if minBal >= 70 {
                requirements.requiredBalance = .light
            } else if let maxBal = maxBalance, maxBal <= 30 {
                requirements.requiredBalance = .dark
            }
        }

        // Map flag requirements
        if !requiredFlags.isEmpty {
            requirements.requiredFlags = requiredFlags
        }

        return requirements
    }
}

// MARK: - Choice Consequences Conversion

extension ChoiceConsequences {

    /// Convert to legacy EventConsequences
    func toEventConsequences() -> EventConsequences {
        var consequences = EventConsequences()

        // Map resource changes
        if let faith = resourceChanges["faith"] {
            consequences.faithChange = faith
        }
        if let health = resourceChanges["health"] {
            consequences.healthChange = health
        }

        // Map balance change
        if balanceDelta != 0 {
            consequences.balanceChange = balanceDelta
        }

        // Map flags
        if !setFlags.isEmpty {
            var flagDict: [String: Bool] = [:]
            for flag in setFlags {
                flagDict[flag] = true
            }
            for flag in clearFlags {
                flagDict[flag] = false
            }
            consequences.setFlags = flagDict
        }

        // Map region state change to anchor integrity
        if let stateChange = regionStateChange,
           let transition = stateChange.transition {
            switch transition {
            case .restore:
                consequences.anchorIntegrityChange = 20
            case .degrade:
                consequences.anchorIntegrityChange = -20
            }
        }

        // Result message from result key
        if let resultKey = resultKey {
            consequences.message = resultKey.replacingOccurrences(of: "_", with: " ").capitalized
        }

        return consequences
    }
}

// MARK: - String UUID Extension

private extension String {
    /// Generate a deterministic UUID-like string from this string
    var md5UUID: String {
        // Simple hash-based UUID generation for determinism
        var hash: UInt64 = 5381
        for char in self.utf8 {
            hash = ((hash << 5) &+ hash) &+ UInt64(char)
        }

        // Format as UUID string (simplified)
        let hex = String(format: "%016llX", hash)
        let padded = hex.padding(toLength: 32, withPad: "0", startingAt: 0)

        // Insert dashes: 8-4-4-4-12
        let chars = Array(padded)
        return "\(String(chars[0..<8]))-\(String(chars[8..<12]))-\(String(chars[12..<16]))-\(String(chars[16..<20]))-\(String(chars[20..<32]))"
    }
}


// ==========================================
// FILE: Engine/Migration/LegacyAdapters.swift
// ==========================================

import Foundation

// MARK: - Legacy Adapters
// Reference: Docs/MIGRATION_PLAN.md, Feature A2
// These adapters provide compatibility between old Models/* and new Engine/Runtime/*

/// Adapter to convert legacy WorldState to WorldRuntimeState
/// Used during migration - will be removed after Phase 3
struct WorldStateAdapter {
    /// Convert legacy WorldState to new WorldRuntimeState
    /// NOTE: This is a one-way conversion for migration
    static func toRuntime(
        from legacyWorld: LegacyWorldStateProtocol,
        contentProvider: ContentProvider
    ) -> WorldRuntimeState {
        // Build regions state
        var regionsState: [String: RegionRuntimeState] = [:]
        for region in contentProvider.getAllRegionDefinitions() {
            let legacyState = legacyWorld.getRegionState(region.id)
            regionsState[region.id] = RegionRuntimeState(
                definitionId: region.id,
                currentState: mapRegionState(legacyState?.stateString ?? region.initialState.rawValue),
                visitCount: legacyState?.visitCount ?? 0,
                isDiscovered: legacyState?.isDiscovered ?? region.initiallyDiscovered
            )
        }

        // Build anchors state
        var anchorsState: [String: AnchorRuntimeState] = [:]
        for anchor in contentProvider.getAllAnchorDefinitions() {
            let legacyIntegrity = legacyWorld.getAnchorIntegrity(anchor.id)
            anchorsState[anchor.id] = AnchorRuntimeState(
                definitionId: anchor.id,
                integrity: legacyIntegrity ?? anchor.initialIntegrity,
                isActive: (legacyIntegrity ?? anchor.initialIntegrity) > 0
            )
        }

        return WorldRuntimeState(
            currentRegionId: legacyWorld.currentRegionId,
            currentTime: legacyWorld.daysPassed,
            pressure: legacyWorld.worldTension,
            daysSinceEscalation: legacyWorld.daysPassed % 3, // Estimate
            regionsState: regionsState,
            anchorsState: anchorsState,
            flags: legacyWorld.flags
        )
    }

    private static func mapRegionState(_ stateString: String) -> RegionStateType {
        switch stateString.lowercased() {
        case "stable": return .stable
        case "borderland": return .borderland
        case "breach": return .breach
        default: return .stable
        }
    }
}

/// Adapter to convert legacy Player to PlayerRuntimeState
struct PlayerStateAdapter {
    static func toRuntime(from legacyPlayer: LegacyPlayerProtocol) -> PlayerRuntimeState {
        return PlayerRuntimeState(
            resources: [
                "health": legacyPlayer.health,
                "faith": legacyPlayer.faith
            ],
            balance: legacyPlayer.balance,
            drawPile: legacyPlayer.drawPileCardIds,
            hand: legacyPlayer.handCardIds,
            discardPile: legacyPlayer.discardPileCardIds,
            exilePile: [],
            activeCurses: Set(legacyPlayer.curseIds)
        )
    }
}

/// Adapter to convert legacy GameSave to GameRuntimeState
struct GameSaveAdapter {
    static func toRuntime(
        from legacySave: LegacyGameSaveProtocol,
        contentProvider: ContentProvider
    ) -> GameRuntimeState {
        let world = WorldStateAdapter.toRuntime(
            from: legacySave.worldState,
            contentProvider: contentProvider
        )

        let player = PlayerStateAdapter.toRuntime(from: legacySave.player)

        let events = EventRuntimeState(
            completedOneTimeEvents: legacySave.completedEventIds,
            eventOccurrenceCount: [:], // Not tracked in legacy
            eventCooldowns: [:] // Not tracked in legacy
        )

        let quests = QuestRuntimeState(
            questStates: legacySave.questStates.mapValues { legacyQuest in
                SingleQuestState(
                    definitionId: legacyQuest.questId,
                    status: mapQuestStatus(legacyQuest.statusString),
                    currentObjectiveId: legacyQuest.currentObjectiveId,
                    completedObjectiveIds: legacyQuest.completedObjectiveIds
                )
            }
        )

        return GameRuntimeState(
            world: world,
            player: player,
            events: events,
            quests: quests,
            phase: .playing,
            playthroughSeed: legacySave.seed ?? UInt64.random(in: 0...UInt64.max),
            saveSlot: legacySave.slotNumber
        )
    }

    private static func mapQuestStatus(_ statusString: String) -> QuestStatus {
        switch statusString.lowercased() {
        case "locked": return .locked
        case "available": return .available
        case "active", "in_progress": return .active
        case "completed", "done": return .completed
        case "failed": return .failed
        default: return .locked
        }
    }
}

// MARK: - Legacy Protocols
// These protocols define the interface expected from legacy Models/*
// Actual conformance is added via extensions in the Models files

/// Protocol for legacy WorldState
protocol LegacyWorldStateProtocol {
    var currentRegionId: String { get }
    var daysPassed: Int { get }
    var worldTension: Int { get }
    var flags: [String: Bool] { get }

    func getRegionState(_ regionId: String) -> LegacyRegionState?
    func getAnchorIntegrity(_ anchorId: String) -> Int?
}

/// Legacy region state data
struct LegacyRegionState {
    let stateString: String
    let visitCount: Int
    let isDiscovered: Bool
}

/// Protocol for legacy Player
protocol LegacyPlayerProtocol {
    var health: Int { get }
    var faith: Int { get }
    var balance: Int { get }
    var drawPileCardIds: [String] { get }
    var handCardIds: [String] { get }
    var discardPileCardIds: [String] { get }
    var curseIds: [String] { get }
}

/// Protocol for legacy GameSave
protocol LegacyGameSaveProtocol {
    var worldState: LegacyWorldStateProtocol { get }
    var player: LegacyPlayerProtocol { get }
    var completedEventIds: Set<String> { get }
    var questStates: [String: LegacyQuestState] { get }
    var seed: UInt64? { get }
    var slotNumber: Int? { get }
}

/// Legacy quest state data
struct LegacyQuestState {
    let questId: String
    let statusString: String
    let currentObjectiveId: String?
    let completedObjectiveIds: Set<String>
}

// MARK: - Reverse Adapter (for compatibility during migration)

/// Adapter to expose new RuntimeState through legacy interface
/// Allows gradual migration without breaking existing code
class RuntimeToLegacyAdapter {
    private var runtime: GameRuntimeState

    init(runtime: GameRuntimeState) {
        self.runtime = runtime
    }

    // MARK: - Legacy World Interface

    var currentRegionId: String {
        return runtime.world.currentRegionId
    }

    var daysPassed: Int {
        return runtime.world.currentTime
    }

    var worldTension: Int {
        return runtime.world.pressure
    }

    // MARK: - Legacy Player Interface

    var health: Int {
        return runtime.player.getResource("health")
    }

    var faith: Int {
        return runtime.player.getResource("faith")
    }

    // MARK: - Update from Engine (during migration)

    func updateFromRuntime(_ newRuntime: GameRuntimeState) {
        self.runtime = newRuntime
    }
}


// ==========================================
// FILE: Engine/Migration/QuestDefinitionAdapter.swift
// ==========================================

import Foundation

// MARK: - Quest Definition Adapter
// Converts QuestDefinition (new data-driven) to Quest (legacy UI-compatible)
// This enables using content packs while maintaining compatibility with existing UI

extension QuestDefinition {

    /// Convert QuestDefinition to legacy Quest for UI compatibility
    /// - Returns: Quest compatible with existing UI
    func toQuest() -> Quest {
        // Generate deterministic UUID from string ID for consistency
        let questUUID = UUID(uuidString: id.md5UUID) ?? UUID()

        // Map quest kind to legacy quest type
        let questType = mapQuestKind(questKind)

        // Convert objectives
        let legacyObjectives = objectives.map { $0.toQuestObjective() }

        // Convert rewards
        let rewards = completionRewards.toQuestRewards()

        return Quest(
            id: questUUID,
            title: title.localized,
            description: description.localized,
            questType: questType,
            stage: 0,
            objectives: legacyObjectives,
            rewards: rewards,
            completed: false
        )
    }

    // MARK: - Private Mapping Helpers

    private func mapQuestKind(_ kind: QuestKind) -> QuestType {
        switch kind {
        case .main:
            return .main
        case .side, .exploration, .challenge:
            return .side
        }
    }
}

// MARK: - Objective Definition to Quest Objective

extension ObjectiveDefinition {

    /// Convert ObjectiveDefinition to legacy QuestObjective
    func toQuestObjective() -> QuestObjective {
        // Generate deterministic UUID from string ID
        let objectiveUUID = UUID(uuidString: id.md5UUID) ?? UUID()

        // Extract required flags from completion condition
        let requiredFlags = extractRequiredFlags(from: completionCondition)

        return QuestObjective(
            id: objectiveUUID,
            description: description.localized,
            completed: false,
            requiredFlags: requiredFlags
        )
    }

    private func extractRequiredFlags(from condition: CompletionCondition) -> [String]? {
        switch condition {
        case .flagSet(let flag):
            return [flag]
        case .eventCompleted(let eventId):
            return ["\(eventId)_completed"]
        case .choiceMade(let eventId, let choiceId):
            return ["\(eventId)_\(choiceId)_chosen"]
        case .visitRegion(let regionId):
            return ["visited_\(regionId)"]
        case .defeatEnemy(let enemyId):
            return ["defeated_\(enemyId)"]
        case .collectItem(let itemId):
            return ["collected_\(itemId)"]
        case .resourceThreshold, .manual:
            return nil
        }
    }
}

// MARK: - Quest Completion Rewards to Quest Rewards

extension QuestCompletionRewards {

    /// Convert to legacy QuestRewards
    func toQuestRewards() -> QuestRewards {
        let faith = resourceChanges["faith"]
        let cards = cardIds.isEmpty ? nil : cardIds

        return QuestRewards(
            faith: faith,
            cards: cards,
            artifact: nil,  // Artifacts not supported in new format yet
            experience: nil  // Experience not supported in new format yet
        )
    }
}

// MARK: - String UUID Extension (reuse from EventDefinitionAdapter)

private extension String {
    /// Generate a deterministic UUID-like string from this string
    var md5UUID: String {
        // Simple hash-based UUID generation for determinism
        var hash: UInt64 = 5381
        for char in self.utf8 {
            hash = ((hash << 5) &+ hash) &+ UInt64(char)
        }

        // Format as UUID string (simplified)
        let hex = String(format: "%016llX", hash)
        let padded = hex.padding(toLength: 32, withPad: "0", startingAt: 0)

        // Insert dashes: 8-4-4-4-12
        let chars = Array(padded)
        return "\(String(chars[0..<8]))-\(String(chars[8..<12]))-\(String(chars[12..<16]))-\(String(chars[16..<20]))-\(String(chars[20..<32]))"
    }
}


// ==========================================
// FILE: Helpers/Localization.swift
// ==========================================

import Foundation

// MARK: - Localization Helper
extension String {
    var localized: String {
        return NSLocalizedString(self, comment: "")
    }

    func localized(with arguments: CVarArg...) -> String {
        return String(format: self.localized, arguments: arguments)
    }
}

// MARK: - Localization Keys
enum L10n {
    // Main Screen
    static let gameTitle = "game.title"
    static let characterSelectTitle = "character.select.title"
    static let characterStats = "character.stats"
    static let characterAbilities = "character.abilities"
    static let buttonStartAdventure = "button.start.adventure"

    // Game Board
    static let turnLabel = "turn.label"
    static let buttonNextPhase = "button.next.phase"
    static let buttonExplore = "button.explore"
    static let buttonRollDice = "button.roll.dice"
    static let diceResult = "dice.result"
    static let diceRollTitle = "dice.roll.title"
    static let diceRollMessage = "dice.roll.message"
    static let buttonOk = "button.ok"

    // Game Phases
    static let phaseSetup = "phase.setup"
    static let phaseExploration = "phase.exploration"
    static let phaseEncounter = "phase.encounter"
    static let phasePlayerTurn = "phase.player.turn"
    static let phaseEnemyTurn = "phase.enemy.turn"
    static let phaseEndTurn = "phase.end.turn"
    static let phaseGameOver = "phase.game.over"

    // Encounter
    static let encounterActive = "encounter.active"

    // Deck
    static let deckEncounters = "deck.encounters"
    static let deckLocations = "deck.locations"
    static let deckCards = "deck.cards"

    // Player Hand
    static let playerHandTitle = "player.hand.title"
    static let playerDiscardPile = "player.discard.pile"
    static let playerDeckRemaining = "player.deck.remaining"

    // Card Types
    static let cardTypeCharacter = "card.type.character"
    static let cardTypeWeapon = "card.type.weapon"
    static let cardTypeSpell = "card.type.spell"
    static let cardTypeArmor = "card.type.armor"
    static let cardTypeItem = "card.type.item"
    static let cardTypeBlessing = "card.type.blessing"
    static let cardTypeMonster = "card.type.monster"
    static let cardTypeLocation = "card.type.location"
    static let cardTypeAlly = "card.type.ally"

    // Stats
    static let statHealth = "stat.health"
    static let statPower = "stat.power"
    static let statDefense = "stat.defense"
    static let statStrength = "stat.strength"
    static let statDexterity = "stat.dexterity"
    static let statConstitution = "stat.constitution"
    static let statIntelligence = "stat.intelligence"
    static let statWisdom = "stat.wisdom"
    static let statCharisma = "stat.charisma"

    // Rarity
    static let rarityCommon = "rarity.common"
    static let rarityUncommon = "rarity.uncommon"
    static let rarityRare = "rarity.rare"
    static let rarityEpic = "rarity.epic"
    static let rarityLegendary = "rarity.legendary"

    // Damage Types
    static let damagePhysical = "damage.physical"
    static let damageFire = "damage.fire"
    static let damageCold = "damage.cold"
    static let damageLightning = "damage.lightning"
    static let damagePoison = "damage.poison"
    static let damageAcid = "damage.acid"
    static let damageHoly = "damage.holy"
    static let damageShadow = "damage.shadow"

    // Actions
    static let actionPlay = "action.play"
    static let actionDiscard = "action.discard"
    static let actionExamine = "action.examine"

    // Rules
    static let rulesTitle = "rules.title"
    static let rulesButton = "rules.button"

    // Rules Sections
    static let rulesObjectiveTitle = "rules.objective.title"
    static let rulesObjectiveContent = "rules.objective.content"

    static let rulesPhasesTitle = "rules.phases.title"
    static let rulesPhasesContent = "rules.phases.content"

    static let rulesPhaseExploration = "rules.phase.exploration"
    static let rulesPhaseEncounter = "rules.phase.encounter"
    static let rulesPhasePlayerTurn = "rules.phase.player.turn"
    static let rulesPhaseEnemyTurn = "rules.phase.enemy.turn"
    static let rulesPhaseEndTurn = "rules.phase.endturn"

    static let rulesCardsTitle = "rules.cards.title"
    static let rulesCardsContent = "rules.cards.content"

    static let rulesResourcesTitle = "rules.resources.title"
    static let rulesResourcesContent = "rules.resources.content"

    static let rulesActionsTitle = "rules.actions.title"
    static let rulesActionsContent = "rules.actions.content"

    static let rulesDiceTitle = "rules.dice.title"
    static let rulesDiceContent = "rules.dice.content"

    static let rulesVictoryTitle = "rules.victory.title"
    static let rulesVictoryContent = "rules.victory.content"

    static let rulesTipsTitle = "rules.tips.title"
    static let rulesTipsContent = "rules.tips.content"

    // MARK: - Twilight Marches
    static let tmGameTitle = "tm.game.title"
    static let tmGameSubtitle = "tm.game.subtitle"

    // Realms
    static let tmRealmYav = "tm.realm.yav"
    static let tmRealmNav = "tm.realm.nav"
    static let tmRealmPrav = "tm.realm.prav"

    // Balance
    static let tmBalanceLight = "tm.balance.light"
    static let tmBalanceNeutral = "tm.balance.neutral"
    static let tmBalanceDark = "tm.balance.dark"

    // Resources
    static let tmResourceFaith = "tm.resource.faith"
    static let tmResourceBalance = "tm.resource.balance"

    // Card Types
    static let tmCardTypeCurse = "tm.card.type.curse"
    static let tmCardTypeSpirit = "tm.card.type.spirit"
    static let tmCardTypeArtifact = "tm.card.type.artifact"
    static let tmCardTypeRitual = "tm.card.type.ritual"

    // Curse Types
    static let tmCurseBlindness = "tm.curse.type.blindness"
    static let tmCurseMuteness = "tm.curse.type.muteness"
    static let tmCurseWeakness = "tm.curse.type.weakness"
    static let tmCurseForgetfulness = "tm.curse.type.forgetfulness"
    static let tmCurseSickness = "tm.curse.type.sickness"
    static let tmCurseMadness = "tm.curse.type.madness"
    static let tmCurseTransformation = "tm.curse.type.transformation"

    // UI Elements
    static let uiMenuButton = "ui.menu.button"
    static let uiPauseMenu = "ui.pause.menu"
    static let uiResume = "ui.resume"
    static let uiSaveGame = "ui.save.game"
    static let uiRules = "ui.rules"
    static let uiExit = "ui.exit"
    static let uiRoll = "ui.roll"
    static let uiResult = "ui.result"
    static let uiEncounters = "ui.encounters"
    static let uiYourDeck = "ui.your.deck"
    static let uiDiscard = "ui.discard"
    static let uiActiveEncounter = "ui.active.encounter"
    static let uiExplore = "ui.explore"
    static let uiDeckInfo = "ui.deck.info"
    static let uiHandTitle = "ui.hand.title"
    static let uiGameSaved = "ui.game.saved"
    static let uiProgressSaved = "ui.progress.saved"

    // Victory/Defeat
    static let uiVictoryTitle = "ui.victory.title"
    static let uiDefeatTitle = "ui.defeat.title"
    static let uiEncountersDefeated = "ui.encounters.defeated"
    static let uiTurnsTaken = "ui.turns.taken"
    static let uiTurnsSurvived = "ui.turns.survived"
    static let uiReturnMenu = "ui.return.menu"

    // Tooltips
    static let tooltipHealth = "tooltip.health"
    static let tooltipFaith = "tooltip.faith"
    static let tooltipBalance = "tooltip.balance"
    static let tooltipNextPhase = "tooltip.next.phase"

    // MARK: - Region UI (Audit v1.1 Issue #2)

    // Region States
    static let regionStateStable = "region.state.stable"
    static let regionStateBorderland = "region.state.borderland"
    static let regionStateBreach = "region.state.breach"

    // Region Info
    static let regionReputation = "region.reputation"
    static let regionCurrentLocation = "region.current.location"

    // Actions
    static let actionTravel = "action.travel"
    static let actionRest = "action.rest"
    static let actionTrade = "action.trade"
    static let actionStrengthenAnchor = "action.strengthen.anchor"
    static let actionExploreRegion = "action.explore.region"

    // MARK: - Combat UI (Engine-First Migration)

    // Combat phases
    static let combatTitle = "combat.title"
    static let combatTurnNumber = "combat.turn.number"
    static let combatActionsRemaining = "combat.actions.remaining"
    static let combatPlayerTurn = "combat.phase.player.turn"
    static let combatEnemyTurn = "combat.phase.enemy.turn"
    static let combatEndTurn = "combat.phase.end.turn"
    static let combatOver = "combat.phase.over"

    // Combat actions
    static let combatAttackButton = "combat.action.attack"
    static let combatEndTurnButton = "combat.action.end.turn"
    static let combatFleeButton = "combat.action.flee"
    static let combatPlayCard = "combat.action.play.card"

    // Combat stats
    static let combatHP = "combat.stat.hp"
    static let combatAttack = "combat.stat.attack"
    static let combatDefense = "combat.stat.defense"
    static let combatStrength = "combat.stat.strength"

    // Combat messages
    static let combatVictory = "combat.message.victory"
    static let combatDefeat = "combat.message.defeat"
    static let combatFled = "combat.message.fled"
    static let combatHit = "combat.message.hit"
    static let combatMiss = "combat.message.miss"
    static let combatDamage = "combat.message.damage"

    // Combat log
    static let combatLogTitle = "combat.log.title"
    static let combatLogBattleStart = "combat.log.battle.start"
    static let combatLogActionsPerTurn = "combat.log.actions.per.turn"
    static let combatLogEnemyAttacks = "combat.log.enemy.attacks"
    static let combatLogSpiritAttacks = "combat.log.spirit.attacks"
    static let combatLogMeditation = "combat.log.meditation"
    static let combatLogTurnSeparator = "combat.log.turn.separator"

    // Combat card effects
    static let combatEffectHeal = "combat.effect.heal"
    static let combatEffectDamage = "combat.effect.damage"
    static let combatEffectDrawCards = "combat.effect.draw.cards"
    static let combatEffectGainFaith = "combat.effect.gain.faith"
    static let combatEffectSpendFaith = "combat.effect.spend.faith"
    static let combatEffectRemoveCurse = "combat.effect.remove.curse"
    static let combatEffectBonusDice = "combat.effect.bonus.dice"
    static let combatEffectShiftBalance = "combat.effect.shift.balance"
    static let combatEffectSummonSpirit = "combat.effect.summon.spirit"
    static let combatEffectSacrifice = "combat.effect.sacrifice"

    // Combat attack breakdown
    static let combatAttackRoll = "combat.attack.roll"
    static let combatDamageCalc = "combat.damage.calc"
    static let combatBaseDamage = "combat.damage.base"

    // Hand UI
    static let combatYourHand = "combat.your.hand"
    static let combatTapToPlay = "combat.tap.to.play"
    static let combatNotEnoughFaith = "combat.not.enough.faith"

    // MARK: - UI Strings (Audit Issue #1 - Hardcoded Strings)

    // ContentView / Save Slots
    static let uiContinue = "ui.continue"
    static let uiBack = "ui.back"
    static let uiSlotSelection = "ui.slot.selection"
    static let uiContinueGame = "ui.continue.game"
    static let uiSlotNumber = "ui.slot.number"
    static let uiTurnNumber = "ui.turn.number"
    static let uiVictories = "ui.victories"
    static let uiLoad = "ui.load"
    static let uiNewGame = "ui.new.game"
    static let uiEmptySlot = "ui.empty.slot"
    static let uiStartNewGame = "ui.start.new.game"
    static let uiDeleteConfirm = "ui.delete.confirm"
    static let uiOverwriteConfirm = "ui.overwrite.confirm"
    static let uiDeleteSave = "ui.delete.save"
    static let uiOverwriteSave = "ui.overwrite.save"
    static let uiCancel = "ui.cancel"
    static let uiDelete = "ui.delete"
    static let uiOverwrite = "ui.overwrite"

    // EventView
    static let eventChooseAction = "event.choose.action"
    static let eventRequiresFaith = "event.requires.faith"
    static let eventYouHaveFaith = "event.you.have.faith"
    static let eventRequiresHealth = "event.requires.health"
    static let eventYouHaveHealth = "event.you.have.health"
    static let eventRequiresPath = "event.requires.path"
    static let eventYourPath = "event.your.path"
    static let eventFaithChange = "event.faith.change"
    static let eventHealthChange = "event.health.change"
    static let eventBalanceToLight = "event.balance.to.light"
    static let eventBalanceToDark = "event.balance.to.dark"
    static let eventReputationChange = "event.reputation.change"
    static let eventReceiveCard = "event.receive.card"
    static let eventReceiveCurse = "event.receive.curse"
    static let eventChoiceMade = "event.choice.made"
    static let eventCombatVictoryMessage = "event.combat.victory.message"
    static let eventCombatDefeatMessage = "event.combat.defeat.message"
    static let eventCombatFledMessage = "event.combat.fled.message"

    // UI Common
    static let uiClose = "ui.close"

    // Balance (genitive form)
    static let tmBalanceLightGenitive = "tm.balance.light.genitive"
    static let tmBalanceNeutralGenitive = "tm.balance.neutral.genitive"
    static let tmBalanceDarkGenitive = "tm.balance.dark.genitive"

    // StatisticsView
    static let statsTitle = "stats.title"
    static let statsGameName = "stats.game.name"
    static let statsGeneral = "stats.general"
    static let statsLeaderboard = "stats.leaderboard"
    static let statsHistory = "stats.history"
    static let statsNoSaves = "stats.no.saves"
    static let statsStartHint = "stats.start.hint"
    static let statsDone = "stats.done"
    static let statsResources = "stats.resources"
    static let statsProgress = "stats.progress"
    static let statsGamesCount = "stats.games.count"
    static let statsBestResult = "stats.best.result"
    static let statsLongestSurvival = "stats.longest.survival"
    static let statsTurnsCount = "stats.turns.count"
    static let statsVictoriesLabel = "stats.victories.label"
    static let statsTurnsLabel = "stats.turns.label"

    // CombatView additional
    static let combatVs = "combat.vs"
    static let combatAttackRollTitle = "combat.attack.roll"
    static let combatDamageCalcTitle = "combat.damage.calc.title"
    static let combatBaseValue = "combat.base.value"
    static let combatTotalDamage = "combat.total.damage"
}

