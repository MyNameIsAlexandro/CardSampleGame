=== DUMP GENERATED ===
Source: /Users/abondarenko/Library/Mobile Documents/com~apple~CloudDocs/XCode/CardSampleGame

=== FILE STRUCTURE (Relevant Files) ===
ViewModels/
    GameViewModel.swift
en.lproj/
App/
    CardGameApp.swift
    ContentView.swift
.claude/
ContentPacks/
    TwilightMarches/
        Cards/
        Balance/
        Campaign/
            ActI/
            Enemies/
        Characters/
        Localization/
Models/
    Card.swift
    CardType.swift
    ExplorationModels.swift
    GameSave.swift
    GameState.swift
    Player.swift
    WorldState.swift
Docs/
    Archive/
Utilities/
    AccessibilityIdentifiers.swift
    Localization.swift
    SafeImage.swift
    WorldRNG.swift
.github/
    workflows/
ru.lproj/
Data/
Views/
    CardView.swift
    CombatView.swift
    EventView.swift
    GameBoardView.swift
    HeroSelectionView.swift
    PlayerHandView.swift
    RulesView.swift
    StatisticsView.swift
    WorldMapView.swift
    Components/
        HeroPanel.swift
Engine/
    Core/
        CoreGameEngine.swift
        EconomyManager.swift
        EngineProtocols.swift
        EngineSave.swift
        GameLoop.swift
        PressureEngine.swift
        RequirementsEvaluator.swift
        TimeEngine.swift
        TwilightGameAction.swift
        TwilightGameEngine.swift
    Combat/
        CombatCalculator.swift
    Config/
        DegradationRules.swift
        TwilightMarchesConfig.swift
    Heroes/
        AbilityRegistry.swift
        HeroAbility.swift
        HeroDefinition.swift
        HeroRegistry.swift
    Cards/
        CardDefinition.swift
        CardFactory.swift
        CardRegistry.swift
        TwilightMarchesCards.swift
    Runtime/
        EventRuntimeState.swift
        GameRuntimeState.swift
        PlayerRuntimeState.swift
        QuestRuntimeState.swift
        WorldRuntimeState.swift
    ContentPacks/
        ContentRegistry.swift
        PackLoader.swift
        PackManifest.swift
        PackTypes.swift
        PackValidator.swift
    Quest/
        QuestTriggerEngine.swift
    Events/
        EventPipeline.swift
        MiniGameDispatcher.swift
    Modules/
        CombatModule.swift
    Data/
        Providers/
            CodeContentProvider.swift
            ContentProvider.swift
            JSONContentProvider.swift
        Definitions/
            AnchorDefinition.swift
            EnemyDefinition.swift
            EventDefinition.swift
            GameDefinition.swift
            LocalizedString.swift
            MiniGameChallengeDefinition.swift
            QuestDefinition.swift
            RegionDefinition.swift
    Migration/
        EngineAdapters.swift
        EventDefinitionAdapter.swift
        QuestDefinitionAdapter.swift
    Story/
        StoryDirector.swift
Helpers/

=== FILE CONTENTS ===

// ==========================================
// FILE: ViewModels/GameViewModel.swift
// ==========================================

import Foundation
import Combine
import SwiftUI

// MARK: - Game View Model
// Central ViewModel that bridges UI with TwilightGameEngine
// All UI actions should go through this ViewModel

/// Main ViewModel for game UI
/// Replaces direct WorldState/Player mutations with Engine-based actions
@MainActor
final class GameViewModel: ObservableObject {
    // MARK: - Published State (for UI binding)

    /// Game engine (source of truth)
    @Published private(set) var engine: TwilightGameEngine

    /// Legacy models (for backward compatibility during migration)
    @Published var gameState: GameState
    @Published var player: Player
    @Published var worldState: WorldState

    // MARK: - UI State

    @Published var isLoading: Bool = false
    @Published var errorMessage: String?
    @Published var showError: Bool = false

    @Published var currentEvent: GameEvent?
    @Published var showEventSheet: Bool = false

    @Published var showCombatView: Bool = false

    // MARK: - Last Action Result

    @Published private(set) var lastResult: ActionResult?

    // MARK: - Cancellables

    private var cancellables = Set<AnyCancellable>()

    // MARK: - Initialization

    init(gameState: GameState) {
        self.gameState = gameState
        self.player = gameState.players.first ?? Player(name: "Default")
        self.worldState = gameState.worldState
        self.engine = TwilightGameEngine()

        // Connect engine to legacy models
        engine.connectToLegacy(worldState: worldState, player: player)

        setupBindings()
    }

    /// Convenience initializer for new game
    convenience init(playerName: String = L10n.defaultPlayerName.localized) {
        let player = Player(name: playerName)
        let gameState = GameState(players: [player])
        self.init(gameState: gameState)
    }

    // MARK: - Setup

    private func setupBindings() {
        // Sync engine state to legacy models
        engine.$currentDay
            .sink { [weak self] day in
                self?.worldState.daysPassed = day
            }
            .store(in: &cancellables)

        engine.$worldTension
            .sink { [weak self] tension in
                self?.worldState.worldTension = tension
            }
            .store(in: &cancellables)

        engine.$currentRegionId
            .sink { [weak self] regionId in
                self?.worldState.currentRegionId = regionId
            }
            .store(in: &cancellables)

        // Note: gameState.isGameOver is computed from isVictory || isDefeat
        // Engine game result already handles setting these via $gameResult subscriber below

        engine.$gameResult
            .compactMap { $0 }
            .sink { [weak self] result in
                switch result {
                case .victory:
                    self?.gameState.isVictory = true
                case .defeat:
                    self?.gameState.isDefeat = true
                case .abandoned:
                    break
                }
            }
            .store(in: &cancellables)
    }

    // MARK: - Game Actions (Through Engine)

    /// Travel to a region
    func travel(to regionId: UUID) {
        let result = engine.performAction(.travel(toRegionId: regionId))
        handleResult(result)

        // Log travel in legacy
        if result.success {
            let fromRegion = worldState.getCurrentRegion()?.name ?? L10n.regionUnknown.localized
            let toRegion = worldState.getRegion(byId: regionId)?.name ?? L10n.regionUnknown.localized
            let cost = worldState.calculateTravelCost(to: regionId)
            worldState.logTravel(from: fromRegion, to: toRegion, days: cost)
        }
    }

    /// Rest in current region
    func rest() {
        let result = engine.performAction(.rest)
        handleResult(result)

        // Log in legacy
        if result.success, let region = worldState.getCurrentRegion() {
            worldState.logEvent(
                regionName: region.name,
                eventTitle: L10n.journalRestTitle.localized,
                choiceMade: L10n.journalRestChoice.localized,
                outcome: L10n.journalRestOutcome.localized,
                type: .exploration
            )
        }
    }

    /// Explore current region
    func explore() {
        let result = engine.performAction(.explore)
        handleResult(result)

        // Show event if triggered
        if let eventId = result.currentEvent {
            showEventForId(eventId)
        }
    }

    /// Trade at market
    func trade() {
        let result = engine.performAction(.trade)
        handleResult(result)
        // Market UI handled separately
    }

    /// Strengthen anchor in current region
    func strengthenAnchor() {
        let result = engine.performAction(.strengthenAnchor)
        handleResult(result)

        // Log in legacy
        if result.success, let region = worldState.getCurrentRegion() {
            worldState.logEvent(
                regionName: region.name,
                eventTitle: L10n.journalAnchorTitle.localized,
                choiceMade: L10n.journalAnchorChoice.localized,
                outcome: L10n.journalAnchorOutcome.localized,
                type: .worldChange
            )
        }
    }

    /// Choose an option in current event
    func chooseEventOption(_ choiceIndex: Int) {
        guard let event = currentEvent else { return }

        let result = engine.performAction(.chooseEventOption(eventId: event.id, choiceIndex: choiceIndex))
        handleResult(result)

        // Apply consequences to legacy
        if result.success {
            let choice = event.choices[choiceIndex]
            worldState.applyConsequences(choice.consequences, to: player, in: worldState.currentRegionId ?? UUID())

            // Log event
            if let region = worldState.getCurrentRegion() {
                worldState.logEvent(
                    regionName: region.name,
                    eventTitle: event.title,
                    choiceMade: choice.text,
                    outcome: choice.consequences.message ?? L10n.journalChoiceMade.localized,
                    type: .exploration
                )
            }

            // Mark oneTime event as completed
            if event.oneTime {
                worldState.markEventCompleted(event.id)
            }
        }

        // Close event sheet
        currentEvent = nil
        showEventSheet = false

        // Check for triggered combat
        if result.combatStarted {
            showCombatView = true
        }
    }

    /// Skip turn (just advance time)
    func skipTurn() {
        let result = engine.performAction(.skipTurn)
        handleResult(result)
    }

    // MARK: - Legacy Action Bridge

    /// Perform legacy action through Engine
    /// Used during migration to gradually replace direct mutations
    func performLegacyAction(_ action: RegionAction, for region: Region) {
        switch action {
        case .travel:
            travel(to: region.id)

        case .rest:
            rest()

        case .trade:
            trade()

        case .strengthenAnchor:
            strengthenAnchor()

        case .explore:
            explore()
        }
    }

    // MARK: - Event Handling

    private func showEventForId(_ eventId: UUID) {
        // Find event in worldState
        guard let region = worldState.getCurrentRegion() else { return }

        let events = worldState.getAvailableEvents(for: region)
        if let event = events.first(where: { $0.id == eventId }) {
            currentEvent = event
            showEventSheet = true
        }
    }

    /// Trigger exploration and show event
    func triggerExploration() {
        guard let region = worldState.getCurrentRegion() else { return }

        // Get available events
        let events = worldState.getAvailableEvents(for: region)

        // Weighted selection from available events
        if let event = selectWeightedEvent(from: events) {
            currentEvent = event
            showEventSheet = true
        }
    }

    /// Select event using weighted random selection
    private func selectWeightedEvent(from events: [GameEvent]) -> GameEvent? {
        guard !events.isEmpty else { return nil }

        let totalWeight = events.reduce(0) { $0 + $1.weight }
        guard totalWeight > 0 else { return events.first }

        let roll = WorldRNG.shared.nextInt(in: 0..<totalWeight)
        var cumulative = 0

        for event in events {
            cumulative += event.weight
            if roll < cumulative {
                return event
            }
        }

        return events.first
    }

    // MARK: - Result Handling

    private func handleResult(_ result: ActionResult) {
        lastResult = result

        if !result.success, let error = result.error {
            errorMessage = error.localizedDescription
            showError = true
        }

        // Sync legacy models after engine action
        objectWillChange.send()
    }

    // MARK: - Validation Helpers

    /// Check if action is available
    func canPerformAction(_ action: TwilightGameAction) -> Bool {
        // Quick validation without executing
        switch action {
        case .travel(let toRegionId):
            guard let currentId = worldState.currentRegionId,
                  let currentRegion = worldState.getRegion(byId: currentId) else {
                return false
            }
            return currentRegion.neighborIds.contains(toRegionId)

        case .rest:
            guard let region = worldState.getCurrentRegion() else { return false }
            return region.canRest

        case .trade:
            guard let region = worldState.getCurrentRegion() else { return false }
            return region.canTrade

        case .strengthenAnchor:
            guard let region = worldState.getCurrentRegion(),
                  region.anchor != nil else { return false }
            return player.faith >= 10

        case .explore:
            return !engine.isInCombat

        default:
            return true
        }
    }

    // MARK: - State Queries

    var currentRegion: Region? {
        worldState.getCurrentRegion()
    }

    var currentDay: Int {
        engine.currentDay
    }

    var tension: Int {
        engine.worldTension
    }

    var isGameOver: Bool {
        engine.isGameOver
    }
}

// MARK: - Region Action

/// Actions available in a region (for ViewModel bridge)
/// Mirrors WorldMapView.RegionAction for migration compatibility
enum RegionAction {
    case travel
    case rest
    case trade
    case strengthenAnchor
    case explore

    /// Convert to TwilightGameAction
    func toEngineAction(for region: Region) -> TwilightGameAction {
        switch self {
        case .travel:
            return .travel(toRegionId: region.id)
        case .rest:
            return .rest
        case .trade:
            return .trade
        case .strengthenAnchor:
            return .strengthenAnchor
        case .explore:
            return .explore
        }
    }
}


// ==========================================
// FILE: App/CardGameApp.swift
// ==========================================

import SwiftUI

@main
struct CardGameApp: App {
    @StateObject private var contentLoader = ContentLoader()

    var body: some Scene {
        WindowGroup {
            if contentLoader.isLoaded {
                ContentView()
            } else {
                LoadingView(progress: contentLoader.loadingProgress, message: contentLoader.loadingMessage)
            }
        }
    }
}

// MARK: - Content Loader (Background Thread)

/// Loads content packs on background thread to prevent main thread blocking
@MainActor
class ContentLoader: ObservableObject {
    @Published var isLoaded = false
    @Published var loadingProgress: Double = 0
    @Published var loadingMessage = L10n.loadingDefault.localized

    init() {
        Task {
            await loadContentPacks()
        }
    }

    private func loadContentPacks() async {
        loadingMessage = L10n.loadingSearchPacks.localized
        loadingProgress = 0.1

        // Run file operations on background thread
        let packURL: URL? = await Task.detached(priority: .userInitiated) { () -> URL? in
            // Find ContentPacks in the bundle
            if let url = Bundle.main.url(forResource: "TwilightMarches", withExtension: nil, subdirectory: "ContentPacks") {
                return url
            }

            // Try finding ContentPacks directory in bundle
            if let resourceURL = Bundle.main.resourceURL {
                let contentPacksURL = resourceURL.appendingPathComponent("ContentPacks/TwilightMarches")
                if FileManager.default.fileExists(atPath: contentPacksURL.path) {
                    return contentPacksURL
                }
            }

            // Fallback: Try source directory path (for development/debugging)
            #if DEBUG
            let sourceURL = URL(fileURLWithPath: #filePath)
                .deletingLastPathComponent()
                .appendingPathComponent("ContentPacks/TwilightMarches")
            if FileManager.default.fileExists(atPath: sourceURL.path) {
                return sourceURL
            }
            #endif

            return nil
        }.value

        loadingProgress = 0.3

        if let url = packURL {
            loadingMessage = L10n.loadingContent.localized
            await loadPack(at: url)
        } else {
            loadingMessage = L10n.loadingContentNotFound.localized
            print("⚠️ ContentPacks not found - using fallback content")
        }

        loadingProgress = 1.0
        loadingMessage = L10n.loadingReady.localized

        // Small delay to show completion
        try? await Task.sleep(nanoseconds: 200_000_000)
        isLoaded = true
    }

    private func loadPack(at url: URL) async {
        let registry = ContentRegistry.shared

        // Run heavy loading on background thread
        let result = await Task.detached(priority: .userInitiated) { () -> Result<LoadedPack, Error> in
            do {
                let pack = try registry.loadPack(from: url)
                return .success(pack)
            } catch {
                return .failure(error)
            }
        }.value

        switch result {
        case .success(let pack):
            loadingProgress = 0.9
            loadingMessage = L10n.loadingContentLoaded.localized
            print("✅ Loaded pack: \(pack.manifest.packId) v\(pack.manifest.version)")
            print("   - \(pack.regions.count) regions")
            print("   - \(pack.events.count) events")
            print("   - \(pack.quests.count) quests")
            print("   - \(pack.anchors.count) anchors")
            print("   - \(pack.heroes.count) heroes")
            print("   - \(pack.cards.count) cards")
        case .failure(let error):
            loadingMessage = L10n.loadingError.localized
            print("❌ Failed to load pack from \(url.path): \(error)")
        }
    }
}

// MARK: - Loading View

struct LoadingView: View {
    let progress: Double
    let message: String

    var body: some View {
        VStack(spacing: 20) {
            Text(L10n.appTitle.localized)
                .font(.largeTitle)
                .fontWeight(.bold)

            ProgressView(value: progress)
                .progressViewStyle(.linear)
                .frame(width: 200)

            Text(message)
                .font(.subheadline)
                .foregroundColor(.secondary)
        }
        .padding()
    }
}


// ==========================================
// FILE: App/ContentView.swift
// ==========================================

import SwiftUI

struct ContentView: View {
    @State private var showingWorldMap = false
    @State private var showingRules = false
    @State private var showingSaveSlots = false
    @State private var showingLoadSlots = false  // New: for "Continue" flow
    @State private var showingStatistics = false
    @State private var selectedHeroId: String?
    @State private var selectedSaveSlot: Int?

    // MARK: - Engine-First Architecture
    // Engine is the single source of truth - replaces GameState
    @StateObject private var engine = TwilightGameEngine()
    @StateObject private var saveManager = SaveManager.shared

    // Legacy support for save/load during transition
    @StateObject private var gameState = GameState(players: [])

    // Heroes loaded from Content Pack (data-driven)
    private var availableHeroes: [HeroDefinition] {
        HeroRegistry.shared.availableHeroes()
    }

    // Check if there are any saves
    var hasSaves: Bool {
        !saveManager.allSaves.isEmpty
    }

    var body: some View {
        NavigationView {
            if showingWorldMap {
                // MARK: - Engine-First: Pass engine directly to WorldMapView
                WorldMapView(
                    engine: engine,
                    onExit: {
                        // Save game before exiting (using legacy save system)
                        if let slot = selectedSaveSlot {
                            saveManager.saveGame(to: slot, gameState: gameState)
                        }
                        showingWorldMap = false
                        showingSaveSlots = false
                        showingLoadSlots = false
                    }
                )
            } else if showingSaveSlots {
                saveSlotSelectionView
            } else if showingLoadSlots {
                loadSlotSelectionView
            } else {
                characterSelectionView
            }
        }
    }

    var characterSelectionView: some View {
        GeometryReader { geometry in
            ZStack(alignment: .bottom) {
                // Scrollable content
                ScrollView {
                    VStack(spacing: 20) {
                        // Header with rules and statistics buttons
                        HStack(spacing: 8) {
                            VStack(alignment: .leading, spacing: 2) {
                                Text(L10n.tmGameTitle.localized)
                                    .font(.title2)
                                    .fontWeight(.bold)
                                    .minimumScaleFactor(0.6)
                                    .lineLimit(2)
                                Text(L10n.tmGameSubtitle.localized)
                                    .font(.caption2)
                                    .foregroundColor(.secondary)
                                    .lineLimit(1)
                                    .minimumScaleFactor(0.8)
                            }
                            .frame(maxWidth: .infinity, alignment: .leading)

                            Button(action: { showingStatistics = true }) {
                                Image(systemName: "chart.bar.fill")
                                    .font(.title3)
                                    .padding(8)
                                    .background(Color.orange.opacity(0.2))
                                    .foregroundColor(.orange)
                                    .cornerRadius(8)
                            }
                            Button(action: { showingRules = true }) {
                                Image(systemName: "book.fill")
                                    .font(.title3)
                                    .padding(8)
                                    .background(Color.blue.opacity(0.2))
                                    .foregroundColor(.blue)
                                    .cornerRadius(8)
                            }
                        }
                        .padding(.horizontal)
                        .padding(.top, 8)

                        Text(L10n.characterSelectTitle.localized)
                            .font(.title2)
                            .foregroundColor(.secondary)

                        // Hero cards scroll (data-driven from HeroRegistry)
                        ScrollView(.horizontal, showsIndicators: false) {
                            HStack(spacing: 20) {
                                ForEach(availableHeroes, id: \.id) { hero in
                                    HeroSelectionCard(
                                        hero: hero,
                                        isSelected: selectedHeroId == hero.id,
                                        onTap: {
                                            selectedHeroId = hero.id
                                        }
                                    )
                                    .frame(width: min(geometry.size.width * 0.65, 240), height: 280)
                                }
                            }
                            .padding(.horizontal)
                            .padding(.vertical, 12)
                        }
                        .frame(height: 320)

                        // Hero stats (data-driven from HeroRegistry)
                        if let heroId = selectedHeroId,
                           let hero = HeroRegistry.shared.hero(id: heroId) {
                            VStack(alignment: .leading, spacing: 16) {
                                Text(L10n.characterStats.localized)
                                    .font(.headline)

                                Text(hero.description)
                                    .font(.body)
                                    .foregroundColor(.secondary)
                                    .fixedSize(horizontal: false, vertical: true)

                                HStack(spacing: 24) {
                                    StatDisplay(icon: "heart.fill", label: L10n.statHealth.localized, value: hero.baseStats.health, color: .red)
                                    StatDisplay(icon: "bolt.fill", label: L10n.statPower.localized, value: hero.baseStats.strength, color: .orange)
                                    StatDisplay(icon: "shield.fill", label: L10n.statDefense.localized, value: hero.baseStats.constitution, color: .blue)
                                }

                                // Hero special ability
                                Divider()
                                Text(L10n.characterAbilities.localized)
                                    .font(.headline)

                                VStack(alignment: .leading, spacing: 4) {
                                    HStack {
                                        Text(hero.specialAbility.icon)
                                        Text(hero.specialAbility.name)
                                            .font(.subheadline)
                                            .fontWeight(.bold)
                                            .foregroundColor(.orange)
                                    }
                                    Text(hero.specialAbility.description)
                                        .font(.caption)
                                        .foregroundColor(.secondary)
                                        .fixedSize(horizontal: false, vertical: true)
                                }
                                .padding(.vertical, 4)
                            }
                            .padding()
                            .background(Color(UIColor.secondarySystemBackground))
                            .cornerRadius(12)
                            .padding(.horizontal)
                        }

                        // Extra space for button
                        Color.clear.frame(height: 90)
                    }
                    .padding(.bottom, 20)
                }

                // Fixed buttons at bottom with shadow
                VStack(spacing: 0) {
                    Rectangle()
                        .fill(
                            LinearGradient(
                                gradient: Gradient(colors: [Color.clear, Color(UIColor.systemBackground)]),
                                startPoint: .top,
                                endPoint: .bottom
                            )
                        )
                        .frame(height: 30)

                    VStack(spacing: 12) {
                        // Continue button (only if saves exist)
                        if hasSaves {
                            Button(action: { handleContinueGame() }) {
                                HStack {
                                    Image(systemName: "play.fill")
                                    Text(L10n.uiContinue.localized)
                                }
                                .font(.title3)
                                .fontWeight(.bold)
                                .foregroundColor(.white)
                                .frame(maxWidth: .infinity)
                                .padding()
                                .background(Color.green)
                                .cornerRadius(12)
                            }
                        }

                        // New game button
                        Button(action: { showingSaveSlots = true }) {
                            HStack {
                                Image(systemName: hasSaves ? "plus.circle.fill" : "play.fill")
                                Text(L10n.buttonStartAdventure.localized)
                            }
                            .font(.title3)
                            .fontWeight(.bold)
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .padding()
                            .background(Color.blue)
                            .cornerRadius(12)
                        }
                    }
                    .padding(.horizontal)
                    .padding(.bottom, 12)
                    .background(Color(UIColor.systemBackground))
                }
            }
        }
        .navigationBarHidden(true)
        .sheet(isPresented: $showingRules) {
            RulesView()
        }
        .sheet(isPresented: $showingStatistics) {
            StatisticsView()
        }
    }

    var saveSlotSelectionView: some View {
        VStack(spacing: 20) {
            // Header
            HStack {
                Button(action: { showingSaveSlots = false }) {
                    HStack(spacing: 4) {
                        Image(systemName: "chevron.left")
                        Text(L10n.uiBack.localized)
                    }
                    .foregroundColor(.blue)
                }
                Spacer()
                VStack(alignment: .trailing, spacing: 4) {
                    Text(L10n.uiSlotSelection.localized)
                        .font(.title2)
                        .fontWeight(.bold)
                    if let heroId = selectedHeroId,
                       let hero = HeroRegistry.shared.hero(id: heroId) {
                        Text(hero.name)
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                    }
                }
            }
            .padding()

            // Save slots
            ScrollView {
                VStack(spacing: 16) {
                    ForEach(1...3, id: \.self) { slotNumber in
                        SaveSlotCard(
                            slotNumber: slotNumber,
                            saveData: saveManager.loadGame(from: slotNumber),
                            onNewGame: { startGame(in: slotNumber) },
                            onLoadGame: { loadGame(from: slotNumber) },
                            onDelete: {
                                saveManager.deleteSave(from: slotNumber)
                            }
                        )
                    }
                }
                .padding()
            }
        }
        .navigationBarHidden(true)
    }

    func startGame(in slot: Int) {
        guard let heroId = selectedHeroId,
              let hero = HeroRegistry.shared.hero(id: heroId) else {
            return
        }

        // Create player with heroId - stats are loaded from HeroRegistry automatically
        let player = Player(
            name: hero.name,
            maxHandSize: 5,
            heroId: heroId
        )

        // Build player's starting deck from CardRegistry (data-driven)
        player.deck = CardRegistry.shared.startingDeck(forHeroID: heroId)
        player.shuffleDeck()

        // Initialize game state with Twilight Marches encounters and market
        gameState.players = [player]
        gameState.encounterDeck = CardFactory.shared.createEncounterDeck()
        gameState.encounterDeck.shuffle()
        gameState.marketCards = CardFactory.shared.createMarketCards()

        // MARK: - Engine-First: Connect engine to legacy state
        engine.connectToLegacy(worldState: gameState.worldState, player: player)

        // Save to selected slot
        selectedSaveSlot = slot
        saveManager.saveGame(to: slot, gameState: gameState)

        showingWorldMap = true
        showingSaveSlots = false
    }

    func loadGame(from slot: Int) {
        guard let saveData = saveManager.loadGame(from: slot) else { return }

        // Find the hero by name (for backward compatibility with old saves)
        let heroId = saveData.heroId ?? availableHeroes.first { $0.name == saveData.characterName }?.id

        if let heroId = heroId {
            selectedHeroId = heroId
        }

        // Create player from save data with heroId
        let player = Player(
            name: saveData.characterName,
            health: saveData.health,
            maxHealth: saveData.maxHealth,
            maxHandSize: 5,
            heroId: heroId
        )

        // Set player resources
        player.faith = saveData.faith
        player.balance = saveData.balance

        // Restore deck composition if saved
        if !saveData.playerDeck.isEmpty {
            player.deck = saveData.playerDeck
            player.hand = saveData.playerHand
            player.discard = saveData.playerDiscard
            player.buried = saveData.playerBuried
        } else if let heroId = heroId {
            // Fallback: create starting deck from CardRegistry
            player.deck = CardRegistry.shared.startingDeck(forHeroID: heroId)
            player.shuffleDeck()
        }

        // Initialize game state with market
        gameState.players = [player]
        gameState.encounterDeck = CardFactory.shared.createEncounterDeck()
        gameState.encounterDeck.shuffle()
        gameState.marketCards = CardFactory.shared.createMarketCards()
        gameState.turnNumber = saveData.turnNumber
        gameState.encountersDefeated = saveData.encountersDefeated

        // Restore world state from save
        gameState.worldState = saveData.worldState

        // MARK: - Engine-First: Connect engine to loaded state
        engine.connectToLegacy(worldState: gameState.worldState, player: player)

        selectedSaveSlot = slot
        showingWorldMap = true
        showingSaveSlots = false
    }

    // MARK: - Continue Game

    func handleContinueGame() {
        let saves = saveManager.allSaves

        if saves.count == 1 {
            // Only one save - load it directly
            loadGame(from: saves[0].slotNumber)
        } else {
            // Multiple saves - show selection screen
            showingLoadSlots = true
        }
    }

    // MARK: - Load Slot Selection View

    var loadSlotSelectionView: some View {
        VStack(spacing: 20) {
            // Header
            HStack {
                Button(action: { showingLoadSlots = false }) {
                    HStack(spacing: 4) {
                        Image(systemName: "chevron.left")
                        Text(L10n.uiBack.localized)
                    }
                    .foregroundColor(.blue)
                }
                Spacer()
                Text(L10n.uiContinueGame.localized)
                    .font(.title2)
                    .fontWeight(.bold)
            }
            .padding()

            // Load slots (only show existing saves)
            ScrollView {
                VStack(spacing: 16) {
                    ForEach(saveManager.allSaves) { save in
                        LoadSlotCard(
                            saveData: save,
                            onLoad: { loadGame(from: save.slotNumber) }
                        )
                    }
                }
                .padding()
            }
        }
        .navigationBarHidden(true)
    }
}

struct StatDisplay: View {
    let icon: String
    let label: String
    let value: Int
    let color: Color

    var body: some View {
        VStack(spacing: 4) {
            Image(systemName: icon)
                .font(.title2)
                .foregroundColor(color)
            Text("\(value)")
                .font(.title3)
                .fontWeight(.bold)
            Text(label)
                .font(.caption)
                .foregroundColor(.secondary)
        }
    }
}

struct SaveSlotCard: View {
    let slotNumber: Int
    let saveData: GameSave?
    let onNewGame: () -> Void
    let onLoadGame: () -> Void
    let onDelete: () -> Void

    @State private var showingDeleteAlert = false
    @State private var showingOverwriteAlert = false

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text(L10n.uiSlotNumber.localized(with: slotNumber))
                    .font(.headline)
                Spacer()
                if saveData != nil {
                    Button(action: { showingDeleteAlert = true }) {
                        Image(systemName: "trash")
                            .foregroundColor(.red)
                    }
                }
            }

            if let save = saveData {
                // Existing save
                VStack(alignment: .leading, spacing: 8) {
                    Text(save.characterName)
                        .font(.title3)
                        .fontWeight(.bold)

                    HStack(spacing: 16) {
                        Label("\(save.health)/\(save.maxHealth)", systemImage: "heart.fill")
                            .foregroundColor(.red)
                        Label("\(save.faith)", systemImage: "sparkles")
                            .foregroundColor(.yellow)
                        Label("\(save.balance)", systemImage: "scale.3d")
                            .foregroundColor(.purple)
                    }
                    .font(.subheadline)

                    HStack {
                        Text(L10n.uiTurnNumber.localized(with: save.turnNumber))
                        Text("•")
                        Text(L10n.uiVictories.localized(with: save.encountersDefeated))
                    }
                    .font(.caption)
                    .foregroundColor(.secondary)

                    Text(save.formattedDate)
                        .font(.caption2)
                        .foregroundColor(.secondary)

                    Divider()

                    HStack(spacing: 12) {
                        Button(action: onLoadGame) {
                            Text(L10n.uiLoad.localized)
                                .font(.subheadline)
                                .fontWeight(.semibold)
                                .foregroundColor(.white)
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, 10)
                                .background(Color.blue)
                                .cornerRadius(8)
                        }

                        Button(action: { showingOverwriteAlert = true }) {
                            Text(L10n.uiNewGame.localized)
                                .font(.subheadline)
                                .fontWeight(.semibold)
                                .foregroundColor(.blue)
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, 10)
                                .background(Color.blue.opacity(0.1))
                                .cornerRadius(8)
                        }
                    }
                }
            } else {
                // Empty slot
                VStack(spacing: 12) {
                    Image(systemName: "square.dashed")
                        .font(.largeTitle)
                        .foregroundColor(.secondary)

                    Text(L10n.uiEmptySlot.localized)
                        .font(.subheadline)
                        .foregroundColor(.secondary)

                    Button(action: onNewGame) {
                        Text(L10n.uiStartNewGame.localized)
                            .font(.subheadline)
                            .fontWeight(.semibold)
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 10)
                            .background(Color.green)
                            .cornerRadius(8)
                    }
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 20)
            }
        }
        .padding()
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(12)
        .alert(L10n.uiDeleteSave.localized, isPresented: $showingDeleteAlert) {
            Button(L10n.uiCancel.localized, role: .cancel) { }
            Button(L10n.uiDelete.localized, role: .destructive) {
                onDelete()
            }
        } message: {
            Text(L10n.uiDeleteConfirm.localized)
        }
        .alert(L10n.uiOverwriteSave.localized, isPresented: $showingOverwriteAlert) {
            Button(L10n.uiCancel.localized, role: .cancel) { }
            Button(L10n.uiOverwrite.localized, role: .destructive) {
                onNewGame()
            }
        } message: {
            Text(L10n.uiOverwriteConfirm.localized)
        }
    }
}

// MARK: - Load Slot Card (for Continue flow)

struct LoadSlotCard: View {
    let saveData: GameSave
    let onLoad: () -> Void

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Save info
            HStack {
                Text(L10n.uiSlotNumber.localized(with: saveData.slotNumber))
                    .font(.headline)
                Spacer()
                Image(systemName: "chevron.right")
                    .foregroundColor(.blue)
            }

            VStack(alignment: .leading, spacing: 8) {
                Text(saveData.characterName)
                    .font(.title3)
                    .fontWeight(.bold)

                HStack(spacing: 16) {
                    Label("\(saveData.health)/\(saveData.maxHealth)", systemImage: "heart.fill")
                        .foregroundColor(.red)
                    Label("\(saveData.faith)", systemImage: "sparkles")
                        .foregroundColor(.yellow)
                    Label("\(saveData.balance)", systemImage: "scale.3d")
                        .foregroundColor(.purple)
                }
                .font(.subheadline)

                HStack {
                    Text(L10n.uiTurnNumber.localized(with: saveData.turnNumber))
                    Text("•")
                    Text(L10n.uiVictories.localized(with: saveData.encountersDefeated))
                }
                .font(.caption)
                .foregroundColor(.secondary)

                Text(saveData.formattedDate)
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(12)
        .onTapGesture {
            onLoad()
        }
    }
}

// MARK: - Hero Selection Card (data-driven)

struct HeroSelectionCard: View {
    let hero: HeroDefinition
    let isSelected: Bool
    let onTap: () -> Void

    var body: some View {
        VStack(spacing: 8) {
            // Hero icon/name header
            VStack(spacing: 4) {
                Image(systemName: hero.icon)
                    .font(.system(size: 40))

                Text(hero.name)
                    .font(.headline)
                    .fontWeight(.bold)
                    .lineLimit(1)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 16)
            .background(Color.purple.opacity(0.8))
            .foregroundColor(.white)

            // Stats
            Text(L10n.cardTypeCharacter.localized)
                .font(.caption)
                .foregroundColor(.secondary)

            HStack(spacing: 12) {
                StatMini(icon: "heart.fill", value: hero.baseStats.health, color: .red)
                StatMini(icon: "bolt.fill", value: hero.baseStats.strength, color: .orange)
                StatMini(icon: "shield.fill", value: hero.baseStats.constitution, color: .blue)
            }
            .padding(.bottom, 8)
        }
        .background(Color(UIColor.systemBackground))
        .cornerRadius(16)
        .overlay(
            RoundedRectangle(cornerRadius: 16)
                .stroke(isSelected ? Color.blue : Color.gray.opacity(0.3), lineWidth: isSelected ? 3 : 1)
        )
        .shadow(radius: isSelected ? 8 : 2)
        .scaleEffect(isSelected ? 1.02 : 1.0)
        .animation(.easeInOut(duration: 0.2), value: isSelected)
        .onTapGesture {
            onTap()
        }
    }
}

struct StatMini: View {
    let icon: String
    let value: Int
    let color: Color

    var body: some View {
        HStack(spacing: 2) {
            Image(systemName: icon)
                .font(.caption2)
                .foregroundColor(color)
            Text("\(value)")
                .font(.caption)
                .fontWeight(.bold)
        }
    }
}

#Preview {
    ContentView()
}


// ==========================================
// FILE: Models/Card.swift
// ==========================================

import Foundation

struct Card: Identifiable, Codable, Hashable {
    let id: UUID
    let definitionId: String  // Content Pack ID (e.g., "leshy_guardian" for enemies)
    let name: String
    let type: CardType
    let rarity: CardRarity
    let description: String
    let imageURL: String?

    // Stats
    var power: Int?
    var defense: Int?
    var health: Int?
    var cost: Int?

    // Abilities and traits
    var abilities: [CardAbility]
    var traits: [String]

    // Card-specific properties
    var damageType: DamageType?
    var range: Int?

    // Twilight Marches mechanics
    var balance: CardBalance?  // Light/Dark alignment
    var realm: Realm?  // Yav/Nav/Prav
    var curseType: CurseType?  // For curse cards
    var expansionSet: String?  // For DLC/expansions tracking
    var role: CardRole?  // Functional role in campaign (Sustain/Control/Power/Utility)
    var regionRequirement: String?  // Required region flag to purchase (for story pool)
    var faithCost: Int  // Cost in faith to purchase from market

    init(
        id: UUID = UUID(),
        definitionId: String = "",
        name: String,
        type: CardType,
        rarity: CardRarity = .common,
        description: String,
        imageURL: String? = nil,
        power: Int? = nil,
        defense: Int? = nil,
        health: Int? = nil,
        cost: Int? = nil,
        abilities: [CardAbility] = [],
        traits: [String] = [],
        damageType: DamageType? = nil,
        range: Int? = nil,
        balance: CardBalance? = nil,
        realm: Realm? = nil,
        curseType: CurseType? = nil,
        expansionSet: String? = nil,
        role: CardRole? = nil,
        regionRequirement: String? = nil,
        faithCost: Int = 3
    ) {
        self.id = id
        self.definitionId = definitionId
        self.name = name
        self.type = type
        self.rarity = rarity
        self.description = description
        self.imageURL = imageURL
        self.power = power
        self.defense = defense
        self.health = health
        self.cost = cost
        self.abilities = abilities
        self.traits = traits
        self.damageType = damageType
        self.range = range
        self.balance = balance
        self.realm = realm
        self.curseType = curseType
        self.expansionSet = expansionSet
        self.role = role
        self.regionRequirement = regionRequirement
        self.faithCost = faithCost
    }

    /// Calculate adjusted cost based on player's Light/Dark balance
    /// See EXPLORATION_CORE_DESIGN.md, section 23.4
    func adjustedFaithCost(playerBalance: Int) -> Int {
        guard let cardBalance = balance else { return faithCost }

        switch cardBalance {
        case .light:
            // Light cards cheaper when player is aligned to light (>50)
            let discount = max(0, (playerBalance - 50) / 20)  // 0 to +2 discount
            return max(1, faithCost - discount)

        case .dark:
            // Dark cards cheaper when player is aligned to dark (<50)
            let discount = max(0, (50 - playerBalance) / 20)  // 0 to +2 discount
            return max(1, faithCost - discount)

        case .neutral:
            return faithCost  // Neutral always base cost
        }
    }
}

struct CardAbility: Identifiable, Hashable {
    let id: UUID
    let stringId: String?
    let name: String
    let description: String
    let effect: AbilityEffect

    init(
        id: UUID = UUID(),
        stringId: String? = nil,
        name: String,
        description: String,
        effect: AbilityEffect
    ) {
        self.id = id
        self.stringId = stringId
        self.name = name
        self.description = description
        self.effect = effect
    }
}

// MARK: - CardAbility Codable

extension CardAbility: Codable {
    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case nameRu = "name_ru"
        case description
        case descriptionRu = "description_ru"
        case effect
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        // Try to decode id as UUID first, then as String
        if let uuidId = try? container.decode(UUID.self, forKey: .id) {
            self.id = uuidId
            self.stringId = nil
        } else if let stringId = try? container.decode(String.self, forKey: .id) {
            self.stringId = stringId
            // Generate deterministic UUID from string
            self.id = UUID(uuidString: stringId.stableUUID) ?? UUID()
        } else {
            self.id = UUID()
            self.stringId = nil
        }

        // Handle localized name
        let name = try container.decode(String.self, forKey: .name)
        let nameRu = try container.decodeIfPresent(String.self, forKey: .nameRu)
        if Locale.current.language.languageCode?.identifier == "ru", let ru = nameRu {
            self.name = ru
        } else {
            self.name = name
        }

        // Handle localized description
        let description = try container.decode(String.self, forKey: .description)
        let descriptionRu = try container.decodeIfPresent(String.self, forKey: .descriptionRu)
        if Locale.current.language.languageCode?.identifier == "ru", let ru = descriptionRu {
            self.description = ru
        } else {
            self.description = description
        }

        self.effect = try container.decode(AbilityEffect.self, forKey: .effect)
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        if let stringId = stringId {
            try container.encode(stringId, forKey: .id)
        } else {
            try container.encode(id, forKey: .id)
        }
        try container.encode(name, forKey: .name)
        try container.encode(description, forKey: .description)
        try container.encode(effect, forKey: .effect)
    }
}

private extension String {
    var stableUUID: String {
        var hash: UInt64 = 5381
        for char in self.utf8 {
            hash = ((hash << 5) &+ hash) &+ UInt64(char)
        }
        let hex = String(format: "%016llX", hash)
        let padded = hex.padding(toLength: 32, withPad: "0", startingAt: 0)
        let chars = Array(padded)
        return "\(String(chars[0..<8]))-\(String(chars[8..<12]))-\(String(chars[12..<16]))-\(String(chars[16..<20]))-\(String(chars[20..<32]))"
    }
}

enum AbilityEffect: Hashable {
    case damage(amount: Int, type: DamageType)
    case heal(amount: Int)
    case drawCards(count: Int)
    case addDice(count: Int)
    case reroll
    case explore
    case custom(String)

    // Twilight Marches mechanics
    case applyCurse(type: CurseType, duration: Int)  // Apply curse
    case removeCurse(type: CurseType?)  // Remove specific or any curse
    case summonSpirit(power: Int, realm: Realm)  // Summon spirit guardian
    case shiftBalance(towards: CardBalance, amount: Int)  // Shift light/dark balance
    case travelRealm(to: Realm)  // Travel between Yav/Nav/Prav
    case gainFaith(amount: Int)  // Gain faith resource
    case sacrifice(cost: Int, benefit: String)  // Sacrifice health/cards for benefit

    // Additional effects from JSON
    case permanentStat(stat: String, amount: Int)
    case temporaryStat(stat: String, amount: Int, duration: Int)
}

// MARK: - AbilityEffect Codable

extension AbilityEffect: Codable {
    private enum CodingKeys: String, CodingKey {
        case damage
        case heal
        case drawCards = "draw_cards"
        case addDice = "add_dice"
        case reroll
        case explore
        case custom
        case applyCurse = "apply_curse"
        case removeCurse = "remove_curse"
        case summonSpirit = "summon_spirit"
        case shiftBalance = "shift_balance"
        case travelRealm = "travel_realm"
        case gainFaith = "gain_faith"
        case faith
        case sacrifice
        case permanentStat = "permanent_stat"
        case temporaryStat = "temporary_stat"
    }

    private struct DamageValue: Codable {
        let amount: Int
        let type: String
    }

    private struct CurseValue: Codable {
        let type: String
        let duration: Int?
    }

    private struct SpiritValue: Codable {
        let power: Int
        let realm: String
    }

    private struct BalanceValue: Codable {
        let towards: String
        let amount: Int
    }

    private struct StatValue: Codable {
        let stat: String
        let amount: Int
        let duration: Int?
    }

    private struct SacrificeValue: Codable {
        let cost: Int
        let benefit: String
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        // Try each effect type
        if let damageValue = try container.decodeIfPresent(DamageValue.self, forKey: .damage) {
            self = .damage(amount: damageValue.amount, type: DamageType(rawValue: damageValue.type) ?? .physical)
        } else if let healAmount = try container.decodeIfPresent(Int.self, forKey: .heal) {
            self = .heal(amount: healAmount)
        } else if let drawCount = try container.decodeIfPresent(Int.self, forKey: .drawCards) {
            self = .drawCards(count: drawCount)
        } else if let diceCount = try container.decodeIfPresent(Int.self, forKey: .addDice) {
            self = .addDice(count: diceCount)
        } else if (try? container.decodeIfPresent(Bool.self, forKey: .reroll)) == true {
            self = .reroll
        } else if (try? container.decodeIfPresent(Bool.self, forKey: .explore)) == true {
            self = .explore
        } else if let curseValue = try container.decodeIfPresent(CurseValue.self, forKey: .applyCurse) {
            self = .applyCurse(type: CurseType(rawValue: curseValue.type) ?? .weakness, duration: curseValue.duration ?? 1)
        } else if let curseString = try container.decodeIfPresent(String.self, forKey: .applyCurse) {
            // Simple format: "apply_curse": "weakness"
            self = .applyCurse(type: CurseType(rawValue: curseString) ?? .weakness, duration: 1)
        } else if let curseType = try container.decodeIfPresent(String.self, forKey: .removeCurse) {
            self = .removeCurse(type: CurseType(rawValue: curseType))
        } else if let spiritValue = try container.decodeIfPresent(SpiritValue.self, forKey: .summonSpirit) {
            self = .summonSpirit(power: spiritValue.power, realm: Realm(rawValue: spiritValue.realm) ?? .yav)
        } else if let balanceValue = try container.decodeIfPresent(BalanceValue.self, forKey: .shiftBalance) {
            self = .shiftBalance(towards: CardBalance(rawValue: balanceValue.towards) ?? .neutral, amount: balanceValue.amount)
        } else if let realmString = try container.decodeIfPresent(String.self, forKey: .travelRealm) {
            self = .travelRealm(to: Realm(rawValue: realmString) ?? .yav)
        } else if let faithAmount = try container.decodeIfPresent(Int.self, forKey: .gainFaith) {
            self = .gainFaith(amount: faithAmount)
        } else if let faithAmount = try container.decodeIfPresent(Int.self, forKey: .faith) {
            // Alias for gain_faith
            self = .gainFaith(amount: faithAmount)
        } else if let sacrificeValue = try container.decodeIfPresent(SacrificeValue.self, forKey: .sacrifice) {
            self = .sacrifice(cost: sacrificeValue.cost, benefit: sacrificeValue.benefit)
        } else if let statValue = try container.decodeIfPresent(StatValue.self, forKey: .permanentStat) {
            self = .permanentStat(stat: statValue.stat, amount: statValue.amount)
        } else if let statValue = try container.decodeIfPresent(StatValue.self, forKey: .temporaryStat) {
            self = .temporaryStat(stat: statValue.stat, amount: statValue.amount, duration: statValue.duration ?? 1)
        } else if let customString = try container.decodeIfPresent(String.self, forKey: .custom) {
            self = .custom(customString)
        } else {
            // Default to custom with unknown
            self = .custom("unknown")
        }
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        switch self {
        case .damage(let amount, let type):
            try container.encode(DamageValue(amount: amount, type: type.rawValue), forKey: .damage)
        case .heal(let amount):
            try container.encode(amount, forKey: .heal)
        case .drawCards(let count):
            try container.encode(count, forKey: .drawCards)
        case .addDice(let count):
            try container.encode(count, forKey: .addDice)
        case .reroll:
            try container.encode(true, forKey: .reroll)
        case .explore:
            try container.encode(true, forKey: .explore)
        case .custom(let string):
            try container.encode(string, forKey: .custom)
        case .applyCurse(let type, let duration):
            try container.encode(CurseValue(type: type.rawValue, duration: duration), forKey: .applyCurse)
        case .removeCurse(let type):
            try container.encode(type?.rawValue, forKey: .removeCurse)
        case .summonSpirit(let power, let realm):
            try container.encode(SpiritValue(power: power, realm: realm.rawValue), forKey: .summonSpirit)
        case .shiftBalance(let towards, let amount):
            try container.encode(BalanceValue(towards: towards.rawValue, amount: amount), forKey: .shiftBalance)
        case .travelRealm(let realm):
            try container.encode(realm.rawValue, forKey: .travelRealm)
        case .gainFaith(let amount):
            try container.encode(amount, forKey: .gainFaith)
        case .sacrifice(let cost, let benefit):
            try container.encode(SacrificeValue(cost: cost, benefit: benefit), forKey: .sacrifice)
        case .permanentStat(let stat, let amount):
            try container.encode(StatValue(stat: stat, amount: amount, duration: nil), forKey: .permanentStat)
        case .temporaryStat(let stat, let amount, let duration):
            try container.encode(StatValue(stat: stat, amount: amount, duration: duration), forKey: .temporaryStat)
        }
    }
}


// ==========================================
// FILE: Models/CardType.swift
// ==========================================

import Foundation

enum CardType: String, Codable, Hashable {
    case character
    case weapon
    case spell
    case armor
    case item
    case ally
    case blessing
    case monster
    case location
    case scenario

    // Twilight Marches specific card types
    case curse      // Проклятия - negative effects
    case spirit     // Духи - summonable allies/enemies
    case artifact   // Артефакты - powerful ancient items
    case ritual     // Ритуалы - special spells requiring preparation

    // Deck-building game card types
    case resource   // Ресурсы - used to purchase cards from market
    case attack     // Атака - deal damage to enemies
    case defense    // Защита - block damage or protect
    case special    // Особые - unique effects and abilities
}

enum CardRarity: String, Codable, Hashable {
    case common
    case uncommon
    case rare
    case epic
    case legendary
}

enum DamageType: String, Codable, Hashable {
    case physical
    case fire
    case cold
    case electricity
    case acid
    case mental
    case poison
    case arcane
}

// Twilight Marches: Balance system (Light/Dark)
enum CardBalance: String, Codable, Hashable {
    case light      // Cards from Prav, protective/healing
    case neutral    // Balanced cards
    case dark       // Cards from Nav, aggressive/cursing

    /// Initialize from Engine's AnchorInfluence
    /// Used by data-driven content loading
    init(from influence: AnchorInfluence) {
        switch influence {
        case .light: self = .light
        case .neutral: self = .neutral
        case .dark: self = .dark
        }
    }
}

// Twilight Marches: Three Realms system
enum Realm: String, Codable, Hashable {
    case yav        // Явь - World of the Living (reality, settlements, heroes)
    case nav        // Навь - World of the Dead (spirits, undead, curses)
    case prav       // Правь - World of the Gods (higher powers, blessings, ancient magic)
}

// Twilight Marches: Functional Card Roles (Campaign system)
// See EXPLORATION_CORE_DESIGN.md, section 22
enum CardRole: String, Codable, Hashable {
    case sustain    // Поддержка - healing, curse removal, recovery
    case control    // Контроль - region stabilization, anchor protection, tension reduction
    case power      // Сила - fast progress, elite enemies, rare rewards (always with a price)
    case utility    // Гибкость - card draw, deck manipulation, preparation

    /// Default balance alignment for this role
    var defaultBalance: CardBalance {
        switch self {
        case .sustain: return .light
        case .control: return .light
        case .power: return .dark
        case .utility: return .neutral
        }
    }

    /// Typical rarity for this role
    var typicalRarity: [CardRarity] {
        switch self {
        case .sustain: return [.common, .uncommon]
        case .control: return [.rare, .epic]
        case .power: return [.uncommon, .rare]
        case .utility: return [.common, .uncommon]
        }
    }
}

// Twilight Marches: Curse system (PLAYABLE curses)
// See EXPLORATION_CORE_DESIGN.md, section 26
enum CurseType: String, Codable, Hashable {
    case weakness       // Слабость: -1 к урону до конца боя (2 веры снять)
    case fear           // Страх: -1 к защите до конца боя (2 веры)
    case exhaustion     // Истощение: -1 действие в этом ходу (3 веры)
    case greed          // Жадность: +2 веры, но WorldTension +1 (4 веры)
    case shadowOfNav    // Тень Нави: +3 урона, но -2 HP (5 веры)
    case bloodCurse     // Проклятие крови: При убийстве +2 HP, баланс к тьме (6 веры)
    case sealOfNav      // Печать Нави: Нельзя использовать Sustain карты (8 веры)

    /// Cost in faith to remove this curse
    var removalCost: Int {
        switch self {
        case .weakness: return 2
        case .fear: return 2
        case .exhaustion: return 3
        case .greed: return 4
        case .shadowOfNav: return 5
        case .bloodCurse: return 6
        case .sealOfNav: return 8
        }
    }

    /// Localized name
    var displayName: String {
        switch self {
        case .weakness: return L10n.curseWeakness.localized
        case .fear: return L10n.curseFear.localized
        case .exhaustion: return L10n.curseExhaustion.localized
        case .greed: return L10n.curseGreed.localized
        case .shadowOfNav: return L10n.curseShadowOfNav.localized
        case .bloodCurse: return L10n.curseBloodCurse.localized
        case .sealOfNav: return L10n.curseSealOfNav.localized
        }
    }
}

// Expansion tracking
enum ExpansionSet: String, Codable {
    case baseSet            // Базовый набор
    case twilightMarches    // Сумрачные Пределы (campaign)
    case borderlands        // Порубежье (first expansion)
    case deepForest         // Дремучий Лес
    case ancientRuins       // Древние Руины
    case frozenNorth        // Замерзший Север
}


// ==========================================
// FILE: Models/ExplorationModels.swift
// ==========================================

import Foundation

// MARK: - Region State

enum RegionState: String, Codable, Hashable {
    case stable         // Стабильная Явь - безопасно
    case borderland     // Пограничье - повышенный риск
    case breach         // Прорыв Нави - опасно

    /// Initialize from Engine's RegionStateType
    /// Used by data-driven content loading
    init(from engineState: RegionStateType) {
        switch engineState {
        case .stable: self = .stable
        case .borderland: self = .borderland
        case .breach: self = .breach
        }
    }

    var displayName: String {
        switch self {
        case .stable: return L10n.regionStateStable.localized
        case .borderland: return L10n.regionStateBorderland.localized
        case .breach: return L10n.regionStateBreach.localized
        }
    }

    var emoji: String {
        switch self {
        case .stable: return "🟢"
        case .borderland: return "🟡"
        case .breach: return "🔴"
        }
    }

    // MARK: - Combat Modifiers

    /// Бонус к силе врага в этом регионе
    var enemyPowerBonus: Int {
        switch self {
        case .stable: return 0
        case .borderland: return 1
        case .breach: return 2
        }
    }

    /// Бонус к здоровью врага в этом регионе
    var enemyHealthBonus: Int {
        switch self {
        case .stable: return 0
        case .borderland: return 2
        case .breach: return 5
        }
    }

    /// Бонус к защите врага в этом регионе
    var enemyDefenseBonus: Int {
        switch self {
        case .stable: return 0
        case .borderland: return 1
        case .breach: return 2
        }
    }
}

// MARK: - Combat Context

/// Контекст боя с учётом региона и проклятий
struct CombatContext {
    let regionState: RegionState
    let playerCurses: [CurseType]

    /// Рассчитать эффективную силу врага
    func adjustedEnemyPower(_ basePower: Int) -> Int {
        return basePower + regionState.enemyPowerBonus
    }

    /// Рассчитать эффективное здоровье врага
    func adjustedEnemyHealth(_ baseHealth: Int) -> Int {
        return baseHealth + regionState.enemyHealthBonus
    }

    /// Рассчитать эффективную защиту врага
    func adjustedEnemyDefense(_ baseDefense: Int) -> Int {
        return baseDefense + regionState.enemyDefenseBonus
    }

    /// Описание модификаторов региона для UI
    var regionModifierDescription: String? {
        switch regionState {
        case .stable:
            return nil
        case .borderland:
            return L10n.combatModifierBorderland.localized
        case .breach:
            return L10n.combatModifierBreach.localized
        }
    }
}

// MARK: - Region Type

enum RegionType: String, Codable, Hashable {
    case forest         // Лес
    case swamp          // Болото
    case mountain       // Горы
    case settlement     // Поселение
    case water          // Водная зона
    case wasteland      // Пустошь
    case sacred         // Священное место

    var displayName: String {
        switch self {
        case .forest: return L10n.regionTypeForest.localized
        case .swamp: return L10n.regionTypeSwamp.localized
        case .mountain: return L10n.regionTypeMountain.localized
        case .settlement: return L10n.regionTypeSettlement.localized
        case .water: return L10n.regionTypeWater.localized
        case .wasteland: return L10n.regionTypeWasteland.localized
        case .sacred: return L10n.regionTypeSacred.localized
        }
    }

    var icon: String {
        switch self {
        case .forest: return "tree.fill"
        case .swamp: return "cloud.fog.fill"
        case .mountain: return "mountain.2.fill"
        case .settlement: return "house.fill"
        case .water: return "drop.fill"
        case .wasteland: return "wind"
        case .sacred: return "star.fill"
        }
    }
}

// MARK: - Anchor Type

enum AnchorType: String, Codable {
    case shrine         // Капище
    case barrow         // Курган
    case sacredTree     // Священный дуб
    case stoneIdol      // Каменная баба
    case spring         // Родник
    case chapel         // Часовня
    case temple         // Храм
    case cross          // Обетный крест

    /// Initialize from JSON string (snake_case format)
    /// Used by data-driven content loading
    init?(fromJSON string: String) {
        switch string {
        case "shrine": self = .shrine
        case "barrow": self = .barrow
        case "sacred_tree": self = .sacredTree
        case "stone_idol": self = .stoneIdol
        case "spring": self = .spring
        case "chapel": self = .chapel
        case "temple": self = .temple
        case "cross": self = .cross
        default: return nil
        }
    }

    var displayName: String {
        switch self {
        case .shrine: return L10n.anchorTypeShrine.localized
        case .barrow: return L10n.anchorTypeBarrow.localized
        case .sacredTree: return L10n.anchorTypeSacredTree.localized
        case .stoneIdol: return L10n.anchorTypeStoneIdol.localized
        case .spring: return L10n.anchorTypeSpring.localized
        case .chapel: return L10n.anchorTypeChapel.localized
        case .temple: return L10n.anchorTypeTemple.localized
        case .cross: return L10n.anchorTypeCross.localized
        }
    }

    var icon: String {
        switch self {
        case .shrine: return "flame.fill"
        case .barrow: return "mountain.2"
        case .sacredTree: return "leaf.fill"
        case .stoneIdol: return "figure.stand"
        case .spring: return "drop.circle.fill"
        case .chapel: return "building.columns.fill"
        case .temple: return "building.2.fill"
        case .cross: return "cross.fill"
        }
    }
}

// MARK: - Anchor

struct Anchor: Identifiable, Codable {
    let id: UUID
    let name: String
    let type: AnchorType
    var integrity: Int          // 0-100%
    var influence: CardBalance  // .light, .neutral, .dark
    let power: Int              // Сила влияния (1-10)

    init(
        id: UUID = UUID(),
        name: String,
        type: AnchorType,
        integrity: Int = 100,
        influence: CardBalance = .light,
        power: Int = 5
    ) {
        self.id = id
        self.name = name
        self.type = type
        self.integrity = max(0, min(100, integrity))
        self.influence = influence
        self.power = power
    }

    // Определяет состояние региона на основе целостности якоря
    var determinedRegionState: RegionState {
        switch integrity {
        case 70...100:
            return .stable
        case 30..<70:
            return .borderland
        default:
            return .breach
        }
    }

    // Проверка, осквернен ли якорь
    var isDefiled: Bool {
        return influence == .dark
    }
}

// MARK: - Region

/// Legacy Region model used for world state persistence and direct UI binding.
///
/// ⚠️ МИГРАЦИЯ (Audit v1.1 Issue #9):
/// - Для нового кода предпочтительнее использовать Engine модели:
///   - `RegionDefinition` - статические данные региона (из ContentProvider)
///   - `RegionRuntimeState` - изменяемое состояние (Engine/Runtime/WorldRuntimeState.swift)
///   - `EngineRegionState` - объединённое состояние для UI (TwilightGameEngine.swift)
/// - Эта модель сохраняется для: сериализации сейвов, legacy UI, unit-тестов
/// - После полной миграции UI на Engine эта модель станет internal для persistence
struct Region: Identifiable, Codable {
    let id: UUID
    let definitionId: String        // Content Pack ID (e.g., "village", "sacred_oak")
    let name: String
    let type: RegionType
    var state: RegionState
    var anchor: Anchor?
    var availableEvents: [String]   // ID событий
    var activeQuests: [String]      // ID активных квестов
    var reputation: Int             // -100 to 100
    var visited: Bool               // Был ли игрок здесь
    var neighborIds: [UUID]         // ID соседних регионов (путешествие = 1 день)

    init(
        id: UUID = UUID(),
        definitionId: String = "",
        name: String,
        type: RegionType,
        state: RegionState = .stable,
        anchor: Anchor? = nil,
        availableEvents: [String] = [],
        activeQuests: [String] = [],
        reputation: Int = 0,
        visited: Bool = false,
        neighborIds: [UUID] = []
    ) {
        self.id = id
        self.definitionId = definitionId
        self.name = name
        self.type = type
        self.state = state
        self.anchor = anchor
        self.availableEvents = availableEvents
        self.activeQuests = activeQuests
        self.reputation = max(-100, min(100, reputation))
        self.visited = visited
        self.neighborIds = neighborIds
    }

    /// Проверить, является ли регион соседним
    func isNeighbor(_ regionId: UUID) -> Bool {
        return neighborIds.contains(regionId)
    }

    // Обновить состояние региона на основе якоря
    mutating func updateStateFromAnchor() {
        if let anchor = anchor {
            self.state = anchor.determinedRegionState
        } else {
            // Без якоря регион всегда в Breach
            self.state = .breach
        }
    }

    // Можно ли торговать в регионе
    var canTrade: Bool {
        return state == .stable && type == .settlement && reputation >= 0
    }

    // Можно ли отдохнуть в регионе
    var canRest: Bool {
        return state == .stable && (type == .settlement || type == .sacred)
    }
}

// MARK: - Event Type

enum EventType: String, Codable, Hashable {
    case combat         // Бой
    case ritual         // Ритуал/Выбор
    case narrative      // Нарративное событие
    case exploration    // Исследование
    case worldShift     // Сдвиг мира

    var displayName: String {
        switch self {
        case .combat: return L10n.eventTypeCombat.localized
        case .ritual: return L10n.eventTypeRitual.localized
        case .narrative: return L10n.eventTypeNarrative.localized
        case .exploration: return L10n.eventTypeExploration.localized
        case .worldShift: return L10n.eventTypeWorldShift.localized
        }
    }

    var icon: String {
        switch self {
        case .combat: return "bolt.fill"
        case .ritual: return "sparkles"
        case .narrative: return "text.bubble.fill"
        case .exploration: return "magnifyingglass"
        case .worldShift: return "globe"
        }
    }
}

// MARK: - Event Choice

struct EventChoice: Identifiable, Codable, Hashable {
    let id: String
    let text: String
    let requirements: EventRequirements?
    let consequences: EventConsequences

    init(
        id: String = UUID().uuidString,
        text: String,
        requirements: EventRequirements? = nil,
        consequences: EventConsequences
    ) {
        self.id = id
        self.text = text
        self.requirements = requirements
        self.consequences = consequences
    }
}

// MARK: - Event Requirements

struct EventRequirements: Codable, Hashable {
    var minimumFaith: Int?
    var minimumHealth: Int?
    var requiredBalance: CardBalance?    // Требуется определенный баланс
    var requiredFlags: [String]?         // Требуются флаги мира

    func canMeet(with player: Player, worldState: WorldState) -> Bool {
        if let minFaith = minimumFaith, player.faith < minFaith {
            return false
        }
        if let minHealth = minimumHealth, player.health < minHealth {
            return false
        }
        if let reqBalance = requiredBalance {
            // Проверка баланса игрока (0-100 scale)
            let playerBalanceEnum: CardBalance
            if player.balance >= 70 {
                playerBalanceEnum = .light
            } else if player.balance <= 30 {
                playerBalanceEnum = .dark
            } else {
                playerBalanceEnum = .neutral
            }

            if playerBalanceEnum != reqBalance {
                return false
            }
        }
        if let reqFlags = requiredFlags {
            for flag in reqFlags {
                if worldState.worldFlags[flag] != true {
                    return false
                }
            }
        }
        return true
    }
}

// MARK: - Event Consequences

struct EventConsequences: Codable, Hashable {
    var faithChange: Int?
    var healthChange: Int?
    var balanceChange: Int?         // Изменение Light/Dark (дельта: +N сдвиг к Свету, -N к Тьме)
    var tensionChange: Int?
    var reputationChange: Int?
    var addCards: [String]?         // ID карт для добавления
    var addCurse: String?           // ID проклятия
    var giveArtifact: String?       // ID артефакта
    var setFlags: [String: Bool]?   // Установить флаги
    var anchorIntegrityChange: Int? // Изменение целостности якоря
    var message: String?            // Сообщение игроку
}

// MARK: - Game Event

struct GameEvent: Identifiable, Codable, Hashable {
    let id: UUID
    let definitionId: String            // Content Pack ID (e.g., "village_elder_request")
    let eventType: EventType
    let title: String
    let description: String
    let regionTypes: [RegionType]       // В каких типах регионов может произойти
    let regionStates: [RegionState]     // В каких состояниях может произойти
    let choices: [EventChoice]
    let questLinks: [String]            // Связь с квестами
    var oneTime: Bool                   // Происходит только один раз
    var completed: Bool                 // Уже произошло
    let monsterCard: Card?              // Карта монстра для боевых событий

    // Новые поля согласно документации
    let instant: Bool                   // true = не тратит день (короткие нарративные события)
    let weight: Int                     // Вес для взвешенного выбора (по умолчанию 1)
    let minTension: Int?                // Минимальный уровень напряжения (0-100)
    let maxTension: Int?                // Максимальный уровень напряжения (0-100)
    let requiredFlags: [String]?        // Флаги, которые должны быть установлены
    let forbiddenFlags: [String]?       // Флаги, которые НЕ должны быть установлены

    init(
        id: UUID = UUID(),
        definitionId: String = "",
        eventType: EventType,
        title: String,
        description: String,
        regionTypes: [RegionType] = [],
        regionStates: [RegionState] = [.stable, .borderland, .breach],
        choices: [EventChoice],
        questLinks: [String] = [],
        oneTime: Bool = false,
        completed: Bool = false,
        monsterCard: Card? = nil,
        instant: Bool = false,
        weight: Int = 1,
        minTension: Int? = nil,
        maxTension: Int? = nil,
        requiredFlags: [String]? = nil,
        forbiddenFlags: [String]? = nil
    ) {
        self.id = id
        self.definitionId = definitionId
        self.eventType = eventType
        self.title = title
        self.description = description
        self.regionTypes = regionTypes
        self.regionStates = regionStates
        self.choices = choices
        self.questLinks = questLinks
        self.oneTime = oneTime
        self.completed = completed
        self.monsterCard = monsterCard
        self.instant = instant
        self.weight = max(1, weight)  // Минимум 1
        self.minTension = minTension
        self.maxTension = maxTension
        self.requiredFlags = requiredFlags
        self.forbiddenFlags = forbiddenFlags
    }

    // Проверка, может ли событие произойти в регионе
    func canOccur(in region: Region) -> Bool {
        if completed && oneTime {
            return false
        }

        if !regionTypes.isEmpty && !regionTypes.contains(region.type) {
            return false
        }

        if !regionStates.contains(region.state) {
            return false
        }

        return true
    }

    /// Проверка с учётом напряжения и флагов мира
    func canOccur(in region: Region, worldTension: Int, worldFlags: [String: Bool]) -> Bool {
        // Базовые проверки
        guard canOccur(in: region) else { return false }

        // Проверка напряжения
        if let min = minTension, worldTension < min {
            return false
        }
        if let max = maxTension, worldTension > max {
            return false
        }

        // Проверка обязательных флагов
        if let required = requiredFlags {
            for flag in required {
                if worldFlags[flag] != true {
                    return false
                }
            }
        }

        // Проверка запрещённых флагов
        if let forbidden = forbiddenFlags {
            for flag in forbidden {
                if worldFlags[flag] == true {
                    return false
                }
            }
        }

        return true
    }
}

// MARK: - Quest Type

enum QuestType: String, Codable {
    case main       // Основной квест
    case side       // Побочный квест
}

// MARK: - Quest Objective

struct QuestObjective: Identifiable, Codable {
    let id: UUID
    let description: String
    var completed: Bool
    var requiredFlags: [String]?  // Флаги, необходимые для выполнения цели

    init(id: UUID = UUID(), description: String, completed: Bool = false, requiredFlags: [String]? = nil) {
        self.id = id
        self.description = description
        self.completed = completed
        self.requiredFlags = requiredFlags
    }
}

// MARK: - Quest Rewards

struct QuestRewards: Codable {
    var faith: Int?
    var cards: [String]?
    var artifact: String?
    var experience: Int?
}

// MARK: - Quest

/// Квест в игре
/// Для side-квестов используйте theme для определения нарративной темы
/// См. EXPLORATION_CORE_DESIGN.md, раздел 30 (Side-квесты как "зеркала мира")
struct Quest: Identifiable, Codable {
    let id: UUID
    let definitionId: String?           // Content Pack ID (e.g., "quest_main_act1")
    let title: String
    let description: String
    let questType: QuestType
    var stage: Int                      // Текущая стадия квеста (0 = не начат)
    var objectives: [QuestObjective]
    let rewards: QuestRewards
    var completed: Bool

    // Narrative System properties (see EXPLORATION_CORE_DESIGN.md, section 30)
    var theme: SideQuestTheme?          // Тема квеста (для side-квестов): consequence/warning/temptation
    var mirrorFlag: String?             // Какой выбор игрока этот квест "отражает"

    init(
        id: UUID = UUID(),
        definitionId: String? = nil,
        title: String,
        description: String,
        questType: QuestType,
        stage: Int = 0,
        objectives: [QuestObjective],
        rewards: QuestRewards,
        completed: Bool = false,
        theme: SideQuestTheme? = nil,
        mirrorFlag: String? = nil
    ) {
        self.id = id
        self.definitionId = definitionId
        self.title = title
        self.description = description
        self.questType = questType
        self.stage = stage
        self.objectives = objectives
        self.rewards = rewards
        self.completed = completed
        self.theme = theme
        self.mirrorFlag = mirrorFlag
    }

    // Проверка, все ли цели выполнены
    var allObjectivesCompleted: Bool {
        return objectives.allSatisfy { $0.completed }
    }

    /// Проверяет, является ли квест "зеркалом" данного флага
    func mirrors(flag: String) -> Bool {
        return mirrorFlag == flag
    }
}

// MARK: - Deck Path (for Ending calculation)

/// Доминирующий путь колоды игрока
/// См. EXPLORATION_CORE_DESIGN.md, раздел 32.5
enum DeckPath: String, Codable {
    case light      // Преобладают Light-карты (>60%)
    case dark       // Преобладают Dark-карты (>60%)
    case balance    // Нет явного преобладания
}

// MARK: - Ending Profile

/// Профиль финала кампании
/// См. EXPLORATION_CORE_DESIGN.md, раздел 32.4
struct EndingProfile: Identifiable, Codable {
    let id: String
    let title: String
    let conditions: EndingConditions
    let summary: String
    let epilogue: EndingEpilogue
    let unlocksForNextRun: [String]?

    init(
        id: String,
        title: String,
        conditions: EndingConditions,
        summary: String,
        epilogue: EndingEpilogue,
        unlocksForNextRun: [String]? = nil
    ) {
        self.id = id
        self.title = title
        self.conditions = conditions
        self.summary = summary
        self.epilogue = epilogue
        self.unlocksForNextRun = unlocksForNextRun
    }
}

/// Условия для получения финала
/// См. EXPLORATION_CORE_DESIGN.md, раздел 32
struct EndingConditions: Codable {
    // WorldTension conditions
    let minTension: Int?                    // Минимальный WorldTension
    let maxTension: Int?                    // Максимальный WorldTension

    // Deck path condition
    let deckPath: DeckPath?                 // Требуемый путь колоды

    // Flag conditions
    let requiredFlags: [String]?            // Обязательные флаги
    let forbiddenFlags: [String]?           // Запрещённые флаги

    // Anchor conditions
    let minStableAnchors: Int?              // Минимум stable якорей
    let maxBreachAnchors: Int?              // Максимум breach регионов

    // Balance conditions
    let minBalance: Int?                    // Минимальный lightDarkBalance
    let maxBalance: Int?                    // Максимальный lightDarkBalance

    init(
        minTension: Int? = nil,
        maxTension: Int? = nil,
        deckPath: DeckPath? = nil,
        requiredFlags: [String]? = nil,
        forbiddenFlags: [String]? = nil,
        minStableAnchors: Int? = nil,
        maxBreachAnchors: Int? = nil,
        minBalance: Int? = nil,
        maxBalance: Int? = nil
    ) {
        self.minTension = minTension
        self.maxTension = maxTension
        self.deckPath = deckPath
        self.requiredFlags = requiredFlags
        self.forbiddenFlags = forbiddenFlags
        self.minStableAnchors = minStableAnchors
        self.maxBreachAnchors = maxBreachAnchors
        self.minBalance = minBalance
        self.maxBalance = maxBalance
    }
}

/// Эпилог финала
struct EndingEpilogue: Codable {
    let anchors: String     // Судьба якорей
    let hero: String        // Судьба героя
    let world: String       // Судьба мира
}

// MARK: - Side Quest Theme

/// Тема побочного квеста (влияет на тон и последствия)
/// См. EXPLORATION_CORE_DESIGN.md, раздел 30.2
enum SideQuestTheme: String, Codable {
    case consequence    // Последствия — мир уже пострадал
    case warning        // Предупреждение — можно предотвратить деградацию
    case temptation     // Соблазн — быстрые выгоды за долгосрочный урон
}

// MARK: - Main Quest Step

/// Шаг основного квеста
/// См. EXPLORATION_CORE_DESIGN.md, раздел 29.3
struct MainQuestStep: Identifiable, Codable {
    let id: String
    let title: String
    let goal: String
    let unlockConditions: QuestConditions
    let completionConditions: QuestConditions
    let effects: QuestEffects?

    init(
        id: String,
        title: String,
        goal: String,
        unlockConditions: QuestConditions,
        completionConditions: QuestConditions,
        effects: QuestEffects? = nil
    ) {
        self.id = id
        self.title = title
        self.goal = goal
        self.unlockConditions = unlockConditions
        self.completionConditions = completionConditions
        self.effects = effects
    }
}

/// Условия для квеста (разблокировки или завершения)
/// См. EXPLORATION_CORE_DESIGN.md, раздел 29
struct QuestConditions: Codable {
    var requiredFlags: [String]?    // Флаги, которые должны быть установлены
    var forbiddenFlags: [String]?   // Флаги, которых НЕ должно быть
    var minTension: Int?            // Минимальный WorldTension
    var maxTension: Int?            // Максимальный WorldTension
    var minBalance: Int?            // Минимальный lightDarkBalance
    var maxBalance: Int?            // Максимальный lightDarkBalance
    var visitedRegions: [String]?   // Посещённые регионы

    init(
        requiredFlags: [String]? = nil,
        forbiddenFlags: [String]? = nil,
        minTension: Int? = nil,
        maxTension: Int? = nil,
        minBalance: Int? = nil,
        maxBalance: Int? = nil,
        visitedRegions: [String]? = nil
    ) {
        self.requiredFlags = requiredFlags
        self.forbiddenFlags = forbiddenFlags
        self.minTension = minTension
        self.maxTension = maxTension
        self.minBalance = minBalance
        self.maxBalance = maxBalance
        self.visitedRegions = visitedRegions
    }
}

/// Эффекты выполнения шага квеста
struct QuestEffects: Codable {
    var unlockRegions: [String]?    // Разблокировать регионы
    var setFlags: [String]?         // Установить флаги
    var tensionChange: Int?         // Изменение WorldTension
    var addCards: [String]?         // Добавить карты

    init(
        unlockRegions: [String]? = nil,
        setFlags: [String]? = nil,
        tensionChange: Int? = nil,
        addCards: [String]? = nil
    ) {
        self.unlockRegions = unlockRegions
        self.setFlags = setFlags
        self.tensionChange = tensionChange
        self.addCards = addCards
    }
}


// ==========================================
// FILE: Models/GameSave.swift
// ==========================================

import Foundation

// Save slot for saving/loading games (Campaign v2.0)
struct GameSave: Codable, Identifiable {
    let id: UUID
    let slotNumber: Int
    let characterName: String
    let heroId: String?  // Hero ID for data-driven system
    let turnNumber: Int

    // Basic player stats
    let health: Int
    let maxHealth: Int
    let faith: Int
    let maxFaith: Int
    let balance: Int

    // CRITICAL: Deck composition (deck-building mechanic)
    let playerDeck: [Card]
    let playerHand: [Card]
    let playerDiscard: [Card]
    let playerBuried: [Card]

    // Player curses and spirits
    let activeCurses: [ActiveCurse]
    let spirits: [Card]
    let currentRealm: Realm

    // Character stats
    let strength: Int
    let dexterity: Int
    let constitution: Int
    let intelligence: Int
    let wisdom: Int
    let charisma: Int

    // CRITICAL: World state (campaign progression)
    let worldState: WorldState

    // Game progress (old system - kept for compatibility)
    let encountersDefeated: Int
    let isVictory: Bool
    let isDefeat: Bool

    let timestamp: Date

    var formattedDate: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        return formatter.string(from: timestamp)
    }
}

// Manager for saving/loading games
class SaveManager: ObservableObject {
    static let shared = SaveManager()

    @Published var saveSlots: [Int: GameSave] = [:]

    private let savesKey = "twilight_marches_saves"

    init() {
        loadAllSaves()
    }

    // Save game to slot (Campaign v2.0 - full save)
    func saveGame(to slot: Int, gameState: GameState) {
        guard let player = gameState.players.first else { return }

        let save = GameSave(
            id: UUID(),
            slotNumber: slot,
            characterName: player.name,
            heroId: player.heroId,
            turnNumber: gameState.turnNumber,
            health: player.health,
            maxHealth: player.maxHealth,
            faith: player.faith,
            maxFaith: player.maxFaith,
            balance: player.balance,
            // CRITICAL: Save deck composition
            playerDeck: player.deck,
            playerHand: player.hand,
            playerDiscard: player.discard,
            playerBuried: player.buried,
            // Save curses and spirits
            activeCurses: player.activeCurses,
            spirits: player.spirits,
            currentRealm: player.currentRealm,
            // Save character stats
            strength: player.strength,
            dexterity: player.dexterity,
            constitution: player.constitution,
            intelligence: player.intelligence,
            wisdom: player.wisdom,
            charisma: player.charisma,
            // CRITICAL: Save world state (campaign progression)
            worldState: gameState.worldState,
            // Old system (compatibility)
            encountersDefeated: gameState.encountersDefeated,
            isVictory: gameState.isVictory,
            isDefeat: gameState.isDefeat,
            timestamp: Date()
        )

        saveSlots[slot] = save
        persistSaves()
    }

    // Load game from slot
    func loadGame(from slot: Int) -> GameSave? {
        return saveSlots[slot]
    }

    // Restore full game state from save (Campaign v2.0)
    func restoreGameState(from save: GameSave) -> GameState {
        // Restore player with full state and heroId
        let player = Player(
            name: save.characterName,
            health: save.health,
            maxHealth: save.maxHealth,
            strength: save.strength,
            dexterity: save.dexterity,
            constitution: save.constitution,
            intelligence: save.intelligence,
            wisdom: save.wisdom,
            charisma: save.charisma,
            faith: save.faith,
            maxFaith: save.maxFaith,
            balance: save.balance,
            currentRealm: save.currentRealm,
            heroId: save.heroId
        )

        // Restore deck composition (CRITICAL for deck-building)
        player.deck = save.playerDeck
        player.hand = save.playerHand
        player.discard = save.playerDiscard
        player.buried = save.playerBuried

        // Restore curses and spirits
        player.activeCurses = save.activeCurses
        player.spirits = save.spirits

        // Create game state with restored player
        let gameState = GameState(players: [player])

        // Restore world state (CRITICAL for campaign)
        gameState.worldState = save.worldState

        // Restore game progress
        gameState.turnNumber = save.turnNumber
        gameState.encountersDefeated = save.encountersDefeated
        gameState.isVictory = save.isVictory
        gameState.isDefeat = save.isDefeat

        // Set initial phase
        if gameState.isGameOver {
            gameState.currentPhase = .gameOver
        } else {
            gameState.currentPhase = .exploration
        }

        return gameState
    }

    // Delete save from slot
    func deleteSave(from slot: Int) {
        saveSlots.removeValue(forKey: slot)
        persistSaves()
    }

    // Check if slot is empty
    func isSlotEmpty(_ slot: Int) -> Bool {
        return saveSlots[slot] == nil
    }

    // Get all saves sorted by slot number
    var allSaves: [GameSave] {
        return saveSlots.values.sorted { $0.slotNumber < $1.slotNumber }
    }

    // MARK: - Persistence

    private func persistSaves() {
        if let encoded = try? JSONEncoder().encode(saveSlots) {
            UserDefaults.standard.set(encoded, forKey: savesKey)
        }
    }

    private func loadAllSaves() {
        if let data = UserDefaults.standard.data(forKey: savesKey),
           let decoded = try? JSONDecoder().decode([Int: GameSave].self, from: data) {
            saveSlots = decoded
        }
    }
}


// ==========================================
// FILE: Models/GameState.swift
// ==========================================

import Foundation
import Combine

enum GamePhase {
    case setup
    case exploration
    case encounter
    case playerTurn
    case enemyTurn
    case endTurn
    case gameOver
}

class GameState: ObservableObject {
    @Published var currentPhase: GamePhase = .setup
    @Published var players: [Player]
    @Published var currentPlayerIndex: Int = 0
    @Published var encounterDeck: [Card]
    @Published var locationDeck: [Card]
    @Published var activeEncounter: Card?
    @Published var turnNumber: Int = 0
    @Published var diceRoll: Int?
    @Published var encountersDefeated: Int = 0
    @Published var isVictory: Bool = false
    @Published var isDefeat: Bool = false
    @Published var actionsRemaining: Int = 3

    // Marketplace for deck-building
    @Published var marketCards: [Card] = []

    // World exploration system
    @Published var worldState: WorldState = WorldState()

    // Auto-save callback
    var onAutoSave: (() -> Void)?

    // Actions per turn
    var actionsPerTurn: Int { 3 }

    var currentPlayer: Player {
        players[currentPlayerIndex]
    }

    // DEPRECATED: Old victory condition (kept for compatibility)
    // New victory: complete main quest (mainQuestStage == 5 && act_completed flags)
    var victoryThreshold: Int { 10 }

    // Game is over if victory or defeat
    var isGameOver: Bool {
        isVictory || isDefeat
    }

    // MARK: - Victory/Defeat Conditions

    /// Check quest-based victory (new system)
    func checkQuestVictory() {
        // Victory: Main quest completed (Act 5 finished)
        if worldState.mainQuestStage >= 5 && worldState.worldFlags["act5_completed"] == true {
            isVictory = true
            currentPhase = .gameOver
        }
    }

    /// Check defeat conditions
    func checkDefeatConditions() {
        // Defeat 1: Player HP = 0
        if currentPlayer.health <= 0 {
            isDefeat = true
            currentPhase = .gameOver
            return
        }

        // Defeat 2: WorldTension = 100% (world fell to Nav)
        if worldState.worldTension >= 100 {
            isDefeat = true
            currentPhase = .gameOver
            return
        }

        // Defeat 3: Critical anchor destroyed (if implemented via flags)
        if worldState.worldFlags["critical_anchor_destroyed"] == true {
            isDefeat = true
            currentPhase = .gameOver
            return
        }
    }

    init(players: [Player]) {
        self.players = players
        self.encounterDeck = []
        self.locationDeck = []
    }

    func startGame() {
        currentPhase = .exploration
        turnNumber = 1
        isVictory = false
        isDefeat = false
        encountersDefeated = 0
        activeEncounter = nil

        // Deal initial hands
        for player in players {
            player.shuffleDeck()
            player.drawCards(count: player.maxHandSize)
        }
    }

    // Purchase card from market
    func purchaseCard(_ card: Card) -> Bool {
        guard let cardCost = card.cost else { return false }

        // Check if player has enough faith
        if currentPlayer.spendFaith(cardCost) {
            // Remove card from market
            if let index = marketCards.firstIndex(where: { $0.id == card.id }) {
                marketCards.remove(at: index)
            }

            // Add card to player's discard pile (standard deck-building mechanic)
            currentPlayer.discard.append(card)

            return true
        }

        return false
    }

    func nextPhase() {
        switch currentPhase {
        case .setup:
            currentPhase = .exploration
        case .exploration:
            currentPhase = .encounter
        case .encounter:
            currentPhase = .playerTurn
        case .playerTurn:
            currentPhase = .enemyTurn
        case .enemyTurn:
            currentPhase = .endTurn
        case .endTurn:
            endTurn()
        case .gameOver:
            break
        }
    }

    func endTurn() {
        currentPlayerIndex = (currentPlayerIndex + 1) % players.count

        if currentPlayerIndex == 0 {
            turnNumber += 1
        }

        // Tick curses at end of turn
        currentPlayer.tickCurses()

        // Check defeat and victory conditions (new system)
        checkDefeatConditions()
        checkQuestVictory()

        if !isGameOver {
            currentPhase = .exploration
            activeEncounter = nil
            actionsRemaining = actionsPerTurn

            // Проклятие истощения: -1 действие в этом ходу
            if currentPlayer.hasCurse(.exhaustion) {
                actionsRemaining = max(1, actionsRemaining - 1)
            }

            // NEW: Discard all cards and draw 5 new ones (deck-building mechanic)
            let player = currentPlayer
            // Discard all cards in hand
            player.discard.append(contentsOf: player.hand)
            player.hand.removeAll()

            // Draw 5 new cards
            player.drawCards(count: 5)

            // Regenerate faith
            currentPlayer.gainFaith(1)
        }

        // Auto-save after turn ends
        onAutoSave?()
    }

    func defeatEncounter() {
        encountersDefeated += 1

        // Check if a boss was defeated (for quest objectives)
        if let encounter = activeEncounter {
            worldState.markBossDefeated(enemyId: encounter.definitionId)
        }

        // Проклятие крови: при убийстве +2 HP и баланс смещается к тьме
        if currentPlayer.hasCurse(.bloodCurse) {
            currentPlayer.heal(2)
            currentPlayer.shiftBalance(towards: .dark, amount: 5)
        }

        activeEncounter = nil
        currentPhase = .exploration

        // DEPRECATED: Old victory condition (kept for compatibility)
        // New system: quest-based victory via checkQuestVictory()
        if encountersDefeated >= victoryThreshold {
            isVictory = true
            currentPhase = .gameOver
        }

        // Check new victory conditions
        checkQuestVictory()

        // Auto-save after defeating encounter
        onAutoSave?()
    }

    // DEPRECATED: Use checkDefeatConditions() instead
    // Kept for backwards compatibility with existing code
    func checkDefeat() {
        checkDefeatConditions()
    }

    func rollDice(sides: Int = 6, count: Int = 1) -> Int {
        // Используем WorldRNG для детерминизма при тестировании
        let total = (0..<count).reduce(0) { sum, _ in
            sum + WorldRNG.shared.nextInt(in: 1...sides)
        }
        diceRoll = total
        return total
    }

    func drawEncounter() {
        guard !encounterDeck.isEmpty else { return }
        activeEncounter = encounterDeck.removeFirst()
        currentPhase = .encounter
    }

    func useAction() -> Bool {
        guard actionsRemaining > 0 else { return false }
        actionsRemaining -= 1
        return true
    }

    func enemyPhaseAction() {
        // Enemy attacks during their phase
        guard let encounter = activeEncounter else { return }

        let encounterPower = encounter.power ?? 3
        // Применяем урон с учётом проклятий (fear увеличивает получаемый урон)
        currentPlayer.takeDamageWithCurses(encounterPower)
        checkDefeat()
    }
}


// ==========================================
// FILE: Models/Player.swift
// ==========================================

import Foundation

// Twilight Marches: Active curse tracking
struct ActiveCurse: Identifiable, Codable {
    let id: UUID
    let type: CurseType
    var duration: Int  // turns remaining
    let sourceCard: String?  // name of card that applied curse

    init(id: UUID = UUID(), type: CurseType, duration: Int, sourceCard: String? = nil) {
        self.id = id
        self.type = type
        self.duration = duration
        self.sourceCard = sourceCard
    }
}

class Player: ObservableObject, Identifiable {
    let id: UUID
    @Published var name: String
    @Published var health: Int
    @Published var maxHealth: Int
    @Published var hand: [Card]
    @Published var deck: [Card]
    @Published var discard: [Card]
    @Published var buried: [Card]

    // Character stats
    @Published var strength: Int
    @Published var dexterity: Int
    @Published var constitution: Int
    @Published var intelligence: Int
    @Published var wisdom: Int
    @Published var charisma: Int

    // Hand size management
    let maxHandSize: Int

    // Hero ID (загружается из Content Pack)
    let heroId: String?

    // Twilight Marches mechanics
    @Published var faith: Int  // Вера - resource for powerful abilities
    @Published var maxFaith: Int
    @Published var balance: Int  // 0 (dark) to 100 (light), 50 is neutral
    @Published var activeCurses: [ActiveCurse]
    @Published var currentRealm: Realm
    @Published var spirits: [Card]  // Summoned spirits

    init(
        id: UUID = UUID(),
        name: String,
        health: Int = 10,
        maxHealth: Int = 10,
        maxHandSize: Int = 7,
        strength: Int = 5,      // Базовая сила для боя (атака = strength + d6)
        dexterity: Int = 0,
        constitution: Int = 0,
        intelligence: Int = 0,
        wisdom: Int = 0,
        charisma: Int = 0,
        faith: Int = 3,
        maxFaith: Int = 10,
        balance: Int = 50,
        currentRealm: Realm = .yav,
        heroId: String? = nil
    ) {
        self.id = id
        self.name = name
        self.heroId = heroId
        self.maxHandSize = maxHandSize
        self.hand = []
        self.deck = []
        self.discard = []
        self.buried = []
        self.activeCurses = []
        self.currentRealm = currentRealm
        self.spirits = []

        // Если указан героя, получаем характеристики из HeroRegistry
        if let heroId = heroId,
           let heroDefinition = HeroRegistry.shared.hero(id: heroId) {
            let stats = heroDefinition.baseStats
            self.health = stats.health
            self.maxHealth = stats.maxHealth
            self.strength = stats.strength
            self.dexterity = stats.dexterity
            self.constitution = stats.constitution
            self.intelligence = stats.intelligence
            self.wisdom = stats.wisdom
            self.charisma = stats.charisma
            self.faith = stats.faith
            self.maxFaith = stats.maxFaith
            self.balance = stats.startingBalance
        } else {
            // Дефолтные значения для тестов
            self.health = health
            self.maxHealth = maxHealth
            self.strength = strength
            self.dexterity = dexterity
            self.constitution = constitution
            self.intelligence = intelligence
            self.wisdom = wisdom
            self.charisma = charisma
            self.faith = faith
            self.maxFaith = maxFaith
            self.balance = balance
        }
    }

    func drawCard() {
        // Auto-reshuffle discard when deck is empty
        if deck.isEmpty && !discard.isEmpty {
            reshuffleDiscard()
        }

        guard !deck.isEmpty else { return }
        let card = deck.removeFirst()
        hand.append(card)
    }

    func drawCards(count: Int) {
        for _ in 0..<count {
            drawCard()
        }
    }

    func playCard(_ card: Card) {
        guard let index = hand.firstIndex(where: { $0.id == card.id }) else { return }
        let playedCard = hand.remove(at: index)
        discard.append(playedCard)
    }

    func shuffleDeck() {
        deck.shuffle()
    }

    func reshuffleDiscard() {
        deck.append(contentsOf: discard)
        discard.removeAll()
        shuffleDeck()
    }

    func takeDamage(_ amount: Int) {
        health = max(0, health - amount)
    }

    func heal(_ amount: Int) {
        health = min(maxHealth, health + amount)
    }

    // Twilight Marches methods
    func gainFaith(_ amount: Int) {
        faith = min(maxFaith, faith + amount)
    }

    func spendFaith(_ amount: Int) -> Bool {
        guard faith >= amount else { return false }
        faith -= amount
        return true
    }

    func shiftBalance(towards: CardBalance, amount: Int) {
        switch towards {
        case .light:
            balance = min(100, balance + amount)
        case .dark:
            balance = max(0, balance - amount)
        case .neutral:
            // Move towards 50 (neutral)
            if balance > 50 {
                balance = max(50, balance - amount)
            } else if balance < 50 {
                balance = min(50, balance + amount)
            }
        }
    }

    func applyCurse(type: CurseType, duration: Int, sourceCard: String? = nil) {
        let curse = ActiveCurse(type: type, duration: duration, sourceCard: sourceCard)
        activeCurses.append(curse)
    }

    func removeCurse(type: CurseType? = nil) {
        if let specificType = type {
            activeCurses.removeAll { $0.type == specificType }
        } else {
            // Remove first curse if no type specified
            if !activeCurses.isEmpty {
                activeCurses.removeFirst()
            }
        }
    }

    func hasCurse(_ type: CurseType) -> Bool {
        return activeCurses.contains { $0.type == type }
    }

    func tickCurses() {
        // Reduce duration of all curses and remove expired ones
        for i in (0..<activeCurses.count).reversed() {
            activeCurses[i].duration -= 1
            if activeCurses[i].duration <= 0 {
                activeCurses.remove(at: i)
            }
        }
    }

    // MARK: - Curse Combat Modifiers

    /// Получить модификатор наносимого урона от проклятий
    /// weakness: -1, shadowOfNav: +3
    func getDamageDealtModifier() -> Int {
        var modifier = 0
        if hasCurse(.weakness) {
            modifier -= 1
        }
        if hasCurse(.shadowOfNav) {
            modifier += 3
        }
        return modifier
    }

    /// Получить модификатор получаемого урона от проклятий
    /// fear: +1 (больше урона получаем)
    func getDamageTakenModifier() -> Int {
        var modifier = 0
        if hasCurse(.fear) {
            modifier += 1
        }
        return modifier
    }

    /// Применить урон с учётом модификаторов проклятий
    func takeDamageWithCurses(_ baseDamage: Int) {
        let modifier = getDamageTakenModifier()
        let actualDamage = max(0, baseDamage + modifier)
        takeDamage(actualDamage)
    }

    /// Рассчитать урон с учётом модификаторов проклятий
    func calculateDamageDealt(_ baseDamage: Int) -> Int {
        let modifier = getDamageDealtModifier()
        return max(0, baseDamage + modifier)
    }

    func summonSpirit(_ spirit: Card) {
        spirits.append(spirit)
    }

    func dismissSpirit(_ spirit: Card) {
        spirits.removeAll { $0.id == spirit.id }
    }

    func travelToRealm(_ realm: Realm) {
        currentRealm = realm
    }

    var balanceState: CardBalance {
        if balance >= 70 {
            return .light
        } else if balance <= 30 {
            return .dark
        } else {
            return .neutral
        }
    }

    // Описание баланса для UI
    var balanceDescription: String {
        switch balance {
        case 0..<30:
            return L10n.balancePathDark.localized
        case 30..<70:
            return L10n.balancePathNeutral.localized
        case 70...100:
            return L10n.balancePathLight.localized
        default:
            return L10n.balancePathUnknown.localized
        }
    }

    // MARK: - Hero Abilities (Data-Driven)

    /// Получить определение героя из реестра
    var heroDefinition: HeroDefinition? {
        guard let heroId = heroId else { return nil }
        return HeroRegistry.shared.hero(id: heroId)
    }

    /// Получить способность героя
    private var heroAbility: HeroAbility? {
        return heroDefinition?.specialAbility
    }

    /// Бонус урона от способности героя (читается из данных способности)
    func getHeroDamageBonus(targetFullHP: Bool = false) -> Int {
        guard let ability = heroAbility,
              ability.trigger == .onDamageDealt else { return 0 }

        // Проверяем условие способности
        if let condition = ability.condition {
            switch condition.type {
            case .hpBelowPercent:
                let threshold = condition.value ?? 50
                guard health < maxHealth * threshold / 100 else { return 0 }
            case .targetFullHP:
                guard targetFullHP else { return 0 }
            default:
                break
            }
        }

        // Возвращаем значение эффекта bonusDamage
        return ability.effects.first { $0.type == .bonusDamage }?.value ?? 0
    }

    /// Снижение получаемого урона от способности героя (читается из данных)
    func getHeroDamageReduction(fromDarkSource: Bool = false) -> Int {
        guard let ability = heroAbility,
              ability.trigger == .onDamageReceived else { return 0 }

        // Проверяем условие способности
        if let condition = ability.condition {
            switch condition.type {
            case .damageSourceDark:
                guard fromDarkSource else { return 0 }
            default:
                break
            }
        }

        // Возвращаем значение эффекта damageReduction
        return ability.effects.first { $0.type == .damageReduction }?.value ?? 0
    }

    /// Бонусные кубики от способности героя (читается из данных)
    func getHeroBonusDice(isFirstAttack: Bool) -> Int {
        guard let ability = heroAbility,
              ability.trigger == .onAttack else { return 0 }

        // Проверяем условие способности
        if let condition = ability.condition {
            switch condition.type {
            case .firstAttack:
                guard isFirstAttack else { return 0 }
            default:
                break
            }
        }

        // Возвращаем значение эффекта bonusDice
        return ability.effects.first { $0.type == .bonusDice }?.value ?? 0
    }

    /// Проверка способности: получение веры в конце хода (читается из данных)
    var shouldGainFaithEndOfTurn: Bool {
        guard let ability = heroAbility,
              ability.trigger == .turnEnd else { return false }
        return ability.effects.contains { $0.type == .gainFaith }
    }

    /// Полный расчёт урона с учётом проклятий и способностей героя
    func calculateTotalDamageDealt(_ baseDamage: Int, targetFullHP: Bool = false) -> Int {
        let curseModifier = getDamageDealtModifier()
        let heroBonus = getHeroDamageBonus(targetFullHP: targetFullHP)
        return max(0, baseDamage + curseModifier + heroBonus)
    }

    /// Полный расчёт получаемого урона с учётом проклятий и способностей героя
    func takeDamageWithAllModifiers(_ baseDamage: Int, fromDarkSource: Bool = false) {
        let curseModifier = getDamageTakenModifier()
        let heroReduction = getHeroDamageReduction(fromDarkSource: fromDarkSource)
        let actualDamage = max(0, baseDamage + curseModifier - heroReduction)
        takeDamage(actualDamage)
    }
}


// ==========================================
// FILE: Models/WorldState.swift
// ==========================================

import Foundation
import Combine

// MARK: - Event Log Entry

/// Запись в журнале событий
struct EventLogEntry: Identifiable, Codable {
    let id: UUID
    let dayNumber: Int
    let timestamp: Date
    let regionName: String
    let eventTitle: String
    let choiceMade: String
    let outcome: String
    let type: EventLogType

    init(
        id: UUID = UUID(),
        dayNumber: Int,
        timestamp: Date = Date(),
        regionName: String,
        eventTitle: String,
        choiceMade: String,
        outcome: String,
        type: EventLogType
    ) {
        self.id = id
        self.dayNumber = dayNumber
        self.timestamp = timestamp
        self.regionName = regionName
        self.eventTitle = eventTitle
        self.choiceMade = choiceMade
        self.outcome = outcome
        self.type = type
    }
}

/// Тип записи в журнале
enum EventLogType: String, Codable {
    case exploration    // Исследование
    case combat         // Бой
    case choice         // Выбор
    case quest          // Квест
    case travel         // Путешествие
    case worldChange    // Изменение мира

    var icon: String {
        switch self {
        case .exploration: return "magnifyingglass"
        case .combat: return "swords"
        case .choice: return "questionmark.circle"
        case .quest: return "scroll"
        case .travel: return "figure.walk"
        case .worldChange: return "globe"
        }
    }
}

/// Событие, произошедшее в конце дня (для уведомлений)
struct DayEvent: Identifiable {
    let id = UUID()
    let day: Int
    let title: String
    let description: String
    let isNegative: Bool

    static func tensionIncrease(day: Int, newTension: Int) -> DayEvent {
        DayEvent(
            day: day,
            title: L10n.dayEventTensionTitle.localized,
            description: L10n.dayEventTensionDescription.localized(with: newTension),
            isNegative: true
        )
    }

    static func regionDegraded(day: Int, regionName: String, newState: RegionState) -> DayEvent {
        DayEvent(
            day: day,
            title: L10n.dayEventRegionDegradedTitle.localized,
            description: L10n.dayEventRegionDegradedDescription.localized(with: regionName, newState.displayName),
            isNegative: true
        )
    }

    static func worldImproving(day: Int) -> DayEvent {
        DayEvent(
            day: day,
            title: L10n.dayEventWorldImprovingTitle.localized,
            description: L10n.dayEventWorldImprovingDescription.localized,
            isNegative: false
        )
    }
}

/// Глобальное состояние мира для системы исследования
class WorldState: ObservableObject, Codable {
    // MARK: - Published Properties

    @Published var regions: [Region] = []
    @Published var worldTension: Int = 30           // 0-100, сила вторжения Нави
    @Published var lightDarkBalance: Int = 50       // 0 (dark) - 100 (light)
    @Published var mainQuestStage: Int = 1          // 1-5 актов
    @Published var activeQuests: [Quest] = []
    @Published var completedQuests: [String] = []   // ID завершенных квестов
    @Published var worldFlags: [String: Bool] = [:] // Сюжетные флаги
    @Published var allEvents: [GameEvent] = []
    @Published var currentRegionId: UUID?           // Текущий регион игрока
    @Published var daysPassed: Int = 0              // Дни в пути
    @Published var eventLog: [EventLogEntry] = []   // Журнал событий
    @Published var lastDayEvent: DayEvent?          // Последнее событие дня (для уведомлений)

    // MARK: - Computed Properties

    var currentRegion: Region? {
        guard let id = currentRegionId else { return nil }
        return regions.first { $0.id == id }
    }

    var averageRegionState: RegionState {
        let stableCount = regions.filter { $0.state == .stable }.count
        let totalCount = regions.count
        let percentage = totalCount > 0 ? (Double(stableCount) / Double(totalCount)) * 100 : 0

        switch percentage {
        case 60...100:
            return .stable
        case 30..<60:
            return .borderland
        default:
            return .breach
        }
    }

    // MARK: - Initialization

    init() {
        setupInitialWorld()
    }

    // MARK: - World Setup

    private func setupInitialWorld() {
        // DATA-DRIVEN: Load all content from ContentRegistry (JSON files)
        // Reference: ENGINE_ARCHITECTURE.md, Section 5
        // ContentRegistry is loaded at app startup via CardGameApp.ContentLoader
        let registry = ContentRegistry.shared

        // Load regions from ContentRegistry (JSON)
        regions = createRegionsFromRegistry(registry)

        // Load events from ContentRegistry (using adapters)
        allEvents = registry.getAllEventDefinitions().map { $0.toGameEvent() }

        // Load quests from ContentRegistry (using adapters)
        let initialQuests = registry.getAllQuestDefinitions().map { $0.toQuest() }
        // Main quest starts automatically
        if let mainQuest = initialQuests.first(where: { $0.questType == .main }) {
            startQuest(mainQuest)
        }

        // Set initial world parameters
        worldTension = 30
        lightDarkBalance = 50
        mainQuestStage = 1
        daysPassed = 0

        // Set starting region by ID (village)
        // Canonical starting region is "village" per game design
        if let villageDef = registry.getRegion(id: "village"),
           let villageRegion = regions.first(where: { $0.name == villageDef.title.localized }) {
            currentRegionId = villageRegion.id
        } else if let firstStable = regions.first(where: { $0.state == .stable }) {
            // Fallback to any stable region if village not found
            currentRegionId = firstStable.id
        }
    }

    /// Convert RegionDefinitions from ContentRegistry to legacy Region models
    /// This bridges the Data-Driven architecture (JSON) with existing runtime models
    private func createRegionsFromRegistry(_ registry: ContentRegistry) -> [Region] {
        let regionDefs = registry.getAllRegionDefinitions()
        var regionMap: [String: Region] = [:]

        // First pass: create regions without neighbor links
        for def in regionDefs {
            let anchor = createAnchorFromDefinition(registry.getAnchorDefinition(forRegion: def.id))
            let regionType = RegionType(rawValue: def.regionType) ?? .forest
            let regionState = RegionState(from: def.initialState)

            var region = Region(
                definitionId: def.id,
                name: def.title.localized,
                type: regionType,
                state: regionState,
                anchor: anchor,
                reputation: 0
            )
            region.updateStateFromAnchor()
            regionMap[def.id] = region
        }

        // Second pass: link neighbors using UUIDs
        for def in regionDefs {
            guard var region = regionMap[def.id] else { continue }
            region.neighborIds = def.neighborIds.compactMap { regionMap[$0]?.id }
            regionMap[def.id] = region
        }

        // Sort by name for deterministic ordering (Dictionary values order is non-deterministic)
        return Array(regionMap.values).sorted { $0.name < $1.name }
    }

    /// Create legacy Anchor from AnchorDefinition
    private func createAnchorFromDefinition(_ def: AnchorDefinition?) -> Anchor? {
        guard let def = def else { return nil }

        let anchorType = AnchorType(fromJSON: def.anchorType) ?? .shrine
        let influence = CardBalance(from: def.initialInfluence)

        return Anchor(
            name: def.title.localized,
            type: anchorType,
            integrity: def.initialIntegrity,
            influence: influence,
            power: def.power
        )
    }

    // MARK: - Region Management

    func updateRegion(_ updatedRegion: Region) {
        if let index = regions.firstIndex(where: { $0.id == updatedRegion.id }) {
            regions[index] = updatedRegion
        }
    }

    func getRegion(byId id: UUID) -> Region? {
        return regions.first { $0.id == id }
    }

    /// Получить текущий регион игрока
    func getCurrentRegion() -> Region? {
        guard let currentId = currentRegionId else { return nil }
        return getRegion(byId: currentId)
    }

    /// - Warning: Internal method. UI code should use `TwilightGameEngine.performAction(.travel(toRegionId:))`.
    /// Called by Engine for state synchronization.
    func moveToRegion(_ regionId: UUID) {
        // Отметить текущий регион как посещенный
        if let currentId = currentRegionId,
           let index = regions.firstIndex(where: { $0.id == currentId }) {
            regions[index].visited = true
        }

        // Рассчитать стоимость путешествия
        let travelCost = calculateTravelCost(to: regionId)

        // Переместиться в новый регион
        currentRegionId = regionId

        // Отметить новый регион как посещенный
        if let index = regions.firstIndex(where: { $0.id == regionId }) {
            regions[index].visited = true
        }

        // Продвинуть время корректно - каждый день обрабатывается отдельно
        // Это критично: travel cost 2 должен обработать день 3, если мы были на дне 2
        advanceTimeInternal(by: travelCost)
    }

    /// Рассчитать стоимость путешествия в регион
    /// Соседний регион: 1 день, дальний: 2 дня
    func calculateTravelCost(to targetId: UUID) -> Int {
        guard let currentId = currentRegionId,
              let currentRegion = getRegion(byId: currentId) else {
            return 1  // По умолчанию 1 день
        }

        return currentRegion.isNeighbor(targetId) ? 1 : 2
    }

    // MARK: - Time-based Degradation (Day Start Algorithm)

    /// Канонический алгоритм начала дня (см. EXPLORATION_CORE_DESIGN.md, раздел 18.1)
    /// Вызывается при каждом увеличении daysPassed
    ///
    /// ## DEPRECATED
    /// - **UI Code**: Use `TwilightGameEngine.performAction()` instead
    /// Process day start effects (tension increase, degradation checks).
    /// Called by Engine and internally by advanceTime methods.
    func processDayStart() {
        performDayStartLogic()
    }

    /// Advance day and process day start logic.
    /// - Note: Increments `daysPassed` by 1 and processes day start logic (tension, degradation, etc.)
    func advanceDayForUI() {
        daysPassed += 1
        performDayStartLogic()
    }

    /// Internal day start logic - shared by processDayStart() and advanceDayForUI()
    /// Uses TwilightPressureRules as single source of truth
    private func performDayStartLogic() {
        // 1. Каждые 3 дня — автоматическая деградация мира
        guard daysPassed > 0 && daysPassed % 3 == 0 else { return }

        // 2. Увеличить напряжение мира с ЭСКАЛАЦИЕЙ
        // Формула из TwilightPressureRules: base + (daysPassed / 10)
        // День 1-9: +3, День 10-19: +4, День 20-29: +5, ...
        let totalIncrement = TwilightPressureRules.calculateTensionIncrease(daysPassed: daysPassed)
        increaseTension(by: totalIncrement)

        // Уведомить о росте напряжения
        lastDayEvent = .tensionIncrease(day: daysPassed, newTension: worldTension)
        logWorldChange(description: L10n.logTensionIncreased.localized(with: worldTension, totalIncrement))

        // 3. Проверить деградацию региона с вероятностью (Tension/100)
        // Используем WorldRNG для детерминизма при тестировании
        let probability = Double(worldTension) / 100.0
        if WorldRNG.shared.checkProbability(probability) {
            checkRegionDegradation()
        }

        // 4. Проверить улучшение мира при низком напряжении
        if worldTension <= 20 {
            improveRandomRegion()
        }

        // 5. Проверить триггеры квестов
        checkQuestTriggers()

        // 6. Проверить глобальные триггеры мира
        checkWorldShiftTriggers()
    }

    /// Проверка деградации региона по весовому алгоритму
    /// (см. EXPLORATION_CORE_DESIGN.md, раздел 18.2)
    /// Использует DegradationRules для определения поведения
    private func checkRegionDegradation() {
        let rules = DegradationRules.current

        // 1. Выбрать случайный регион с весами из правил
        guard let selectedRegion = selectRegionForDegradation() else { return }

        // 2. Проверить сопротивление якоря (вероятностное, не пороговое)
        // P(resist) = integrity/100: чем сильнее якорь, тем выше шанс сопротивляться
        if let anchor = selectedRegion.anchor {
            let resistProb = rules.resistanceProbability(anchorIntegrity: anchor.integrity)
            if WorldRNG.shared.checkProbability(resistProb) {
                // Якорь сопротивляется — деградация не происходит
                logWorldChange(description: L10n.logAnchorResists.localized(with: selectedRegion.name, anchor.integrity))
                return
            }
        }

        // 3. Применить деградацию и уведомить
        let oldState = selectedRegion.state
        degradeRegion(selectedRegion.id, amount: rules.degradationAmount)

        // Получить новое состояние после деградации
        if let updatedRegion = getRegion(byId: selectedRegion.id), updatedRegion.state != oldState {
            lastDayEvent = .regionDegraded(day: daysPassed, regionName: updatedRegion.name, newState: updatedRegion.state)
            logWorldChange(description: L10n.logRegionDegraded.localized(with: updatedRegion.name, updatedRegion.state.displayName))
        }
    }

    /// Выбор региона для деградации с учётом весов из DegradationRules
    /// Веса определяются правилами: Stable = 0, Borderland = 1, Breach = 2
    private func selectRegionForDegradation() -> Region? {
        let rules = DegradationRules.current

        // Формируем пул регионов с весами из правил
        var weightedPool: [(region: Region, weight: Int)] = []

        for region in regions {
            let weight = rules.selectionWeight(for: region.state)
            if weight > 0 {
                weightedPool.append((region, weight))
            }
        }

        // Если нет подходящих регионов (все Stable), деградация не происходит
        // ВАЖНО: Stable регионы НЕ деградируют напрямую согласно документации
        if weightedPool.isEmpty {
            return nil
        }

        // Взвешенный случайный выбор (используем WorldRNG для детерминизма)
        let totalWeight = weightedPool.reduce(0) { $0 + $1.weight }
        guard totalWeight > 0 else { return nil }

        var randomValue = WorldRNG.shared.nextInt(in: 0..<totalWeight)
        for (region, weight) in weightedPool {
            randomValue -= weight
            if randomValue < 0 {
                return region
            }
        }

        return weightedPool.first?.region
    }

    /// Применить деградацию к конкретному региону
    /// - Parameters:
    ///   - regionId: ID региона для деградации
    ///   - amount: Урон якорю (по умолчанию из DegradationRules.current)
    private func degradeRegion(_ regionId: UUID, amount: Int? = nil) {
        guard var region = getRegion(byId: regionId) else { return }

        let degradationAmount = amount ?? DegradationRules.current.degradationAmount

        if var anchor = region.anchor {
            // Уменьшить integrity якоря на указанное значение
            anchor.integrity = max(0, anchor.integrity - degradationAmount)
            region.anchor = anchor
            region.updateStateFromAnchor()
            updateRegion(region)
        }
    }

    /// Проверка триггеров квестов (вызывается каждые 3 дня)
    private func checkQuestTriggers() {
        // Проверить условия продвижения для каждого активного квеста
        for quest in activeQuests {
            checkQuestProgress(quest)
        }
    }

    /// Проверка глобальных триггеров мира (World Shift Events)
    private func checkWorldShiftTriggers() {
        // При пороговых значениях Tension могут срабатывать глобальные события
        if worldTension >= 50 && !hasFlag("world_shift_50") {
            setFlag("world_shift_50", value: true)
            // Можно триггерить World Shift Event здесь
        }
        if worldTension >= 75 && !hasFlag("world_shift_75") {
            setFlag("world_shift_75", value: true)
        }
        if worldTension >= 90 && !hasFlag("world_shift_90") {
            setFlag("world_shift_90", value: true)
        }
    }

    /// Метод для ручного продвижения времени (для Rest, StrengthenAnchor и т.д.)
    ///
    /// ## DEPRECATED
    /// - **UI Code**: Use `TwilightGameEngine.performAction()` instead
    /// Advance time by specified number of days.
    /// Each day processes day start logic (tension, degradation, etc.)
    func advanceTime(by days: Int = 1) {
        advanceTimeInternal(by: days)
    }

    /// Internal time advancement - used by moveToRegion and other internal methods
    private func advanceTimeInternal(by days: Int) {
        for _ in 0..<days {
            daysPassed += 1
            performDayStartLogic()
        }
    }

    // MARK: - Anchor Management

    func strengthenAnchor(in regionId: UUID, amount: Int = 20) -> Bool {
        guard var region = getRegion(byId: regionId),
              var anchor = region.anchor else {
            return false
        }

        anchor.integrity = min(100, anchor.integrity + amount)
        region.anchor = anchor
        region.updateStateFromAnchor()
        updateRegion(region)

        return true
    }

    func defileAnchor(in regionId: UUID, amount: Int = 30) -> Bool {
        guard var region = getRegion(byId: regionId),
              var anchor = region.anchor else {
            return false
        }

        anchor.integrity = max(0, anchor.integrity - amount)
        anchor.influence = .dark
        region.anchor = anchor
        region.updateStateFromAnchor()
        updateRegion(region)

        // Увеличиваем напряжение мира
        increaseTension(by: 10)

        return true
    }

    func purifyAnchor(in regionId: UUID) -> Bool {
        guard var region = getRegion(byId: regionId),
              var anchor = region.anchor else {
            return false
        }

        anchor.influence = .light
        anchor.integrity = min(100, anchor.integrity + 50)
        region.anchor = anchor
        region.updateStateFromAnchor()
        updateRegion(region)

        // Уменьшаем напряжение мира
        decreaseTension(by: 15)

        return true
    }

    // MARK: - World Tension Management

    func increaseTension(by amount: Int) {
        worldTension = min(100, worldTension + amount)
        checkTensionEffects()
    }

    func decreaseTension(by amount: Int) {
        worldTension = max(0, worldTension - amount)
        checkTensionEffects()
    }

    private func checkTensionEffects() {
        // При высоком напряжении (≥80) — немедленная деградация через весовой алгоритм
        if worldTension >= 80 {
            checkRegionDegradation()
        }

        // При низком напряжении (≤20) — мир начинает восстанавливаться
        if worldTension <= 20 {
            improveRandomRegion()
        }
    }

    /// Улучшение случайного региона (при низком Tension)
    private func improveRandomRegion() {
        // Предпочитаем улучшать Breach регионы
        let breachRegions = regions.filter { $0.state == .breach }
        let borderlandRegions = regions.filter { $0.state == .borderland }

        let targetRegion: Region?
        if !breachRegions.isEmpty {
            targetRegion = WorldRNG.shared.randomElement(from: breachRegions)
        } else if !borderlandRegions.isEmpty {
            targetRegion = WorldRNG.shared.randomElement(from: borderlandRegions)
        } else {
            targetRegion = nil
        }

        guard let region = targetRegion,
              let index = regions.firstIndex(where: { $0.id == region.id }) else {
            return
        }

        var updatedRegion = regions[index]
        if var anchor = updatedRegion.anchor {
            anchor.integrity = min(100, anchor.integrity + 15)
            updatedRegion.anchor = anchor
            updatedRegion.updateStateFromAnchor()
            updateRegion(updatedRegion)
        }
    }

    // MARK: - Campaign Market System
    // See EXPLORATION_CORE_DESIGN.md, section 24

    /// Generate market cards based on current region and world state
    /// Market is formed from 3 pools: Global, Regional, Story
    func generateMarket(allCards: [Card], globalPoolSize: Int = 3, regionalPoolSize: Int = 2) -> [Card] {
        var market: [Card] = []

        // 1. Global pool (always available Sustain/Utility cards)
        let globalCards = allCards.filter { card in
            guard let role = card.role else { return false }
            return role == .sustain || role == .utility
        }
        let shuffledGlobal = WorldRNG.shared.shuffled(globalCards)
        market.append(contentsOf: shuffledGlobal.prefix(globalPoolSize))

        // 2. Regional pool (based on current region state)
        if let region = currentRegion {
            let regionalCards = getRegionalCards(allCards: allCards, regionState: region.state)
            let shuffledRegional = WorldRNG.shared.shuffled(regionalCards)
            market.append(contentsOf: shuffledRegional.prefix(regionalPoolSize))
        }

        // 3. Story pool (cards unlocked by flags)
        if let storyCard = getStoryCard(allCards: allCards) {
            market.append(storyCard)
        }

        return market
    }

    /// Get cards appropriate for the region state
    private func getRegionalCards(allCards: [Card], regionState: RegionState) -> [Card] {
        switch regionState {
        case .stable:
            // Stable regions offer Sustain and Control cards
            return allCards.filter { card in
                guard let role = card.role else { return false }
                return role == .sustain || role == .control
            }

        case .borderland:
            // Borderland offers Utility and Power cards
            return allCards.filter { card in
                guard let role = card.role else { return false }
                return role == .utility || role == .power
            }

        case .breach:
            // Breach offers Power cards (risky but rewarding)
            return allCards.filter { card in
                guard let role = card.role else { return false }
                return role == .power
            }
        }
    }

    /// Get a story card if player has the required flag
    private func getStoryCard(allCards: [Card]) -> Card? {
        // Find cards that require specific flags
        let storyCards = allCards.filter { card in
            guard let requirement = card.regionRequirement else { return false }
            return hasFlag(requirement)
        }
        return WorldRNG.shared.randomElement(from: storyCards)
    }

    /// Calculate adjusted card cost based on Light/Dark balance
    func adjustedCardCost(_ card: Card) -> Int {
        return card.adjustedFaithCost(playerBalance: lightDarkBalance)
    }

    // MARK: - Balance Management

    func shiftToLight(by amount: Int) {
        lightDarkBalance = min(100, lightDarkBalance + amount)
    }

    func shiftToDark(by amount: Int) {
        lightDarkBalance = max(0, lightDarkBalance - amount)
    }

    var balanceDescription: String {
        switch lightDarkBalance {
        case 0..<30:
            return L10n.balancePathDark.localized
        case 30..<70:
            return L10n.balancePathNeutral.localized
        case 70...100:
            return L10n.balancePathLight.localized
        default:
            return L10n.balancePathUnknown.localized
        }
    }

    // MARK: - Event Management

    func getAvailableEvents(for region: Region) -> [GameEvent] {
        return allEvents.filter { event in
            event.canOccur(in: region, worldTension: worldTension, worldFlags: worldFlags)
        }
    }

    /// Взвешенный случайный выбор события
    /// События с большим весом имеют пропорционально большую вероятность быть выбранными
    func selectWeightedRandomEvent(from events: [GameEvent]) -> GameEvent? {
        guard !events.isEmpty else { return nil }

        let totalWeight = events.reduce(0) { $0 + $1.weight }
        guard totalWeight > 0 else {
            // Используем WorldRNG для randomElement
            let index = WorldRNG.shared.nextInt(in: 0..<events.count)
            return events[index]
        }

        // Используем WorldRNG для детерминизма
        let randomValue = WorldRNG.shared.nextInt(in: 1...totalWeight)
        var cumulativeWeight = 0

        for event in events {
            cumulativeWeight += event.weight
            if randomValue <= cumulativeWeight {
                return event
            }
        }

        return events.last
    }

    func markEventCompleted(_ eventId: UUID) {
        if let index = allEvents.firstIndex(where: { $0.id == eventId }) {
            allEvents[index].completed = true
        }
    }

    // MARK: - Event Log Management

    /// Добавить запись в журнал событий
    func logEvent(
        regionName: String,
        eventTitle: String,
        choiceMade: String,
        outcome: String,
        type: EventLogType
    ) {
        let entry = EventLogEntry(
            dayNumber: daysPassed,
            regionName: regionName,
            eventTitle: eventTitle,
            choiceMade: choiceMade,
            outcome: outcome,
            type: type
        )
        eventLog.append(entry)

        // Ограничиваем журнал последними 100 записями
        if eventLog.count > 100 {
            eventLog.removeFirst(eventLog.count - 100)
        }
    }

    /// Добавить запись о путешествии
    func logTravel(from: String, to: String, days: Int) {
        let outcomeKey = days == 1 ? L10n.logTravelOutcomeDay : L10n.logTravelOutcomeDays
        logEvent(
            regionName: to,
            eventTitle: L10n.logTravelTitle.localized,
            choiceMade: L10n.logTravelChoice.localized(with: to),
            outcome: outcomeKey.localized(with: days),
            type: .travel
        )
    }

    /// Добавить запись об изменении мира
    func logWorldChange(description: String) {
        let regionName = getCurrentRegion()?.name ?? L10n.logWorld.localized
        logEvent(
            regionName: regionName,
            eventTitle: L10n.logWorldChange.localized,
            choiceMade: "-",
            outcome: description,
            type: .worldChange
        )
    }

    /// Получить последние записи журнала
    func getRecentLogEntries(count: Int = 10) -> [EventLogEntry] {
        return Array(eventLog.suffix(count))
    }

    // MARK: - Quest Management

    func startQuest(_ quest: Quest) {
        var newQuest = quest
        newQuest.stage = 1
        activeQuests.append(newQuest)
    }

    func updateQuest(_ updatedQuest: Quest) {
        if let index = activeQuests.firstIndex(where: { $0.id == updatedQuest.id }) {
            activeQuests[index] = updatedQuest

            // Если квест завершен, переместить в завершенные
            if updatedQuest.completed {
                completedQuests.append(updatedQuest.id.uuidString)
                activeQuests.remove(at: index)
            }
        }
    }

    /// Проверка прогресса квеста по флагам (вызывается из processDayStart)
    func checkQuestProgress(_ quest: Quest) {
        // Проверить, выполнены ли условия для текущих целей квеста
        for (index, objective) in quest.objectives.enumerated() {
            if objective.completed { continue }

            // Проверить флаги, связанные с целью
            if let requiredFlags = objective.requiredFlags {
                let allFlagsSet = requiredFlags.allSatisfy { hasFlag($0) }
                if allFlagsSet {
                    var updatedQuest = quest
                    updatedQuest.objectives[index].completed = true
                    updateQuest(updatedQuest)
                }
            }
        }
    }

    // MARK: - Flag Management

    /// Проверить, установлен ли флаг
    func hasFlag(_ key: String) -> Bool {
        return worldFlags[key] == true
    }

    /// Установить значение флага
    func setFlag(_ key: String, value: Bool) {
        worldFlags[key] = value
    }

    /// Получить значение флага (nil если не установлен)
    func getFlag(_ key: String) -> Bool? {
        return worldFlags[key]
    }

    /// Переключить флаг
    func toggleFlag(_ key: String) {
        worldFlags[key] = !(worldFlags[key] ?? false)
    }

    // MARK: - Apply Event Consequences

    func applyConsequences(_ consequences: EventConsequences, to player: Player, in regionId: UUID) {
        // Изменение веры
        if let faithChange = consequences.faithChange {
            if faithChange > 0 {
                player.gainFaith(faithChange)
            } else {
                _ = player.spendFaith(abs(faithChange))
            }
        }

        // Изменение здоровья
        if let healthChange = consequences.healthChange {
            if healthChange > 0 {
                player.heal(healthChange)
            } else {
                player.takeDamage(abs(healthChange))
            }
        }

        // Изменение баланса
        if let balanceChange = consequences.balanceChange {
            if balanceChange > 0 {
                shiftToLight(by: abs(balanceChange))
            } else {
                shiftToDark(by: abs(balanceChange))
            }
        }

        // Изменение напряжения мира
        if let tensionChange = consequences.tensionChange {
            if tensionChange > 0 {
                increaseTension(by: tensionChange)
            } else {
                decreaseTension(by: abs(tensionChange))
            }
        }

        // Изменение репутации
        if let reputationChange = consequences.reputationChange,
           let index = regions.firstIndex(where: { $0.id == regionId }) {
            regions[index].reputation += reputationChange
            regions[index].reputation = max(-100, min(100, regions[index].reputation))
        }

        // Изменение целостности якоря
        if let anchorChange = consequences.anchorIntegrityChange {
            if var region = getRegion(byId: regionId),
               var anchor = region.anchor {
                anchor.integrity = max(0, min(100, anchor.integrity + anchorChange))
                region.anchor = anchor
                region.updateStateFromAnchor()
                updateRegion(region)
            }
        }

        // Установка флагов (ключевая механика — события не меняют мир напрямую, а через флаги)
        // См. EXPLORATION_CORE_DESIGN.md, раздел 18.7
        // Quest progress now handled by QuestTriggerEngine via flagSet action
        if let flags = consequences.setFlags {
            for (key, value) in flags {
                setFlag(key, value: value)
            }
        }

        // Добавление карт в колоду игрока
        if let cardIDs = consequences.addCards {
            for cardID in cardIDs {
                if let card = CardFactory.shared.getCard(id: cardID) {
                    // Add card to player's discard pile (standard deck-building mechanic)
                    player.discard.append(card)
                }
            }
        }

        // Проверка триггеров изменения состояния региона
        if consequences.anchorIntegrityChange != nil {
            // Якорь изменён — это может повлиять на глобальное состояние
            checkWorldShiftTriggers()
        }

        // TODO: Добавление проклятий и артефактов
        // if let curseID = consequences.addCurse { ... }
        // if let artifactID = consequences.giveArtifact { ... }
    }

    // MARK: - Quest Management

    /// Complete a quest and give rewards to the player
    func completeQuest(_ questId: UUID, player: Player) {
        guard let index = activeQuests.firstIndex(where: { $0.id == questId }) else { return }

        var quest = activeQuests[index]
        quest.completed = true

        // Move quest from active to completed
        completedQuests.append(quest.id.uuidString)
        activeQuests.remove(at: index)

        // Give rewards
        applyQuestRewards(quest.rewards, to: player)
    }

    /// Apply quest rewards to the player
    func applyQuestRewards(_ rewards: QuestRewards, to player: Player) {
        // Faith reward
        if let faith = rewards.faith {
            player.gainFaith(faith)
        }

        // Card rewards
        if let cardIDs = rewards.cards {
            for cardID in cardIDs {
                if let card = CardFactory.shared.getCard(id: cardID) {
                    // Add card to player's discard pile
                    player.discard.append(card)
                }
            }
        }

        // TODO: Artifact rewards
        // if let artifactID = rewards.artifact { ... }

        // TODO: Experience rewards
        // if let experience = rewards.experience { ... }
    }

    /// Mark boss as defeated after combat victory
    /// Uses enemy definitionId for data-driven matching
    /// - Note: Quest progress is now handled by QuestTriggerEngine via flag triggers
    func markBossDefeated(enemyId: String) {
        if enemyId == "leshy_guardian" {
            worldFlags["leshy_guardian_defeated"] = true
            // Quest progress handled by QuestTriggerEngine when it processes flagSet action
        }
    }


    // MARK: - Narrative System (Endings & Deck Path)
    // See EXPLORATION_CORE_DESIGN.md, sections 28-34

    /// Calculate player's dominant deck path based on card balance alignment
    ///
    /// Edge case: Если в колоде нет карт со смещением (все neutral или колода пуста),
    /// путь считается нейтральным (.balance). Это корректное поведение —
    /// игрок, не делавший выбора между Светом и Тьмой, идёт путём Равновесия.
    func calculateDeckPath(playerDeck: [Card]) -> DeckPath {
        guard !playerDeck.isEmpty else { return .balance }

        var lightCount = 0
        var darkCount = 0
        var neutralCount = 0

        for card in playerDeck {
            switch card.balance {
            case .light:
                lightCount += 1
            case .dark:
                darkCount += 1
            case .neutral, .none:
                neutralCount += 1
            }
        }

        let total = playerDeck.count
        let lightRatio = Double(lightCount) / Double(total)
        let darkRatio = Double(darkCount) / Double(total)

        // Need >50% of one type to be considered on that path
        // Если нет явного большинства — путь Равновесия
        if lightRatio > 0.5 {
            return .light
        } else if darkRatio > 0.5 {
            return .dark
        } else {
            return .balance
        }
    }

    /// Determine the ending based on world state and player choices
    /// See EXPLORATION_CORE_DESIGN.md, section 32 for ending matrix
    func determineEnding(playerDeck: [Card], allEndings: [EndingProfile]) -> EndingProfile? {
        let deckPath = calculateDeckPath(playerDeck: playerDeck)

        // Calculate anchor states summary
        let stableAnchors = regions.filter { $0.state == .stable }.count
        let breachAnchors = regions.filter { $0.state == .breach }.count

        // Check each ending's conditions
        for ending in allEndings {
            let conditions = ending.conditions

            // Check WorldTension range
            if let minTension = conditions.minTension, worldTension < minTension {
                continue
            }
            if let maxTension = conditions.maxTension, worldTension > maxTension {
                continue
            }

            // Check required flags
            if let requiredFlags = conditions.requiredFlags {
                let hasAllFlags = requiredFlags.allSatisfy { hasFlag($0) }
                if !hasAllFlags {
                    continue
                }
            }

            // Check forbidden flags
            if let forbiddenFlags = conditions.forbiddenFlags {
                let hasAnyForbidden = forbiddenFlags.contains { hasFlag($0) }
                if hasAnyForbidden {
                    continue
                }
            }

            // Check deck path requirement
            if let requiredPath = conditions.deckPath, deckPath != requiredPath {
                continue
            }

            // Check anchor state requirements
            if let minStable = conditions.minStableAnchors, stableAnchors < minStable {
                continue
            }
            if let maxBreach = conditions.maxBreachAnchors, breachAnchors > maxBreach {
                continue
            }

            // Check balance range
            if let minBalance = conditions.minBalance, lightDarkBalance < minBalance {
                continue
            }
            if let maxBalance = conditions.maxBalance, lightDarkBalance > maxBalance {
                continue
            }

            // All conditions met - return this ending
            return ending
        }

        // Fallback: return first ending or nil
        return allEndings.first
    }

    /// Get summary of current state for ending evaluation
    func getEndingStateDescription(playerDeck: [Card]) -> String {
        let deckPath = calculateDeckPath(playerDeck: playerDeck)
        let stableCount = regions.filter { $0.state == .stable }.count
        let breachCount = regions.filter { $0.state == .breach }.count

        // Internal debug format - uses English keys for consistency
        return """
        Tension: \(worldTension)/100
        Balance: \(balanceDescription) (\(lightDarkBalance))
        Deck Path: \(deckPath.rawValue)
        Anchors: \(stableCount) stable, \(breachCount) breach
        Active Flags: \(worldFlags.filter { $0.value }.count)
        """
    }

    /// Check if a main quest step can be unlocked
    func canUnlockQuestStep(_ step: MainQuestStep) -> Bool {
        let conditions = step.unlockConditions

        // Check required flags
        if let requiredFlags = conditions.requiredFlags {
            let hasAllFlags = requiredFlags.allSatisfy { hasFlag($0) }
            if !hasAllFlags { return false }
        }

        // Check forbidden flags
        if let forbiddenFlags = conditions.forbiddenFlags {
            let hasAnyForbidden = forbiddenFlags.contains { hasFlag($0) }
            if hasAnyForbidden { return false }
        }

        // Check tension requirements
        if let minTension = conditions.minTension, worldTension < minTension {
            return false
        }
        if let maxTension = conditions.maxTension, worldTension > maxTension {
            return false
        }

        // Check balance requirements
        if let minBalance = conditions.minBalance, lightDarkBalance < minBalance {
            return false
        }
        if let maxBalance = conditions.maxBalance, lightDarkBalance > maxBalance {
            return false
        }

        return true
    }

    /// Check if a main quest step is completed
    func isQuestStepCompleted(_ step: MainQuestStep) -> Bool {
        let conditions = step.completionConditions

        // Check required flags
        if let requiredFlags = conditions.requiredFlags {
            let hasAllFlags = requiredFlags.allSatisfy { hasFlag($0) }
            if !hasAllFlags { return false }
        }

        // Check forbidden flags (things that must NOT have happened)
        if let forbiddenFlags = conditions.forbiddenFlags {
            let hasAnyForbidden = forbiddenFlags.contains { hasFlag($0) }
            if hasAnyForbidden { return false }
        }

        return true
    }

    // MARK: - Codable Implementation

    enum CodingKeys: String, CodingKey {
        case regions
        case worldTension
        case lightDarkBalance
        case mainQuestStage
        case activeQuests
        case completedQuests
        case worldFlags
        case allEvents
        case currentRegionId
        case daysPassed
        case eventLog
    }

    required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        regions = try container.decode([Region].self, forKey: .regions)
        worldTension = try container.decode(Int.self, forKey: .worldTension)
        lightDarkBalance = try container.decode(Int.self, forKey: .lightDarkBalance)
        mainQuestStage = try container.decode(Int.self, forKey: .mainQuestStage)
        activeQuests = try container.decode([Quest].self, forKey: .activeQuests)
        completedQuests = try container.decode([String].self, forKey: .completedQuests)
        worldFlags = try container.decode([String: Bool].self, forKey: .worldFlags)
        allEvents = try container.decode([GameEvent].self, forKey: .allEvents)
        currentRegionId = try container.decodeIfPresent(UUID.self, forKey: .currentRegionId)
        daysPassed = try container.decode(Int.self, forKey: .daysPassed)
        eventLog = try container.decodeIfPresent([EventLogEntry].self, forKey: .eventLog) ?? []
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(regions, forKey: .regions)
        try container.encode(worldTension, forKey: .worldTension)
        try container.encode(lightDarkBalance, forKey: .lightDarkBalance)
        try container.encode(mainQuestStage, forKey: .mainQuestStage)
        try container.encode(activeQuests, forKey: .activeQuests)
        try container.encode(completedQuests, forKey: .completedQuests)
        try container.encode(worldFlags, forKey: .worldFlags)
        try container.encode(allEvents, forKey: .allEvents)
        try container.encodeIfPresent(currentRegionId, forKey: .currentRegionId)
        try container.encode(daysPassed, forKey: .daysPassed)
        try container.encode(eventLog, forKey: .eventLog)
    }
}


// ==========================================
// FILE: Utilities/AccessibilityIdentifiers.swift
// ==========================================

import Foundation

/// Централизованные accessibility identifiers для UI тестов
/// Используйте эти константы вместо строковых литералов
enum AccessibilityIdentifiers {

    // MARK: - WorldMapView

    enum WorldMap {
        static let view = "worldMapView"
        static let playerInfoBar = "playerInfoBar"
        static let worldInfoBar = "worldInfoBar"
        static let regionsList = "regionsList"

        static func regionCard(_ regionId: UUID) -> String {
            "regionCard_\(regionId.uuidString)"
        }

        static func regionCard(name: String) -> String {
            "regionCard_\(name)"
        }
    }

    // MARK: - RegionDetailView

    enum RegionDetail {
        static let view = "regionDetailView"
        static let anchorInfo = "anchorInfo"
        static let stateIndicator = "stateIndicator"

        // Actions
        static let actionTravel = "action_travel"
        static let actionRest = "action_rest"
        static let actionTrade = "action_trade"
        static let actionExplore = "action_explore"
        static let actionStrengthenAnchor = "action_strengthenAnchor"
    }

    // MARK: - EventView

    enum Event {
        static let view = "eventView"
        static let title = "eventTitle"
        static let description = "eventDescription"
        static let consequencesPreview = "consequencesPreview"
        static let closeButton = "closeEvent"

        static func choice(_ choiceId: UUID) -> String {
            "choice_\(choiceId.uuidString)"
        }

        static func choice(index: Int) -> String {
            "choice_\(index)"
        }
    }

    // MARK: - CombatView

    enum Combat {
        static let view = "combatView"
        static let monsterCard = "monsterCard"
        static let playerStats = "playerStats"
        static let actionBar = "actionBar"
        static let combatLog = "combatLog"
        static let playerHand = "playerHand"

        // Actions
        static let attackButton = "attackButton"
        static let endTurnButton = "endTurnButton"
        static let fleeButton = "fleeButton"

        static func handCard(_ cardId: UUID) -> String {
            "handCard_\(cardId.uuidString)"
        }
    }

    // MARK: - GameBoardView

    enum GameBoard {
        static let view = "gameBoardView"
        static let topBar = "topBar"
        static let encounterArea = "encounterArea"
        static let marketView = "marketView"
        static let deckInfo = "deckInfo"
        static let phaseProgress = "phaseProgress"

        static let pauseButton = "pauseButton"
        static let nextPhaseButton = "nextPhaseButton"
        static let rollDiceButton = "rollDiceButton"
    }

    // MARK: - MainMenu / ContentView

    enum MainMenu {
        static let view = "mainMenuView"
        static let continueButton = "continueButton"
        static let newGameButton = "newGameButton"
        static let loadGameButton = "loadGameButton"
        static let settingsButton = "settingsButton"
    }
}


// ==========================================
// FILE: Utilities/Localization.swift
// ==========================================

import Foundation

// MARK: - Localization Helper
extension String {
    var localized: String {
        return NSLocalizedString(self, comment: "")
    }

    func localized(with arguments: CVarArg...) -> String {
        return String(format: self.localized, arguments: arguments)
    }
}

// MARK: - Localization Keys
enum L10n {
    // Main Screen
    static let gameTitle = "game.title"
    static let characterSelectTitle = "character.select.title"
    static let characterStats = "character.stats"
    static let characterAbilities = "character.abilities"
    static let buttonStartAdventure = "button.start.adventure"

    // Game Board
    static let turnLabel = "turn.label"
    static let buttonNextPhase = "button.next.phase"
    static let buttonExplore = "button.explore"
    static let buttonRollDice = "button.roll.dice"
    static let diceResult = "dice.result"
    static let diceRollTitle = "dice.roll.title"
    static let diceRollMessage = "dice.roll.message"
    static let buttonOk = "button.ok"

    // Game Phases
    static let phaseSetup = "phase.setup"
    static let phaseExploration = "phase.exploration"
    static let phaseEncounter = "phase.encounter"
    static let phasePlayerTurn = "phase.player.turn"
    static let phaseEnemyTurn = "phase.enemy.turn"
    static let phaseEndTurn = "phase.end.turn"
    static let phaseGameOver = "phase.game.over"

    // Encounter
    static let encounterActive = "encounter.active"

    // Deck
    static let deckEncounters = "deck.encounters"
    static let deckLocations = "deck.locations"
    static let deckCards = "deck.cards"

    // Player Hand
    static let playerHandTitle = "player.hand.title"
    static let playerDiscardPile = "player.discard.pile"
    static let playerDeckRemaining = "player.deck.remaining"

    // Card Types
    static let cardTypeCharacter = "card.type.character"
    static let cardTypeWeapon = "card.type.weapon"
    static let cardTypeSpell = "card.type.spell"
    static let cardTypeArmor = "card.type.armor"
    static let cardTypeItem = "card.type.item"
    static let cardTypeBlessing = "card.type.blessing"
    static let cardTypeMonster = "card.type.monster"
    static let cardTypeLocation = "card.type.location"
    static let cardTypeAlly = "card.type.ally"

    // Stats
    static let statHealth = "stat.health"
    static let statPower = "stat.power"
    static let statDefense = "stat.defense"
    static let statStrength = "stat.strength"
    static let statDexterity = "stat.dexterity"
    static let statConstitution = "stat.constitution"
    static let statIntelligence = "stat.intelligence"
    static let statWisdom = "stat.wisdom"
    static let statCharisma = "stat.charisma"

    // Rarity
    static let rarityCommon = "rarity.common"
    static let rarityUncommon = "rarity.uncommon"
    static let rarityRare = "rarity.rare"
    static let rarityEpic = "rarity.epic"
    static let rarityLegendary = "rarity.legendary"

    // Damage Types
    static let damagePhysical = "damage.physical"
    static let damageFire = "damage.fire"
    static let damageCold = "damage.cold"
    static let damageLightning = "damage.lightning"
    static let damagePoison = "damage.poison"
    static let damageAcid = "damage.acid"
    static let damageHoly = "damage.holy"
    static let damageShadow = "damage.shadow"

    // Actions
    static let actionPlay = "action.play"
    static let actionDiscard = "action.discard"
    static let actionExamine = "action.examine"

    // Rules
    static let rulesTitle = "rules.title"
    static let rulesButton = "rules.button"

    // Rules Sections
    static let rulesObjectiveTitle = "rules.objective.title"
    static let rulesObjectiveContent = "rules.objective.content"

    static let rulesPhasesTitle = "rules.phases.title"
    static let rulesPhasesContent = "rules.phases.content"

    static let rulesPhaseExploration = "rules.phase.exploration"
    static let rulesPhaseEncounter = "rules.phase.encounter"
    static let rulesPhasePlayerTurn = "rules.phase.player.turn"
    static let rulesPhaseEnemyTurn = "rules.phase.enemy.turn"
    static let rulesPhaseEndTurn = "rules.phase.endturn"

    static let rulesCardsTitle = "rules.cards.title"
    static let rulesCardsContent = "rules.cards.content"

    static let rulesResourcesTitle = "rules.resources.title"
    static let rulesResourcesContent = "rules.resources.content"

    static let rulesActionsTitle = "rules.actions.title"
    static let rulesActionsContent = "rules.actions.content"

    static let rulesDiceTitle = "rules.dice.title"
    static let rulesDiceContent = "rules.dice.content"

    static let rulesVictoryTitle = "rules.victory.title"
    static let rulesVictoryContent = "rules.victory.content"

    static let rulesTipsTitle = "rules.tips.title"
    static let rulesTipsContent = "rules.tips.content"

    // MARK: - Twilight Marches
    static let tmGameTitle = "tm.game.title"
    static let tmGameSubtitle = "tm.game.subtitle"

    // Realms
    static let tmRealmYav = "tm.realm.yav"
    static let tmRealmNav = "tm.realm.nav"
    static let tmRealmPrav = "tm.realm.prav"

    // Balance
    static let tmBalanceLight = "tm.balance.light"
    static let tmBalanceNeutral = "tm.balance.neutral"
    static let tmBalanceDark = "tm.balance.dark"

    // Resources
    static let tmResourceFaith = "tm.resource.faith"
    static let tmResourceBalance = "tm.resource.balance"

    // Card Types
    static let tmCardTypeCurse = "tm.card.type.curse"
    static let tmCardTypeSpirit = "tm.card.type.spirit"
    static let tmCardTypeArtifact = "tm.card.type.artifact"
    static let tmCardTypeRitual = "tm.card.type.ritual"

    // Curse Types
    static let tmCurseBlindness = "tm.curse.type.blindness"
    static let tmCurseMuteness = "tm.curse.type.muteness"
    static let tmCurseWeakness = "tm.curse.type.weakness"
    static let tmCurseForgetfulness = "tm.curse.type.forgetfulness"
    static let tmCurseSickness = "tm.curse.type.sickness"
    static let tmCurseMadness = "tm.curse.type.madness"
    static let tmCurseTransformation = "tm.curse.type.transformation"

    // UI Elements
    static let uiMenuButton = "ui.menu.button"
    static let uiPauseMenu = "ui.pause.menu"
    static let uiResume = "ui.resume"
    static let uiSaveGame = "ui.save.game"
    static let uiRules = "ui.rules"
    static let uiExit = "ui.exit"
    static let uiRoll = "ui.roll"
    static let uiResult = "ui.result"
    static let uiEncounters = "ui.encounters"
    static let uiYourDeck = "ui.your.deck"
    static let uiDiscard = "ui.discard"
    static let uiActiveEncounter = "ui.active.encounter"
    static let uiExplore = "ui.explore"
    static let uiDeckInfo = "ui.deck.info"
    static let uiHandTitle = "ui.hand.title"
    static let uiGameSaved = "ui.game.saved"
    static let uiProgressSaved = "ui.progress.saved"

    // Victory/Defeat
    static let uiVictoryTitle = "ui.victory.title"
    static let uiDefeatTitle = "ui.defeat.title"
    static let uiEncountersDefeated = "ui.encounters.defeated"
    static let uiTurnsTaken = "ui.turns.taken"
    static let uiTurnsSurvived = "ui.turns.survived"
    static let uiReturnMenu = "ui.return.menu"

    // Tooltips
    static let tooltipHealth = "tooltip.health"
    static let tooltipFaith = "tooltip.faith"
    static let tooltipBalance = "tooltip.balance"
    static let tooltipNextPhase = "tooltip.next.phase"

    // MARK: - Region UI (Audit v1.1 Issue #2)

    // Region States
    static let regionStateStable = "region.state.stable"
    static let regionStateBorderland = "region.state.borderland"
    static let regionStateBreach = "region.state.breach"

    // Region Info
    static let regionReputation = "region.reputation"
    static let regionCurrentLocation = "region.current.location"

    // Actions
    static let actionTravel = "action.travel"
    static let actionRest = "action.rest"
    static let actionTrade = "action.trade"
    static let actionStrengthenAnchor = "action.strengthen.anchor"
    static let actionExploreRegion = "action.explore.region"

    // MARK: - Combat UI (Engine-First Migration)

    // Combat phases
    static let combatTitle = "combat.title"
    static let combatTurnNumber = "combat.turn.number"
    static let combatActionsRemaining = "combat.actions.remaining"
    static let combatPlayerTurn = "combat.phase.player.turn"
    static let combatEnemyTurn = "combat.phase.enemy.turn"
    static let combatEndTurn = "combat.phase.end.turn"
    static let combatOver = "combat.phase.over"

    // Combat actions
    static let combatAttackButton = "combat.action.attack"
    static let combatEndTurnButton = "combat.action.end.turn"
    static let combatFleeButton = "combat.action.flee"
    static let combatPlayCard = "combat.action.play.card"

    // Combat stats
    static let combatHP = "combat.stat.hp"
    static let combatAttack = "combat.stat.attack"
    static let combatDefense = "combat.stat.defense"
    static let combatStrength = "combat.stat.strength"

    // Combat messages
    static let combatVictory = "combat.message.victory"
    static let combatDefeat = "combat.message.defeat"
    static let combatFled = "combat.message.fled"
    static let combatHit = "combat.message.hit"
    static let combatMiss = "combat.message.miss"
    static let combatDamage = "combat.message.damage"

    // Combat log
    static let combatLogTitle = "combat.log.title"
    static let combatLogBattleStart = "combat.log.battle.start"
    static let combatLogActionsPerTurn = "combat.log.actions.per.turn"
    static let combatLogEnemyAttacks = "combat.log.enemy.attacks"
    static let combatLogSpiritAttacks = "combat.log.spirit.attacks"
    static let combatLogMeditation = "combat.log.meditation"
    static let combatLogTurnSeparator = "combat.log.turn.separator"

    // Combat card effects
    static let combatEffectHeal = "combat.effect.heal"
    static let combatEffectDamage = "combat.effect.damage"
    static let combatEffectDrawCards = "combat.effect.draw.cards"
    static let combatEffectGainFaith = "combat.effect.gain.faith"
    static let combatEffectSpendFaith = "combat.effect.spend.faith"
    static let combatEffectRemoveCurse = "combat.effect.remove.curse"
    static let combatEffectBonusDice = "combat.effect.bonus.dice"
    static let combatEffectShiftBalance = "combat.effect.shift.balance"
    static let combatEffectSummonSpirit = "combat.effect.summon.spirit"
    static let combatEffectSacrifice = "combat.effect.sacrifice"

    // Combat attack breakdown
    static let combatAttackRoll = "combat.attack.roll"
    static let combatDamageCalc = "combat.damage.calc"
    static let combatBaseDamage = "combat.damage.base"

    // Hand UI
    static let combatYourHand = "combat.your.hand"
    static let combatTapToPlay = "combat.tap.to.play"
    static let combatNotEnoughFaith = "combat.not.enough.faith"

    // MARK: - UI Strings (Audit Issue #1 - Hardcoded Strings)

    // ContentView / Save Slots
    static let uiContinue = "ui.continue"
    static let uiBack = "ui.back"
    static let uiSlotSelection = "ui.slot.selection"
    static let uiContinueGame = "ui.continue.game"
    static let uiSlotNumber = "ui.slot.number"
    static let uiTurnNumber = "ui.turn.number"
    static let uiVictories = "ui.victories"
    static let uiLoad = "ui.load"
    static let uiNewGame = "ui.new.game"
    static let uiEmptySlot = "ui.empty.slot"
    static let uiStartNewGame = "ui.start.new.game"
    static let uiDeleteConfirm = "ui.delete.confirm"
    static let uiOverwriteConfirm = "ui.overwrite.confirm"
    static let uiDeleteSave = "ui.delete.save"
    static let uiOverwriteSave = "ui.overwrite.save"
    static let uiCancel = "ui.cancel"
    static let uiDelete = "ui.delete"
    static let uiOverwrite = "ui.overwrite"

    // EventView
    static let eventChooseAction = "event.choose.action"
    static let eventRequiresFaith = "event.requires.faith"
    static let eventYouHaveFaith = "event.you.have.faith"
    static let eventRequiresHealth = "event.requires.health"
    static let eventYouHaveHealth = "event.you.have.health"
    static let eventRequiresPath = "event.requires.path"
    static let eventYourPath = "event.your.path"
    static let eventFaithChange = "event.faith.change"
    static let eventHealthChange = "event.health.change"
    static let eventBalanceToLight = "event.balance.to.light"
    static let eventBalanceToDark = "event.balance.to.dark"
    static let eventReputationChange = "event.reputation.change"
    static let eventReceiveCard = "event.receive.card"
    static let eventReceiveCurse = "event.receive.curse"
    static let eventChoiceMade = "event.choice.made"
    static let eventCombatVictoryMessage = "event.combat.victory.message"
    static let eventCombatDefeatMessage = "event.combat.defeat.message"
    static let eventCombatFledMessage = "event.combat.fled.message"

    // UI Common
    static let uiClose = "ui.close"

    // Balance (genitive form)
    static let tmBalanceLightGenitive = "tm.balance.light.genitive"
    static let tmBalanceNeutralGenitive = "tm.balance.neutral.genitive"
    static let tmBalanceDarkGenitive = "tm.balance.dark.genitive"

    // StatisticsView
    static let statsTitle = "stats.title"
    static let statsGameName = "stats.game.name"
    static let statsGeneral = "stats.general"
    static let statsLeaderboard = "stats.leaderboard"
    static let statsHistory = "stats.history"
    static let statsNoSaves = "stats.no.saves"
    static let statsStartHint = "stats.start.hint"
    static let statsDone = "stats.done"
    static let statsResources = "stats.resources"
    static let statsProgress = "stats.progress"
    static let statsGamesCount = "stats.games.count"
    static let statsBestResult = "stats.best.result"
    static let statsLongestSurvival = "stats.longest.survival"
    static let statsTurnsCount = "stats.turns.count"
    static let statsVictoriesLabel = "stats.victories.label"
    static let statsTurnsLabel = "stats.turns.label"

    // CombatView additional
    static let combatVs = "combat.vs"
    static let combatAttackRollTitle = "combat.attack.roll"
    static let combatDamageCalcTitle = "combat.damage.calc.title"
    static let combatBaseValue = "combat.base.value"
    static let combatTotalDamage = "combat.total.damage"

    // Combat UI labels (Audit v2.1 Item 5)
    static let combatShield = "combat.shield"
    static let combatDefend = "combat.defend"
    static let combatFallen = "combat.fallen"
    static let combatStatsTurns = "combat.stats.turns"
    static let combatStatsDamageDealt = "combat.stats.damage.dealt"
    static let combatStatsDamageTaken = "combat.stats.damage.taken"
    static let combatStatsCardsPlayed = "combat.stats.cards.played"
    static let combatAttackVsDefense = "combat.attack.vs.defense"

    // MARK: - WorldMapView (Full localization - Audit v2.1)

    // Loading & Alerts
    static let worldLoading = "world.loading"
    static let worldEvent = "world.event"
    static let buttonUnderstood = "button.understood"
    static let dayNumber = "day.number"
    static let worldLabel = "world.label"
    static let daysInJourney = "days.in.journey"
    static let buttonConfirm = "button.confirm"
    static let nothingFound = "nothing.found"
    static let noEventsInRegion = "no.events.in.region"
    static let cardsReceived = "cards.received"
    static let addedToDeck = "added.to.deck"
    static let buttonGreat = "button.great"
    static let youAreHere = "you.are.here"

    // Region descriptions
    static let regionDescStable = "region.desc.stable"
    static let regionDescBorderland = "region.desc.borderland"
    static let regionDescBreach = "region.desc.breach"

    // Combat modifiers
    static let combatModifiers = "combat.modifiers"
    static let enemyStrength = "enemy.strength"
    static let enemyDefense = "enemy.defense"
    static let enemyHealth = "enemy.health"

    // Anchor
    static let anchorOfYav = "anchor.of.yav"
    static let anchorIntegrity = "anchor.integrity"
    static let anchorInfluence = "anchor.influence"

    // Balance names
    static let balanceLight = "balance.light"
    static let balanceNeutral = "balance.neutral"
    static let balanceDark = "balance.dark"

    // Actions
    static let availableActions = "available.actions"
    static let dayWord1 = "day.word.1"
    static let dayWord234 = "day.word.234"
    static let actionTravelTo = "action.travel.to"
    static let actionRegionFar = "action.region.far"
    static let actionMoveToRegionHint = "action.move.to.region.hint"
    static let actionRegionNotDirectlyAccessible = "action.region.not.directly.accessible"
    static let actionRestWithHealth = "action.rest.with.health"
    static let actionStrengthenAnchorCost = "action.strengthen.anchor.cost"

    // Quest
    static let activeQuestsInRegion = "active.quests.in.region"
    static let questProgress = "quest.progress"

    // Journal
    static let journalEmpty = "journal.empty"
    static let journalTitle = "journal.title"

    // Confirmations
    static let confirmationTitle = "confirmation.title"
    static let confirmTravelTo = "confirm.travel.to"
    static let confirmRest = "confirm.rest"
    static let confirmTrade = "confirm.trade"
    static let confirmStrengthenAnchor = "confirm.strengthen.anchor"
    static let confirmExplore = "confirm.explore"
    static let locationUnknown = "location.unknown"

    // Log entries
    static let logEventRest = "log.event.rest"
    static let logChoiceRest = "log.choice.rest"
    static let logOutcomeHealthRestored = "log.outcome.health.restored"
    static let logEventStrengthenAnchor = "log.event.strengthen.anchor"
    static let logChoiceFaithSpent = "log.choice.faith.spent"
    static let logOutcomeAnchorStrengthened = "log.outcome.anchor.strengthened"

    // Warnings
    static let warningTitle = "warning.title"
    static let warningHighDanger = "warning.high.danger"
    static let actionImpossible = "action.impossible"
    static let goThroughFirst = "go.through.first"

    // MARK: - HeroSelectionView / HeroPanel

    static let heroClassDefault = "hero.class.default"
    static let heroSelectTitle = "hero.select.title"
    static let heroSelectSubtitle = "hero.select.subtitle"
    static let heroStartGame = "hero.start.game"
    static let heroSelectClass = "hero.select.class"
    static let heroPath = "hero.path"
    static let pathLight = "path.light"
    static let pathDark = "path.dark"
    static let pathBalance = "path.balance"

    // MARK: - GameBoardView

    static let enemyDefeated = "enemy.defeated"
    static let returningToEvent = "returning.to.event"
    static let rollResult = "roll.result"
    static let enemyAttacksYou = "enemy.attacks.you"
    static let marketplace = "marketplace"
    static let noCardsForPurchase = "no.cards.for.purchase"
    static let victoryMessage = "victory.message"
    static let defeatMessage = "defeat.message"
    static let buttonBuy = "button.buy"

    // MARK: - CardView

    static let cardStatHealth = "card.stat.health"
    static let cardStatStrength = "card.stat.strength"
    static let cardStatDefense = "card.stat.defense"

    // MARK: - PlayerHandView

    static let noCardsInHand = "no.cards.in.hand"

    // MARK: - GameBoardView (Full localization - Audit v2.1)

    // Combat alerts
    static let combatAlertSuccess = "combat.alert.success"
    static let combatAlertFail = "combat.alert.fail"
    static let combatRollResultSuccess = "combat.roll.result.success"
    static let combatRollResultFail = "combat.roll.result.fail"
    static let combatEnemyAttackTitle = "combat.enemy.attack.title"
    static let combatEnemyAttackMessage = "combat.enemy.attack.message"

    // Pause menu
    static let worldMap = "world.map"

    // Stats display
    static let statsEncountersDefeated = "stats.encounters.defeated"
    static let statsTurnsMade = "stats.turns.made"
    static let statsTurnsSurvived = "stats.turns.survived"

    // Card types for market
    static let cardTypeResource = "card.type.resource"
    static let cardTypeAttack = "card.type.attack"
    static let cardTypeDefense = "card.type.defense"
    static let cardTypeSpecial = "card.type.special"

    // Phase progress bar labels
    static let phaseProgressExploration = "phase.progress.exploration"
    static let phaseProgressEncounter = "phase.progress.encounter"
    static let phaseProgressPlayerTurn = "phase.progress.player.turn"
    static let phaseProgressEnemyTurn = "phase.progress.enemy.turn"
    static let phaseProgressEndTurn = "phase.progress.end.turn"

    // MARK: - Models/ExplorationModels - Combat Modifiers
    static let combatModifierBorderland = "combat.modifier.borderland"
    static let combatModifierBreach = "combat.modifier.breach"

    // MARK: - Models/ExplorationModels - RegionType
    static let regionTypeForest = "region.type.forest"
    static let regionTypeSwamp = "region.type.swamp"
    static let regionTypeMountain = "region.type.mountain"
    static let regionTypeSettlement = "region.type.settlement"
    static let regionTypeWater = "region.type.water"
    static let regionTypeWasteland = "region.type.wasteland"
    static let regionTypeSacred = "region.type.sacred"

    // MARK: - Models/ExplorationModels - AnchorType
    static let anchorTypeShrine = "anchor.type.shrine"
    static let anchorTypeBarrow = "anchor.type.barrow"
    static let anchorTypeSacredTree = "anchor.type.sacred.tree"
    static let anchorTypeStoneIdol = "anchor.type.stone.idol"
    static let anchorTypeSpring = "anchor.type.spring"
    static let anchorTypeChapel = "anchor.type.chapel"
    static let anchorTypeTemple = "anchor.type.temple"
    static let anchorTypeCross = "anchor.type.cross"

    // MARK: - Models/ExplorationModels - EventType
    static let eventTypeCombat = "event.type.combat"
    static let eventTypeRitual = "event.type.ritual"
    static let eventTypeNarrative = "event.type.narrative"
    static let eventTypeExploration = "event.type.exploration"
    static let eventTypeWorldShift = "event.type.world.shift"

    // MARK: - Models/Player - Balance path
    static let balancePathDark = "balance.path.dark"
    static let balancePathNeutral = "balance.path.neutral"
    static let balancePathLight = "balance.path.light"
    static let balancePathUnknown = "balance.path.unknown"

    // MARK: - CardGameApp - Loading messages
    static let loadingDefault = "loading.default"
    static let loadingSearchPacks = "loading.search.packs"
    static let loadingContent = "loading.content"
    static let loadingContentNotFound = "loading.content.not.found"
    static let loadingReady = "loading.ready"
    static let loadingContentLoaded = "loading.content.loaded"
    static let loadingError = "loading.error"
    static let appTitle = "app.title"

    // MARK: - ViewModels/GameViewModel
    static let defaultPlayerName = "default.player.name"
    static let regionUnknown = "region.unknown"
    static let journalEntryRest = "journal.entry.rest"
    static let journalEntryRestChoice = "journal.entry.rest.choice"
    static let journalEntryRestOutcome = "journal.entry.rest.outcome"
    static let journalEntryAnchor = "journal.entry.anchor"
    static let journalEntryAnchorChoice = "journal.entry.anchor.choice"
    static let journalEntryAnchorOutcome = "journal.entry.anchor.outcome"
    static let choiceMade = "choice.made"

    // MARK: - WorldMapView - Additional Actions (unique keys)
    static let actionTravelFar = "action.travel.far"
    static let actionExplore = "action.explore"
    static let confirmTravel = "confirm.travel"

    // MARK: - WorldMapView - Journal entries
    static let journalEntryTravel = "journal.entry.travel"
    static let journalEntryTravelChoice = "journal.entry.travel.choice"
    static let journalEntryTravelOutcome = "journal.entry.travel.outcome"
    static let journalEntryExplore = "journal.entry.explore"
    static let journalEntryExploreChoice = "journal.entry.explore.choice"
    static let journalEntryExploreNothing = "journal.entry.explore.nothing"

    // MARK: - WorldMapView - Error messages
    static let errorUnknown = "error.unknown"
    static let errorRegionFar = "error.region.far"
    static let errorRegionInaccessible = "error.region.inaccessible"
    static let errorHealthLow = "error.health.low"
    static let errorInsufficientResource = "error.insufficient.resource"
    static let errorInCombat = "error.in.combat"
    static let errorFinishEvent = "error.finish.event"
    static let errorActionFailed = "error.action.failed"

    // MARK: - GameViewModel Journal entries (used in GameViewModel.swift)
    static let journalRestTitle = "journal.rest.title"
    static let journalRestChoice = "journal.rest.choice"
    static let journalRestOutcome = "journal.rest.outcome"
    static let journalAnchorTitle = "journal.anchor.title"
    static let journalAnchorChoice = "journal.anchor.choice"
    static let journalAnchorOutcome = "journal.anchor.outcome"
    static let journalChoiceMade = "journal.choice.made"

    // MARK: - WorldMapView - Action buttons (localized titles)
    static let actionRestHeal = "action.rest.heal"
    static let actionTradeName = "action.trade.name"
    static let actionExploreName = "action.explore.name"
    static let actionAnchorCost = "action.anchor.cost"

    // MARK: - CurseType display names
    static let curseWeakness = "curse.weakness"
    static let curseFear = "curse.fear"
    static let curseExhaustion = "curse.exhaustion"
    static let curseGreed = "curse.greed"
    static let curseShadowOfNav = "curse.shadow.of.nav"
    static let curseBloodCurse = "curse.blood.curse"
    static let curseSealOfNav = "curse.seal.of.nav"

    // MARK: - DayEvent notifications
    static let dayEventTensionTitle = "dayevent.tension.title"
    static let dayEventTensionDescription = "dayevent.tension.description"
    static let dayEventRegionDegradedTitle = "dayevent.region.degraded.title"
    static let dayEventRegionDegradedDescription = "dayevent.region.degraded.description"
    static let dayEventWorldImprovingTitle = "dayevent.world.improving.title"
    static let dayEventWorldImprovingDescription = "dayevent.world.improving.description"

    // MARK: - World log messages
    static let logTensionIncreased = "log.tension.increased"
    static let logAnchorResists = "log.anchor.resists"
    static let logRegionDegraded = "log.region.degraded"
    static let logWorldChange = "log.world.change"
    static let logWorld = "log.world"

    // MARK: - Travel log messages
    static let logTravelTitle = "log.travel.title"
    static let logTravelChoice = "log.travel.choice"
    static let logTravelOutcomeDay = "log.travel.outcome.day"
    static let logTravelOutcomeDays = "log.travel.outcome.days"

    // MARK: - Combat UI strings
    static let combatTurnsStats = "combat.turns.stats"
    static let combatActionCost = "combat.action.cost"
    static let combatMonsterDefeated = "combat.monster.defeated"
    static let combatContinue = "combat.continue"
    static let combatReturn = "combat.return"
    static let combatHitResult = "combat.hit.result"
    static let combatMissResult = "combat.miss.result"
    static let combatDiceRoll = "combat.dice.roll"
    static let combatDefenseValue = "combat.defense.value"
    static let combatDamageValue = "combat.damage.value"

    // MARK: - Combat log messages
    static let combatLogBattleStartEnemy = "combat.log.battle.start.enemy"
    static let combatLogActionsInfo = "combat.log.actions.info"
    static let combatLogHit = "combat.log.hit"
    static let combatLogMissed = "combat.log.miss"
    static let combatLogCover = "combat.log.cover"
    static let combatLogStrengthBonus = "combat.log.strength.bonus"
    static let combatLogInsufficientFaith = "combat.log.insufficient.faith"
    static let combatLogFaithSpent = "combat.log.faith.spent"
    static let combatLogShieldCard = "combat.log.shield.card"
    static let combatLogAttackBonus = "combat.log.attack.bonus"
    static let combatLogSpellCast = "combat.log.spell.cast"
    static let combatLogCardPlayed = "combat.log.card.played"
    static let combatLogHealEffect = "combat.log.heal.effect"
    static let combatLogDamageEffect = "combat.log.damage.effect"
    static let combatLogDrawCards = "combat.log.draw.cards"
    static let combatLogFaithGained = "combat.log.faith.gained"
    static let combatLogCurseRemoved = "combat.log.curse.removed"
    static let combatLogBonusDice = "combat.log.bonus.dice"
    static let combatLogReroll = "combat.log.reroll"
    static let combatLogBalanceShift = "combat.log.balance.shift"
    static let combatLogCurseDamage = "combat.log.curse.damage"
    static let combatLogSpiritSummoned = "combat.log.spirit.summoned"
    static let combatLogSpiritAttack = "combat.log.spirit.attack"

    // MARK: - Realm names
    static let realmYav = "realm.yav"
    static let realmNav = "realm.nav"
    static let realmPrav = "realm.prav"

    // MARK: - Hero Classes
    static let heroClassWarrior = "hero.class.warrior"
    static let heroClassMage = "hero.class.mage"
    static let heroClassRanger = "hero.class.ranger"
    static let heroClassPriest = "hero.class.priest"
    static let heroClassShadow = "hero.class.shadow"

    static let heroClassWarriorDesc = "hero.class.warrior.desc"
    static let heroClassMageDesc = "hero.class.mage.desc"
    static let heroClassRangerDesc = "hero.class.ranger.desc"
    static let heroClassPriestDesc = "hero.class.priest.desc"
    static let heroClassShadowDesc = "hero.class.shadow.desc"

    static let heroAbilityWarrior = "hero.ability.warrior"
    static let heroAbilityMage = "hero.ability.mage"
    static let heroAbilityRanger = "hero.ability.ranger"
    static let heroAbilityPriest = "hero.ability.priest"
    static let heroAbilityShadow = "hero.ability.shadow"

    // MARK: - Curse Definitions
    static let curseWeaknessName = "curse.weakness.name"
    static let curseWeaknessDescription = "curse.weakness.description"
    static let curseFearName = "curse.fear.name"
    static let curseFearDescription = "curse.fear.description"
    static let curseExhaustionName = "curse.exhaustion.name"
    static let curseExhaustionDescription = "curse.exhaustion.description"
    static let curseGreedName = "curse.greed.name"
    static let curseGreedDescription = "curse.greed.description"
    static let curseShadowOfNavName = "curse.shadow.of.nav.name"
    static let curseShadowOfNavDescription = "curse.shadow.of.nav.description"
    static let curseBloodCurseName = "curse.blood.curse.name"
    static let curseBloodCurseDescription = "curse.blood.curse.description"
    static let curseSealOfNavName = "curse.seal.of.nav.name"
    static let curseSealOfNavDescription = "curse.seal.of.nav.description"

    // MARK: - Hero Ability Definitions
    static let abilityWarriorRageName = "ability.warrior.rage.name"
    static let abilityWarriorRageDesc = "ability.warrior.rage.desc"
    static let abilityMageMeditationName = "ability.mage.meditation.name"
    static let abilityMageMeditationDesc = "ability.mage.meditation.desc"
    static let abilityRangerTrackingName = "ability.ranger.tracking.name"
    static let abilityRangerTrackingDesc = "ability.ranger.tracking.desc"
    static let abilityPriestBlessingName = "ability.priest.blessing.name"
    static let abilityPriestBlessingDesc = "ability.priest.blessing.desc"
    static let abilityShadowAmbushName = "ability.shadow.ambush.name"
    static let abilityShadowAmbushDesc = "ability.shadow.ambush.desc"

    // MARK: - Action Errors
    static let errorInvalidAction = "error.invalid.action"
    static let errorRegionNotAccessible = "error.region.not.accessible"
    static let errorRegionNotNeighbor = "error.region.not.neighbor"
    static let errorActionNotAvailable = "error.action.not.available"
    static let errorInsufficientResources = "error.insufficient.resources"
    static let errorHealthTooLow = "error.health.too.low"
    static let errorGameNotInProgress = "error.game.not.in.progress"
    static let errorCombatInProgress = "error.combat.in.progress"
    static let errorEventInProgress = "error.event.in.progress"
    static let errorNoActiveEvent = "error.no.active.event"
    static let errorNoActiveCombat = "error.no.active.combat"
    static let errorEventNotFound = "error.event.not.found"
    static let errorInvalidChoiceIndex = "error.invalid.choice.index"
    static let errorChoiceRequirementsNotMet = "error.choice.requirements.not.met"
    static let errorCardNotInHand = "error.card.not.in.hand"
    static let errorNotEnoughActions = "error.not.enough.actions"
    static let errorInvalidTarget = "error.invalid.target"
}


// ==========================================
// FILE: Utilities/SafeImage.swift
// ==========================================

import SwiftUI

// MARK: - Safe Image Loading
// Audit 2.0 Requirement: Fallback System for missing icons
// If icon not found in Assets → show default placeholder

/// Safe image view that handles missing assets gracefully
struct SafeImage: View {
    let name: String
    let fallbackSystemName: String

    init(_ name: String, fallback: String = "questionmark.circle") {
        self.name = name
        self.fallbackSystemName = fallback
    }

    var body: some View {
        if let uiImage = UIImage(named: name) {
            Image(uiImage: uiImage)
                .resizable()
                .scaledToFit()
        } else {
            // Fallback: show SF Symbol placeholder
            Image(systemName: fallbackSystemName)
                .foregroundColor(.secondary)
        }
    }
}

/// Safe async image loading with fallback
struct SafeAsyncImage: View {
    let name: String
    let fallbackSystemName: String

    init(_ name: String, fallback: String = "questionmark.circle") {
        self.name = name
        self.fallbackSystemName = fallback
    }

    var body: some View {
        if UIImage(named: name) != nil {
            Image(name)
                .resizable()
                .scaledToFit()
        } else {
            Image(systemName: fallbackSystemName)
                .foregroundColor(.secondary)
        }
    }
}

// MARK: - Image Validation Utility

/// Utility to validate asset availability at runtime
enum AssetValidator {

    /// Check if asset exists in bundle
    static func assetExists(_ name: String, in bundle: Bundle = .main) -> Bool {
        return UIImage(named: name, in: bundle, compatibleWith: nil) != nil
    }

    /// Validate all icons referenced in content pack
    static func validatePackIcons(icons: [String], in bundle: Bundle = .main) -> [String] {
        return icons.filter { !assetExists($0, in: bundle) }
    }

    /// Get safe icon name with fallback
    static func safeIconName(_ name: String?, fallback: String = "questionmark.circle") -> String {
        guard let name = name, !name.isEmpty else {
            return fallback
        }

        // If it looks like an SF Symbol (contains period), assume it exists
        if name.contains(".") {
            return name
        }

        // For custom assets, check if they exist
        if assetExists(name) {
            return name
        } else {
            return fallback
        }
    }
}

// MARK: - View Extension for Safe Images

extension View {
    /// Apply safe icon with fallback
    func safeIcon(_ name: String?, fallback: String = "questionmark.circle") -> some View {
        let safeName = AssetValidator.safeIconName(name, fallback: fallback)
        return AnyView(
            Group {
                if safeName.contains(".") {
                    // SF Symbol
                    Image(systemName: safeName)
                } else {
                    // Custom asset
                    SafeImage(safeName, fallback: fallback)
                }
            }
        )
    }
}

// MARK: - Preview

#if DEBUG
struct SafeImage_Previews: PreviewProvider {
    static var previews: some View {
        VStack(spacing: 20) {
            // Existing asset (should show image)
            SafeImage("AppIcon", fallback: "star.fill")
                .frame(width: 50, height: 50)

            // Missing asset (should show fallback)
            SafeImage("nonexistent_icon", fallback: "exclamationmark.triangle")
                .frame(width: 50, height: 50)

            // SF Symbol style
            Image(systemName: AssetValidator.safeIconName("valid.symbol", fallback: "questionmark"))
                .font(.largeTitle)
        }
        .padding()
    }
}
#endif


// ==========================================
// FILE: Utilities/WorldRNG.swift
// ==========================================

import Foundation

// MARK: - World Random Number Generator
// Детерминированный RNG для воспроизводимости игрового мира
// Использует LCG (Linear Congruential Generator) - тот же алгоритм что в тестах

/// Протокол для внедрения RNG в игровой мир
protocol WorldRandomGenerator {
    mutating func nextDouble() -> Double
    mutating func nextInt(in range: Range<Int>) -> Int
    mutating func nextInt(in range: ClosedRange<Int>) -> Int
}

/// Детерминированный RNG с seed (для тестов и воспроизводимости)
struct SeededWorldRNG: WorldRandomGenerator, RandomNumberGenerator {
    private(set) var state: UInt64

    init(seed: UInt64) {
        self.state = seed
    }

    mutating func next() -> UInt64 {
        // LCG параметры (те же что в существующих тестах)
        state = state &* 6364136223846793005 &+ 1442695040888963407
        return state
    }

    mutating func nextDouble() -> Double {
        // Преобразуем UInt64 в Double в диапазоне [0, 1)
        return Double(next()) / Double(UInt64.max)
    }

    mutating func nextInt(in range: Range<Int>) -> Int {
        guard !range.isEmpty else { return range.lowerBound }
        let bound = UInt64(range.count)
        return range.lowerBound + Int(next() % bound)
    }

    mutating func nextInt(in range: ClosedRange<Int>) -> Int {
        let bound = UInt64(range.count)
        return range.lowerBound + Int(next() % bound)
    }
}

/// Системный RNG (обёртка над Swift random для единообразия интерфейса)
struct SystemWorldRNG: WorldRandomGenerator {
    mutating func nextDouble() -> Double {
        return Double.random(in: 0..<1)
    }

    mutating func nextInt(in range: Range<Int>) -> Int {
        return Int.random(in: range)
    }

    mutating func nextInt(in range: ClosedRange<Int>) -> Int {
        return Int.random(in: range)
    }
}

// MARK: - WorldRNG Singleton with Injection Support

/// Глобальный RNG для игрового мира с поддержкой инъекции для тестов
final class WorldRNG {
    /// Shared instance (по умолчанию системный RNG)
    static var shared: WorldRNG = WorldRNG()

    private var rng: any WorldRandomGenerator

    /// Инициализация с системным RNG (по умолчанию)
    init() {
        self.rng = SystemWorldRNG()
    }

    /// Инициализация с seeded RNG (для тестов)
    init(seed: UInt64) {
        self.rng = SeededWorldRNG(seed: seed)
    }

    /// Установить seed для детерминированного поведения
    func setSeed(_ seed: UInt64) {
        self.rng = SeededWorldRNG(seed: seed)
    }

    /// Сбросить на системный RNG
    func resetToSystem() {
        self.rng = SystemWorldRNG()
    }

    /// Случайное Double в [0, 1)
    func nextDouble() -> Double {
        return rng.nextDouble()
    }

    /// Случайный Int в диапазоне [lowerBound, upperBound)
    func nextInt(in range: Range<Int>) -> Int {
        return rng.nextInt(in: range)
    }

    /// Случайный Int в диапазоне [lowerBound, upperBound]
    func nextInt(in range: ClosedRange<Int>) -> Int {
        return rng.nextInt(in: range)
    }

    /// Проверка вероятности (возвращает true с вероятностью p)
    func checkProbability(_ p: Double) -> Bool {
        return nextDouble() < p
    }

    // MARK: - Collection Helpers (Deterministic)

    /// Выбрать случайный элемент из массива (детерминировано)
    func randomElement<T>(from array: [T]) -> T? {
        guard !array.isEmpty else { return nil }
        let index = nextInt(in: 0..<array.count)
        return array[index]
    }

    /// Детерминированный shuffle массива (Fisher-Yates с WorldRNG)
    func shuffled<T>(_ array: [T]) -> [T] {
        guard array.count > 1 else { return array }
        var result = array
        for i in stride(from: result.count - 1, through: 1, by: -1) {
            let j = nextInt(in: 0...i)
            if i != j {
                result.swapAt(i, j)
            }
        }
        return result
    }

    /// In-place детерминированный shuffle (Fisher-Yates с WorldRNG)
    func shuffle<T>(_ array: inout [T]) {
        guard array.count > 1 else { return }
        for i in stride(from: array.count - 1, through: 1, by: -1) {
            let j = nextInt(in: 0...i)
            if i != j {
                array.swapAt(i, j)
            }
        }
    }
}


// ==========================================
// FILE: Views/CardView.swift
// ==========================================

import SwiftUI

struct CardView: View {
    let card: Card
    var isSelected: Bool = false
    var onTap: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Card header with name and type
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(card.name)
                        .font(.headline)
                        .fontWeight(.bold)
                        .foregroundColor(.white)
                    Spacer()
                    if let cost = card.cost {
                        Text("\(cost)")
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(.yellow)
                            .padding(6)
                            .background(Circle().fill(Color.black.opacity(0.6)))
                    }
                }

                Text(localizedCardType)
                    .font(.caption)
                    .foregroundColor(.white.opacity(0.8))
            }
            .padding(12)
            .background(headerColor)

            // Card image area
            ZStack {
                Rectangle()
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [cardColor.opacity(0.3), cardColor]),
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    )

                VStack {
                    Image(systemName: cardIcon)
                        .font(.system(size: 60))
                        .foregroundColor(.white.opacity(0.9))
                }
            }
            .frame(height: 120)

            // Stats section
            if hasStats {
                HStack(spacing: 16) {
                    if let power = card.power {
                        CardStatBadge(icon: "bolt.fill", value: power, color: .red)
                    }
                    if let defense = card.defense {
                        CardStatBadge(icon: "shield.fill", value: defense, color: .blue)
                    }
                    if let health = card.health {
                        CardStatBadge(icon: "heart.fill", value: health, color: .green)
                    }
                    Spacer()
                }
                .padding(.horizontal, 12)
                .padding(.vertical, 8)
                .background(Color.black.opacity(0.2))
            }

            // Description
            ScrollView {
                VStack(alignment: .leading, spacing: 8) {
                    Text(card.description)
                        .font(.caption)
                        .foregroundColor(.primary)
                        .fixedSize(horizontal: false, vertical: true)

                    // Abilities
                    ForEach(card.abilities) { ability in
                        VStack(alignment: .leading, spacing: 2) {
                            Text(ability.name)
                                .font(.caption)
                                .fontWeight(.bold)
                                .foregroundColor(.orange)
                            Text(ability.description)
                                .font(.caption2)
                                .foregroundColor(.secondary)
                                .fixedSize(horizontal: false, vertical: true)
                        }
                        .padding(.top, 4)
                    }

                    // Traits
                    if !card.traits.isEmpty {
                        HStack {
                            ForEach(card.traits, id: \.self) { trait in
                                Text(trait.localized)
                                    .font(.caption2)
                                    .padding(.horizontal, 6)
                                    .padding(.vertical, 2)
                                    .background(Capsule().fill(Color.gray.opacity(0.3)))
                            }
                        }
                        .padding(.top, 4)
                    }
                }
                .padding(12)
            }

            // Rarity indicator
            HStack {
                Spacer()
                Circle()
                    .fill(rarityColor)
                    .frame(width: 8, height: 8)
                Text(localizedRarity)
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
            .padding(8)
        }
        .frame(height: 320)
        .background(Color(UIColor.systemBackground))
        .cornerRadius(12)
        .shadow(color: isSelected ? .blue.opacity(0.5) : .black.opacity(0.2), radius: isSelected ? 8 : 4)
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(isSelected ? Color.blue : Color.clear, lineWidth: 3)
        )
        .onTapGesture {
            onTap?()
        }
    }

    var hasStats: Bool {
        card.power != nil || card.defense != nil || card.health != nil
    }

    var localizedCardType: String {
        switch card.type {
        case .character: return L10n.cardTypeCharacter.localized
        case .weapon: return L10n.cardTypeWeapon.localized
        case .spell: return L10n.cardTypeSpell.localized
        case .armor: return L10n.cardTypeArmor.localized
        case .item: return L10n.cardTypeItem.localized
        case .ally: return L10n.cardTypeAlly.localized
        case .blessing: return L10n.cardTypeBlessing.localized
        case .monster: return L10n.cardTypeMonster.localized
        case .location: return L10n.cardTypeLocation.localized
        case .scenario: return card.type.rawValue.capitalized
        case .curse: return L10n.tmCardTypeCurse.localized
        case .spirit: return L10n.tmCardTypeSpirit.localized
        case .artifact: return L10n.tmCardTypeArtifact.localized
        case .ritual: return L10n.tmCardTypeRitual.localized
        case .resource: return L10n.cardTypeResource.localized
        case .attack: return L10n.cardTypeAttack.localized
        case .defense: return L10n.cardTypeDefense.localized
        case .special: return L10n.cardTypeSpecial.localized
        }
    }

    var localizedRarity: String {
        switch card.rarity {
        case .common: return L10n.rarityCommon.localized
        case .uncommon: return L10n.rarityUncommon.localized
        case .rare: return L10n.rarityRare.localized
        case .epic: return L10n.rarityEpic.localized
        case .legendary: return L10n.rarityLegendary.localized
        }
    }

    var headerColor: Color {
        switch card.type {
        case .character: return Color.purple
        case .weapon: return Color.red
        case .spell: return Color.blue
        case .armor: return Color.gray
        case .item: return Color.brown
        case .ally: return Color.green
        case .blessing: return Color.yellow
        case .monster: return Color.red.opacity(0.8)
        case .location: return Color.teal
        case .scenario: return Color.indigo
        case .curse: return Color.black
        case .spirit: return Color.cyan
        case .artifact: return Color.orange
        case .ritual: return Color.indigo
        case .resource: return Color.green
        case .attack: return Color.red
        case .defense: return Color.blue
        case .special: return Color.purple
        }
    }

    var cardColor: Color {
        headerColor.opacity(0.6)
    }

    var cardIcon: String {
        switch card.type {
        case .character: return "person.fill"
        case .weapon: return "bolt.fill"
        case .spell: return "sparkles"
        case .armor: return "shield.fill"
        case .item: return "bag.fill"
        case .ally: return "person.2.fill"
        case .blessing: return "star.fill"
        case .monster: return "flame.fill"
        case .location: return "mappin.and.ellipse"
        case .scenario: return "book.fill"
        case .curse: return "cloud.bolt.fill"
        case .spirit: return "cloud.moon.fill"
        case .artifact: return "crown.fill"
        case .ritual: return "book.closed.fill"
        case .resource: return "leaf.fill"
        case .attack: return "bolt.fill"
        case .defense: return "shield.fill"
        case .special: return "star.circle.fill"
        }
    }

    var rarityColor: Color {
        switch card.rarity {
        case .common: return .gray
        case .uncommon: return .green
        case .rare: return .blue
        case .epic: return .purple
        case .legendary: return .orange
        }
    }
}

struct CardStatBadge: View {
    let icon: String
    let value: Int
    let color: Color

    var body: some View {
        HStack(spacing: 4) {
            Image(systemName: icon)
                .font(.caption)
            Text("\(value)")
                .font(.caption)
                .fontWeight(.bold)
        }
        .foregroundColor(color)
    }
}

// Compact card view for character selection
// Compact card view for character selection
struct CompactCardView: View {
    let card: Card
    var isSelected: Bool = false
    var onTap: (() -> Void)?

    var body: some View {
        VStack(spacing: 0) {
            // Card header
            Text(card.name)
                .font(.title3)
                .fontWeight(.bold)
                .foregroundColor(.white)
                .frame(maxWidth: .infinity)
                .padding(.vertical, 12)
                .background(headerColor)

            // Card image area
            ZStack {
                Rectangle()
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [headerColor.opacity(0.3), headerColor.opacity(0.6)]),
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    )

                Image(systemName: cardIcon)
                    .font(.system(size: 70))
                    .foregroundColor(.white.opacity(0.9))
            }
            .frame(height: 140)

            // Stats
            VStack(spacing: 8) {
                Text(localizedCardType)
                    .font(.caption)
                    .foregroundColor(.secondary)

                HStack(spacing: 20) {
                    if let health = card.health {
                        VStack(spacing: 2) {
                            Image(systemName: "heart.fill")
                                .font(.title3)
                                .foregroundColor(.red)
                            Text("\(health)")
                                .font(.headline)
                                .fontWeight(.bold)
                            Text(L10n.cardStatHealth.localized)
                                .font(.system(size: 9))
                                .foregroundColor(.secondary)
                        }
                    }
                    if let power = card.power {
                        VStack(spacing: 2) {
                            Image(systemName: "bolt.fill")
                                .font(.title3)
                                .foregroundColor(.orange)
                            Text("\(power)")
                                .font(.headline)
                                .fontWeight(.bold)
                            Text(L10n.cardStatStrength.localized)
                                .font(.system(size: 9))
                                .foregroundColor(.secondary)
                        }
                    }
                    if let defense = card.defense {
                        VStack(spacing: 2) {
                            Image(systemName: "shield.fill")
                                .font(.title3)
                                .foregroundColor(.blue)
                            Text("\(defense)")
                                .font(.headline)
                                .fontWeight(.bold)
                            Text(L10n.cardStatDefense.localized)
                                .font(.system(size: 9))
                                .foregroundColor(.secondary)
                        }
                    }
                }

                Circle()
                    .fill(rarityColor)
                    .frame(width: 6, height: 6)
            }
            .padding(.vertical, 10)
            .frame(maxWidth: .infinity)
            .background(Color(UIColor.secondarySystemBackground))
        }
        .frame(height: 280)
        .background(Color(UIColor.systemBackground))
        .cornerRadius(16)
        .shadow(color: isSelected ? headerColor.opacity(0.5) : .black.opacity(0.2), radius: isSelected ? 10 : 5)
        .overlay(
            RoundedRectangle(cornerRadius: 16)
                .stroke(isSelected ? headerColor : Color.clear, lineWidth: 3)
        )
        .scaleEffect(isSelected ? 1.05 : 1.0)
        .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isSelected)
        .onTapGesture {
            onTap?()
        }
    }

    var headerColor: Color {
        switch card.type {
        case .character: return Color.purple
        case .weapon: return Color.red
        case .spell: return Color.blue
        case .armor: return Color.gray
        case .item: return Color.brown
        case .ally: return Color.green
        case .blessing: return Color.yellow
        case .monster: return Color.red.opacity(0.8)
        case .location: return Color.teal
        case .scenario: return Color.indigo
        case .curse: return Color.black
        case .spirit: return Color.cyan
        case .artifact: return Color.orange
        case .ritual: return Color.indigo
        case .resource: return Color.green
        case .attack: return Color.red
        case .defense: return Color.blue
        case .special: return Color.purple
        }
    }

    var cardIcon: String {
        switch card.type {
        case .character: return "person.fill"
        case .weapon: return "bolt.fill"
        case .spell: return "sparkles"
        case .armor: return "shield.fill"
        case .item: return "bag.fill"
        case .ally: return "person.2.fill"
        case .blessing: return "star.fill"
        case .monster: return "flame.fill"
        case .location: return "mappin.and.ellipse"
        case .scenario: return "book.fill"
        case .curse: return "cloud.bolt.fill"
        case .spirit: return "cloud.moon.fill"
        case .artifact: return "crown.fill"
        case .ritual: return "book.closed.fill"
        case .resource: return "leaf.fill"
        case .attack: return "bolt.fill"
        case .defense: return "shield.fill"
        case .special: return "star.circle.fill"
        }
    }

    var localizedCardType: String {
        switch card.type {
        case .character: return L10n.cardTypeCharacter.localized
        case .weapon: return L10n.cardTypeWeapon.localized
        case .spell: return L10n.cardTypeSpell.localized
        case .armor: return L10n.cardTypeArmor.localized
        case .item: return L10n.cardTypeItem.localized
        case .ally: return L10n.cardTypeAlly.localized
        case .blessing: return L10n.cardTypeBlessing.localized
        case .monster: return L10n.cardTypeMonster.localized
        case .location: return L10n.cardTypeLocation.localized
        case .scenario: return card.type.rawValue.capitalized
        case .curse: return L10n.tmCardTypeCurse.localized
        case .spirit: return L10n.tmCardTypeSpirit.localized
        case .artifact: return L10n.tmCardTypeArtifact.localized
        case .ritual: return L10n.tmCardTypeRitual.localized
        case .resource: return L10n.cardTypeResource.localized
        case .attack: return L10n.cardTypeAttack.localized
        case .defense: return L10n.cardTypeDefense.localized
        case .special: return L10n.cardTypeSpecial.localized
        }
    }

    var rarityColor: Color {
        switch card.rarity {
        case .common: return .gray
        case .uncommon: return .green
        case .rare: return .blue
        case .epic: return .purple
        case .legendary: return .orange
        }
    }
}

// Very compact card view for player hand
struct HandCardView: View {
    let card: Card
    var isSelected: Bool = false
    var onTap: (() -> Void)?

    var body: some View {
        VStack(spacing: 0) {
            // Card name
            Text(card.name)
                .font(.system(size: 10))
                .fontWeight(.bold)
                .foregroundColor(.white)
                .lineLimit(1)
                .minimumScaleFactor(0.7)
                .frame(maxWidth: .infinity)
                .padding(.vertical, 3)
                .padding(.horizontal, 2)
                .background(headerColor)

            // Card icon
            ZStack {
                Rectangle()
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [headerColor.opacity(0.3), headerColor.opacity(0.6)]),
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    )

                Image(systemName: cardIcon)
                    .font(.system(size: 32))
                    .foregroundColor(.white.opacity(0.9))
            }
            .frame(height: 55)

            // Stats in vertical column
            VStack(spacing: 2) {
                if let cost = card.cost {
                    HStack(spacing: 2) {
                        Image(systemName: "star.fill")
                            .font(.system(size: 8))
                            .foregroundColor(.yellow)
                        Text("\(cost)")
                            .font(.system(size: 9))
                            .fontWeight(.bold)
                    }
                }
                if let power = card.power {
                    HStack(spacing: 2) {
                        Image(systemName: "bolt.fill")
                            .font(.system(size: 8))
                            .foregroundColor(.red)
                        Text("\(power)")
                            .font(.system(size: 9))
                            .fontWeight(.bold)
                    }
                }
                if let defense = card.defense {
                    HStack(spacing: 2) {
                        Image(systemName: "shield.fill")
                            .font(.system(size: 8))
                            .foregroundColor(.blue)
                        Text("\(defense)")
                            .font(.system(size: 9))
                            .fontWeight(.bold)
                    }
                }
            }
            .padding(.vertical, 3)
            .frame(maxWidth: .infinity)
            .background(Color(UIColor.secondarySystemBackground))
        }
        .frame(width: 85, height: 115)
        .background(Color(UIColor.systemBackground))
        .cornerRadius(8)
        .shadow(color: isSelected ? headerColor.opacity(0.6) : .black.opacity(0.2), radius: isSelected ? 6 : 3)
        .overlay(
            RoundedRectangle(cornerRadius: 8)
                .stroke(isSelected ? headerColor : Color.clear, lineWidth: 2)
        )
        .scaleEffect(isSelected ? 1.1 : 1.0)
        .animation(.spring(response: 0.2, dampingFraction: 0.7), value: isSelected)
        .onTapGesture {
            onTap?()
        }
    }

    var headerColor: Color {
        switch card.type {
        case .character: return Color.purple
        case .weapon: return Color.red
        case .spell: return Color.blue
        case .armor: return Color.gray
        case .item: return Color.brown
        case .ally: return Color.green
        case .blessing: return Color.yellow
        case .monster: return Color.red.opacity(0.8)
        case .location: return Color.teal
        case .scenario: return Color.indigo
        case .curse: return Color.black
        case .spirit: return Color.cyan
        case .artifact: return Color.orange
        case .ritual: return Color.indigo
        case .resource: return Color.green
        case .attack: return Color.red
        case .defense: return Color.blue
        case .special: return Color.purple
        }
    }

    var cardIcon: String {
        switch card.type {
        case .character: return "person.fill"
        case .weapon: return "bolt.fill"
        case .spell: return "sparkles"
        case .armor: return "shield.fill"
        case .item: return "bag.fill"
        case .ally: return "person.2.fill"
        case .blessing: return "star.fill"
        case .monster: return "flame.fill"
        case .location: return "mappin.and.ellipse"
        case .scenario: return "book.fill"
        case .curse: return "cloud.bolt.fill"
        case .spirit: return "cloud.moon.fill"
        case .artifact: return "crown.fill"
        case .ritual: return "book.closed.fill"
        case .resource: return "leaf.fill"
        case .attack: return "bolt.fill"
        case .defense: return "shield.fill"
        case .special: return "star.circle.fill"
        }
    }
}


// ==========================================
// FILE: Views/CombatView.swift
// ==========================================

import SwiftUI

/// Боевой экран - реализация по документации GAME_DESIGN_DOCUMENT.md
/// Цикл: PlayerTurn → EnemyTurn → EndTurn (повтор до победы/поражения)
/// Действия: 3 за ход. Играть карту = 1 действие, Атаковать = 1 действие
///
/// Engine-First Architecture (Gate 1 Compliant):
/// - All player mutations go through engine.performAction()
/// - UI reads state from engine properties
struct CombatView: View {
    // MARK: - Engine-First Architecture
    @ObservedObject var engine: TwilightGameEngine
    let onCombatEnd: (CombatOutcome) -> Void

    // MARK: - Legacy Support (for backwards compatibility during migration)
    // Will be removed after full migration
    private var legacyPlayer: Player?
    private var legacyMonster: Binding<Card>?

    enum CombatOutcome: Equatable {
        case victory(stats: CombatStats)
        case defeat(stats: CombatStats)
        case fled

        var isVictory: Bool {
            if case .victory = self { return true }
            return false
        }
    }

    struct CombatStats: Equatable {
        let turnsPlayed: Int
        let totalDamageDealt: Int
        let totalDamageTaken: Int
        let cardsPlayed: Int

        var summary: String {
            L10n.combatTurnsStats.localized(with: turnsPlayed, totalDamageDealt, totalDamageTaken)
        }
    }

    enum CombatPhase {
        case playerTurn
        case enemyTurn
        case endTurn
        case combatOver
    }

    @State private var phase: CombatPhase = .playerTurn
    @State private var turnNumber: Int = 1
    @State private var actionsRemaining: Int = 3
    @State private var combatLog: [String] = []
    @State private var lastMessage: String = ""
    @State private var showingMessage = false

    // Боевые бонусы (сбрасываются в конце хода/после атаки)
    @State private var bonusDice: Int = 0          // Дополнительные кубики от карт
    @State private var bonusDamage: Int = 0        // Бонусный урон
    @State private var canReroll: Bool = false     // Возможность перебросить кубик
    @State private var summonedSpirits: [(power: Int, realm: Realm)] = []  // Призванные духи
    @State private var isFirstAttackThisCombat: Bool = true  // Для способности Следопыта
    @State private var lastCombatResult: CombatResult? = nil  // Последний результат атаки

    // NEW: Temporary Shield (защита от карт, поглощает урон, сбрасывается в конце раунда)
    @State private var temporaryShield: Int = 0

    // Combat statistics tracking
    @State private var totalDamageDealt: Int = 0
    @State private var totalDamageTaken: Int = 0
    @State private var cardsPlayedCount: Int = 0

    // Combat end state (for victory/defeat screen)
    @State private var finalCombatStats: CombatStats? = nil
    @State private var isVictory: Bool = false
    @State private var defeatedMonsterName: String = ""  // Saved before combat ends for UI
    @State private var savedMonsterCard: Card? = nil     // Saved monster for display after combat ends

    // Dice roll animation state
    @State private var showDiceRollOverlay: Bool = false
    @State private var animatingDiceValues: [Int] = []
    @State private var diceAnimationPhase: Int = 0

    // MARK: - Computed Properties (Engine-First)

    /// Player from engine or legacy
    private var player: Player? {
        // In Engine-First mode, use engine's legacyPlayer
        // Fall back to stored legacyPlayer for backwards compatibility
        engine.legacyPlayer ?? legacyPlayer
    }

    /// Monster from engine combat state or legacy binding
    /// Uses savedMonsterCard when combat is over to avoid "Unknown" display
    private var monster: Card {
        get {
            // After combat ends, use saved monster card to display correct info
            if phase == .combatOver, let saved = savedMonsterCard {
                return saved
            }
            return engine.combatState?.enemy ?? legacyMonster?.wrappedValue ?? savedMonsterCard ?? Card(
                name: "Unknown",
                type: .monster,
                description: "Unknown enemy"
            )
        }
    }

    /// Monster health from engine
    private var monsterHealth: Int {
        engine.combatState?.enemyHealth ?? monster.health ?? 10
    }

    // MARK: - Initialization (Engine-First)

    init(engine: TwilightGameEngine, onCombatEnd: @escaping (CombatOutcome) -> Void) {
        self.engine = engine
        self.onCombatEnd = onCombatEnd
        self.legacyPlayer = nil
        self.legacyMonster = nil
    }

    // MARK: - Legacy Initialization (for backwards compatibility)

    init(player: Player, monster: Binding<Card>, onCombatEnd: @escaping (CombatOutcome) -> Void) {
        // Create engine connected to legacy player
        let newEngine = TwilightGameEngine()
        // Setup combat enemy in engine
        newEngine.setupCombatEnemy(monster.wrappedValue)
        self.engine = newEngine
        self.onCombatEnd = onCombatEnd
        self.legacyPlayer = player
        self.legacyMonster = monster
    }

    var body: some View {
        VStack(spacing: 0) {
            // Hero Panel (persistent, consistent design)
            HeroPanel(engine: engine, compact: true, showAvatar: true)
                .padding(.horizontal, 8)
                .padding(.top, 4)

            // Верхняя панель
            combatHeader

            // Основная область боя
            ScrollView {
                VStack(spacing: 16) {
                    // Монстр
                    monsterCard

                    // VS разделитель
                    vsIndicator

                    // Игрок
                    playerStats

                    // Инструкции и действия
                    if phase == .playerTurn {
                        playerTurnControls
                    } else if phase == .enemyTurn {
                        enemyTurnView
                    } else if phase == .endTurn {
                        endTurnView
                    } else if phase == .combatOver {
                        combatOverView
                    }

                    // Лог боя
                    combatLogView
                }
                .padding()
            }

            Divider()

            // Рука игрока
            playerHandView
        }
        .background(Color(UIColor.systemBackground))
        .accessibilityIdentifier(AccessibilityIdentifiers.Combat.view)
        .overlay {
            // Dice roll animation overlay
            if showDiceRollOverlay {
                diceRollOverlay
            }
        }
        .alert(L10n.combatTitle.localized, isPresented: $showingMessage) {
            Button(L10n.buttonOk.localized) { }
        } message: {
            Text(lastMessage)
        }
        .onAppear {
            startCombat()
        }
    }

    // MARK: - Header

    var combatHeader: some View {
        HStack {
            // Ход и фаза
            VStack(alignment: .leading, spacing: 2) {
                Text(L10n.combatTurnNumber.localized(with: turnNumber))
                    .font(.headline)
                Text(phaseText)
                    .font(.subheadline)
                    .foregroundColor(phaseColor)
            }

            Spacer()

            // Действия (показываем только в ход игрока)
            if phase == .playerTurn {
                HStack(spacing: 6) {
                    ForEach(0..<3, id: \.self) { i in
                        Circle()
                            .fill(i < actionsRemaining ? Color.orange : Color.gray.opacity(0.3))
                            .frame(width: 16, height: 16)
                    }
                }

                Text("\(actionsRemaining)/3")
                    .font(.headline)
                    .foregroundColor(.orange)
                    .padding(.leading, 4)
            }

            Spacer()

            // Кнопка побега
            Button(action: flee) {
                HStack(spacing: 4) {
                    Image(systemName: "figure.run")
                    Text(L10n.combatFleeButton.localized)
                        .font(.caption)
                }
                .foregroundColor(.gray)
                .padding(.horizontal, 12)
                .padding(.vertical, 6)
                .background(Color.gray.opacity(0.2))
                .cornerRadius(8)
            }
            .disabled(phase != .playerTurn)
        }
        .padding()
        .background(Color(UIColor.secondarySystemBackground))
    }

    // MARK: - Monster Card

    var monsterCard: some View {
        VStack(spacing: 8) {
            Text(monster.name)
                .font(.title2)
                .fontWeight(.bold)
                .foregroundColor(.red)

            HStack(spacing: 32) {
                // HP монстра (Engine-First: read from engine.combatState)
                VStack {
                    Image(systemName: "heart.fill")
                        .font(.title)
                        .foregroundColor(.red)
                    Text("\(monsterHealth)")
                        .font(.title)
                        .fontWeight(.bold)
                    Text(L10n.combatHP.localized)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }

                // Атака монстра
                VStack {
                    Image(systemName: "burst.fill")
                        .font(.title)
                        .foregroundColor(.orange)
                    Text("\(monster.power ?? 3)")
                        .font(.title)
                        .fontWeight(.bold)
                    Text(L10n.combatAttack.localized)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }

                // Защита монстра
                VStack {
                    Image(systemName: "shield.fill")
                        .font(.title)
                        .foregroundColor(.blue)
                    Text("\(monster.defense ?? 10)")
                        .font(.title)
                        .fontWeight(.bold)
                    Text(L10n.combatDefense.localized)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
        }
        .padding()
        .frame(maxWidth: .infinity)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.red.opacity(0.1))
                .overlay(
                    RoundedRectangle(cornerRadius: 12)
                        .stroke(Color.red, lineWidth: 2)
                )
        )
    }

    var vsIndicator: some View {
        HStack {
            Rectangle().fill(Color.red.opacity(0.5)).frame(height: 2)
            Text("⚔️ VS ⚔️")
                .font(.headline)
                .padding(.horizontal, 8)
            Rectangle().fill(Color.red.opacity(0.5)).frame(height: 2)
        }
    }

    // MARK: - Player Stats (Engine-First: reads from engine.player*)

    var playerStats: some View {
        VStack(spacing: 8) {
            // Main stats row
            HStack(spacing: 20) {
                VStack {
                    Image(systemName: "heart.fill")
                        .foregroundColor(.red)
                    Text("\(engine.playerHealth)/\(engine.playerMaxHealth)")
                        .fontWeight(.bold)
                    Text(L10n.combatHP.localized)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }

                VStack {
                    Image(systemName: "hand.raised.fill")
                        .foregroundColor(.orange)
                    Text("\(player?.strength ?? 1)")
                        .fontWeight(.bold)
                    Text(L10n.combatStrength.localized)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }

                VStack {
                    Image(systemName: "sparkles")
                        .foregroundColor(.yellow)
                    Text("\(engine.playerFaith)")
                        .fontWeight(.bold)
                    Text(L10n.tmResourceFaith.localized)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }

                // NEW: Shield display
                if temporaryShield > 0 {
                    VStack {
                        Image(systemName: "shield.fill")
                            .foregroundColor(.cyan)
                        Text("\(temporaryShield)")
                            .fontWeight(.bold)
                        Text(L10n.combatShield.localized)
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
            }

            // Combat bonuses indicator (if any)
            if bonusDice > 0 || bonusDamage > 0 {
                HStack(spacing: 12) {
                    if bonusDice > 0 {
                        HStack(spacing: 4) {
                            Image(systemName: "dice.fill")
                                .foregroundColor(.purple)
                            Text("+\(bonusDice)")
                                .font(.caption)
                                .fontWeight(.bold)
                                .foregroundColor(.purple)
                        }
                    }
                    if bonusDamage > 0 {
                        HStack(spacing: 4) {
                            Image(systemName: "flame.fill")
                                .foregroundColor(.orange)
                            Text("+\(bonusDamage)")
                                .font(.caption)
                                .fontWeight(.bold)
                                .foregroundColor(.orange)
                        }
                    }
                }
                .padding(.horizontal, 8)
                .padding(.vertical, 4)
                .background(Color.purple.opacity(0.1))
                .cornerRadius(8)
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.blue.opacity(0.1))
        )
    }

    // MARK: - Player Turn Controls

    var playerTurnControls: some View {
        VStack(spacing: 16) {
            // Инструкция
            VStack(spacing: 4) {
                Text(L10n.combatPlayerTurn.localized)
                    .font(.headline)
                    .foregroundColor(.green)

                if actionsRemaining > 0 {
                    Text(L10n.combatActionsRemaining.localized(with: actionsRemaining))
                        .font(.subheadline)
                    Text(L10n.combatTapToPlay.localized)
                        .font(.caption)
                        .foregroundColor(.secondary)
                } else {
                    Text(L10n.combatActionsRemaining.localized(with: 0))
                        .font(.subheadline)
                        .foregroundColor(.orange)
                    Text(L10n.combatEndTurnButton.localized)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            .padding()
            .frame(maxWidth: .infinity)
            .background(Color.green.opacity(0.1))
            .cornerRadius(12)

            // Кнопки действий (каждое действие тратит 1 из 3)
            HStack(spacing: 8) {
                // Базовая атака
                Button(action: performBasicAttack) {
                    VStack(spacing: 4) {
                        Image(systemName: "hand.raised.fill")
                            .font(.title2)
                        Text(L10n.combatAttackButton.localized)
                            .font(.caption)
                            .fontWeight(.semibold)
                        // Show accumulated bonuses
                        if bonusDamage > 0 || bonusDice > 0 {
                            Text("+\(bonusDamage)💥 +\(bonusDice)🎲")
                                .font(.system(size: 9))
                                .foregroundColor(.yellow)
                        } else {
                            Text(L10n.combatActionCost.localized)
                                .font(.system(size: 9))
                                .foregroundColor(.white.opacity(0.7))
                        }
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(actionsRemaining > 0 ? Color.orange : Color.gray)
                    .foregroundColor(.white)
                    .cornerRadius(12)
                }
                .disabled(actionsRemaining <= 0)
                .accessibilityIdentifier(AccessibilityIdentifiers.Combat.attackButton)

                // NEW: Укрытие (Defend/Take Cover)
                Button(action: performDefend) {
                    VStack(spacing: 4) {
                        Image(systemName: "shield.fill")
                            .font(.title2)
                        Text(L10n.combatDefend.localized)
                            .font(.caption)
                            .fontWeight(.semibold)
                        Text("+3🛡️ (-1)")
                            .font(.system(size: 9))
                            .foregroundColor(.white.opacity(0.7))
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(actionsRemaining > 0 ? Color.cyan : Color.gray)
                    .foregroundColor(.white)
                    .cornerRadius(12)
                }
                .disabled(actionsRemaining <= 0)

                // Завершить ход
                Button(action: endPlayerTurn) {
                    VStack(spacing: 4) {
                        Image(systemName: "arrow.right.circle.fill")
                            .font(.title2)
                        Text(L10n.combatEndTurnButton.localized)
                            .font(.caption)
                            .fontWeight(.semibold)
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.purple)
                    .foregroundColor(.white)
                    .cornerRadius(12)
                }
                .accessibilityIdentifier(AccessibilityIdentifiers.Combat.endTurnButton)
            }
            .accessibilityIdentifier(AccessibilityIdentifiers.Combat.actionBar)
        }
    }

    // MARK: - Enemy Turn View

    var enemyTurnView: some View {
        VStack(spacing: 12) {
            Text(L10n.combatEnemyTurn.localized)
                .font(.headline)
                .foregroundColor(.red)

            HStack {
                Image(systemName: "burst.fill")
                    .foregroundColor(.red)
                Text(L10n.combatLogEnemyAttacks.localized(with: monster.name))
            }

            ProgressView()
                .progressViewStyle(CircularProgressViewStyle(tint: .red))
        }
        .padding()
        .frame(maxWidth: .infinity)
        .background(Color.red.opacity(0.1))
        .cornerRadius(12)
        .onAppear {
            performEnemyAttack()
        }
    }

    // MARK: - End Turn View

    var endTurnView: some View {
        VStack(spacing: 12) {
            Text(L10n.combatEndTurn.localized)
                .font(.headline)
                .foregroundColor(.purple)

            ProgressView()
                .progressViewStyle(CircularProgressViewStyle(tint: .purple))
        }
        .padding()
        .frame(maxWidth: .infinity)
        .background(Color.purple.opacity(0.1))
        .cornerRadius(12)
        .onAppear {
            performEndTurn()
        }
    }

    // MARK: - Combat Over View (Full-screen victory/defeat display)
    // Player must tap "Continue" to dismiss - no auto-dismiss

    var combatOverView: some View {
        VStack(spacing: 24) {
            Spacer()

            // Victory/Defeat Icon and Title
            if isVictory {
                VStack(spacing: 12) {
                    Text("🎉")
                        .font(.system(size: 72))

                    Text(L10n.combatVictory.localized)
                        .font(.largeTitle)
                        .fontWeight(.bold)
                        .foregroundColor(.green)

                    Text(L10n.combatMonsterDefeated.localized(with: defeatedMonsterName))
                        .font(.title3)
                        .foregroundColor(.secondary)
                }
            } else {
                VStack(spacing: 12) {
                    Text("💀")
                        .font(.system(size: 72))

                    Text(L10n.combatDefeat.localized)
                        .font(.largeTitle)
                        .fontWeight(.bold)
                        .foregroundColor(.red)

                    Text(L10n.combatFallen.localized)
                        .font(.title3)
                        .foregroundColor(.secondary)
                }
            }

            // Combat Statistics
            if let stats = finalCombatStats {
                VStack(spacing: 16) {
                    Text("📊 " + L10n.combatLogTitle.localized)
                        .font(.headline)
                        .foregroundColor(.primary)

                    HStack(spacing: 32) {
                        // Turns
                        VStack {
                            Text("\(stats.turnsPlayed)")
                                .font(.title)
                                .fontWeight(.bold)
                                .foregroundColor(.blue)
                            Text(L10n.combatStatsTurns.localized)
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }

                        // Damage dealt
                        VStack {
                            Text("\(stats.totalDamageDealt)")
                                .font(.title)
                                .fontWeight(.bold)
                                .foregroundColor(.orange)
                            Text(L10n.combatStatsDamageDealt.localized)
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }

                        // Damage taken
                        VStack {
                            Text("\(stats.totalDamageTaken)")
                                .font(.title)
                                .fontWeight(.bold)
                                .foregroundColor(.red)
                            Text(L10n.combatStatsDamageTaken.localized)
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }

                        // Cards played
                        VStack {
                            Text("\(stats.cardsPlayed)")
                                .font(.title)
                                .fontWeight(.bold)
                                .foregroundColor(.purple)
                            Text(L10n.combatStatsCardsPlayed.localized)
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                    }
                }
                .padding()
                .background(Color(UIColor.secondarySystemBackground))
                .cornerRadius(12)
            }

            Spacer()

            // Continue Button - player controls when to dismiss
            Button(action: {
                let stats = finalCombatStats ?? CombatStats(
                    turnsPlayed: turnNumber,
                    totalDamageDealt: totalDamageDealt,
                    totalDamageTaken: totalDamageTaken,
                    cardsPlayed: cardsPlayedCount
                )
                let outcome: CombatOutcome = isVictory ? .victory(stats: stats) : .defeat(stats: stats)
                onCombatEnd(outcome)
            }) {
                HStack {
                    Image(systemName: isVictory ? "arrow.right.circle.fill" : "arrow.counterclockwise.circle.fill")
                    Text(isVictory ? L10n.combatContinue.localized : L10n.combatReturn.localized)
                }
                .font(.title2)
                .fontWeight(.semibold)
                .foregroundColor(.white)
                .frame(maxWidth: .infinity)
                .padding()
                .background(isVictory ? Color.green : Color.blue)
                .cornerRadius(12)
            }
            .padding(.horizontal)
            .padding(.bottom, 32)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(
            LinearGradient(
                gradient: Gradient(colors: isVictory
                    ? [Color.green.opacity(0.1), Color.black.opacity(0.3)]
                    : [Color.red.opacity(0.1), Color.black.opacity(0.3)]),
                startPoint: .top,
                endPoint: .bottom
            )
        )
    }

    // MARK: - Combat Log

    var combatLogView: some View {
        VStack(alignment: .leading, spacing: 8) {
            // Детальный результат последней атаки
            if let result = lastCombatResult {
                combatResultDetailView(result)
            }

            // Журнал боя
            VStack(alignment: .leading, spacing: 4) {
                Text("📜 " + L10n.combatLogTitle.localized)
                    .font(.caption)
                    .fontWeight(.bold)
                    .foregroundColor(.secondary)

                ForEach(Array(combatLog.suffix(5).enumerated()), id: \.offset) { index, entry in
                    Text("• \(entry)")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                }
            }
            .frame(maxWidth: .infinity, alignment: .leading)
            .padding()
            .background(Color(UIColor.tertiarySystemBackground))
            .cornerRadius(8)
        }
    }

    /// Детальный вид результата атаки
    func combatResultDetailView(_ result: CombatResult) -> some View {
        VStack(alignment: .leading, spacing: 6) {
            // Заголовок попадание/промах
            HStack {
                Text(result.isHit ? L10n.combatHitResult.localized : L10n.combatMissResult.localized)
                    .font(.headline)
                    .fontWeight(.bold)
                    .foregroundColor(result.isHit ? .green : .red)

                Spacer()

                // Общий результат
                Text(L10n.combatAttackVsDefense.localized(with: result.attackRoll.total, result.defenseValue))
                    .font(.caption)
                    .foregroundColor(.secondary)
            }

            Divider()

            // Разбивка броска атаки
            VStack(alignment: .leading, spacing: 2) {
                Text(L10n.combatAttackRollTitle.localized)
                    .font(.caption)
                    .fontWeight(.semibold)

                HStack(spacing: 4) {
                    Text("💪 \(result.attackRoll.baseStrength)")
                        .font(.caption2)

                    Text("+")
                        .font(.caption2)
                        .foregroundColor(.secondary)

                    // Кубики
                    ForEach(result.attackRoll.diceRolls.indices, id: \.self) { index in
                        diceView(result.attackRoll.diceRolls[index])
                    }

                    if result.attackRoll.bonusDamage > 0 {
                        Text("+ \(result.attackRoll.bonusDamage)")
                            .font(.caption2)
                            .foregroundColor(.orange)
                    }

                    Text("= \(result.attackRoll.total)")
                        .font(.caption)
                        .fontWeight(.bold)
                }

                // Модификаторы атаки
                ForEach(result.attackRoll.modifiers.indices, id: \.self) { index in
                    let modifier = result.attackRoll.modifiers[index]
                    Text("\(modifier.icon) \(modifier.description)")
                        .font(.caption2)
                        .foregroundColor(.blue)
                }
            }

            // Расчёт урона (если попадание)
            if result.isHit, let damage = result.damageCalculation {
                Divider()

                VStack(alignment: .leading, spacing: 2) {
                    Text(L10n.combatDamageCalcTitle.localized)
                        .font(.caption)
                        .fontWeight(.semibold)

                    HStack {
                        Text(L10n.combatBaseValue.localized(with: damage.base))
                            .font(.caption2)

                        ForEach(damage.modifiers.indices, id: \.self) { index in
                            let mod = damage.modifiers[index]
                            Text("\(mod.value > 0 ? "+" : "")\(mod.value)")
                                .font(.caption2)
                                .foregroundColor(mod.value > 0 ? .green : .red)
                        }

                        Text("= \(damage.total) 💥")
                            .font(.caption)
                            .fontWeight(.bold)
                            .foregroundColor(.red)
                    }

                    // Детализация модификаторов урона
                    ForEach(damage.modifiers.indices, id: \.self) { index in
                        let modifier = damage.modifiers[index]
                        HStack(spacing: 4) {
                            Text(modifier.icon)
                            Text(modifier.description)
                            Text("\(modifier.value > 0 ? "+" : "")\(modifier.value)")
                                .foregroundColor(modifier.value > 0 ? .green : .red)
                        }
                        .font(.caption2)
                    }
                }
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(result.isHit ? Color.green.opacity(0.1) : Color.red.opacity(0.1))
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(result.isHit ? Color.green : Color.red, lineWidth: 1)
                )
        )
    }

    /// Вид кубика
    func diceView(_ value: Int) -> some View {
        ZStack {
            RoundedRectangle(cornerRadius: 4)
                .fill(Color.white)
                .frame(width: 24, height: 24)
                .shadow(radius: 1)

            Text("\(value)")
                .font(.caption)
                .fontWeight(.bold)
                .foregroundColor(value >= 5 ? .green : value <= 2 ? .red : .black)
        }
    }

    // MARK: - Dice Roll Overlay

    /// Prominent dice roll animation overlay
    var diceRollOverlay: some View {
        ZStack {
            // Semi-transparent background
            Color.black.opacity(0.6)
                .ignoresSafeArea()

            VStack(spacing: 20) {
                // Title
                Text(L10n.combatDiceRoll.localized)
                    .font(.title2)
                    .fontWeight(.bold)
                    .foregroundColor(.white)

                // Animated dice
                HStack(spacing: 16) {
                    ForEach(animatingDiceValues.indices, id: \.self) { index in
                        animatedDiceView(value: animatingDiceValues[index], index: index)
                    }
                }
                .padding()

                // Result display (after animation completes)
                if let result = lastCombatResult, diceAnimationPhase >= 3 {
                    VStack(spacing: 12) {
                        // Attack total
                        HStack(spacing: 8) {
                            Text("💪 \(result.attackRoll.baseStrength)")
                                .foregroundColor(.cyan)
                            Text("+")
                                .foregroundColor(.white)
                            Text("🎲 \(result.attackRoll.diceTotal)")
                                .foregroundColor(.yellow)
                            if result.attackRoll.bonusDamage > 0 {
                                Text("+")
                                    .foregroundColor(.white)
                                Text("⚔️ \(result.attackRoll.bonusDamage)")
                                    .foregroundColor(.orange)
                            }
                            Text("=")
                                .foregroundColor(.white)
                            Text("\(result.attackRoll.total)")
                                .font(.title)
                                .fontWeight(.bold)
                                .foregroundColor(.white)
                        }
                        .font(.headline)

                        // VS Defense
                        HStack(spacing: 8) {
                            Text("vs")
                                .foregroundColor(.gray)
                            Text(L10n.combatDefenseValue.localized(with: result.defenseValue))
                                .foregroundColor(.blue)
                        }
                        .font(.subheadline)

                        // Hit/Miss result
                        if result.isHit {
                            VStack(spacing: 4) {
                                Text(L10n.combatHitResult.localized)
                                    .font(.title)
                                    .fontWeight(.bold)
                                    .foregroundColor(.green)

                                if let damage = result.damageCalculation {
                                    Text(L10n.combatDamageValue.localized(with: damage.total))
                                        .font(.headline)
                                        .foregroundColor(.red)
                                }
                            }
                        } else {
                            Text(L10n.combatMissResult.localized)
                                .font(.title)
                                .fontWeight(.bold)
                                .foregroundColor(.red)
                        }
                    }
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: 12)
                            .fill(Color.black.opacity(0.8))
                    )
                    .transition(.scale.combined(with: .opacity))
                }
            }
        }
        .onTapGesture {
            // Allow dismissing overlay by tapping
            withAnimation(.easeOut(duration: 0.2)) {
                showDiceRollOverlay = false
            }
        }
    }

    /// Single animated dice
    func animatedDiceView(value: Int, index: Int) -> some View {
        ZStack {
            // Dice background
            RoundedRectangle(cornerRadius: 8)
                .fill(Color.white)
                .frame(width: 60, height: 60)
                .shadow(color: .black.opacity(0.3), radius: 4, x: 2, y: 2)

            // Dice value
            Text("\(value)")
                .font(.system(size: 32, weight: .bold, design: .rounded))
                .foregroundColor(value >= 5 ? .green : value <= 2 ? .red : .black)
        }
        .scaleEffect(diceAnimationPhase >= 2 ? 1.0 : 1.2)
        .rotationEffect(.degrees(diceAnimationPhase >= 2 ? 0 : Double(index * 30)))
        .animation(
            .spring(response: 0.3, dampingFraction: 0.6),
            value: diceAnimationPhase
        )
    }

    /// Trigger dice roll animation
    func showDiceAnimation(diceRolls: [Int]) {
        // Start with random values
        animatingDiceValues = diceRolls.map { _ in Int.random(in: 1...6) }
        diceAnimationPhase = 0

        withAnimation(.easeIn(duration: 0.1)) {
            showDiceRollOverlay = true
        }

        // Animation sequence: roll several times then show final result
        let rollDuration = 0.1

        // Roll 1
        DispatchQueue.main.asyncAfter(deadline: .now() + rollDuration) {
            animatingDiceValues = diceRolls.map { _ in Int.random(in: 1...6) }
            diceAnimationPhase = 1
        }

        // Roll 2
        DispatchQueue.main.asyncAfter(deadline: .now() + rollDuration * 2) {
            animatingDiceValues = diceRolls.map { _ in Int.random(in: 1...6) }
        }

        // Roll 3
        DispatchQueue.main.asyncAfter(deadline: .now() + rollDuration * 3) {
            animatingDiceValues = diceRolls.map { _ in Int.random(in: 1...6) }
        }

        // Final result
        DispatchQueue.main.asyncAfter(deadline: .now() + rollDuration * 4) {
            withAnimation(.spring(response: 0.4, dampingFraction: 0.7)) {
                animatingDiceValues = diceRolls
                diceAnimationPhase = 2
            }
        }

        // Show hit/miss result
        DispatchQueue.main.asyncAfter(deadline: .now() + rollDuration * 4 + 0.3) {
            withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                diceAnimationPhase = 3
            }
        }

        // Auto-dismiss after showing result
        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
            withAnimation(.easeOut(duration: 0.3)) {
                showDiceRollOverlay = false
            }
        }
    }

    // MARK: - Player Hand (Engine-First)

    /// Player's hand cards - use engine's published playerHand for proper UI updates
    private var playerHand: [Card] {
        // Engine-First: prefer engine.playerHand for proper @Published reactivity
        // Fall back to legacy player.hand if engine doesn't have cards yet
        if !engine.playerHand.isEmpty {
            return engine.playerHand
        }
        return player?.hand ?? []
    }

    var playerHandView: some View {
        VStack(spacing: 4) {
            HStack {
                Text("🃏 " + L10n.combatYourHand.localized + " (\(playerHand.count))")
                    .font(.caption)
                    .foregroundColor(.secondary)

                Spacer()

                if phase == .playerTurn && actionsRemaining > 0 {
                    Text(L10n.combatTapToPlay.localized)
                        .font(.system(size: 10))
                        .foregroundColor(.green)
                }
            }
            .padding(.horizontal)

            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 8) {
                    ForEach(playerHand) { card in
                        CombatCardView(
                            card: card,
                            canPlay: actionsRemaining > 0 && phase == .playerTurn
                        ) {
                            playCard(card)
                        }
                    }
                }
                .padding(.horizontal)
            }
        }
        .frame(height: 150)
        .background(Color(UIColor.secondarySystemBackground))
    }

    // MARK: - Combat Logic (Engine-First: uses engine.performAction())

    func startCombat() {
        // Save monster card for display after combat ends
        savedMonsterCard = engine.combatState?.enemy ?? legacyMonster?.wrappedValue

        combatLog.append(L10n.combatLogBattleStartEnemy.localized(with: monster.name))
        combatLog.append(L10n.combatLogActionsInfo.localized(with: 3))

        // Engine-First: Initialize combat through engine
        engine.performAction(.combatInitialize)

        // Legacy fallback for deck operations
        if let p = player {
            p.shuffleDeck()
            p.drawCards(count: p.maxHandSize)
            // Sync engine's playerHand after legacy deck operations
            engine.syncPlayerHand()
        }

        actionsRemaining = 3
        phase = .playerTurn
    }

    func performBasicAttack() {
        guard actionsRemaining > 0 else { return }

        actionsRemaining -= 1

        let monsterDef = monster.defense ?? 10
        let monsterCurrentHP = monsterHealth
        let monsterMaxHP = monster.health ?? 10

        // Используем CombatCalculator для расчёта атаки
        guard let p = player else { return }
        let result = CombatCalculator.calculatePlayerAttack(
            player: p,
            monsterDefense: monsterDef,
            monsterCurrentHP: monsterCurrentHP,
            monsterMaxHP: monsterMaxHP,
            bonusDice: bonusDice,
            bonusDamage: bonusDamage,
            isFirstAttack: isFirstAttackThisCombat
        )

        // Сохраняем результат для отображения
        lastCombatResult = result

        // Show dice roll animation
        showDiceAnimation(diceRolls: result.attackRoll.diceRolls)

        if result.isHit, let damageCalc = result.damageCalculation {
            let damage = damageCalc.total

            // Track damage for statistics
            totalDamageDealt += damage

            // Engine-First: Apply damage through engine action
            engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: damage)))

            // Update legacy monster binding if available
            legacyMonster?.wrappedValue.health = monsterHealth

            combatLog.append(L10n.combatLogHit.localized(with: result.attackRoll.total, monsterDef, damage, monsterHealth))

            if monsterHealth <= 0 {
                finishCombat(victory: true)
            }
        } else {
            combatLog.append(L10n.combatLogMissed.localized(with: result.attackRoll.total, monsterDef))
        }

        // Сбросить бонусы после атаки
        bonusDice = 0
        bonusDamage = 0
        isFirstAttackThisCombat = false
    }

    /// Take Cover / Defend action - adds shield to absorb damage
    func performDefend() {
        guard actionsRemaining > 0 else { return }

        actionsRemaining -= 1

        // Base defend gives +3 shield
        let baseShield = 3

        // Player strength adds to defense (some classes may have bonus)
        let strengthBonus = (player?.strength ?? 1) / 2  // Half strength as shield bonus

        let totalShield = baseShield + strengthBonus
        temporaryShield += totalShield

        combatLog.append(L10n.combatLogCover.localized(with: totalShield, temporaryShield))

        // Log breakdown
        if strengthBonus > 0 {
            combatLog.append(L10n.combatLogStrengthBonus.localized(with: strengthBonus))
        }
    }

    /// Play a card as a modifier (does NOT consume actions)
    /// Cards enhance the next action (attack) or add to shield (defense)
    func playCard(_ card: Card) {
        guard phase == .playerTurn else { return }

        // Проверяем стоимость веры (Engine-First: check via engine)
        // Cards cost Faith to play - this limits infinite card usage
        let faithCost = card.cost ?? 0
        if faithCost > 0 {
            guard engine.playerFaith >= faithCost else {
                combatLog.append(L10n.combatLogInsufficientFaith.localized(with: card.name, faithCost, engine.playerFaith))
                return
            }
            // Engine-First: Spend faith through engine action
            engine.performAction(.combatApplyEffect(effect: .spendFaith(amount: faithCost)))
            combatLog.append(L10n.combatLogFaithSpent.localized(with: faithCost))
        }

        // Track cards played for statistics
        cardsPlayedCount += 1

        // Legacy: play card from hand (remove from hand)
        player?.playCard(card)

        // Sync engine's playerHand with legacy player (for @Published reactivity)
        engine.syncPlayerHand()

        // NEW: Cards are modifiers, not actions
        // Defense cards add to temporary shield
        // Attack cards add to bonus damage/dice
        switch card.type {
        case .defense, .armor:
            // Defense cards add to temporary shield
            let shieldValue = card.defense ?? card.power ?? 2
            temporaryShield += shieldValue
            combatLog.append(L10n.combatLogShieldCard.localized(with: card.name, shieldValue, temporaryShield))

        case .attack, .weapon:
            // Attack cards add bonus damage
            let attackBonus = card.power ?? 2
            bonusDamage += attackBonus
            combatLog.append(L10n.combatLogAttackBonus.localized(with: card.name, attackBonus))

        case .spell, .ritual:
            // Spells apply their effects
            combatLog.append(L10n.combatLogSpellCast.localized(with: card.name))
            applyCardEffects(card)

        default:
            // Other cards (items, etc.) apply their effects
            combatLog.append(L10n.combatLogCardPlayed.localized(with: card.name))
            applyCardEffects(card)
        }

        // Apply card abilities (on top of type-based effects)
        if card.type != .spell && card.type != .ritual {
            applyCardEffects(card)
        }

        // Проверяем победу (Engine-First: read from engine)
        if monsterHealth <= 0 {
            finishCombat(victory: true)
        }
    }

    func applyCardEffects(_ card: Card) {
        for ability in card.abilities {
            switch ability.effect {
            case .heal(let amount):
                // Engine-First: Heal through engine action
                engine.performAction(.combatApplyEffect(effect: .heal(amount: amount)))
                combatLog.append(L10n.combatLogHealEffect.localized(with: amount))

            case .damage(let amount, _):
                let actualDamage = player?.calculateDamageDealt(amount) ?? amount
                // Engine-First: Damage enemy through engine action
                engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: actualDamage)))
                legacyMonster?.wrappedValue.health = monsterHealth
                combatLog.append(L10n.combatLogDamageEffect.localized(with: actualDamage, monsterHealth))

            case .drawCards(let count):
                // Engine-First: Draw cards through engine action
                engine.performAction(.combatApplyEffect(effect: .drawCards(count: count)))
                player?.drawCards(count: count)  // Legacy sync
                engine.syncPlayerHand()  // Sync for UI reactivity
                combatLog.append(L10n.combatLogDrawCards.localized(with: count))

            case .gainFaith(let amount):
                // Engine-First: Gain faith through engine action
                engine.performAction(.combatApplyEffect(effect: .gainFaith(amount: amount)))
                combatLog.append(L10n.combatLogFaithGained.localized(with: amount))

            case .removeCurse(let type):
                // Engine-First: Remove curse through engine action (convert CurseType to String)
                engine.performAction(.combatApplyEffect(effect: .removeCurse(type: type?.rawValue)))
                combatLog.append(L10n.combatLogCurseRemoved.localized)

            case .addDice(let count):
                // Engine-First: Add bonus dice through engine action
                engine.performAction(.combatApplyEffect(effect: .addBonusDice(count: count)))
                bonusDice += count  // Local tracking for UI
                combatLog.append(L10n.combatLogBonusDice.localized(with: count))

            case .reroll:
                // Reroll даёт +1 кубик (выбирается лучший результат)
                engine.performAction(.combatApplyEffect(effect: .addBonusDice(count: 1)))
                bonusDice += 1
                combatLog.append(L10n.combatLogReroll.localized)

            case .shiftBalance(let towards, let amount):
                // Engine-First: Shift balance through engine action
                let directionString = towards == .light ? "light" : towards == .dark ? "dark" : "equilibrium"
                engine.performAction(.combatApplyEffect(effect: .shiftBalance(towards: directionString, amount: amount)))
                let directionText = towards == .light ? L10n.balanceLight.localized : towards == .dark ? L10n.balanceDark.localized : L10n.balanceNeutral.localized
                combatLog.append(L10n.combatLogBalanceShift.localized(with: directionText, amount))

            case .applyCurse(let curseType, let duration):
                // В бою проклятие наносит урон монстру (тёмная магия)
                let curseDamage = duration * 2
                // Engine-First: Damage enemy through engine action
                engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: curseDamage)))
                legacyMonster?.wrappedValue.health = monsterHealth
                combatLog.append(L10n.combatLogCurseDamage.localized(with: curseType.rawValue, curseDamage))

            case .summonSpirit(let power, let realm):
                summonedSpirits.append((power: power, realm: realm))
                let realmName = realm == .yav ? L10n.realmYav.localized : realm == .nav ? L10n.realmNav.localized : L10n.realmPrav.localized
                let realmString = realm == .yav ? "yav" : realm == .nav ? "nav" : "prav"
                combatLog.append(L10n.combatLogSpiritSummoned.localized(with: realmName, power))
                // Engine-First: Spirit attacks enemy immediately through engine action
                engine.performAction(.combatApplyEffect(effect: .summonSpirit(power: power, realm: realmString)))
                legacyMonster?.wrappedValue.health = monsterHealth
                combatLog.append(L10n.combatLogSpiritAttack.localized(with: power))

            case .sacrifice(let cost, let benefit):
                // Engine-First: Take damage through engine action
                engine.performAction(.combatApplyEffect(effect: .takeDamage(amount: cost)))
                combatLog.append("   🩸 Жертва: -\(cost) HP")
                // Парсим benefit для эффекта
                if benefit.lowercased().contains("урон") || benefit.lowercased().contains("damage") {
                    engine.performAction(.combatApplyEffect(effect: .addBonusDamage(amount: cost * 2)))
                    bonusDamage += cost * 2
                    combatLog.append("   🔥 +\(cost * 2) к урону следующей атаки")
                } else if benefit.lowercased().contains("карт") || benefit.lowercased().contains("draw") {
                    engine.performAction(.combatApplyEffect(effect: .drawCards(count: cost)))
                    player?.drawCards(count: cost)  // Legacy sync
                    engine.syncPlayerHand()  // Sync for UI reactivity
                    combatLog.append("   🃏 Взято карт: \(cost)")
                } else {
                    // Общий бонус - добавить урон
                    engine.performAction(.combatApplyEffect(effect: .addBonusDamage(amount: cost)))
                    bonusDamage += cost
                    combatLog.append("   🔥 +\(cost) к урону (\(benefit))")
                }

            case .explore:
                // Исследование не применимо в бою
                combatLog.append("   🔍 Исследование недоступно в бою")

            case .travelRealm:
                // Путешествие между мирами не применимо в бою
                combatLog.append("   🌀 Путешествие недоступно в бою")

            case .permanentStat(let stat, let amount):
                // Постоянный бонус к характеристике
                combatLog.append("   ⬆️ Постоянный бонус: +\(amount) к \(stat)")

            case .temporaryStat(let stat, let amount, let duration):
                // Временный бонус к характеристике
                if stat == "defense" {
                    temporaryShield += amount
                    combatLog.append("   🛡️ +\(amount) к защите на \(duration) ход(а)")
                } else {
                    bonusDamage += amount
                    combatLog.append("   ⬆️ +\(amount) к \(stat) на \(duration) ход(а)")
                }

            case .custom(let description):
                combatLog.append("   📜 \(description)")
            }
        }
    }

    func endPlayerTurn() {
        phase = .enemyTurn
    }

    func performEnemyAttack() {
        // Capture engine weakly to prevent retain cycles (engine is a class)
        // SwiftUI View is a struct, so @State vars are managed by SwiftUI
        let engineRef = engine
        let monsterName = monster.name
        let monsterPowerVal = monster.power ?? 3
        let currentShield = temporaryShield

        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) { [weak engineRef] in
            guard let engine = engineRef else { return }
            guard engine.combatState?.enemyHealth ?? 0 > 0 else {
                phase = .endTurn
                return
            }

            var rawDamage = monsterPowerVal
            var shieldAbsorbed = 0
            var actualDamage = 0

            // NEW: Shield absorbs damage first
            if currentShield > 0 {
                shieldAbsorbed = min(currentShield, rawDamage)
                rawDamage -= shieldAbsorbed
                temporaryShield -= shieldAbsorbed
            }

            // Remaining damage goes to HP
            if rawDamage > 0 {
                let healthBefore = engine.playerHealth
                engine.performAction(.combatEnemyAttack(damage: rawDamage))
                actualDamage = healthBefore - engine.playerHealth
            }

            // Track damage taken for statistics (only HP damage, not shield)
            totalDamageTaken += actualDamage

            // Build detailed combat log message
            var logMessage = "👹 \(monsterName) атакует! Сила: \(monsterPowerVal)"
            if shieldAbsorbed > 0 {
                logMessage += " | 🛡️ Щит поглотил: \(shieldAbsorbed)"
            }
            if actualDamage > 0 {
                logMessage += " | 💔 Урон HP: \(actualDamage)"
            } else if shieldAbsorbed == monsterPowerVal {
                logMessage += " | ✨ Полностью заблокировано!"
            }
            logMessage += " (HP: \(engine.playerHealth)/\(engine.playerMaxHealth), Щит: \(temporaryShield))"
            combatLog.append(logMessage)

            if engine.playerHealth <= 0 {
                finishCombat(victory: false)
            } else {
                phase = .endTurn
            }
        }
    }

    func performEndTurn() {
        // Capture engine weakly to prevent retain cycles
        let engineRef = engine
        let currentSpirits = summonedSpirits
        let currentPlayer = player

        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) { [weak engineRef] in
            guard let engine = engineRef else { return }

            // Духи атакуют в конце хода (если ещё живы)
            if !currentSpirits.isEmpty {
                for spirit in currentSpirits {
                    let spiritDamage = spirit.power
                    // Engine-First: Spirit damage through engine action
                    engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: spiritDamage)))
                    legacyMonster?.wrappedValue.health = monsterHealth
                    let realmName = spirit.realm == .yav ? "Явь" : spirit.realm == .nav ? "Навь" : "Правь"
                    combatLog.append("👻 Дух \(realmName) атакует: \(spiritDamage) урона")
                }
                // Духи исчезают после атаки
                summonedSpirits.removeAll()
            }

            // Проверяем победу после атак духов (Engine-First: read from engine)
            if engine.combatState?.enemyHealth ?? 0 <= 0 {
                finishCombat(victory: true)
                return
            }

            // Сбрасываем бонусы и щит на конец раунда
            if temporaryShield > 0 {
                combatLog.append("🛡️ Временный щит рассеялся (\(temporaryShield) → 0)")
            }
            bonusDice = 0
            bonusDamage = 0
            temporaryShield = 0  // Shield resets at end of round
            canReroll = false

            // Engine-First: End turn phase through engine action (discard, draw, faith restore)
            engine.performAction(.combatEndTurnPhase)

            // Legacy sync: discard and draw (with safety limit to prevent infinite loop)
            if let p = currentPlayer {
                let maxIterations = p.hand.count + 1  // Safety limit
                var iterations = 0
                while !p.hand.isEmpty && iterations < maxIterations {
                    p.playCard(p.hand[0])
                    iterations += 1
                }
                p.drawCards(count: p.maxHandSize)
                // Sync engine's playerHand after legacy deck operations
                engine.syncPlayerHand()
            }

            // Способность Мага: +1 вера в конце хода (Медитация)
            if currentPlayer?.shouldGainFaithEndOfTurn == true {
                combatLog.append("🔮 Медитация: +1 вера")
            }

            // Новый ход
            turnNumber += 1
            actionsRemaining = 3

            combatLog.append("━━━ Ход \(turnNumber) ━━━")

            phase = .playerTurn
        }
    }

    func finishCombat(victory: Bool) {
        phase = .combatOver

        // Save monster name BEFORE engine clears combatEnemy
        defeatedMonsterName = monster.name

        // Engine-First: Finish combat through engine action
        engine.performAction(.combatFinish(victory: victory))

        // Create combat statistics
        let stats = CombatStats(
            turnsPlayed: turnNumber,
            totalDamageDealt: totalDamageDealt,
            totalDamageTaken: totalDamageTaken,
            cardsPlayed: cardsPlayedCount
        )

        // Store stats for display in victory/defeat screen
        finalCombatStats = stats
        isVictory = victory

        if victory {
            combatLog.append("🎉 Победа! \(defeatedMonsterName) повержен!")
            combatLog.append("📊 \(stats.summary)")
        } else {
            combatLog.append("💀 Поражение...")
            combatLog.append("📊 \(stats.summary)")
        }

        // NOTE: No auto-dismiss! Player taps "Continue" button in combatOverView
        // This lets the player enjoy the victory moment and review stats
    }

    func flee() {
        // Engine-First: Flee combat through engine action
        engine.performAction(.combatFlee)

        combatLog.append("🏃 Вы сбежали из боя!")
        onCombatEnd(.fled)
    }

    // MARK: - Helpers

    var phaseText: String {
        switch phase {
        case .playerTurn: return L10n.combatPlayerTurn.localized
        case .enemyTurn: return L10n.combatEnemyTurn.localized
        case .endTurn: return L10n.combatEndTurn.localized
        case .combatOver: return L10n.combatOver.localized
        }
    }

    var phaseColor: Color {
        switch phase {
        case .playerTurn: return .green
        case .enemyTurn: return .red
        case .endTurn: return .purple
        case .combatOver: return .gray
        }
    }
}

// MARK: - Combat Card View

struct CombatCardView: View {
    let card: Card
    let canPlay: Bool
    let onPlay: () -> Void

    var body: some View {
        VStack(spacing: 4) {
            // Название карты
            Text(card.name)
                .font(.caption)
                .fontWeight(.semibold)
                .lineLimit(2)
                .multilineTextAlignment(.center)

            // Стоимость веры (если есть)
            if let cost = card.cost, cost > 0 {
                HStack(spacing: 2) {
                    Image(systemName: "sparkles")
                        .font(.system(size: 10))
                    Text("\(cost)")
                        .font(.caption2)
                }
                .foregroundColor(.yellow)
            }

            // Тип карты
            Text(cardTypeText)
                .font(.system(size: 9))
                .foregroundColor(cardTypeColor)
                .fontWeight(.medium)

            // Основной эффект
            if let ability = card.abilities.first {
                Text(abilityText(ability))
                    .font(.system(size: 10))
                    .foregroundColor(.secondary)
                    .lineLimit(2)
            }
        }
        .frame(width: 85, height: 110)
        .padding(6)
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(cardBackground)
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(canPlay ? cardBorder : Color.gray, lineWidth: canPlay ? 2 : 1)
                )
        )
        .opacity(canPlay ? 1.0 : 0.5)
        .scaleEffect(canPlay ? 1.0 : 0.95)
        .onTapGesture {
            if canPlay {
                onPlay()
            }
        }
    }

    var cardTypeText: String {
        switch card.type {
        case .attack: return "⚔️ Атака"
        case .defense: return "🛡 Защита"
        case .spell: return "✨ Заклинание"
        case .resource: return "💰 Ресурс"
        default: return "📜 Карта"
        }
    }

    var cardTypeColor: Color {
        switch card.type {
        case .attack: return .red
        case .defense: return .blue
        case .spell: return .purple
        case .resource: return .yellow
        default: return .gray
        }
    }

    var cardBackground: Color {
        switch card.type {
        case .attack: return Color.red.opacity(0.15)
        case .defense: return Color.blue.opacity(0.15)
        case .spell: return Color.purple.opacity(0.15)
        case .resource: return Color.yellow.opacity(0.15)
        default: return Color.gray.opacity(0.15)
        }
    }

    var cardBorder: Color {
        switch card.type {
        case .attack: return .red
        case .defense: return .blue
        case .spell: return .purple
        case .resource: return .yellow
        default: return .gray
        }
    }

    func abilityText(_ ability: CardAbility) -> String {
        switch ability.effect {
        case .damage(let amount, _): return "Урон: \(amount)"
        case .heal(let amount): return "Лечение: +\(amount)"
        case .drawCards(let count): return "Карты: +\(count)"
        case .gainFaith(let amount): return "Вера: +\(amount)"
        case .addDice(let count): return "+\(count) 🎲"
        case .reroll: return "Перебросок"
        case .shiftBalance(let towards, let amount):
            let dir = towards == .light ? "☀️" : towards == .dark ? "🌙" : "⚖️"
            return "\(dir) +\(amount)"
        case .applyCurse(let type, _): return "Проклятие: \(type)"
        case .removeCurse: return "Снять проклятие"
        case .summonSpirit(let power, let realm):
            let realmIcon = realm == .yav ? "🌳" : realm == .nav ? "💀" : "⭐"
            return "\(realmIcon) Дух (\(power))"
        case .sacrifice(let cost, _): return "Жертва: \(cost) HP"
        case .explore: return "Исследовать"
        case .travelRealm(let realm):
            let realmName = realm == .yav ? "Явь" : realm == .nav ? "Навь" : "Правь"
            return "→ \(realmName)"
        case .permanentStat(let stat, let amount): return "+\(amount) \(stat)"
        case .temporaryStat(let stat, let amount, let duration): return "+\(amount) \(stat) (\(duration))"
        case .custom: return ability.description
        }
    }
}


// ==========================================
// FILE: Views/EventView.swift
// ==========================================

import SwiftUI

/// Event view with Engine-First Architecture
/// - All state mutations go through engine.performAction()
/// - UI reads state from engine properties
struct EventView: View {
    // MARK: - Engine-First Architecture
    @ObservedObject var engine: TwilightGameEngine

    let event: GameEvent
    let regionId: UUID
    let onChoiceSelected: (EventChoice) -> Void
    let onDismiss: () -> Void

    // MARK: - Legacy Support (for backwards compatibility)
    private var legacyPlayer: Player?
    private var legacyWorldState: WorldState?

    @State private var selectedChoice: EventChoice?
    @State private var showingResult = false
    @State private var resultMessage: String = ""
    @State private var combatMonster: Card?
    @State private var combatVictory: Bool?

    // MARK: - Computed Properties (Engine-First with legacy fallback)

    private var player: Player? {
        legacyPlayer
    }

    // MARK: - Initialization (Engine-First)

    init(
        engine: TwilightGameEngine,
        event: GameEvent,
        regionId: UUID,
        onChoiceSelected: @escaping (EventChoice) -> Void,
        onDismiss: @escaping () -> Void
    ) {
        self.engine = engine
        self.event = event
        self.regionId = regionId
        self.onChoiceSelected = onChoiceSelected
        self.onDismiss = onDismiss
        self.legacyPlayer = nil
        self.legacyWorldState = nil
    }

    // MARK: - Legacy Initialization (for backwards compatibility)

    init(
        event: GameEvent,
        player: Player,
        worldState: WorldState,
        regionId: UUID,
        onChoiceSelected: @escaping (EventChoice) -> Void,
        onDismiss: @escaping () -> Void
    ) {
        // Create engine connected to legacy
        let newEngine = TwilightGameEngine()
        newEngine.connectToLegacy(worldState: worldState, player: player)
        self.engine = newEngine
        self.event = event
        self.regionId = regionId
        self.onChoiceSelected = onChoiceSelected
        self.onDismiss = onDismiss
        self.legacyPlayer = player
        self.legacyWorldState = worldState
    }

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 20) {
                    // Hero Panel (consistent design across all screens)
                    HeroPanel(engine: engine, compact: true)
                        .padding(.horizontal)

                    // Event header
                    eventHeader

                    Divider()

                    // Event description
                    Text(event.description)
                        .font(.body)
                        .foregroundColor(.secondary)
                        .padding(.horizontal)

                    Divider()

                    // Choices
                    VStack(spacing: 12) {
                        Text(L10n.eventChooseAction.localized)
                            .font(.headline)
                            .padding(.horizontal)

                        ForEach(event.choices) { choice in
                            choiceButton(choice)
                        }
                    }
                    .padding(.horizontal)
                }
                .padding(.vertical)
            }
            .navigationTitle(event.title)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(L10n.uiClose.localized) {
                        onDismiss()
                    }
                }
            }
            .alert(L10n.uiResult.localized, isPresented: $showingResult) {
                Button(L10n.buttonOk.localized) {
                    // Note: onChoiceSelected is already called in handleCombatEnd for combat victories
                    // or in handleNonCombatChoice for non-combat choices
                    onDismiss()
                }
            } message: {
                Text(resultMessage)
            }
            .fullScreenCover(item: $combatMonster) { _ in
                // Combat already set up in initiateCombat via engine.setupCombatEnemy
                CombatView(
                    engine: engine,
                    onCombatEnd: { outcome in
                        handleCombatEnd(outcome: outcome)
                    }
                )
            }
        }
    }

    // MARK: - Event Header

    var eventHeader: some View {
        HStack(spacing: 12) {
            // Event type icon
            ZStack {
                Circle()
                    .fill(eventTypeColor.opacity(0.2))
                    .frame(width: 60, height: 60)

                Image(systemName: event.eventType.icon)
                    .font(.title2)
                    .foregroundColor(eventTypeColor)
            }

            VStack(alignment: .leading, spacing: 4) {
                Text(event.eventType.displayName)
                    .font(.caption)
                    .foregroundColor(.secondary)

                Text(event.title)
                    .font(.title3)
                    .fontWeight(.bold)
            }

            Spacer()
        }
        .padding(.horizontal)
    }

    // MARK: - Hero Stats (now uses HeroPanel component)
    // Old heroStatsBar removed - using unified HeroPanel component instead

    var eventTypeColor: Color {
        switch event.eventType {
        case .combat: return .red
        case .ritual: return .purple
        case .narrative: return .blue
        case .exploration: return .cyan
        case .worldShift: return .orange
        }
    }

    // MARK: - Choice Button

    func choiceButton(_ choice: EventChoice) -> some View {
        let canChoose = canMeetRequirementsEngine(choice)
        let isCombatChoice = event.eventType == .combat &&
                             choice.id == event.choices.first?.id &&
                             event.monsterCard != nil

        return Button {
            guard canChoose else { return }

            // Defer all state changes to avoid "Publishing changes from within view updates"
            DispatchQueue.main.async {
                selectedChoice = choice

                // Check if this is a combat choice
                if isCombatChoice {
                    initiateCombat(choice: choice)
                } else {
                    onChoiceSelected(choice)
                    onDismiss()
                }
            }
        } label: {
            VStack(alignment: .leading, spacing: 8) {
                Text(choice.text)
                    .font(.body)
                    .fontWeight(.medium)
                    .foregroundColor(canChoose ? .primary : .gray)

                // Requirements
                if let requirements = choice.requirements {
                    requirementsView(requirements, canMeet: canChoose)
                }

                // Preview consequences (only positive ones)
                consequencesPreview(choice.consequences)
            }
            .frame(maxWidth: .infinity, alignment: .leading)
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(canChoose ? Color(UIColor.secondarySystemBackground) : Color.gray.opacity(0.1))
            )
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(canChoose ? Color.blue.opacity(0.5) : Color.clear, lineWidth: 2)
            )
            .contentShape(Rectangle())
        }
        .buttonStyle(.plain)
        .disabled(!canChoose)
    }

    func requirementsView(_ requirements: EventRequirements, canMeet: Bool) -> some View {
        VStack(alignment: .leading, spacing: 4) {
            if let minFaith = requirements.minimumFaith {
                HStack(spacing: 4) {
                    Image(systemName: "sparkles")
                        .font(.caption2)
                    Text(L10n.eventRequiresFaith.localized(with: minFaith))
                        .font(.caption2)
                    // Engine-First: read from engine
                    Text(L10n.eventYouHaveFaith.localized(with: engine.playerFaith))
                        .font(.caption2)
                        .foregroundColor(engine.playerFaith >= minFaith ? .green : .red)
                }
                .foregroundColor(.secondary)
            }

            if let minHealth = requirements.minimumHealth {
                HStack(spacing: 4) {
                    Image(systemName: "heart.fill")
                        .font(.caption2)
                    Text(L10n.eventRequiresHealth.localized(with: minHealth))
                        .font(.caption2)
                    // Engine-First: read from engine
                    Text(L10n.eventYouHaveHealth.localized(with: engine.playerHealth))
                        .font(.caption2)
                        .foregroundColor(engine.playerHealth >= minHealth ? .green : .red)
                }
                .foregroundColor(.secondary)
            }

            if let reqBalance = requirements.requiredBalance {
                // Engine-First: read from engine
                let playerBalanceEnum = getBalanceEnum(engine.playerBalance)
                let meetsRequirement = playerBalanceEnum == reqBalance

                HStack(spacing: 4) {
                    Image(systemName: "circle.lefthalf.filled")
                        .font(.caption2)
                    Text(L10n.eventRequiresPath.localized(with: balanceText(reqBalance)))
                        .font(.caption2)
                    Text(L10n.eventYourPath.localized(with: balanceText(playerBalanceEnum)))
                        .font(.caption2)
                        .foregroundColor(meetsRequirement ? .green : .red)
                }
                .foregroundColor(.secondary)
            }
        }
    }

    func consequencesPreview(_ consequences: EventConsequences) -> some View {
        VStack(alignment: .leading, spacing: 2) {
            if let faithChange = consequences.faithChange, faithChange != 0 {
                HStack(spacing: 4) {
                    Image(systemName: faithChange > 0 ? "arrow.up" : "arrow.down")
                        .font(.caption2)
                    Text(L10n.eventFaithChange.localized(with: faithChange > 0 ? "+" : "", faithChange))
                        .font(.caption2)
                }
                .foregroundColor(faithChange > 0 ? .green : .orange)
            }

            if let healthChange = consequences.healthChange, healthChange != 0 {
                HStack(spacing: 4) {
                    Image(systemName: healthChange > 0 ? "arrow.up" : "arrow.down")
                        .font(.caption2)
                    Text(L10n.eventHealthChange.localized(with: healthChange > 0 ? "+" : "", healthChange))
                        .font(.caption2)
                }
                .foregroundColor(healthChange > 0 ? .green : .red)
            }

            if let balanceChange = consequences.balanceChange, balanceChange != 0 {
                HStack(spacing: 4) {
                    Image(systemName: balanceChange > 0 ? "sun.max.fill" : "moon.fill")
                        .font(.caption2)
                    Text(balanceChange > 0 ? L10n.eventBalanceToLight.localized : L10n.eventBalanceToDark.localized)
                        .font(.caption2)
                }
                .foregroundColor(balanceChange > 0 ? .yellow : .purple)
            }

            if let reputationChange = consequences.reputationChange, reputationChange != 0 {
                HStack(spacing: 4) {
                    Image(systemName: reputationChange > 0 ? "hand.thumbsup.fill" : "hand.thumbsdown.fill")
                        .font(.caption2)
                    Text(L10n.eventReputationChange.localized(with: reputationChange > 0 ? "+" : "", reputationChange))
                        .font(.caption2)
                }
                .foregroundColor(reputationChange > 0 ? .green : .red)
            }

            if consequences.addCards != nil {
                HStack(spacing: 4) {
                    Image(systemName: "rectangle.stack.fill.badge.plus")
                        .font(.caption2)
                    Text(L10n.eventReceiveCard.localized)
                        .font(.caption2)
                }
                .foregroundColor(.blue)
            }

            if consequences.addCurse != nil {
                HStack(spacing: 4) {
                    Image(systemName: "exclamationmark.triangle.fill")
                        .font(.caption2)
                    Text(L10n.eventReceiveCurse.localized)
                        .font(.caption2)
                }
                .foregroundColor(.red)
            }
        }
    }

    // MARK: - Combat Management

    func initiateCombat(choice: EventChoice) {
        guard let monster = event.monsterCard else { return }

        // Engine-First: Get combat context from engine or legacy
        let regionState = engine.currentRegion?.state ?? .stable
        let combatContext = CombatContext(
            regionState: regionState,
            playerCurses: player?.activeCurses.map { $0.type } ?? []
        )

        // Создать врага с модификаторами региона
        var adjustedMonster = monster
        if let baseHealth = monster.health {
            adjustedMonster.health = combatContext.adjustedEnemyHealth(baseHealth)
        }
        if let basePower = monster.power {
            adjustedMonster.power = combatContext.adjustedEnemyPower(basePower)
        }
        if let baseDefense = monster.defense {
            adjustedMonster.defense = combatContext.adjustedEnemyDefense(baseDefense)
        }

        // Setup combat in engine first, then show fullScreenCover
        engine.setupCombatEnemy(adjustedMonster)
        combatMonster = adjustedMonster
    }

    func handleCombatEnd(outcome: CombatView.CombatOutcome) {
        // Apply non-combat consequences from the choice (if victory)
        if outcome.isVictory, let choice = selectedChoice {
            onChoiceSelected(choice)
        }

        // Combat already shows its own victory/defeat screen, no need for additional alert
        // Just close combat and dismiss event view
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
            combatMonster = nil
            // Small delay before dismissing to allow animation to complete
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
                onDismiss()
            }
        }
    }

    // MARK: - Helpers

    func canMeetRequirements(_ choice: EventChoice) -> Bool {
        guard let requirements = choice.requirements else { return true }
        // Engine-First: check requirements using engine state or legacy fallback
        if let ws = legacyWorldState, let p = legacyPlayer {
            return requirements.canMeet(with: p, worldState: ws)
        }
        // TODO: Implement pure engine-based requirement checking
        return true
    }

    /// Engine-based requirement checking
    func canMeetRequirementsEngine(_ choice: EventChoice) -> Bool {
        guard let requirements = choice.requirements else { return true }

        // Check minimum faith
        if let minFaith = requirements.minimumFaith {
            if engine.playerFaith < minFaith {
                return false
            }
        }

        // Check minimum health
        if let minHealth = requirements.minimumHealth {
            if engine.playerHealth < minHealth {
                return false
            }
        }

        // Check balance requirement
        if let reqBalance = requirements.requiredBalance {
            let playerBalanceEnum = getBalanceEnum(engine.playerBalance)
            if playerBalanceEnum != reqBalance {
                return false
            }
        }

        return true
    }

    func balanceText(_ balance: CardBalance) -> String {
        switch balance {
        case .light: return L10n.tmBalanceLightGenitive.localized
        case .neutral: return L10n.tmBalanceNeutralGenitive.localized
        case .dark: return L10n.tmBalanceDarkGenitive.localized
        }
    }

    func getBalanceEnum(_ balanceValue: Int) -> CardBalance {
        if balanceValue >= 70 {        // Light path (70-100)
            return .light
        } else if balanceValue <= 30 { // Dark path (0-30)
            return .dark
        } else {                       // Neutral (30-70)
            return .neutral
        }
    }
}

// MARK: - Preview

struct EventView_Previews: PreviewProvider {
    static var previews: some View {
        let player = Player(
            name: "Волхв",
            health: 20,
            maxHealth: 20,
            maxHandSize: 5,
            faith: 10,
            balance: 0
        )

        let worldState = WorldState()

        let event = GameEvent(
            eventType: .narrative,
            title: "Тестовое событие",
            description: "Это тестовое событие для предварительного просмотра",
            choices: [
                EventChoice(
                    text: "Выбор 1",
                    consequences: EventConsequences(
                        faithChange: 5,
                        message: "Результат выбора 1"
                    )
                ),
                EventChoice(
                    text: "Выбор 2",
                    requirements: EventRequirements(minimumFaith: 10),
                    consequences: EventConsequences(
                        faithChange: -3,
                        healthChange: -2,
                        message: "Результат выбора 2"
                    )
                )
            ]
        )

        return EventView(
            event: event,
            player: player,
            worldState: worldState,
            regionId: UUID(),
            onChoiceSelected: { _ in },
            onDismiss: { }
        )
    }
}


// ==========================================
// FILE: Views/GameBoardView.swift
// ==========================================

import SwiftUI

struct GameBoardView: View {
    @StateObject var gameState: GameState
    var saveSlot: Int?
    var onExit: (() -> Void)?
    @State private var selectedCard: Card?
    @State private var showingDiceRoll = false
    @State private var combatResult: CombatResult?
    @State private var showingRules = false
    @State private var showingPauseMenu = false
    @State private var showingSaveConfirmation = false
    @State private var showingEnemyAttack = false
    @State private var showingWorldMap = false
    @State private var enemyDamage: Int = 0
    @State private var showingEventCombatVictory = false  // Для победы в бою из события
    @State private var isExitingCombat = false  // Флаг что выходим из боя
    @StateObject private var saveManager = SaveManager.shared

    struct CombatResult {
        let diceRoll: Int
        let total: Int
        let defense: Int
        let success: Bool
        let damage: Int
    }

    // Custom initializer to accept external GameState instance
    init(gameState: GameState, saveSlot: Int? = nil, onExit: (() -> Void)? = nil) {
        _gameState = StateObject(wrappedValue: gameState)
        self.saveSlot = saveSlot
        self.onExit = onExit
    }

    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // Main game view
                VStack(spacing: 0) {
                    // Top bar
                    topBar
                        .frame(height: 95)
                        .background(Color(UIColor.systemBackground))
                        .shadow(radius: 2)

                    // Main game area (scrollable)
                    ScrollView {
                        VStack(spacing: 16) {
                            // Current encounter or exploration
                            encounterArea
                                .padding(.horizontal)

                            // Market section
                            marketView
                                .padding(.horizontal)

                            // Deck info
                            deckInfoView
                                .padding(.horizontal)

                            // Space for hand
                            Color.clear.frame(height: 120)
                        }
                        .padding(.vertical)
                    }

                    Divider()

                    // Fixed player hand at bottom
                    PlayerHandView(
                        player: gameState.currentPlayer,
                        selectedCard: $selectedCard,
                        onCardPlay: playCard
                    )
                    .frame(height: 120)
                    .background(Color(UIColor.secondarySystemBackground))
                }

                // Pause menu overlay
                if showingPauseMenu {
                    pauseMenuOverlay
                }

                // Victory screen
                if gameState.isVictory {
                    Color.black.opacity(0.3)
                        .ignoresSafeArea()
                    VictoryView(
                        encountersDefeated: gameState.encountersDefeated,
                        turnsTaken: gameState.turnNumber,
                        onDismiss: {
                            onExit?()
                        }
                    )
                    .padding(20)
                }

                // Defeat screen
                if gameState.isDefeat {
                    Color.black.opacity(0.3)
                        .ignoresSafeArea()
                    DefeatView(
                        encountersDefeated: gameState.encountersDefeated,
                        turnsTaken: gameState.turnNumber,
                        onDismiss: {
                            onExit?()
                        }
                    )
                    .padding(20)
                }

                // Оверлей победы в бою из события (не полная победа в игре)
                if showingEventCombatVictory {
                    Color.black.opacity(0.5)
                        .ignoresSafeArea()
                    VStack(spacing: 16) {
                        Image(systemName: "checkmark.circle.fill")
                            .font(.system(size: 60))
                            .foregroundColor(.green)
                        Text(L10n.enemyDefeated.localized)
                            .font(.title)
                            .fontWeight(.bold)
                            .foregroundColor(.white)
                        Text(L10n.returningToEvent.localized)
                            .font(.subheadline)
                            .foregroundColor(.white.opacity(0.8))
                    }
                    .padding(40)
                    .background(Color(UIColor.systemBackground).opacity(0.95))
                    .cornerRadius(20)
                    .shadow(radius: 20)
                }
            }
        }
        .navigationBarHidden(true)
        .onAppear {
            setupAutoSave()
        }
        .onDisappear {
            autoSaveOnExit()
        }
        .onChange(of: gameState.currentPhase) { newPhase in
            if newPhase == .enemyTurn {
                // Enemy attacks during their phase
                // Capture game state weakly (it's a class via @ObservedObject)
                let gameStateRef = gameState
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak gameStateRef] in
                    guard let gs = gameStateRef else { return }
                    if let encounter = gs.activeEncounter {
                        let damage = encounter.power ?? 3
                        enemyDamage = damage
                        gs.enemyPhaseAction()
                        showingEnemyAttack = true
                    }
                }
            }
        }
        .onChange(of: gameState.activeEncounter?.id) { _ in
            // Если враг побеждён (activeEncounter стал nil) и это бой из события,
            // показываем оверлей победы и затем закрываем
            if gameState.activeEncounter == nil && onExit != nil && !gameState.isGameOver && !isExitingCombat {
                isExitingCombat = true

                // Сначала закрываем все открытые alerts
                showingDiceRoll = false
                showingEnemyAttack = false
                combatResult = nil

                // Показываем оверлей победы
                showingEventCombatVictory = true

                // После небольшой задержки закрываем экран боя
                // Capture callback before async to avoid retaining view
                let exitCallback = onExit
                DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                    showingEventCombatVictory = false
                    exitCallback?()
                }
            }
        }
        .sheet(isPresented: $showingRules) {
            RulesView()
        }
        .sheet(isPresented: $showingWorldMap) {
            WorldMapView(worldState: gameState.worldState, player: gameState.currentPlayer)
        }
        .alert(combatResult?.success == true ? L10n.combatAlertSuccess.localized : L10n.combatAlertFail.localized, isPresented: $showingDiceRoll) {
            Button(L10n.buttonOk.localized, role: .cancel) {
                combatResult = nil
            }
        } message: {
            if let result = combatResult {
                if result.success {
                    Text(L10n.combatRollResultSuccess.localized(with: result.diceRoll, result.total - result.diceRoll, result.total, result.defense, result.damage))
                } else {
                    Text(L10n.combatRollResultFail.localized(with: result.diceRoll, result.total - result.diceRoll, result.total, result.defense))
                }
            }
        }
        .alert(L10n.uiGameSaved.localized, isPresented: $showingSaveConfirmation) {
            Button(L10n.buttonOk.localized, role: .cancel) { }
        } message: {
            Text(L10n.uiProgressSaved.localized)
        }
        .alert(L10n.combatEnemyAttackTitle.localized, isPresented: $showingEnemyAttack) {
            Button(L10n.buttonOk.localized, role: .cancel) { }
        } message: {
            Text(L10n.combatEnemyAttackMessage.localized(with: enemyDamage, gameState.currentPlayer.health))
        }
    }

    // MARK: - Top Bar

    var topBar: some View {
        VStack(spacing: 4) {
            HStack(spacing: 12) {
                // Pause/Menu button
                Button(action: { showingPauseMenu = true }) {
                    Image(systemName: "line.3.horizontal")
                        .font(.title3)
                        .foregroundColor(.blue)
                        .padding(8)
                }

                VStack(alignment: .leading, spacing: 2) {
                    Text(L10n.turnLabel.localized(with: gameState.turnNumber))
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text(phaseText)
                        .font(.caption)
                        .fontWeight(.bold)
                        .foregroundColor(phaseColor)
                }

                Spacer()

                // Player resources - compact with icons only
                HStack(spacing: 8) {
                    // Actions
                    HStack(spacing: 2) {
                        Image(systemName: "bolt.fill")
                            .font(.system(size: 12))
                            .foregroundColor(.orange)
                        Text("\(gameState.actionsRemaining)")
                            .font(.system(size: 13))
                            .fontWeight(.bold)
                    }

                    // Health
                    HStack(spacing: 2) {
                        Image(systemName: "heart.fill")
                            .font(.system(size: 12))
                            .foregroundColor(.red)
                        Text("\(gameState.currentPlayer.health)")
                            .font(.system(size: 13))
                            .fontWeight(.bold)
                    }

                    // Faith
                    HStack(spacing: 2) {
                        Image(systemName: "sparkles")
                            .font(.system(size: 12))
                            .foregroundColor(.yellow)
                        Text("\(gameState.currentPlayer.faith)")
                            .font(.system(size: 13))
                            .fontWeight(.bold)
                    }
                }

                // Next phase button
                Button(action: {
                    gameState.nextPhase()
                }) {
                    Image(systemName: "arrow.right.circle.fill")
                        .font(.title2)
                        .foregroundColor(.green)
                }
                .padding(4)
            }
            .padding(.horizontal)

            // Phase progress bar
            PhaseProgressBar(currentPhase: gameState.currentPhase)
                .padding(.horizontal, 12)
                .padding(.bottom, 4)
        }
    }

    func resourceBadge(icon: String, value: String, color: Color, label: String) -> some View {
        HStack(spacing: 4) {
            Image(systemName: icon)
                .font(.caption)
                .foregroundColor(color)
            Text(value)
                .font(.caption2)
                .fontWeight(.bold)
            if !label.isEmpty {
                Text(label)
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
        }
        .padding(.horizontal, 6)
        .padding(.vertical, 4)
        .background(Color(UIColor.tertiarySystemBackground))
        .cornerRadius(6)
    }

    // MARK: - Encounter Area

    var encounterArea: some View {
        Group {
            if let encounter = gameState.activeEncounter {
                VStack(spacing: 12) {
                    Text(L10n.uiActiveEncounter.localized)
                        .font(.headline)
                        .foregroundColor(.red)

                    CardView(card: encounter)
                        .frame(width: 180, height: 280)

                    HStack(spacing: 16) {
                        Button(action: rollDice) {
                            Label(L10n.uiRoll.localized, systemImage: "dice.fill")
                                .font(.caption)
                                .padding(.horizontal, 12)
                                .padding(.vertical, 6)
                                .background(Color.orange)
                                .foregroundColor(.white)
                                .cornerRadius(8)
                        }

                        if let roll = gameState.diceRoll {
                            Text(L10n.uiResult.localized(with: roll))
                                .font(.subheadline)
                                .fontWeight(.bold)
                                .foregroundColor(.orange)
                        }
                    }
                }
                .padding()
                .background(
                    RoundedRectangle(cornerRadius: 12)
                        .fill(Color.red.opacity(0.1))
                        .overlay(
                            RoundedRectangle(cornerRadius: 12)
                                .stroke(Color.red, lineWidth: 2)
                        )
                )
            } else if gameState.currentPhase == .exploration {
                Button(action: {
                    gameState.drawEncounter()
                }) {
                    VStack(spacing: 12) {
                        Image(systemName: "magnifyingglass")
                            .font(.system(size: 40))
                        Text(L10n.uiExplore.localized)
                            .font(.title3)
                            .fontWeight(.bold)
                    }
                    .frame(maxWidth: .infinity)
                    .frame(height: 120)
                    .background(Color.blue.opacity(0.2))
                    .cornerRadius(12)
                }
            }
        }
    }

    // MARK: - Market View

    var marketView: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Image(systemName: "cart.fill")
                    .font(.title3)
                    .foregroundColor(.orange)
                Text(L10n.marketplace.localized)
                    .font(.title3)
                    .fontWeight(.bold)
                Spacer()
                HStack(spacing: 4) {
                    Image(systemName: "sparkles")
                        .font(.caption)
                        .foregroundColor(.yellow)
                    Text("\(gameState.currentPlayer.faith)")
                        .font(.subheadline)
                        .fontWeight(.bold)
                }
            }

            if gameState.marketCards.isEmpty {
                Text(L10n.noCardsForPurchase.localized)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .frame(maxWidth: .infinity)
                    .padding()
            } else {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 12) {
                        ForEach(gameState.marketCards) { card in
                            MarketCardView(
                                card: card,
                                canAfford: gameState.currentPlayer.faith >= (card.cost ?? 0),
                                onPurchase: {
                                    if gameState.purchaseCard(card) {
                                        // Card purchased successfully
                                    }
                                }
                            )
                        }
                    }
                    .padding(.vertical, 8)
                }
            }
        }
        .padding()
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(12)
    }

    // MARK: - Deck Info

    var deckInfoView: some View {
        HStack(spacing: 12) {
            DeckPileView(
                title: L10n.uiEncounters.localized,
                count: gameState.encounterDeck.count,
                color: .red
            )

            DeckPileView(
                title: L10n.uiYourDeck.localized,
                count: gameState.currentPlayer.deck.count,
                color: .blue
            )

            DeckPileView(
                title: L10n.uiDiscard.localized,
                count: gameState.currentPlayer.discard.count,
                color: .gray
            )
        }
    }

    // MARK: - Pause Menu

    var pauseMenuOverlay: some View {
        ZStack {
            Color.black.opacity(0.5)
                .ignoresSafeArea()
                .onTapGesture {
                    showingPauseMenu = false
                }

            VStack(spacing: 16) {
                Text(L10n.uiPauseMenu.localized)
                    .font(.title2)
                    .fontWeight(.bold)

                Button(action: {
                    showingPauseMenu = false
                }) {
                    Label(L10n.uiResume.localized, systemImage: "play.fill")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.green)
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }

                Button(action: {
                    showingRules = true
                    showingPauseMenu = false
                }) {
                    Label(L10n.uiRules.localized, systemImage: "book.fill")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.blue)
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }

                Button(action: {
                    showingWorldMap = true
                    showingPauseMenu = false
                }) {
                    Label(L10n.worldMap.localized, systemImage: "map.fill")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.cyan)
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }

                if let slot = saveSlot {
                    Button(action: {
                        saveManager.saveGame(to: slot, gameState: gameState)
                        showingSaveConfirmation = true
                        showingPauseMenu = false
                    }) {
                        Label(L10n.uiSaveGame.localized, systemImage: "tray.and.arrow.down.fill")
                            .frame(maxWidth: .infinity)
                            .padding()
                            .background(Color.orange)
                            .foregroundColor(.white)
                            .cornerRadius(10)
                    }
                }

                Button(action: {
                    showingPauseMenu = false
                    onExit?()
                }) {
                    Label(L10n.uiExit.localized, systemImage: "house.fill")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.red)
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }
            }
            .padding(30)
            .background(Color(UIColor.systemBackground))
            .cornerRadius(16)
            .shadow(radius: 20)
            .padding(40)
        }
    }

    // MARK: - Helper Properties

    var phaseText: String {
        switch gameState.currentPhase {
        case .setup: return L10n.phaseSetup.localized
        case .exploration: return L10n.phaseExploration.localized
        case .encounter: return L10n.phaseEncounter.localized
        case .playerTurn: return L10n.phasePlayerTurn.localized
        case .enemyTurn: return L10n.phaseEnemyTurn.localized
        case .endTurn: return L10n.phaseEndTurn.localized
        case .gameOver: return L10n.phaseGameOver.localized
        }
    }

    var phaseColor: Color {
        switch gameState.currentPhase {
        case .setup: return .gray
        case .exploration: return .blue
        case .encounter: return .orange
        case .playerTurn: return .green
        case .enemyTurn: return .red
        case .endTurn: return .purple
        case .gameOver: return .black
        }
    }

    var balanceIcon: String {
        let balance = gameState.currentPlayer.balance
        if balance >= 70 {              // Light path (70-100)
            return "sun.max.fill"
        } else if balance <= 30 {       // Dark path (0-30)
            return "moon.fill"
        } else {                        // Neutral (30-70)
            return "circle.lefthalf.filled"
        }
    }

    var balanceColor: Color {
        let balance = gameState.currentPlayer.balance
        if balance >= 70 {              // Light path (70-100)
            return .yellow
        } else if balance <= 30 {       // Dark path (0-30)
            return .purple
        } else {                        // Neutral (30-70)
            return .gray
        }
    }

    // MARK: - Helper Functions

    func rollDice() {
        guard let encounter = gameState.activeEncounter else { return }

        // Check if player has actions remaining
        guard gameState.useAction() else {
            // Show alert that no actions left
            return
        }

        // Roll dice
        let diceResult = gameState.rollDice(sides: 6, count: 1)

        // Calculate total (dice + player power)
        let playerPower = gameState.currentPlayer.strength
        let total = diceResult + playerPower

        // Get encounter defense (or use default 10 if not specified)
        let encounterDefense = encounter.defense ?? 10

        // Combat resolution
        let success = total >= encounterDefense
        var damageDealt = 0

        if success {
            // Success! Deal damage to encounter with curse modifiers
            let baseDamage = max(1, total - encounterDefense + 3) // Base 3 damage + excess
            damageDealt = gameState.currentPlayer.calculateDamageDealt(baseDamage)
            if var updatedEncounter = gameState.activeEncounter {
                let currentHealth = updatedEncounter.health ?? 10
                updatedEncounter.health = max(0, currentHealth - damageDealt)
                gameState.activeEncounter = updatedEncounter

                // Check if encounter defeated
                if updatedEncounter.health == 0 {
                    gameState.defeatEncounter()
                }
            }
        }
        // Enemy attacks during enemy phase, not immediately after player attack

        // Store combat result for display
        combatResult = CombatResult(
            diceRoll: diceResult,
            total: total,
            defense: encounterDefense,
            success: success,
            damage: damageDealt
        )

        showingDiceRoll = true
    }

    func playCard(_ card: Card) {
        // Печать Нави: нельзя использовать Sustain карты
        if card.role == .sustain && gameState.currentPlayer.hasCurse(.sealOfNav) {
            // TODO: Show alert that Sustain cards are blocked by curse
            return
        }

        // Check if player has actions remaining
        guard gameState.useAction() else {
            // TODO: Show alert that no actions left
            return
        }

        // Check if player has enough faith
        guard let cost = card.cost else {
            gameState.currentPlayer.playCard(card)
            applyCardEffects(card)
            return
        }

        if gameState.currentPlayer.spendFaith(cost) {
            gameState.currentPlayer.playCard(card)
            applyCardEffects(card)
        } else {
            // Refund action if couldn't spend faith
            gameState.actionsRemaining += 1
        }
    }

    func applyCardEffects(_ card: Card) {
        for ability in card.abilities {
            switch ability.effect {
            case .heal(let amount):
                gameState.currentPlayer.heal(amount)

            case .damage(let amount, _):
                if var encounter = gameState.activeEncounter, let health = encounter.health {
                    // Применяем модификаторы проклятий к урону
                    let actualDamage = gameState.currentPlayer.calculateDamageDealt(amount)
                    encounter.health = max(0, health - actualDamage)
                    gameState.activeEncounter = encounter
                    if encounter.health == 0 {
                        // Encounter defeated!
                        gameState.defeatEncounter()
                    }
                }

            case .drawCards(let count):
                gameState.currentPlayer.drawCards(count: count)

            case .gainFaith(let amount):
                gameState.currentPlayer.gainFaith(amount)

            case .removeCurse(let type):
                gameState.currentPlayer.removeCurse(type: type)

            case .shiftBalance(let towards, let amount):
                gameState.currentPlayer.shiftBalance(towards: towards, amount: amount)

            default:
                break
            }
        }
    }

    // MARK: - Auto-Save Functions

    func setupAutoSave() {
        guard let slot = saveSlot else { return }

        gameState.onAutoSave = { [weak saveManager, weak gameState] in
            guard let saveManager = saveManager,
                  let gameState = gameState else { return }
            saveManager.saveGame(to: slot, gameState: gameState)
        }
    }

    func autoSaveOnExit() {
        guard let slot = saveSlot else { return }
        saveManager.saveGame(to: slot, gameState: gameState)
    }
}

// MARK: - Victory/Defeat Screens

struct VictoryView: View {
    let encountersDefeated: Int
    let turnsTaken: Int
    let onDismiss: () -> Void

    var body: some View {
        VStack(spacing: 20) {
            Image(systemName: "crown.fill")
                .font(.system(size: 80))
                .foregroundColor(.yellow)

            Text(L10n.uiVictoryTitle.localized)
                .font(.largeTitle)
                .fontWeight(.bold)

            Text(L10n.victoryMessage.localized)
                .font(.title3)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)

            VStack(spacing: 12) {
                StatRow(label: L10n.statsEncountersDefeated.localized, value: "\(encountersDefeated)")
                StatRow(label: L10n.statsTurnsMade.localized, value: "\(turnsTaken)")
            }
            .padding()
            .background(Color(UIColor.secondarySystemBackground))
            .cornerRadius(12)

            Button(action: onDismiss) {
                Text(L10n.uiReturnMenu.localized)
                    .font(.headline)
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.blue)
                    .cornerRadius(12)
            }
        }
        .padding(40)
        .background(Color(UIColor.systemBackground))
        .cornerRadius(20)
        .shadow(radius: 20)
    }
}

struct DefeatView: View {
    let encountersDefeated: Int
    let turnsTaken: Int
    let onDismiss: () -> Void

    var body: some View {
        VStack(spacing: 20) {
            Image(systemName: "xmark.circle.fill")
                .font(.system(size: 80))
                .foregroundColor(.red)

            Text(L10n.uiDefeatTitle.localized)
                .font(.largeTitle)
                .fontWeight(.bold)

            Text(L10n.defeatMessage.localized)
                .font(.title3)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)

            VStack(spacing: 12) {
                StatRow(label: L10n.statsEncountersDefeated.localized, value: "\(encountersDefeated)")
                StatRow(label: L10n.statsTurnsSurvived.localized, value: "\(turnsTaken)")
            }
            .padding()
            .background(Color(UIColor.secondarySystemBackground))
            .cornerRadius(12)

            Button(action: onDismiss) {
                Text(L10n.uiReturnMenu.localized)
                    .font(.headline)
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.blue)
                    .cornerRadius(12)
            }
        }
        .padding(40)
        .background(Color(UIColor.systemBackground))
        .cornerRadius(20)
        .shadow(radius: 20)
    }
}

struct StatRow: View {
    let label: String
    let value: String

    var body: some View {
        HStack {
            Text(label)
                .foregroundColor(.secondary)
            Spacer()
            Text(value)
                .fontWeight(.bold)
        }
    }
}

// MARK: - Deck Pile View

struct DeckPileView: View {
    let title: String
    let count: Int
    let color: Color

    var body: some View {
        VStack(spacing: 6) {
            ZStack {
                ForEach(0..<min(count, 3), id: \.self) { index in
                    RoundedRectangle(cornerRadius: 4)
                        .fill(color.opacity(0.7))
                        .frame(width: 50, height: 70)
                        .offset(x: CGFloat(index) * 2, y: CGFloat(index) * -2)
                }
            }
            .frame(width: 60, height: 80)

            Text(title)
                .font(.caption2)
                .fontWeight(.bold)
                .multilineTextAlignment(.center)
            Text("\(count)")
                .font(.caption2)
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity)
    }
}

// MARK: - Market Card View

struct MarketCardView: View {
    let card: Card
    let canAfford: Bool
    let onPurchase: () -> Void

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // Rarity badge
            HStack {
                rarityBadge
                Spacer()
                // Cost badge
                HStack(spacing: 2) {
                    Image(systemName: "sparkles")
                        .font(.caption2)
                    Text("\(card.cost ?? 0)")
                        .font(.caption)
                        .fontWeight(.bold)
                }
                .padding(.horizontal, 6)
                .padding(.vertical, 2)
                .background(canAfford ? Color.yellow.opacity(0.3) : Color.gray.opacity(0.3))
                .foregroundColor(canAfford ? .yellow : .gray)
                .cornerRadius(8)
            }

            // Card name
            Text(card.name)
                .font(.subheadline)
                .fontWeight(.bold)
                .lineLimit(2)
                .minimumScaleFactor(0.8)
                .frame(height: 32, alignment: .top)

            // Card type
            Text(cardTypeText)
                .font(.caption2)
                .foregroundColor(.secondary)

            // Card stats
            HStack(spacing: 8) {
                if let power = card.power {
                    HStack(spacing: 2) {
                        Image(systemName: "bolt.fill")
                            .font(.caption2)
                            .foregroundColor(.orange)
                        Text("\(power)")
                            .font(.caption)
                    }
                }
                if let defense = card.defense {
                    HStack(spacing: 2) {
                        Image(systemName: "shield.fill")
                            .font(.caption2)
                            .foregroundColor(.blue)
                        Text("\(defense)")
                            .font(.caption)
                    }
                }
            }

            Spacer()

            // Purchase button
            Button(action: onPurchase) {
                Text(L10n.buttonBuy.localized)
                    .font(.caption)
                    .fontWeight(.semibold)
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 6)
                    .background(canAfford ? Color.green : Color.gray)
                    .cornerRadius(6)
            }
            .disabled(!canAfford)
        }
        .padding(8)
        .frame(width: 120, height: 180)
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(rarityBackgroundColor)
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(rarityBorderColor, lineWidth: 2)
                )
        )
    }

    var cardTypeText: String {
        switch card.type {
        case .resource: return L10n.cardTypeResource.localized
        case .attack: return L10n.cardTypeAttack.localized
        case .defense: return L10n.cardTypeDefense.localized
        case .special: return L10n.cardTypeSpecial.localized
        default: return card.type.rawValue
        }
    }

    var rarityBadge: some View {
        Text(rarityText)
            .font(.system(size: 8))
            .fontWeight(.bold)
            .foregroundColor(.white)
            .padding(.horizontal, 4)
            .padding(.vertical, 2)
            .background(rarityBorderColor)
            .cornerRadius(4)
    }

    var rarityText: String {
        switch card.rarity {
        case .common: return L10n.rarityCommon.localized
        case .uncommon: return L10n.rarityUncommon.localized
        case .rare: return L10n.rarityRare.localized
        case .epic: return L10n.rarityEpic.localized
        case .legendary: return L10n.rarityLegendary.localized
        }
    }

    var rarityBackgroundColor: Color {
        switch card.rarity {
        case .common: return Color(UIColor.tertiarySystemBackground)
        case .uncommon: return Color.green.opacity(0.1)
        case .rare: return Color.blue.opacity(0.1)
        case .epic: return Color.purple.opacity(0.1)
        case .legendary: return Color.orange.opacity(0.1)
        }
    }

    var rarityBorderColor: Color {
        switch card.rarity {
        case .common: return .gray
        case .uncommon: return .green
        case .rare: return .blue
        case .epic: return .purple
        case .legendary: return .orange
        }
    }
}

// MARK: - Phase Progress Bar

struct PhaseProgressBar: View {
    let currentPhase: GamePhase

    var phases: [(phase: GamePhase, name: String, color: Color)] {
        [
            (.exploration, L10n.phaseProgressExploration.localized, .blue),
            (.encounter, L10n.phaseProgressEncounter.localized, .orange),
            (.playerTurn, L10n.phaseProgressPlayerTurn.localized, .green),
            (.enemyTurn, L10n.phaseProgressEnemyTurn.localized, .red),
            (.endTurn, L10n.phaseProgressEndTurn.localized, .purple)
        ]
    }

    var body: some View {
        VStack(spacing: 4) {
            // Progress bar
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    // Background
                    Rectangle()
                        .fill(Color.gray.opacity(0.2))
                        .frame(height: 4)
                        .cornerRadius(2)

                    // Progress indicator
                    Rectangle()
                        .fill(currentPhaseColor)
                        .frame(width: progressWidth(totalWidth: geometry.size.width), height: 4)
                        .cornerRadius(2)
                }
            }
            .frame(height: 4)

            // Phase indicators
            HStack(spacing: 0) {
                ForEach(Array(phases.enumerated()), id: \.offset) { index, phaseInfo in
                    VStack(spacing: 2) {
                        Circle()
                            .fill(phaseInfo.phase == currentPhase ? phaseInfo.color : Color.gray.opacity(0.3))
                            .frame(width: 8, height: 8)
                            .overlay(
                                Circle()
                                    .stroke(phaseInfo.color, lineWidth: phaseInfo.phase == currentPhase ? 2 : 0)
                            )

                        Text(phaseInfo.name)
                            .font(.system(size: 8))
                            .foregroundColor(phaseInfo.phase == currentPhase ? phaseInfo.color : .secondary)
                            .lineLimit(1)
                            .minimumScaleFactor(0.5)
                    }
                    .frame(maxWidth: .infinity)
                }
            }
        }
    }

    var currentPhaseColor: Color {
        phases.first(where: { $0.phase == currentPhase })?.color ?? .gray
    }

    func progressWidth(totalWidth: CGFloat) -> CGFloat {
        guard let currentIndex = phases.firstIndex(where: { $0.phase == currentPhase }) else {
            return 0
        }
        let progress = CGFloat(currentIndex + 1) / CGFloat(phases.count)
        return totalWidth * progress
    }
}


// ==========================================
// FILE: Views/HeroSelectionView.swift
// ==========================================

import SwiftUI

/// Экран выбора героя при начале новой игры
/// Герои загружаются из HeroRegistry (data-driven)
struct HeroSelectionView: View {
    let onHeroSelected: (String) -> Void  // Возвращает heroId

    @State private var selectedHeroId: String?

    /// Все доступные герои из реестра
    private var availableHeroes: [HeroDefinition] {
        HeroRegistry.shared.availableHeroes()
    }

    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Заголовок
                VStack(spacing: 8) {
                    Text("Выберите героя")
                        .font(.largeTitle)
                        .fontWeight(.bold)

                    Text("Каждый герой имеет уникальные характеристики и способности")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                        .padding(.horizontal)
                }
                .padding(.top, 20)
                .padding(.bottom, 16)

                // Список героев
                ScrollView {
                    VStack(spacing: 12) {
                        ForEach(availableHeroes, id: \.id) { hero in
                            HeroCard(
                                hero: hero,
                                isSelected: selectedHeroId == hero.id
                            ) {
                                withAnimation(.easeInOut(duration: 0.2)) {
                                    selectedHeroId = hero.id
                                }
                            }
                        }
                    }
                    .padding(.horizontal)
                    .padding(.bottom, 100)  // Место для кнопки
                }

                Spacer()

                // Кнопка подтверждения
                VStack(spacing: 8) {
                    if let heroId = selectedHeroId,
                       let hero = HeroRegistry.shared.hero(id: heroId) {
                        Button(action: {
                            onHeroSelected(heroId)
                        }) {
                            HStack {
                                Text(hero.icon)
                                Text("Начать игру за \(hero.name)")
                                    .fontWeight(.semibold)
                            }
                            .frame(maxWidth: .infinity)
                            .padding()
                            .background(Color.blue)
                            .foregroundColor(.white)
                            .cornerRadius(12)
                        }
                        .padding(.horizontal)
                    } else {
                        Text("Выберите героя")
                            .foregroundColor(.secondary)
                            .padding()
                    }
                }
                .padding(.bottom, 20)
                .background(
                    Color(UIColor.systemBackground)
                        .shadow(radius: 5)
                )
            }
            .background(Color(UIColor.secondarySystemBackground))
            .navigationBarHidden(true)
        }
    }
}

/// Карточка героя
struct HeroCard: View {
    let hero: HeroDefinition
    let isSelected: Bool
    let onTap: () -> Void

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Заголовок
            HStack {
                Text(hero.icon)
                    .font(.title)

                VStack(alignment: .leading, spacing: 2) {
                    Text(hero.name)
                        .font(.title2)
                        .fontWeight(.bold)

                    Text(hero.description)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }

                Spacer()

                if isSelected {
                    Image(systemName: "checkmark.circle.fill")
                        .font(.title2)
                        .foregroundColor(.blue)
                }
            }

            // Характеристики
            let stats = hero.baseStats
            HStack(spacing: 16) {
                StatBadge(icon: "heart.fill", value: stats.health, label: "HP", color: .red)
                StatBadge(icon: "hand.raised.fill", value: stats.strength, label: "Сила", color: .orange)
                StatBadge(icon: "sparkles", value: stats.faith, label: "Вера", color: .yellow)
                StatBadge(icon: "brain.head.profile", value: stats.intelligence, label: "Инт", color: .purple)
            }

            // Особая способность
            HStack(spacing: 8) {
                Image(systemName: "star.fill")
                    .foregroundColor(.yellow)
                    .font(.caption)

                Text(hero.specialAbility.description)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            .padding(8)
            .background(Color.yellow.opacity(0.1))
            .cornerRadius(8)
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(UIColor.systemBackground))
                .overlay(
                    RoundedRectangle(cornerRadius: 12)
                        .stroke(isSelected ? Color.blue : Color.gray.opacity(0.3), lineWidth: isSelected ? 3 : 1)
                )
        )
        .onTapGesture {
            onTap()
        }
    }
}

/// Бейдж характеристики
struct StatBadge: View {
    let icon: String
    let value: Int
    let label: String
    let color: Color

    var body: some View {
        VStack(spacing: 2) {
            Image(systemName: icon)
                .font(.caption)
                .foregroundColor(color)

            Text("\(value)")
                .font(.caption)
                .fontWeight(.bold)

            Text(label)
                .font(.system(size: 8))
                .foregroundColor(.secondary)
        }
        .frame(minWidth: 40)
    }
}

#Preview {
    HeroSelectionView { heroId in
        print("Selected: \(heroId)")
    }
}


// ==========================================
// FILE: Views/PlayerHandView.swift
// ==========================================

import SwiftUI

struct PlayerHandView: View {
    @ObservedObject var player: Player
    @Binding var selectedCard: Card?
    var onCardPlay: ((Card) -> Void)?

    var body: some View {
        VStack(spacing: 4) {
            // Play card button (shown when card is selected)
            if let selected = selectedCard {
                HStack(spacing: 12) {
                    Button(action: {
                        onCardPlay?(selected)
                        selectedCard = nil
                    }) {
                        Label(L10n.combatPlayCard.localized, systemImage: "play.fill")
                            .font(.headline)
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 8)
                            .background(Color.green)
                            .cornerRadius(8)
                    }

                    Button(action: {
                        selectedCard = nil
                    }) {
                        Image(systemName: "xmark.circle.fill")
                            .font(.title2)
                            .foregroundColor(.gray)
                    }
                }
                .padding(.horizontal, 12)
                .padding(.vertical, 4)
                .background(Color(UIColor.tertiarySystemBackground))
            }

            // Compact deck info
            HStack(spacing: 16) {
                Text(player.name)
                    .font(.caption)
                    .fontWeight(.bold)

                Spacer()

                // Deck count
                HStack(spacing: 4) {
                    Image(systemName: "rectangle.stack.fill")
                        .font(.caption2)
                    Text("\(player.deck.count)")
                        .font(.caption2)
                }
                .foregroundColor(.blue)

                // Discard count
                HStack(spacing: 4) {
                    Image(systemName: "trash.fill")
                        .font(.caption2)
                    Text("\(player.discard.count)")
                        .font(.caption2)
                }
                .foregroundColor(.gray)
            }
            .padding(.horizontal, 12)
            .padding(.vertical, 4)
            .background(Color(UIColor.secondarySystemBackground))

            // Hand of cards
            if player.hand.isEmpty {
                Text(L10n.noCardsInHand.localized)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .padding()
            } else {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 8) {
                        ForEach(player.hand) { card in
                            HandCardView(
                                card: card,
                                isSelected: selectedCard?.id == card.id,
                                onTap: {
                                    if selectedCard?.id == card.id {
                                        selectedCard = nil
                                    } else {
                                        selectedCard = card
                                    }
                                }
                            )
                        }
                    }
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                }
            }
        }
    }
}


// ==========================================
// FILE: Views/RulesView.swift
// ==========================================

import SwiftUI

struct RulesView: View {
    @Environment(\.dismiss) var dismiss

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 24) {
                    // Game Objective
                    RuleSection(
                        icon: "target",
                        color: .blue,
                        title: L10n.rulesObjectiveTitle.localized,
                        content: L10n.rulesObjectiveContent.localized
                    )

                    // Game Phases
                    RuleSection(
                        icon: "arrow.triangle.2.circlepath",
                        color: .orange,
                        title: L10n.rulesPhasesTitle.localized,
                        content: L10n.rulesPhasesContent.localized
                    )

                    VStack(alignment: .leading, spacing: 12) {
                        PhaseCard(
                            phase: L10n.phaseExploration.localized,
                            description: L10n.rulesPhaseExploration.localized,
                            color: .blue
                        )
                        PhaseCard(
                            phase: L10n.phaseEncounter.localized,
                            description: L10n.rulesPhaseEncounter.localized,
                            color: .orange
                        )
                        PhaseCard(
                            phase: L10n.phasePlayerTurn.localized,
                            description: L10n.rulesPhasePlayerTurn.localized,
                            color: .green
                        )
                        PhaseCard(
                            phase: L10n.phaseEnemyTurn.localized,
                            description: L10n.rulesPhaseEnemyTurn.localized,
                            color: .red
                        )
                        PhaseCard(
                            phase: L10n.phaseEndTurn.localized,
                            description: L10n.rulesPhaseEndTurn.localized,
                            color: .purple
                        )
                    }
                    .padding(.leading, 8)

                    // Card Types
                    RuleSection(
                        icon: "rectangle.stack.fill",
                        color: .purple,
                        title: L10n.rulesCardsTitle.localized,
                        content: L10n.rulesCardsContent.localized
                    )

                    // Resources
                    RuleSection(
                        icon: "star.fill",
                        color: .pink,
                        title: L10n.rulesResourcesTitle.localized,
                        content: L10n.rulesResourcesContent.localized
                    )

                    // Actions
                    RuleSection(
                        icon: "bolt.fill",
                        color: .orange,
                        title: L10n.rulesActionsTitle.localized,
                        content: L10n.rulesActionsContent.localized
                    )

                    // Dice Rolls
                    RuleSection(
                        icon: "dice.fill",
                        color: .green,
                        title: L10n.rulesDiceTitle.localized,
                        content: L10n.rulesDiceContent.localized
                    )

                    // Victory Conditions
                    RuleSection(
                        icon: "trophy.fill",
                        color: .yellow,
                        title: L10n.rulesVictoryTitle.localized,
                        content: L10n.rulesVictoryContent.localized
                    )

                    // Tips
                    RuleSection(
                        icon: "lightbulb.fill",
                        color: .cyan,
                        title: L10n.rulesTipsTitle.localized,
                        content: L10n.rulesTipsContent.localized
                    )
                }
                .padding()
            }
            .navigationTitle(L10n.rulesTitle.localized)
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark.circle.fill")
                            .foregroundColor(.secondary)
                    }
                }
            }
        }
    }
}

struct RuleSection: View {
    let icon: String
    let color: Color
    let title: String
    let content: String

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack(spacing: 12) {
                Image(systemName: icon)
                    .font(.title2)
                    .foregroundColor(color)

                Text(title)
                    .font(.title2)
                    .fontWeight(.bold)
            }

            Text(content)
                .font(.body)
                .foregroundColor(.primary)
                .fixedSize(horizontal: false, vertical: true)
        }
        .padding()
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(12)
    }
}

struct PhaseCard: View {
    let phase: String
    let description: String
    let color: Color

    var body: some View {
        HStack(spacing: 12) {
            Circle()
                .fill(color)
                .frame(width: 12, height: 12)

            VStack(alignment: .leading, spacing: 4) {
                Text(phase)
                    .font(.headline)
                    .foregroundColor(color)

                Text(description)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(Color(UIColor.tertiarySystemBackground))
        .cornerRadius(8)
    }
}

#Preview {
    RulesView()
}


// ==========================================
// FILE: Views/StatisticsView.swift
// ==========================================

import SwiftUI

struct StatisticsView: View {
    @StateObject private var saveManager = SaveManager.shared
    @Environment(\.dismiss) var dismiss

    var allSaves: [GameSave] {
        [1, 2, 3].compactMap { saveManager.loadGame(from: $0) }
    }

    var bestEncountersDefeated: Int {
        allSaves.map { $0.encountersDefeated }.max() ?? 0
    }

    var longestSurvival: Int {
        allSaves.map { $0.turnNumber }.max() ?? 0
    }

    var totalGames: Int {
        allSaves.count
    }

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 24) {
                    // Header
                    VStack(spacing: 8) {
                        Text("📊 " + L10n.statsTitle.localized)
                            .font(.largeTitle)
                            .fontWeight(.bold)
                        Text(L10n.statsGameName.localized)
                            .font(.title3)
                            .foregroundColor(.secondary)
                    }
                    .padding(.top)

                    // Overall Statistics
                    VStack(alignment: .leading, spacing: 16) {
                        Text(L10n.statsGeneral.localized)
                            .font(.headline)

                        HStack(spacing: 16) {
                            StatCard(
                                icon: "gamecontroller.fill",
                                title: L10n.statsGamesCount.localized,
                                value: "\(totalGames)",
                                color: .blue
                            )

                            StatCard(
                                icon: "trophy.fill",
                                title: L10n.statsBestResult.localized,
                                value: "\(bestEncountersDefeated)",
                                color: .orange
                            )

                            StatCard(
                                icon: "clock.fill",
                                title: L10n.statsLongestSurvival.localized,
                                value: L10n.statsTurnsCount.localized(with: longestSurvival),
                                color: .green
                            )
                        }
                    }
                    .padding()
                    .background(Color(UIColor.secondarySystemBackground))
                    .cornerRadius(12)

                    // Leaderboard
                    if !allSaves.isEmpty {
                        VStack(alignment: .leading, spacing: 16) {
                            Text(L10n.statsLeaderboard.localized)
                                .font(.headline)

                            ForEach(Array(allSaves.sorted(by: { $0.encountersDefeated > $1.encountersDefeated }).enumerated()), id: \.element.id) { index, save in
                                LeaderboardRow(
                                    rank: index + 1,
                                    save: save
                                )
                            }
                        }
                        .padding()
                        .background(Color(UIColor.secondarySystemBackground))
                        .cornerRadius(12)

                        // Detailed Game Records
                        VStack(alignment: .leading, spacing: 16) {
                            Text(L10n.statsHistory.localized)
                                .font(.headline)

                            ForEach(allSaves.sorted(by: { $0.timestamp > $1.timestamp })) { save in
                                GameRecordCard(save: save)
                            }
                        }
                        .padding()
                        .background(Color(UIColor.secondarySystemBackground))
                        .cornerRadius(12)
                    } else {
                        VStack(spacing: 12) {
                            Image(systemName: "chart.bar.xaxis")
                                .font(.system(size: 60))
                                .foregroundColor(.secondary)
                            Text(L10n.statsNoSaves.localized)
                                .font(.headline)
                                .foregroundColor(.secondary)
                            Text(L10n.statsStartHint.localized)
                                .font(.subheadline)
                                .foregroundColor(.secondary)
                                .multilineTextAlignment(.center)
                        }
                        .padding(40)
                        .background(Color(UIColor.secondarySystemBackground))
                        .cornerRadius(12)
                    }
                }
                .padding()
            }
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: { dismiss() }) {
                        Text(L10n.statsDone.localized)
                            .fontWeight(.semibold)
                    }
                }
            }
        }
    }
}

struct StatCard: View {
    let icon: String
    let title: String
    let value: String
    let color: Color

    var body: some View {
        VStack(spacing: 8) {
            Image(systemName: icon)
                .font(.title2)
                .foregroundColor(color)

            Text(value)
                .font(.title3)
                .fontWeight(.bold)

            Text(title)
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(Color(UIColor.tertiarySystemBackground))
        .cornerRadius(10)
    }
}

struct LeaderboardRow: View {
    let rank: Int
    let save: GameSave

    var rankIcon: String {
        switch rank {
        case 1: return "🥇"
        case 2: return "🥈"
        case 3: return "🥉"
        default: return "\(rank)."
        }
    }

    var body: some View {
        HStack(spacing: 12) {
            Text(rankIcon)
                .font(.title2)
                .frame(width: 40)

            VStack(alignment: .leading, spacing: 4) {
                Text(save.characterName)
                    .font(.subheadline)
                    .fontWeight(.semibold)

                HStack(spacing: 8) {
                    Label("\(save.encountersDefeated)", systemImage: "star.fill")
                        .font(.caption)
                        .foregroundColor(.orange)
                    Label("\(save.turnNumber)", systemImage: "clock.fill")
                        .font(.caption)
                        .foregroundColor(.blue)
                }
            }

            Spacer()

            VStack(alignment: .trailing, spacing: 4) {
                Text(L10n.uiSlotNumber.localized(with: save.slotNumber))
                    .font(.caption2)
                    .foregroundColor(.secondary)
                Text(save.formattedDate)
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color(UIColor.tertiarySystemBackground))
        .cornerRadius(8)
    }
}

struct GameRecordCard: View {
    let save: GameSave

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(save.characterName)
                        .font(.headline)
                    Text(L10n.uiSlotNumber.localized(with: save.slotNumber))
                        .font(.caption)
                        .foregroundColor(.secondary)
                }

                Spacer()

                Text(save.formattedDate)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }

            Divider()

            HStack(spacing: 20) {
                VStack(alignment: .leading, spacing: 4) {
                    Text(L10n.statsResources.localized)
                        .font(.caption)
                        .foregroundColor(.secondary)
                    HStack(spacing: 12) {
                        Label("\(save.health)/\(save.maxHealth)", systemImage: "heart.fill")
                            .foregroundColor(.red)
                        Label("\(save.faith)", systemImage: "sparkles")
                            .foregroundColor(.yellow)
                        Label("\(save.balance)", systemImage: "scale.3d")
                            .foregroundColor(.purple)
                    }
                    .font(.caption)
                }

                Spacer()

                VStack(alignment: .trailing, spacing: 4) {
                    Text(L10n.statsProgress.localized)
                        .font(.caption)
                        .foregroundColor(.secondary)
                    HStack(spacing: 12) {
                        VStack(alignment: .trailing, spacing: 2) {
                            Text("\(save.encountersDefeated)")
                                .font(.headline)
                            Text(L10n.statsVictoriesLabel.localized)
                                .font(.caption2)
                                .foregroundColor(.secondary)
                        }
                        VStack(alignment: .trailing, spacing: 2) {
                            Text("\(save.turnNumber)")
                                .font(.headline)
                            Text(L10n.statsTurnsLabel.localized)
                                .font(.caption2)
                                .foregroundColor(.secondary)
                        }
                    }
                }
            }
        }
        .padding()
        .background(Color(UIColor.tertiarySystemBackground))
        .cornerRadius(10)
    }
}

#Preview {
    StatisticsView()
}


// ==========================================
// FILE: Views/WorldMapView.swift
// ==========================================

import SwiftUI

struct WorldMapView: View {
    // MARK: - Engine-First Architecture
    // Engine is the ONLY source of truth for UI
    @ObservedObject var engine: TwilightGameEngine
    var onExit: (() -> Void)? = nil

    // MARK: - Legacy Support (for gradual migration)
    // These will be removed once all Views are migrated
    private var worldState: WorldState?
    private var player: Player?

    @State private var selectedRegion: EngineRegionState?
    @State private var showingExitConfirmation = false
    @State private var showingEventLog = false
    @State private var showingDayEvent = false
    @State private var currentDayEvent: DayEvent?

    // MARK: - Initialization (Engine-First)

    init(engine: TwilightGameEngine, onExit: (() -> Void)? = nil) {
        self.engine = engine
        self.onExit = onExit
        self.worldState = nil
        self.player = nil
    }

    // MARK: - Legacy Initialization (for backwards compatibility during migration)

    init(worldState: WorldState, player: Player, onExit: (() -> Void)? = nil) {
        // Create new engine connected to legacy
        let newEngine = TwilightGameEngine()
        newEngine.connectToLegacy(worldState: worldState, player: player)
        self.engine = newEngine
        self.onExit = onExit
        self.worldState = worldState
        self.player = player
    }

    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Hero Panel (persistent, consistent design across all screens)
                HeroPanel(engine: engine)
                    .padding(.horizontal, 8)
                    .padding(.top, 4)

                Divider()
                    .padding(.vertical, 4)

                // Top bar with world info
                worldInfoBar

                Divider()

                // Regions list (Engine-First: reads from engine.regionsArray)
                if engine.regionsArray.isEmpty {
                    // Show loading state if regions aren't loaded yet
                    VStack(spacing: 16) {
                        ProgressView()
                            .scaleEffect(1.5)
                        Text(L10n.worldLoading.localized)
                            .font(.headline)
                            .foregroundColor(.secondary)
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else {
                    ScrollView {
                        LazyVStack(spacing: 12) {
                            ForEach(engine.regionsArray, id: \.id) { region in
                                EngineRegionCardView(
                                    region: region,
                                    isCurrentLocation: region.id == engine.currentRegionId
                                )
                                .onTapGesture {
                                    selectedRegion = region
                                }
                            }
                        }
                        .padding()
                    }
                }
            }
            .navigationTitle(L10n.tmGameTitle.localized)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    if onExit != nil {
                        Button(action: {
                            showingExitConfirmation = true
                        }) {
                            HStack(spacing: 4) {
                                Image(systemName: "chevron.left")
                                Text(L10n.uiMenuButton.localized)
                            }
                        }
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        showingEventLog = true
                    }) {
                        Image(systemName: "book.closed")
                    }
                }
            }
            .sheet(isPresented: $showingEventLog) {
                EngineEventLogView(engine: engine)
            }
            .sheet(item: $selectedRegion) { region in
                EngineRegionDetailView(
                    region: region,
                    engine: engine,
                    onDismiss: {
                        selectedRegion = nil
                    },
                    onRegionChange: { newRegion in
                        selectedRegion = newRegion
                    }
                )
            }
            .alert(L10n.uiExit.localized + "?", isPresented: $showingExitConfirmation) {
                Button(L10n.uiCancel.localized, role: .cancel) { }
                Button(L10n.uiExit.localized, role: .destructive) {
                    onExit?()
                }
            } message: {
                Text(L10n.uiProgressSaved.localized)
            }
            .alert(currentDayEvent?.title ?? L10n.worldEvent.localized, isPresented: $showingDayEvent) {
                Button(L10n.buttonUnderstood.localized, role: .cancel) {
                    currentDayEvent = nil
                }
            } message: {
                if let event = currentDayEvent {
                    Text(L10n.dayNumber.localized(with: event.day) + "\n\n\(event.description)")
                }
            }
            .onChange(of: engine.lastDayEvent?.id) { _ in
                if let event = engine.lastDayEvent {
                    currentDayEvent = event
                    showingDayEvent = true
                    // Dismiss via Engine action (Engine-First)
                    engine.performAction(.dismissDayEvent)
                }
            }
        }
    }

    // MARK: - Player Info (now uses HeroPanel component)
    // Old playerInfoBar removed - using unified HeroPanel component instead

    // MARK: - World Info Bar (Engine-First: reads from engine.*)

    var worldInfoBar: some View {
        VStack(spacing: 8) {
            HStack {
                // World Tension
                VStack(alignment: .leading, spacing: 2) {
                    Text(L10n.tooltipBalance.localized)
                        .font(.caption2)
                        .foregroundColor(.secondary)
                    HStack(spacing: 4) {
                        Image(systemName: "exclamationmark.triangle.fill")
                            .font(.caption)
                            .foregroundColor(tensionColor)
                        Text("\(engine.worldTension)%")
                            .font(.caption)
                            .fontWeight(.bold)
                    }
                }

                Spacer()

                // World Light/Dark Balance (Явь vs Навь)
                VStack(spacing: 2) {
                    Text(L10n.worldLabel.localized)
                        .font(.caption2)
                        .foregroundColor(.secondary)
                    Text(engine.worldBalanceDescription)
                        .font(.caption)
                        .fontWeight(.bold)
                        .foregroundColor(balanceColor)
                }

                Spacer()

                // Days passed
                VStack(alignment: .trailing, spacing: 2) {
                    Text(L10n.daysInJourney.localized)
                        .font(.caption2)
                        .foregroundColor(.secondary)
                    Text("\(engine.currentDay)")
                        .font(.caption)
                        .fontWeight(.bold)
                }
            }
            .padding(.horizontal)

            // Tension progress bar
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    Rectangle()
                        .fill(Color.gray.opacity(0.2))
                        .frame(height: 4)

                    Rectangle()
                        .fill(tensionColor)
                        .frame(
                            width: geometry.size.width * CGFloat(engine.worldTension) / 100,
                            height: 4
                        )
                }
            }
            .frame(height: 4)
            .padding(.horizontal)
        }
        .padding(.vertical, 8)
        .background(Color(UIColor.systemBackground))
    }

    var tensionColor: Color {
        switch engine.worldTension {
        case 0..<30: return .green
        case 30..<60: return .yellow
        case 60..<80: return .orange
        default: return .red
        }
    }

    var balanceColor: Color {
        switch engine.lightDarkBalance {
        case 0..<30: return .purple      // Тьма
        case 30..<70: return .gray       // Нейтрально
        case 70...100: return .yellow    // Свет
        default: return .gray
        }
    }
}

// MARK: - Region Card View

struct RegionCardView: View {
    let region: Region
    let isCurrentLocation: Bool

    var body: some View {
        HStack(spacing: 12) {
            // Icon
            ZStack {
                Circle()
                    .fill(stateColor.opacity(0.2))
                    .frame(width: 60, height: 60)

                Image(systemName: region.type.icon)
                    .font(.title2)
                    .foregroundColor(stateColor)
            }

            // Info
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(region.name)
                        .font(.headline)
                        .fontWeight(.bold)

                    if isCurrentLocation {
                        Image(systemName: "location.fill")
                            .font(.caption)
                            .foregroundColor(.blue)
                    }
                }

                HStack(spacing: 8) {
                    Text(region.state.emoji)
                        .font(.caption)
                    Text(region.state.displayName)
                        .font(.caption)
                        .foregroundColor(.secondary)

                    Spacer()

                    Text(region.type.displayName)
                        .font(.caption2)
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(Color.gray.opacity(0.2))
                        .cornerRadius(4)
                }

                // Anchor info
                if let anchor = region.anchor {
                    HStack(spacing: 4) {
                        Image(systemName: anchor.type.icon)
                            .font(.caption2)
                            .foregroundColor(.orange)
                        Text(anchor.name)
                            .font(.caption2)
                            .foregroundColor(.secondary)
                        Spacer()
                        Text("\(anchor.integrity)%")
                            .font(.caption2)
                            .fontWeight(.bold)
                            .foregroundColor(anchorIntegrityColor(anchor.integrity))
                    }
                }

                // Reputation
                if region.reputation != 0 {
                    HStack(spacing: 4) {
                        Image(systemName: region.reputation > 0 ? "hand.thumbsup.fill" : "hand.thumbsdown.fill")
                            .font(.caption2)
                            .foregroundColor(region.reputation > 0 ? .green : .red)
                        Text(L10n.regionReputation.localized + ": \(region.reputation > 0 ? "+" : "")\(region.reputation)")
                            .font(.caption2)
                            .foregroundColor(.secondary)
                    }
                }
            }

            Spacer()

            // Arrow
            Image(systemName: "chevron.right")
                .font(.caption)
                .foregroundColor(.gray)
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(UIColor.secondarySystemBackground))
                .shadow(color: isCurrentLocation ? .blue.opacity(0.3) : .clear, radius: 4)
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(isCurrentLocation ? Color.blue : Color.clear, lineWidth: 2)
        )
    }

    var stateColor: Color {
        switch region.state {
        case .stable: return .green
        case .borderland: return .orange
        case .breach: return .red
        }
    }

    func anchorIntegrityColor(_ integrity: Int) -> Color {
        switch integrity {
        case 70...100: return .green
        case 30..<70: return .orange
        default: return .red
        }
    }
}

// MARK: - Region Detail View

struct RegionDetailView: View {
    let region: Region
    @ObservedObject var worldState: WorldState
    @ObservedObject var player: Player
    @ObservedObject var engine: TwilightGameEngine  // Audit v1.1 Issue #4
    let onDismiss: () -> Void
    @State private var showingActionConfirmation = false
    @State private var selectedAction: RegionAction?
    @State private var eventToShow: GameEvent?
    @State private var showingNoEventsAlert = false

    // Card received notification
    @State private var showingCardNotification = false
    @State private var receivedCardNames: [String] = []

    enum RegionAction {
        case travel
        case rest
        case trade
        case strengthenAnchor
        case explore
    }

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 20) {
                    // Region header
                    regionHeader

                    // Risk display for non-stable regions
                    if region.state != .stable {
                        riskInfoSection
                    }

                    Divider()

                    // Anchor section
                    if let anchor = region.anchor {
                        anchorSection(anchor: anchor)
                        Divider()
                    }

                    // Available actions
                    actionsSection

                    Divider()

                    // Quest info
                    if !region.activeQuests.isEmpty {
                        questsSection
                    }
                }
                .padding()
            }
            .navigationTitle(region.name)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(L10n.uiClose.localized) {
                        onDismiss()
                    }
                }
            }
            .sheet(item: $eventToShow) { event in
                EventView(
                    event: event,
                    player: player,
                    worldState: worldState,
                    regionId: region.id,
                    onChoiceSelected: { choice in
                        handleEventChoice(choice, event: event)
                    },
                    onDismiss: {
                        eventToShow = nil
                    }
                )
            }
            .alert(actionConfirmationTitle, isPresented: $showingActionConfirmation) {
                Button(L10n.buttonConfirm.localized) {
                    if let action = selectedAction {
                        performAction(action)
                    }
                }
                Button(L10n.uiCancel.localized, role: .cancel) { }
            } message: {
                Text(actionConfirmationMessage)
            }
            .alert(L10n.nothingFound.localized, isPresented: $showingNoEventsAlert) {
                Button(L10n.buttonOk.localized, role: .cancel) { }
            } message: {
                Text(L10n.noEventsInRegion.localized)
            }
            .overlay {
                // Card received notification overlay
                if showingCardNotification && !receivedCardNames.isEmpty {
                    legacyCardReceivedNotificationView
                }
            }
        }
    }

    // MARK: - Legacy Card Received Notification View

    var legacyCardReceivedNotificationView: some View {
        ZStack {
            Color.black.opacity(0.5)
                .ignoresSafeArea()
                .onTapGesture {
                    withAnimation(.easeOut(duration: 0.3)) {
                        showingCardNotification = false
                    }
                }

            VStack(spacing: 20) {
                VStack(spacing: 8) {
                    Text("🃏")
                        .font(.system(size: 48))
                    Text(L10n.cardsReceived.localized)
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.white)
                    Text(L10n.addedToDeck.localized)
                        .font(.subheadline)
                        .foregroundColor(.white.opacity(0.8))
                }

                VStack(spacing: 12) {
                    ForEach(receivedCardNames, id: \.self) { cardName in
                        HStack {
                            Image(systemName: "rectangle.stack.badge.plus")
                                .foregroundColor(.yellow)
                            Text(cardName)
                                .fontWeight(.semibold)
                                .foregroundColor(.white)
                        }
                        .padding(.horizontal, 16)
                        .padding(.vertical, 10)
                        .background(
                            RoundedRectangle(cornerRadius: 8)
                                .fill(Color.purple.opacity(0.6))
                        )
                    }
                }

                Button(action: {
                    withAnimation(.easeOut(duration: 0.3)) {
                        showingCardNotification = false
                    }
                }) {
                    Text(L10n.buttonGreat.localized)
                        .font(.headline)
                        .foregroundColor(.white)
                        .frame(minWidth: 120)
                        .padding()
                        .background(Color.blue)
                        .cornerRadius(12)
                }
            }
            .padding(24)
            .background(
                RoundedRectangle(cornerRadius: 20)
                    .fill(Color(UIColor.systemBackground).opacity(0.95))
                    .shadow(radius: 20)
            )
            .transition(.scale.combined(with: .opacity))
        }
    }

    // MARK: - Region Header

    var regionHeader: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Image(systemName: region.type.icon)
                    .font(.largeTitle)
                    .foregroundColor(stateColor)

                VStack(alignment: .leading) {
                    Text(region.type.displayName)
                        .font(.subheadline)
                        .foregroundColor(.secondary)

                    HStack {
                        Text(region.state.emoji)
                        Text(region.state.displayName)
                            .font(.title3)
                            .fontWeight(.bold)
                            .foregroundColor(stateColor)
                    }
                }

                Spacer()

                // Индикатор текущей локации
                if isPlayerHere {
                    HStack(spacing: 4) {
                        Image(systemName: "person.fill")
                        Text(L10n.youAreHere.localized)
                    }
                    .font(.caption)
                    .fontWeight(.bold)
                    .foregroundColor(.white)
                    .padding(.horizontal, 10)
                    .padding(.vertical, 6)
                    .background(Color.blue)
                    .cornerRadius(12)
                }
            }

            Text(regionDescription)
                .font(.body)
                .foregroundColor(.secondary)
        }
    }

    var regionDescription: String {
        switch region.state {
        case .stable:
            return L10n.regionDescStable.localized
        case .borderland:
            return L10n.regionDescBorderland.localized
        case .breach:
            return L10n.regionDescBreach.localized
        }
    }

    // MARK: - Risk Info Section

    var riskInfoSection: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Image(systemName: "exclamationmark.triangle.fill")
                    .foregroundColor(region.state == .breach ? .red : .orange)
                Text(L10n.combatModifiers.localized)
                    .font(.caption)
                    .fontWeight(.bold)
            }

            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(L10n.enemyStrength.localized + ":")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("+\(region.state.enemyPowerBonus)")
                        .font(.caption)
                        .fontWeight(.bold)
                        .foregroundColor(.red)
                }

                HStack {
                    Text(L10n.enemyDefense.localized + ":")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("+\(region.state.enemyDefenseBonus)")
                        .font(.caption)
                        .fontWeight(.bold)
                        .foregroundColor(.red)
                }

                HStack {
                    Text(L10n.enemyHealth.localized + ":")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("+\(region.state.enemyHealthBonus)")
                        .font(.caption)
                        .fontWeight(.bold)
                        .foregroundColor(.red)
                }
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(region.state == .breach ? Color.red.opacity(0.1) : Color.orange.opacity(0.1))
        )
    }

    // MARK: - Anchor Section

    func anchorSection(anchor: Anchor) -> some View {
        VStack(alignment: .leading, spacing: 12) {
            Text(L10n.anchorOfYav.localized)
                .font(.headline)

            HStack(spacing: 12) {
                Image(systemName: anchor.type.icon)
                    .font(.title)
                    .foregroundColor(.orange)
                    .frame(width: 50, height: 50)
                    .background(Circle().fill(Color.orange.opacity(0.2)))

                VStack(alignment: .leading, spacing: 4) {
                    Text(anchor.name)
                        .font(.subheadline)
                        .fontWeight(.bold)

                    Text(anchor.type.displayName)
                        .font(.caption)
                        .foregroundColor(.secondary)

                    // Integrity bar
                    HStack(spacing: 4) {
                        Text(L10n.anchorIntegrity.localized + ":")
                            .font(.caption2)
                        GeometryReader { geometry in
                            ZStack(alignment: .leading) {
                                Rectangle()
                                    .fill(Color.gray.opacity(0.2))
                                    .frame(height: 6)

                                Rectangle()
                                    .fill(anchorIntegrityColor(anchor.integrity))
                                    .frame(
                                        width: geometry.size.width * CGFloat(anchor.integrity) / 100,
                                        height: 6
                                    )
                            }
                        }
                        .frame(height: 6)

                        Text("\(anchor.integrity)%")
                            .font(.caption2)
                            .fontWeight(.bold)
                            .foregroundColor(anchorIntegrityColor(anchor.integrity))
                    }

                    // Influence
                    HStack(spacing: 4) {
                        Text(L10n.anchorInfluence.localized + ":")
                            .font(.caption2)
                        Text(influenceText(anchor.influence))
                            .font(.caption2)
                            .fontWeight(.bold)
                            .foregroundColor(influenceColor(anchor.influence))
                    }
                }
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(Color(UIColor.tertiarySystemBackground))
            )
        }
    }

    func influenceText(_ influence: CardBalance) -> String {
        switch influence {
        case .light: return L10n.balanceLight.localized
        case .neutral: return L10n.balanceNeutral.localized
        case .dark: return L10n.balanceDark.localized
        }
    }

    func influenceColor(_ influence: CardBalance) -> Color {
        switch influence {
        case .light: return .yellow
        case .neutral: return .gray
        case .dark: return .purple
        }
    }

    // MARK: - Actions Section

    /// Проверка, находится ли игрок в этом регионе
    var isPlayerHere: Bool {
        region.id == worldState.currentRegionId
    }

    var actionsSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text(L10n.availableActions.localized)
                .font(.headline)

            VStack(spacing: 8) {
                // Travel action - только если игрок НЕ здесь
                if !isPlayerHere {
                    let travelCost = worldState.calculateTravelCost(to: region.id)
                    let dayWord = travelCost == 1 ? L10n.dayWord1.localized : L10n.dayWord234.localized
                    let canTravel = region.isNeighbor(worldState.currentRegionId ?? UUID())

                    actionButton(
                        title: canTravel ? L10n.actionTravelTo.localized(with: travelCost, dayWord) : L10n.actionRegionFar.localized,
                        icon: canTravel ? "arrow.right.circle.fill" : "xmark.circle",
                        color: canTravel ? .blue : .gray,
                        enabled: canTravel
                    ) {
                        selectedAction = .travel
                        showingActionConfirmation = true
                    }

                    // Сообщение о необходимости переместиться
                    if canTravel {
                        HStack {
                            Image(systemName: "info.circle")
                                .foregroundColor(.secondary)
                            Text(L10n.actionMoveToRegionHint.localized)
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        .padding(.vertical, 8)
                    } else {
                        HStack {
                            Image(systemName: "map")
                                .foregroundColor(.orange)
                            Text(L10n.actionRegionNotDirectlyAccessible.localized)
                                .font(.caption)
                                .foregroundColor(.orange)
                        }
                        .padding(.vertical, 8)
                    }
                }

                // Действия доступны ТОЛЬКО если игрок находится в регионе
                if isPlayerHere {
                    // Rest action
                    actionButton(
                        title: L10n.actionRestHeal.localized(with: 5),
                        icon: "bed.double.fill",
                        color: .green,
                        enabled: region.canRest
                    ) {
                        selectedAction = .rest
                        showingActionConfirmation = true
                    }

                    // Trade action
                    actionButton(
                        title: L10n.actionTradeName.localized,
                        icon: "cart.fill",
                        color: .orange,
                        enabled: region.canTrade
                    ) {
                        selectedAction = .trade
                        showingActionConfirmation = true
                    }

                    // Strengthen anchor
                    if region.anchor != nil {
                        actionButton(
                            title: L10n.actionAnchorCost.localized(with: 10, 20),
                            icon: "hammer.fill",
                            color: .purple,
                            enabled: player.faith >= 10
                        ) {
                            selectedAction = .strengthenAnchor
                            showingActionConfirmation = true
                        }
                    }

                    // Explore (only if events available)
                    let hasEvents = worldState.getAvailableEvents(for: region).count > 0
                    actionButton(
                        title: L10n.actionExploreName.localized,
                        icon: "magnifyingglass",
                        color: .cyan,
                        enabled: hasEvents
                    ) {
                        triggerExploration()
                    }
                }
            }
        }
    }

    func actionButton(
        title: String,
        icon: String,
        color: Color,
        enabled: Bool,
        action: @escaping () -> Void
    ) -> some View {
        Button(action: action) {
            HStack {
                Image(systemName: icon)
                    .font(.body)
                Text(title)
                    .font(.body)
                Spacer()
            }
            .padding()
            .foregroundColor(enabled ? .white : .gray)
            .background(enabled ? color : Color.gray.opacity(0.3))
            .cornerRadius(10)
        }
        .disabled(!enabled)
    }

    // MARK: - Quests Section

    var questsSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text(L10n.activeQuestsInRegion.localized)
                .font(.headline)

            ForEach(region.activeQuests, id: \.self) { questId in
                if let quest = worldState.activeQuests.first(where: { $0.id.uuidString == questId }) {
                    questView(quest)
                }
            }
        }
    }

    func questView(_ quest: Quest) -> some View {
        VStack(alignment: .leading, spacing: 8) {
            // Quest title
            HStack {
                Image(systemName: quest.questType == .main ? "star.fill" : "scroll.fill")
                    .foregroundColor(quest.questType == .main ? .yellow : .blue)
                Text(quest.title)
                    .font(.headline)
                    .foregroundColor(.primary)
            }

            // Quest description
            Text(quest.description)
                .font(.caption)
                .foregroundColor(.secondary)
                .lineLimit(2)

            // Objectives
            VStack(alignment: .leading, spacing: 4) {
                ForEach(quest.objectives) { objective in
                    HStack(spacing: 8) {
                        Image(systemName: objective.completed ? "checkmark.circle.fill" : "circle")
                            .foregroundColor(objective.completed ? .green : .gray)
                            .font(.caption)
                        Text(objective.description)
                            .font(.caption)
                            .foregroundColor(objective.completed ? .secondary : .primary)
                            .strikethrough(objective.completed)
                    }
                }
            }
            .padding(.leading, 8)

            // Progress indicator
            let completedCount = quest.objectives.filter { $0.completed }.count
            let totalCount = quest.objectives.count
            if totalCount > 0 {
                HStack(spacing: 4) {
                    Text(L10n.questProgress.localized + ":")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                    Text("\(completedCount)/\(totalCount)")
                        .font(.caption2)
                        .fontWeight(.bold)
                        .foregroundColor(completedCount == totalCount ? .green : .orange)
                }
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(quest.questType == .main ? Color.yellow.opacity(0.15) : Color.blue.opacity(0.1))
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(quest.questType == .main ? Color.yellow.opacity(0.5) : Color.blue.opacity(0.3), lineWidth: 1)
        )
    }

    // MARK: - Helpers

    var stateColor: Color {
        switch region.state {
        case .stable: return .green
        case .borderland: return .orange
        case .breach: return .red
        }
    }

    func anchorIntegrityColor(_ integrity: Int) -> Color {
        switch integrity {
        case 70...100: return .green
        case 30..<70: return .orange
        default: return .red
        }
    }

    // MARK: - Event Handling

    func triggerExploration() {
        // Get available events for this region (with tension and flag filtering)
        let availableEvents = worldState.getAvailableEvents(for: region)

        print("DEBUG: Region: \(region.name), Type: \(region.type), State: \(region.state)")
        print("DEBUG: World tension: \(worldState.worldTension)")
        print("DEBUG: Available events count: \(availableEvents.count)")
        for event in availableEvents {
            print("DEBUG: - Event: \(event.title) (weight: \(event.weight))")
        }

        // Weighted random selection
        if let selectedEvent = worldState.selectWeightedRandomEvent(from: availableEvents) {
            eventToShow = selectedEvent
        } else {
            // No events available - show alert
            showingNoEventsAlert = true
        }
    }

    func handleEventChoice(_ choice: EventChoice, event: GameEvent) {
        // Check for card rewards before processing
        var cardsToNotify: [String] = []
        if let cardIDs = choice.consequences.addCards {
            for cardID in cardIDs {
                if let card = CardFactory.shared.getCard(id: cardID) {
                    cardsToNotify.append(card.name)
                }
            }
        }

        // Apply consequences
        worldState.applyConsequences(
            choice.consequences,
            to: player,
            in: region.id
        )

        // Quest progress now handled by QuestTriggerEngine via completedEvent action

        // Mark event as completed if it's one-time
        if event.oneTime {
            worldState.markEventCompleted(event.id)
        }

        // Записать событие в журнал
        let logType: EventLogType = event.eventType == .combat ? .combat : .exploration
        let outcomeMessage = choice.consequences.message ?? L10n.journalChoiceMade.localized
        worldState.logEvent(
            regionName: region.name,
            eventTitle: event.title,
            choiceMade: choice.text,
            outcome: outcomeMessage,
            type: logType
        )

        // Исследование события тратит день (кроме instant событий)
        if !event.instant {
            worldState.advanceDayForUI()
        }

        // Show card received notification if cards were gained
        if !cardsToNotify.isEmpty {
            receivedCardNames = cardsToNotify
            // Delay slightly to allow event sheet to dismiss first
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                    showingCardNotification = true
                }
            }
        }
    }

    // MARK: - Action Handling

    var actionConfirmationTitle: String {
        guard let action = selectedAction else { return L10n.confirmationTitle.localized }
        switch action {
        case .travel: return L10n.actionTravel.localized
        case .rest: return L10n.actionRest.localized
        case .trade: return L10n.actionTrade.localized
        case .strengthenAnchor: return L10n.actionStrengthenAnchor.localized
        case .explore: return L10n.actionExploreRegion.localized
        }
    }

    var actionConfirmationMessage: String {
        guard let action = selectedAction else { return "" }
        switch action {
        case .travel:
            let cost = worldState.calculateTravelCost(to: region.id)
            let dayWord = cost == 1 ? L10n.dayWord1.localized : L10n.dayWord234.localized
            return L10n.confirmTravel.localized(with: region.name, cost, dayWord)
        case .rest:
            return L10n.confirmRest.localized(with: 5)
        case .trade:
            return L10n.confirmTrade.localized
        case .strengthenAnchor:
            return L10n.confirmStrengthenAnchor.localized(with: 10, 20)
        case .explore:
            return L10n.confirmExplore.localized
        }
    }

    // MARK: - Actions via Engine (Audit v1.1 Issue #4)

    func performAction(_ action: RegionAction) {
        switch action {
        case .travel:
            // Use Engine for travel (Audit v1.1)
            let fromRegion = worldState.getCurrentRegion()?.name ?? L10n.regionUnknown.localized
            let result = engine.performAction(.travel(toRegionId: region.id))

            if result.success {
                // Log travel (legacy logging still supported)
                let cost = worldState.calculateTravelCost(to: region.id)
                worldState.logTravel(from: fromRegion, to: region.name, days: cost)
                // Quest progress now handled by QuestTriggerEngine via visitedRegion action
            }
            onDismiss()

        case .rest:
            // Use Engine for rest (Audit v1.1)
            let result = engine.performAction(.rest)

            if result.success {
                worldState.logEvent(
                    regionName: region.name,
                    eventTitle: L10n.journalRestTitle.localized,
                    choiceMade: L10n.journalRestChoice.localized,
                    outcome: L10n.journalRestOutcome.localized,
                    type: .exploration
                )
            }

        case .trade:
            // Phase 4: Implement trade/market view
            break

        case .strengthenAnchor:
            // Use Engine for strengthen anchor (Audit v1.1)
            let result = engine.performAction(.strengthenAnchor)

            if result.success {
                worldState.logEvent(
                    regionName: region.name,
                    eventTitle: L10n.journalAnchorTitle.localized,
                    choiceMade: L10n.journalAnchorChoice.localized,
                    outcome: L10n.journalAnchorOutcome.localized,
                    type: .worldChange
                )
            }

        case .explore:
            // This is handled separately by triggerExploration()
            break
        }
    }
}

// MARK: - Event Log View

struct EventLogView: View {
    @ObservedObject var worldState: WorldState
    @Environment(\.dismiss) var dismiss

    var body: some View {
        NavigationView {
            List {
                if worldState.eventLog.isEmpty {
                    Text(L10n.journalEmpty.localized)
                        .foregroundColor(.secondary)
                        .padding()
                } else {
                    ForEach(worldState.eventLog.reversed()) { entry in
                        EventLogEntryView(entry: entry)
                    }
                }
            }
            .navigationTitle(L10n.journalTitle.localized)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(L10n.uiClose.localized) {
                        dismiss()
                    }
                }
            }
        }
    }
}

struct EventLogEntryView: View {
    let entry: EventLogEntry

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // Header
            HStack {
                Image(systemName: entry.type.icon)
                    .foregroundColor(typeColor)

                Text(L10n.dayNumber.localized(with: entry.dayNumber))
                    .font(.caption)
                    .fontWeight(.bold)

                Spacer()

                Text(entry.regionName)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }

            // Event title
            Text(entry.eventTitle)
                .font(.subheadline)
                .fontWeight(.semibold)

            // Choice made
            HStack {
                Image(systemName: "arrow.turn.down.right")
                    .font(.caption2)
                    .foregroundColor(.secondary)
                Text(entry.choiceMade)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }

            // Outcome
            Text(entry.outcome)
                .font(.caption)
                .italic()
        }
        .padding(.vertical, 4)
    }

    var typeColor: Color {
        switch entry.type {
        case .combat: return .red
        case .exploration: return .blue
        case .choice: return .orange
        case .quest: return .purple
        case .travel: return .green
        case .worldChange: return .yellow
        }
    }
}

// MARK: - Engine-First Region Card View

struct EngineRegionCardView: View {
    let region: EngineRegionState
    let isCurrentLocation: Bool

    var body: some View {
        HStack(spacing: 12) {
            // Icon
            ZStack {
                Circle()
                    .fill(stateColor.opacity(0.2))
                    .frame(width: 60, height: 60)

                Image(systemName: region.type.icon)
                    .font(.title2)
                    .foregroundColor(stateColor)
            }

            // Info
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(region.name)
                        .font(.headline)
                        .fontWeight(.bold)

                    if isCurrentLocation {
                        Image(systemName: "location.fill")
                            .font(.caption)
                            .foregroundColor(.blue)
                    }
                }

                HStack(spacing: 8) {
                    Text(region.state.emoji)
                        .font(.caption)
                    Text(region.state.displayName)
                        .font(.caption)
                        .foregroundColor(.secondary)

                    Spacer()

                    Text(region.type.displayName)
                        .font(.caption2)
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(Color.gray.opacity(0.2))
                        .cornerRadius(4)
                }

                // Anchor info
                if let anchor = region.anchor {
                    HStack(spacing: 4) {
                        Image(systemName: "flame")
                            .font(.caption2)
                            .foregroundColor(.orange)
                        Text(anchor.name)
                            .font(.caption2)
                            .foregroundColor(.secondary)
                        Spacer()
                        Text("\(anchor.integrity)%")
                            .font(.caption2)
                            .fontWeight(.bold)
                            .foregroundColor(anchorIntegrityColor(anchor.integrity))
                    }
                }

                // Reputation
                if region.reputation != 0 {
                    HStack(spacing: 4) {
                        Image(systemName: region.reputation > 0 ? "hand.thumbsup.fill" : "hand.thumbsdown.fill")
                            .font(.caption2)
                            .foregroundColor(region.reputation > 0 ? .green : .red)
                        Text(L10n.regionReputation.localized + ": \(region.reputation > 0 ? "+" : "")\(region.reputation)")
                            .font(.caption2)
                            .foregroundColor(.secondary)
                    }
                }
            }

            Spacer()

            // Arrow
            Image(systemName: "chevron.right")
                .font(.caption)
                .foregroundColor(.gray)
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(UIColor.secondarySystemBackground))
                .shadow(color: isCurrentLocation ? .blue.opacity(0.3) : .clear, radius: 4)
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(isCurrentLocation ? Color.blue : Color.clear, lineWidth: 2)
        )
    }

    var stateColor: Color {
        switch region.state {
        case .stable: return .green
        case .borderland: return .orange
        case .breach: return .red
        }
    }

    func anchorIntegrityColor(_ integrity: Int) -> Color {
        switch integrity {
        case 70...100: return .green
        case 30..<70: return .orange
        default: return .red
        }
    }
}

// MARK: - Engine-First Region Detail View

struct EngineRegionDetailView: View {
    let region: EngineRegionState
    @ObservedObject var engine: TwilightGameEngine
    let onDismiss: () -> Void
    var onRegionChange: ((EngineRegionState?) -> Void)? = nil

    @State private var showingActionConfirmation = false
    @State private var selectedAction: EngineRegionAction?
    @State private var eventToShow: GameEvent?
    @State private var showingNoEventsAlert = false
    @State private var showingActionError = false
    @State private var actionErrorMessage = ""

    // Card received notification
    @State private var showingCardNotification = false
    @State private var receivedCardNames: [String] = []

    enum EngineRegionAction {
        case travel
        case rest
        case trade
        case strengthenAnchor
        case explore
    }

    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Hero Panel (persistent, consistent design across all screens)
                HeroPanel(engine: engine)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)

                ScrollView {
                    VStack(alignment: .leading, spacing: 20) {
                        // Region header
                        regionHeader

                        // Risk display for non-stable regions
                        if region.state != .stable {
                            riskInfoSection
                        }

                        Divider()

                        // Anchor section
                        if let anchor = region.anchor {
                            anchorSection(anchor: anchor)
                            Divider()
                        }

                        // Available actions
                        actionsSection
                    }
                    .padding()
                }
            }
            .navigationTitle(region.name)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(L10n.uiClose.localized) {
                        onDismiss()
                    }
                }
            }
            .alert(actionConfirmationTitle, isPresented: $showingActionConfirmation) {
                Button(L10n.buttonConfirm.localized) {
                    if let action = selectedAction {
                        performAction(action)
                    }
                }
                Button(L10n.uiCancel.localized, role: .cancel) { }
            } message: {
                Text(actionConfirmationMessage)
            }
            .alert(L10n.nothingFound.localized, isPresented: $showingNoEventsAlert) {
                Button(L10n.buttonUnderstood.localized, role: .cancel) { }
            } message: {
                Text(L10n.noEventsInRegion.localized)
            }
            .alert(L10n.actionImpossible.localized, isPresented: $showingActionError) {
                Button(L10n.buttonUnderstood.localized, role: .cancel) { }
            } message: {
                Text(actionErrorMessage)
            }
            .sheet(item: $eventToShow) { event in
                EventView(
                    engine: engine,
                    event: event,
                    regionId: region.id,
                    onChoiceSelected: { choice in
                        handleEventChoice(choice, event: event)
                    },
                    onDismiss: {
                        eventToShow = nil
                        // Dismiss current event in engine
                        engine.performAction(.dismissCurrentEvent)
                    }
                )
            }
            .onChange(of: engine.currentEvent?.id) { _ in
                // When engine triggers an event, show it
                if let event = engine.currentEvent {
                    eventToShow = event
                }
            }
            .overlay {
                // Card received notification overlay
                if showingCardNotification && !receivedCardNames.isEmpty {
                    cardReceivedNotificationView
                }
            }
        }
    }

    // MARK: - Card Received Notification View

    var cardReceivedNotificationView: some View {
        ZStack {
            // Semi-transparent background
            Color.black.opacity(0.5)
                .ignoresSafeArea()
                .onTapGesture {
                    withAnimation(.easeOut(duration: 0.3)) {
                        showingCardNotification = false
                    }
                }

            VStack(spacing: 20) {
                // Header
                VStack(spacing: 8) {
                    Text("🃏")
                        .font(.system(size: 48))

                    Text(L10n.cardsReceived.localized)
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.white)

                    Text(L10n.addedToDeck.localized)
                        .font(.subheadline)
                        .foregroundColor(.white.opacity(0.8))
                }

                // Cards list
                VStack(spacing: 12) {
                    ForEach(receivedCardNames, id: \.self) { cardName in
                        HStack {
                            Image(systemName: "rectangle.stack.badge.plus")
                                .foregroundColor(.yellow)
                            Text(cardName)
                                .fontWeight(.semibold)
                                .foregroundColor(.white)
                        }
                        .padding(.horizontal, 16)
                        .padding(.vertical, 10)
                        .background(
                            RoundedRectangle(cornerRadius: 8)
                                .fill(Color.purple.opacity(0.6))
                        )
                    }
                }

                // Dismiss button
                Button(action: {
                    withAnimation(.easeOut(duration: 0.3)) {
                        showingCardNotification = false
                    }
                }) {
                    Text(L10n.buttonGreat.localized)
                        .font(.headline)
                        .foregroundColor(.white)
                        .frame(minWidth: 120)
                        .padding()
                        .background(Color.blue)
                        .cornerRadius(12)
                }
            }
            .padding(24)
            .background(
                RoundedRectangle(cornerRadius: 20)
                    .fill(Color(UIColor.systemBackground).opacity(0.95))
                    .shadow(radius: 20)
            )
            .transition(.scale.combined(with: .opacity))
        }
    }

    // MARK: - Region Header

    var regionHeader: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Image(systemName: region.type.icon)
                    .font(.largeTitle)
                    .foregroundColor(stateColor)

                VStack(alignment: .leading) {
                    Text(region.type.displayName)
                        .font(.subheadline)
                        .foregroundColor(.secondary)

                    HStack {
                        Text(region.state.emoji)
                        Text(region.state.displayName)
                            .font(.title3)
                            .fontWeight(.bold)
                            .foregroundColor(stateColor)
                    }
                }

                Spacer()

                // Current location indicator
                if isPlayerHere {
                    HStack(spacing: 4) {
                        Image(systemName: "person.fill")
                        Text(L10n.youAreHere.localized)
                    }
                    .font(.caption)
                    .fontWeight(.bold)
                    .foregroundColor(.white)
                    .padding(.horizontal, 10)
                    .padding(.vertical, 6)
                    .background(Color.blue)
                    .cornerRadius(12)
                }
            }

            Text(regionDescription)
                .font(.body)
                .foregroundColor(.secondary)
        }
    }

    var regionDescription: String {
        switch region.state {
        case .stable:
            return L10n.regionDescStable.localized
        case .borderland:
            return L10n.regionDescBorderland.localized
        case .breach:
            return L10n.regionDescBreach.localized
        }
    }

    // MARK: - Risk Info Section

    var riskInfoSection: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Image(systemName: "exclamationmark.triangle.fill")
                    .foregroundColor(region.state == .breach ? .red : .orange)
                Text(L10n.warningTitle.localized)
                    .font(.caption)
                    .fontWeight(.bold)
            }

            Text(L10n.warningHighDanger.localized)
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(region.state == .breach ? Color.red.opacity(0.1) : Color.orange.opacity(0.1))
        )
    }

    // MARK: - Anchor Section

    func anchorSection(anchor: EngineAnchorState) -> some View {
        VStack(alignment: .leading, spacing: 12) {
            Text(L10n.anchorOfYav.localized)
                .font(.headline)

            HStack(spacing: 12) {
                Image(systemName: "flame")
                    .font(.title)
                    .foregroundColor(.orange)
                    .frame(width: 50, height: 50)
                    .background(Circle().fill(Color.orange.opacity(0.2)))

                VStack(alignment: .leading, spacing: 4) {
                    Text(anchor.name)
                        .font(.subheadline)
                        .fontWeight(.bold)

                    // Integrity bar
                    HStack(spacing: 4) {
                        Text(L10n.anchorIntegrity.localized + ":")
                            .font(.caption2)
                        GeometryReader { geometry in
                            ZStack(alignment: .leading) {
                                Rectangle()
                                    .fill(Color.gray.opacity(0.2))
                                    .frame(height: 6)

                                Rectangle()
                                    .fill(anchorIntegrityColor(anchor.integrity))
                                    .frame(
                                        width: geometry.size.width * CGFloat(anchor.integrity) / 100,
                                        height: 6
                                    )
                            }
                        }
                        .frame(height: 6)

                        Text("\(anchor.integrity)%")
                            .font(.caption2)
                            .fontWeight(.bold)
                            .foregroundColor(anchorIntegrityColor(anchor.integrity))
                    }
                }
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(Color(UIColor.tertiarySystemBackground))
            )
        }
    }

    // MARK: - Actions Section

    var isPlayerHere: Bool {
        region.id == engine.currentRegionId
    }

    var actionsSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text(L10n.availableActions.localized)
                .font(.headline)

            VStack(spacing: 8) {
                // Travel action - only if player is NOT here
                if !isPlayerHere {
                    let canTravel = engine.canTravelTo(regionId: region.id)
                    let routingHint = engine.getRoutingHint(to: region.id)
                    let travelCost = engine.calculateTravelCost(to: region.id)
                    let dayWord = travelCost == 1 ? L10n.dayWord1.localized : L10n.dayWord234.localized

                    actionButton(
                        title: canTravel ? L10n.actionTravelTo.localized(with: travelCost, dayWord) : L10n.actionRegionFar.localized,
                        icon: canTravel ? "arrow.right.circle.fill" : "xmark.circle",
                        color: canTravel ? .blue : .gray,
                        enabled: canTravel
                    ) {
                        selectedAction = .travel
                        showingActionConfirmation = true
                    }

                    if canTravel {
                        HStack {
                            Image(systemName: "info.circle")
                                .foregroundColor(.secondary)
                            Text(L10n.actionMoveToRegionHint.localized)
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        .padding(.vertical, 8)
                    } else {
                        // Show routing hint for distant regions
                        HStack {
                            Image(systemName: "map")
                                .foregroundColor(.orange)
                            if !routingHint.isEmpty {
                                Text(L10n.goThroughFirst.localized(with: routingHint.joined(separator: ", ")))
                                    .font(.caption)
                                    .foregroundColor(.orange)
                            } else {
                                Text(L10n.actionRegionNotDirectlyAccessible.localized)
                                    .font(.caption)
                                    .foregroundColor(.orange)
                            }
                        }
                        .padding(.vertical, 8)
                    }
                }

                // Actions available ONLY if player is in the region
                if isPlayerHere {
                    // Rest action
                    actionButton(
                        title: L10n.actionRestHeal.localized(with: 3),
                        icon: "bed.double.fill",
                        color: .green,
                        enabled: region.canRest
                    ) {
                        selectedAction = .rest
                        showingActionConfirmation = true
                    }

                    // Trade action
                    actionButton(
                        title: L10n.actionTradeName.localized,
                        icon: "cart.fill",
                        color: .orange,
                        enabled: region.canTrade
                    ) {
                        selectedAction = .trade
                        showingActionConfirmation = true
                    }

                    // Strengthen anchor
                    if region.anchor != nil {
                        actionButton(
                            title: L10n.actionAnchorCost.localized(with: 5, 20),
                            icon: "hammer.fill",
                            color: .purple,
                            enabled: engine.canAffordFaith(5)
                        ) {
                            selectedAction = .strengthenAnchor
                            showingActionConfirmation = true
                        }
                    }

                    // Explore (only if events available)
                    let hasEvents = engine.hasAvailableEventsInCurrentRegion()
                    actionButton(
                        title: L10n.actionExploreName.localized,
                        icon: "magnifyingglass",
                        color: .cyan,
                        enabled: hasEvents
                    ) {
                        selectedAction = .explore
                        showingActionConfirmation = true
                    }
                }
            }
        }
    }

    func actionButton(
        title: String,
        icon: String,
        color: Color,
        enabled: Bool,
        action: @escaping () -> Void
    ) -> some View {
        Button(action: action) {
            HStack {
                Image(systemName: icon)
                    .font(.body)
                Text(title)
                    .font(.body)
                Spacer()
            }
            .padding()
            .foregroundColor(enabled ? .white : .gray)
            .background(enabled ? color : Color.gray.opacity(0.3))
            .cornerRadius(10)
        }
        .disabled(!enabled)
    }

    // MARK: - Helpers

    var stateColor: Color {
        switch region.state {
        case .stable: return .green
        case .borderland: return .orange
        case .breach: return .red
        }
    }

    func anchorIntegrityColor(_ integrity: Int) -> Color {
        switch integrity {
        case 70...100: return .green
        case 30..<70: return .orange
        default: return .red
        }
    }

    // MARK: - Action Handling

    var actionConfirmationTitle: String {
        guard let action = selectedAction else { return L10n.confirmationTitle.localized }
        switch action {
        case .travel: return L10n.actionTravel.localized
        case .rest: return L10n.actionRest.localized
        case .trade: return L10n.actionTrade.localized
        case .strengthenAnchor: return L10n.actionStrengthenAnchor.localized
        case .explore: return L10n.actionExploreRegion.localized
        }
    }

    var actionConfirmationMessage: String {
        guard let action = selectedAction else { return "" }
        switch action {
        case .travel:
            let days = engine.calculateTravelCost(to: region.id)
            let dayWord = days == 1 ? L10n.dayWord1.localized : L10n.dayWord234.localized
            return L10n.confirmTravel.localized(with: region.name, days, dayWord)
        case .rest:
            return L10n.confirmRest.localized(with: 3)
        case .trade:
            return L10n.confirmTrade.localized
        case .strengthenAnchor:
            return L10n.confirmStrengthenAnchor.localized(with: 5, 20)
        case .explore:
            return L10n.confirmExplore.localized
        }
    }

    // MARK: - Actions via Engine

    func performAction(_ action: EngineRegionAction) {
        switch action {
        case .travel:
            let result = engine.performAction(.travel(toRegionId: region.id))
            if result.success {
                engine.addLogEntry(
                    regionName: region.name,
                    eventTitle: L10n.journalEntryTravel.localized,
                    choiceMade: L10n.journalEntryTravelChoice.localized,
                    outcome: L10n.journalEntryTravelOutcome.localized(with: region.name),
                    type: .travel
                )
                // После перемещения показываем новый регион (текущую локацию)
                if let newRegion = engine.regionsArray.first(where: { $0.id == engine.currentRegionId }) {
                    onRegionChange?(newRegion)
                } else {
                    onDismiss()
                }
            } else {
                // Show error to user
                actionErrorMessage = errorMessage(for: result.error)
                showingActionError = true
            }

        case .rest:
            let result = engine.performAction(.rest)
            if result.success {
                engine.addLogEntry(
                    regionName: region.name,
                    eventTitle: L10n.journalRestTitle.localized,
                    choiceMade: L10n.journalRestChoice.localized,
                    outcome: L10n.journalRestOutcome.localized,
                    type: .exploration
                )
            }

        case .trade:
            // Phase 4: Implement trade/market view
            break

        case .strengthenAnchor:
            let result = engine.performAction(.strengthenAnchor)
            if result.success {
                engine.addLogEntry(
                    regionName: region.name,
                    eventTitle: L10n.journalAnchorTitle.localized,
                    choiceMade: L10n.journalAnchorChoice.localized,
                    outcome: L10n.journalAnchorOutcome.localized,
                    type: .worldChange
                )
            }

        case .explore:
            let result = engine.performAction(.explore)
            if result.success {
                // Check if an event was triggered
                if result.currentEvent == nil {
                    // No event available - show alert
                    showingNoEventsAlert = true
                    engine.addLogEntry(
                        regionName: region.name,
                        eventTitle: L10n.journalEntryExplore.localized,
                        choiceMade: L10n.journalEntryExploreChoice.localized,
                        outcome: L10n.journalEntryExploreNothing.localized,
                        type: .exploration
                    )
                }
                // If event was triggered, it will be shown via onChange of engine.currentEvent
            }
        }
    }

    // MARK: - Error Messages

    func errorMessage(for error: ActionError?) -> String {
        guard let error = error else { return L10n.errorUnknown.localized }
        switch error {
        case .regionNotNeighbor:
            return L10n.errorRegionFar.localized
        case .regionNotAccessible:
            return L10n.errorRegionInaccessible.localized
        case .healthTooLow:
            return L10n.errorHealthLow.localized
        case .insufficientResources(let resource, let required, let available):
            return L10n.errorInsufficientResource.localized(with: resource, required, available)
        case .invalidAction(let reason):
            return reason
        case .combatInProgress:
            return L10n.errorInCombat.localized
        case .eventInProgress:
            return L10n.errorFinishEvent.localized
        default:
            return L10n.errorActionFailed.localized(with: "\(error)")
        }
    }

    // MARK: - Event Choice Handling

    func handleEventChoice(_ choice: EventChoice, event: GameEvent) {
        // Check for card rewards before processing
        var cardsToNotify: [String] = []
        if let cardIDs = choice.consequences.addCards {
            for cardID in cardIDs {
                if let card = CardFactory.shared.getCard(id: cardID) {
                    cardsToNotify.append(card.name)
                }
            }
        }

        // Execute choice via engine
        if let choiceIndex = event.choices.firstIndex(where: { $0.id == choice.id }) {
            let result = engine.performAction(.chooseEventOption(eventId: event.id, choiceIndex: choiceIndex))

            if result.success {
                // Log the event
                let logType: EventLogType = event.eventType == .combat ? .combat : .exploration
                let outcomeMessage = choice.consequences.message ?? L10n.journalChoiceMade.localized
                engine.addLogEntry(
                    regionName: region.name,
                    eventTitle: event.title,
                    choiceMade: choice.text,
                    outcome: outcomeMessage,
                    type: logType
                )
            }
        }

        // Dismiss event view
        eventToShow = nil
        engine.performAction(.dismissCurrentEvent)

        // Show card received notification if cards were gained
        if !cardsToNotify.isEmpty {
            receivedCardNames = cardsToNotify
            // Delay slightly to allow event sheet to dismiss first
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                    showingCardNotification = true
                }
            }
        }
    }
}

// MARK: - Engine-First Event Log View

struct EngineEventLogView: View {
    @ObservedObject var engine: TwilightGameEngine
    @Environment(\.dismiss) var dismiss

    var body: some View {
        NavigationView {
            List {
                if engine.publishedEventLog.isEmpty {
                    Text(L10n.journalEmpty.localized)
                        .foregroundColor(.secondary)
                        .padding()
                } else {
                    ForEach(engine.publishedEventLog.reversed()) { entry in
                        EventLogEntryView(entry: entry)
                    }
                }
            }
            .navigationTitle(L10n.journalTitle.localized)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(L10n.uiClose.localized) {
                        dismiss()
                    }
                }
            }
        }
    }
}


// ==========================================
// FILE: Views/Components/HeroPanel.swift
// ==========================================

import SwiftUI

/// Unified Hero Panel - displays hero stats consistently across all screens
/// Inspired by Arkham Horror LCG investigator cards but with unique Twilight Marches style
/// Engine-First Architecture: reads all data from TwilightGameEngine
struct HeroPanel: View {
    @ObservedObject var engine: TwilightGameEngine

    /// Compact mode for screens with limited space (like combat header)
    var compact: Bool = false

    /// Show hero portrait/avatar
    var showAvatar: Bool = true

    var body: some View {
        if compact {
            compactPanel
        } else {
            fullPanel
        }
    }

    // MARK: - Full Panel (for main screens like WorldMap, RegionDetail)

    var fullPanel: some View {
        HStack(spacing: 12) {
            // Hero Avatar
            if showAvatar {
                heroAvatar
            }

            // Hero Info
            VStack(alignment: .leading, spacing: 4) {
                // Name and class
                HStack {
                    Text(engine.playerName)
                        .font(.headline)
                        .fontWeight(.bold)
                    Text(heroClass)
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(Color.gray.opacity(0.2))
                        .cornerRadius(4)
                }

                // Stats row
                HStack(spacing: 12) {
                    // Health
                    statBadge(
                        icon: "heart.fill",
                        value: "\(engine.playerHealth)/\(engine.playerMaxHealth)",
                        color: healthColor,
                        label: nil
                    )

                    // Faith
                    statBadge(
                        icon: "sparkles",
                        value: "\(engine.playerFaith)",
                        color: .yellow,
                        label: nil
                    )

                    // Strength
                    statBadge(
                        icon: "hand.raised.fill",
                        value: "\(engine.legacyPlayer?.strength ?? 1)",
                        color: .orange,
                        label: nil
                    )

                    // Balance indicator
                    balanceIndicator
                }
            }

            Spacer()
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 10)
        .background(heroPanelBackground)
    }

    // MARK: - Compact Panel (for combat, events with limited space)

    var compactPanel: some View {
        HStack(spacing: 8) {
            // Mini avatar
            if showAvatar {
                ZStack {
                    Circle()
                        .fill(balanceGradient)
                        .frame(width: 32, height: 32)

                    Text(heroInitials)
                        .font(.caption)
                        .fontWeight(.bold)
                        .foregroundColor(.white)
                }
            }

            // Compact stats
            HStack(spacing: 8) {
                // Health
                HStack(spacing: 2) {
                    Image(systemName: "heart.fill")
                        .font(.caption2)
                        .foregroundColor(.red)
                    Text("\(engine.playerHealth)")
                        .font(.caption)
                        .fontWeight(.semibold)
                }

                // Faith
                HStack(spacing: 2) {
                    Image(systemName: "sparkles")
                        .font(.caption2)
                        .foregroundColor(.yellow)
                    Text("\(engine.playerFaith)")
                        .font(.caption)
                        .fontWeight(.semibold)
                }

                // Balance (small icon only)
                Image(systemName: balanceIcon)
                    .font(.caption2)
                    .foregroundColor(balanceColor)
            }

            Spacer()
        }
        .padding(.horizontal, 8)
        .padding(.vertical, 6)
        .background(Color(UIColor.secondarySystemBackground).opacity(0.9))
        .cornerRadius(8)
    }

    // MARK: - Hero Avatar

    var heroAvatar: some View {
        ZStack {
            // Background circle with balance gradient
            Circle()
                .fill(balanceGradient)
                .frame(width: 50, height: 50)

            // Inner circle
            Circle()
                .fill(Color(UIColor.systemBackground))
                .frame(width: 44, height: 44)

            // Hero initials or icon
            Text(heroInitials)
                .font(.title3)
                .fontWeight(.bold)
                .foregroundColor(balanceColor)
        }
    }

    // MARK: - Stat Badge

    func statBadge(icon: String, value: String, color: Color, label: String?) -> some View {
        HStack(spacing: 4) {
            Image(systemName: icon)
                .font(.caption)
                .foregroundColor(color)

            VStack(alignment: .leading, spacing: 0) {
                Text(value)
                    .font(.subheadline)
                    .fontWeight(.semibold)

                if let label = label {
                    Text(label)
                        .font(.system(size: 9))
                        .foregroundColor(.secondary)
                }
            }
        }
        .padding(.horizontal, 8)
        .padding(.vertical, 4)
        .background(color.opacity(0.15))
        .cornerRadius(6)
    }

    // MARK: - Balance Indicator

    var balanceIndicator: some View {
        HStack(spacing: 4) {
            Image(systemName: balanceIcon)
                .font(.caption)
                .foregroundColor(balanceColor)

            Text(balanceText)
                .font(.caption)
                .fontWeight(.medium)
                .foregroundColor(balanceColor)
        }
        .padding(.horizontal, 8)
        .padding(.vertical, 4)
        .background(balanceColor.opacity(0.15))
        .cornerRadius(6)
    }

    // MARK: - Background

    var heroPanelBackground: some View {
        ZStack {
            // Base background
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(UIColor.secondarySystemBackground))

            // Subtle balance-colored border
            RoundedRectangle(cornerRadius: 12)
                .stroke(balanceColor.opacity(0.3), lineWidth: 1)
        }
    }

    // MARK: - Computed Properties

    var heroClass: String {
        // In data-driven architecture, hero role comes from hero definition
        // For now, return localized default or hero name
        return L10n.heroClassDefault.localized
    }

    var heroInitials: String {
        let name = engine.playerName
        let words = name.split(separator: " ")
        if words.count >= 2 {
            return String(words[0].prefix(1)) + String(words[1].prefix(1))
        }
        return String(name.prefix(2)).uppercased()
    }

    var healthColor: Color {
        let percentage = Double(engine.playerHealth) / Double(max(engine.playerMaxHealth, 1))
        if percentage > 0.6 {
            return .green
        } else if percentage > 0.3 {
            return .orange
        } else {
            return .red
        }
    }

    var balanceIcon: String {
        let balance = engine.playerBalance
        if balance >= 70 {
            return "sun.max.fill"      // Light path (70-100)
        } else if balance <= 30 {
            return "moon.fill"          // Dark path (0-30)
        } else {
            return "circle.lefthalf.filled"  // Neutral (30-70)
        }
    }

    var balanceColor: Color {
        let balance = engine.playerBalance
        if balance >= 70 {
            return .yellow              // Light path
        } else if balance <= 30 {
            return .purple              // Dark path
        } else {
            return .gray                // Neutral
        }
    }

    var balanceText: String {
        let balance = engine.playerBalance
        if balance >= 70 {
            return L10n.balanceLight.localized
        } else if balance <= 30 {
            return L10n.balanceDark.localized
        } else {
            return L10n.balanceNeutral.localized
        }
    }

    var balanceGradient: LinearGradient {
        let balance = engine.playerBalance
        if balance >= 70 {
            return LinearGradient(
                colors: [.yellow.opacity(0.8), .orange.opacity(0.6)],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        } else if balance <= 30 {
            return LinearGradient(
                colors: [.purple.opacity(0.8), .indigo.opacity(0.6)],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        } else {
            return LinearGradient(
                colors: [.gray.opacity(0.6), .gray.opacity(0.4)],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        }
    }
}

// MARK: - Preview

struct HeroPanel_Previews: PreviewProvider {
    static var previews: some View {
        VStack(spacing: 20) {
            // Full panel
            HeroPanel(engine: previewEngine)
                .padding()

            // Compact panel
            HeroPanel(engine: previewEngine, compact: true)
                .padding()

            // Full panel without avatar
            HeroPanel(engine: previewEngine, showAvatar: false)
                .padding()
        }
        .background(Color(UIColor.systemBackground))
    }

    static var previewEngine: TwilightGameEngine {
        let engine = TwilightGameEngine()
        // Preview data would be set here
        return engine
    }
}


// ==========================================
// FILE: Engine/Core/CoreGameEngine.swift
// ==========================================

import Foundation
import Combine

// MARK: - Core Game Engine

/// Content-agnostic game engine that loads all configuration from Content Packs
/// This is the generic engine that can run ANY content pack, not just Twilight Marches.
///
/// Usage:
/// 1. Load a content pack into ContentRegistry
/// 2. Create CoreGameEngine with the registry
/// 3. Initialize game with initializeNewGame()
///
/// All game-specific content (regions, events, balance) comes from the loaded pack.
final class CoreGameEngine: ObservableObject {

    // MARK: - Published State (for UI binding)

    @Published private(set) var currentDay: Int = 0
    @Published private(set) var worldTension: Int = 0
    @Published private(set) var currentRegionId: String?
    @Published private(set) var isGameOver: Bool = false
    @Published private(set) var gameResult: GameEndResult?

    @Published private(set) var currentEventId: String?
    @Published private(set) var isInCombat: Bool = false
    @Published private(set) var lastActionResult: ActionResult?

    /// All regions with their current state
    @Published private(set) var regions: [String: CoreRegionState] = [:]

    /// Player stats
    @Published private(set) var playerHealth: Int = 10
    @Published private(set) var playerMaxHealth: Int = 10
    @Published private(set) var playerFaith: Int = 3
    @Published private(set) var playerMaxFaith: Int = 10
    @Published private(set) var playerBalance: Int = 50
    @Published private(set) var playerName: String = "Hero"

    /// World flags for quest/event conditions
    @Published private(set) var worldFlags: [String: Bool] = [:]

    /// Current event being displayed
    @Published private(set) var currentEvent: EventDefinition?

    /// Active quests
    @Published private(set) var activeQuests: [QuestDefinition] = []

    /// Light/Dark balance of the world
    @Published private(set) var lightDarkBalance: Int = 50

    // MARK: - Content Source

    /// Content registry - source of all game content
    private let contentRegistry: ContentRegistry

    /// Balance configuration from loaded pack
    private var balanceConfig: BalanceConfiguration

    // MARK: - Internal State

    private var completedEventIds: Set<String> = []
    private var completedQuestIds: Set<String> = []
    private var questStages: [String: Int] = [:]
    private var eventLog: [CoreEventLogEntry] = []

    // MARK: - Computed Properties

    /// Get regions as sorted array for UI
    var regionsArray: [CoreRegionState] {
        regions.values.sorted { $0.name < $1.name }
    }

    /// Get current region
    var currentRegion: CoreRegionState? {
        guard let id = currentRegionId else { return nil }
        return regions[id]
    }

    /// Check if player can afford faith cost
    func canAffordFaith(_ cost: Int) -> Bool {
        return playerFaith >= cost
    }

    /// Check if region is neighbor to current region
    func isNeighbor(regionId: String) -> Bool {
        guard let current = currentRegion else { return false }
        return current.neighborIds.contains(regionId)
    }

    // MARK: - Initialization

    /// Create engine with content registry
    /// - Parameter registry: Content registry with loaded packs
    init(registry: ContentRegistry = .shared) {
        self.contentRegistry = registry
        self.balanceConfig = registry.getBalanceConfig() ?? .default
    }

    // MARK: - Game Initialization

    /// Initialize a new game from loaded content packs
    /// - Parameters:
    ///   - playerName: Name of the player character
    ///   - startingRegionId: Optional override for starting region
    func initializeNewGame(playerName: String = "Hero", startingRegionId: String? = nil) {
        // Reset state
        isGameOver = false
        gameResult = nil
        currentEventId = nil
        currentEvent = nil
        isInCombat = false

        // Load balance config from pack
        balanceConfig = contentRegistry.getBalanceConfig() ?? .default

        // Setup player from balance config
        self.playerName = playerName
        playerHealth = balanceConfig.resources.startingHealth
        playerMaxHealth = balanceConfig.resources.maxHealth
        playerFaith = balanceConfig.resources.startingFaith
        playerMaxFaith = balanceConfig.resources.maxFaith
        playerBalance = 50

        // Setup world from balance config
        currentDay = 0
        worldTension = balanceConfig.pressure.startingPressure
        lightDarkBalance = 50
        worldFlags = [:]
        completedEventIds = []
        completedQuestIds = []
        eventLog = []

        // Load regions from content registry
        setupRegionsFromRegistry(startingRegionId: startingRegionId)

        // Load initial quests
        setupInitialQuests()
    }

    /// Setup regions from content registry
    private func setupRegionsFromRegistry(startingRegionId: String?) {
        let regionDefs = contentRegistry.getAllRegions()
        var newRegions: [String: CoreRegionState] = [:]

        for def in regionDefs {
            let anchor = contentRegistry.getAnchor(forRegion: def.id)
            let anchorState: CoreAnchorState? = anchor.map {
                CoreAnchorState(
                    id: $0.id,
                    name: $0.title.localized,
                    integrity: $0.initialIntegrity
                )
            }

            let regionState = CoreRegionState(
                id: def.id,
                name: def.title.localized,
                state: def.initialState,
                anchor: anchorState,
                neighborIds: def.neighborIds,
                canTrade: def.initialState == .stable
            )
            newRegions[def.id] = regionState
        }

        regions = newRegions

        // Set starting region
        if let startId = startingRegionId, regions[startId] != nil {
            currentRegionId = startId
        } else {
            // Use first loaded pack's entry region or first available region
            currentRegionId = contentRegistry.loadedPacks.values.first?.manifest.entryRegionId
                ?? regions.keys.first
        }
    }

    /// Setup initial quests from content registry
    private func setupInitialQuests() {
        // Load quests marked as auto-start
        let allQuests = contentRegistry.getAllQuests()
        activeQuests = allQuests.filter { $0.autoStart }
    }

    // MARK: - Actions

    /// Perform a game action
    @discardableResult
    func performAction(_ action: CoreGameAction) -> CoreActionResult {
        guard !isGameOver else {
            return CoreActionResult(success: false, error: .gameNotInProgress)
        }

        // Validate action
        if let error = validateAction(action) {
            return CoreActionResult(success: false, error: error)
        }

        // Execute action
        var stateChanges: [CoreStateChange] = []

        // Advance time if action costs time
        let timeCost = action.timeCost
        if timeCost > 0 {
            let timeChanges = advanceTime(by: timeCost)
            stateChanges.append(contentsOf: timeChanges)
        }

        // Execute action-specific logic
        switch action {
        case .travel(let toRegionId):
            let changes = executeTravel(to: toRegionId)
            stateChanges.append(contentsOf: changes)

        case .rest:
            let changes = executeRest()
            stateChanges.append(contentsOf: changes)

        case .explore:
            let changes = executeExplore()
            stateChanges.append(contentsOf: changes)

        case .strengthenAnchor:
            let changes = executeStrengthenAnchor()
            stateChanges.append(contentsOf: changes)

        case .chooseEventOption(let eventId, let choiceIndex):
            let changes = executeEventChoice(eventId: eventId, choiceIndex: choiceIndex)
            stateChanges.append(contentsOf: changes)

        case .dismissEvent:
            currentEvent = nil
            currentEventId = nil

        case .skipTurn:
            break
        }

        // Check quest progress
        checkQuestProgress()

        // Check end conditions
        if let endResult = checkEndConditions() {
            isGameOver = true
            gameResult = endResult
            return CoreActionResult(success: true, stateChanges: stateChanges, gameEnded: endResult)
        }

        return CoreActionResult(success: true, stateChanges: stateChanges)
    }

    // MARK: - Validation

    private func validateAction(_ action: CoreGameAction) -> CoreActionError? {
        switch action {
        case .travel(let toRegionId):
            guard let current = currentRegion else {
                return .invalidAction(reason: "No current region")
            }
            if !current.neighborIds.contains(toRegionId) {
                return .regionNotNeighbor(regionId: toRegionId)
            }
            if playerHealth <= 0 {
                return .healthTooLow
            }

        case .rest:
            guard let region = currentRegion else {
                return .invalidAction(reason: "No current region")
            }
            if region.state == .breach {
                return .actionNotAvailableInRegion(action: "rest", regionState: "breach")
            }

        case .strengthenAnchor:
            guard let region = currentRegion else {
                return .invalidAction(reason: "No current region")
            }
            if region.anchor == nil {
                return .actionNotAvailableInRegion(action: "strengthen anchor", regionState: "no anchor")
            }
            let cost = balanceConfig.anchor.strengthenCost
            if playerFaith < cost {
                return .insufficientResources(resource: "faith", required: cost, available: playerFaith)
            }

        default:
            break
        }
        return nil
    }

    // MARK: - Time

    private func advanceTime(by days: Int) -> [CoreStateChange] {
        var changes: [CoreStateChange] = []

        for _ in 0..<days {
            currentDay += 1
            changes.append(.dayAdvanced(newDay: currentDay))

            // Check tension tick
            let interval = balanceConfig.pressure.thresholds.warning > 0 ? 3 : 1
            if currentDay > 0 && currentDay % interval == 0 {
                let tensionIncrease = calculateTensionIncrease()
                worldTension = min(balanceConfig.pressure.maxPressure, worldTension + tensionIncrease)
                changes.append(.tensionChanged(delta: tensionIncrease, newValue: worldTension))

                // World degradation
                let degradationChanges = processWorldDegradation()
                changes.append(contentsOf: degradationChanges)
            }
        }

        return changes
    }

    private func calculateTensionIncrease() -> Int {
        let base = balanceConfig.pressure.pressurePerTurn
        let escalationBonus = currentDay / 10
        return base + escalationBonus
    }

    private func processWorldDegradation() -> [CoreStateChange] {
        var changes: [CoreStateChange] = []

        // Get degradation chance based on tension level
        let degradationChance: Double
        if worldTension >= balanceConfig.pressure.thresholds.critical {
            degradationChance = balanceConfig.pressure.degradation.criticalChance
        } else if worldTension >= balanceConfig.pressure.thresholds.warning {
            degradationChance = balanceConfig.pressure.degradation.warningChance
        } else {
            return changes
        }

        // Find regions that can degrade
        let degradableRegions = regions.values.filter { $0.state != .breach }
        guard !degradableRegions.isEmpty else { return changes }

        // Deterministic random check using WorldRNG (not Double.random)
        let roll = WorldRNG.shared.nextDouble()
        if roll < degradationChance {
            // Pick a borderland region to degrade using deterministic selection
            let borderlands = degradableRegions.filter { $0.state == .borderland }
            if let regionToDemote = WorldRNG.shared.randomElement(from: Array(borderlands)) {
                if var region = regions[regionToDemote.id] {
                    region.state = .breach
                    regions[regionToDemote.id] = region
                    changes.append(.regionStateChanged(regionId: regionToDemote.id, newState: .breach))
                }
            }
        }

        return changes
    }

    // MARK: - Action Execution

    private func executeTravel(to regionId: String) -> [CoreStateChange] {
        var changes: [CoreStateChange] = []

        currentRegionId = regionId
        changes.append(.regionChanged(regionId: regionId))

        // Mark region as visited
        if var region = regions[regionId] {
            region.visited = true
            regions[regionId] = region
        }

        // Generate travel event
        if let event = generateEvent(for: regionId, trigger: .arrival) {
            currentEventId = event.id
            currentEvent = event
            changes.append(.eventTriggered(eventId: event.id))
        }

        return changes
    }

    private func executeRest() -> [CoreStateChange] {
        var changes: [CoreStateChange] = []

        let healAmount = 3  // Could come from balance config
        let newHealth = min(playerMaxHealth, playerHealth + healAmount)
        let delta = newHealth - playerHealth
        playerHealth = newHealth
        changes.append(.healthChanged(delta: delta, newValue: newHealth))

        return changes
    }

    private func executeExplore() -> [CoreStateChange] {
        var changes: [CoreStateChange] = []

        guard let regionId = currentRegionId else { return changes }

        // Generate exploration event
        if let event = generateEvent(for: regionId, trigger: .exploration) {
            currentEventId = event.id
            currentEvent = event
            changes.append(.eventTriggered(eventId: event.id))
        }

        return changes
    }

    private func executeStrengthenAnchor() -> [CoreStateChange] {
        var changes: [CoreStateChange] = []

        guard let regionId = currentRegionId,
              var region = regions[regionId],
              var anchor = region.anchor else {
            return changes
        }

        // Spend faith (from balance config)
        let cost = balanceConfig.anchor.strengthenCost
        playerFaith -= cost
        changes.append(.faithChanged(delta: -cost, newValue: playerFaith))

        // Strengthen anchor
        let strengthAmount = balanceConfig.anchor.strengthenAmount
        let newIntegrity = min(balanceConfig.anchor.maxIntegrity, anchor.integrity + strengthAmount)
        let delta = newIntegrity - anchor.integrity
        anchor.integrity = newIntegrity
        region.anchor = anchor
        regions[regionId] = region

        changes.append(.anchorIntegrityChanged(anchorId: anchor.id, delta: delta, newValue: newIntegrity))

        return changes
    }

    private func executeEventChoice(eventId: String, choiceIndex: Int) -> [CoreStateChange] {
        var changes: [CoreStateChange] = []

        guard let event = currentEvent,
              choiceIndex < event.choices.count else {
            return changes
        }

        let choice = event.choices[choiceIndex]

        // Apply resource changes
        for (resource, delta) in choice.consequences.resourceChanges {
            switch resource {
            case "health":
                playerHealth = max(0, min(playerMaxHealth, playerHealth + delta))
                changes.append(.healthChanged(delta: delta, newValue: playerHealth))
            case "faith":
                playerFaith = max(0, playerFaith + delta)
                changes.append(.faithChanged(delta: delta, newValue: playerFaith))
            case "tension":
                worldTension = max(0, min(100, worldTension + delta))
                changes.append(.tensionChanged(delta: delta, newValue: worldTension))
            default:
                break
            }
        }

        // Apply balance change
        if choice.consequences.balanceDelta != 0 {
            lightDarkBalance = max(0, min(100, lightDarkBalance + choice.consequences.balanceDelta))
            changes.append(.balanceChanged(delta: choice.consequences.balanceDelta, newValue: lightDarkBalance))
        }

        // Set flags (setFlags is an array of flag names, all set to true)
        for flag in choice.consequences.setFlags {
            worldFlags[flag] = true
            changes.append(.flagSet(key: flag, value: true))
        }

        // Clear flags
        for flag in choice.consequences.clearFlags {
            worldFlags[flag] = false
            changes.append(.flagSet(key: flag, value: false))
        }

        // Mark event completed if one-time
        if event.isOneTime {
            completedEventIds.insert(eventId)
        }

        currentEventId = nil
        currentEvent = nil
        changes.append(.eventCompleted(eventId: eventId))

        return changes
    }

    // MARK: - Event Generation

    private func generateEvent(for regionId: String, trigger: CoreEventTrigger) -> EventDefinition? {
        let availableEvents = contentRegistry.getAvailableEvents(
            forRegion: regionId,
            pressure: worldTension
        ).filter { event in
            // Filter out completed one-time events
            if event.isOneTime && completedEventIds.contains(event.id) {
                return false
            }
            return true
        }

        // Use deterministic selection via WorldRNG (not randomElement)
        return WorldRNG.shared.randomElement(from: availableEvents)
    }

    // MARK: - Quest Progress

    private func checkQuestProgress() {
        // Check quest conditions and update stages
        for quest in activeQuests {
            // Check if quest objectives are completed
            // For simplicity, check if all objectives with flagSet condition have their flags set
            var allObjectivesComplete = true
            for objective in quest.objectives {
                switch objective.completionCondition {
                case .flagSet(let flagName):
                    if worldFlags[flagName] != true {
                        allObjectivesComplete = false
                    }
                case .visitRegion(let regionId):
                    // Would need to track visited regions
                    if regions[regionId]?.visited != true {
                        allObjectivesComplete = false
                    }
                default:
                    // For other conditions, assume incomplete unless explicitly marked
                    break
                }
            }

            if allObjectivesComplete && !quest.objectives.isEmpty {
                completedQuestIds.insert(quest.id)
            }
        }

        // Remove completed quests from active
        activeQuests = activeQuests.filter { !completedQuestIds.contains($0.id) }
    }

    // MARK: - End Conditions

    private func checkEndConditions() -> GameEndResult? {
        // Defeat: tension at max
        if let pressureLoss = balanceConfig.endConditions.pressureLoss,
           worldTension >= pressureLoss {
            return .defeat(reason: "World tension reached maximum")
        }

        // Defeat: health 0
        if playerHealth <= 0 {
            return .defeat(reason: "Hero died")
        }

        // Victory: check victory quests
        for questId in balanceConfig.endConditions.victoryQuests {
            if completedQuestIds.contains(questId) {
                return .victory(endingId: "standard")
            }
        }

        return nil
    }
}

// MARK: - Core Game Action

/// Actions that can be performed in the game
enum CoreGameAction {
    case travel(toRegionId: String)
    case rest
    case explore
    case strengthenAnchor
    case chooseEventOption(eventId: String, choiceIndex: Int)
    case dismissEvent
    case skipTurn

    var timeCost: Int {
        switch self {
        case .travel: return 1
        case .rest: return 1
        case .explore: return 1
        case .strengthenAnchor: return 1
        case .chooseEventOption, .dismissEvent, .skipTurn: return 0
        }
    }
}

// MARK: - Core Action Result

struct CoreActionResult {
    let success: Bool
    let error: CoreActionError?
    let stateChanges: [CoreStateChange]
    let gameEnded: GameEndResult?

    init(success: Bool, error: CoreActionError? = nil, stateChanges: [CoreStateChange] = [], gameEnded: GameEndResult? = nil) {
        self.success = success
        self.error = error
        self.stateChanges = stateChanges
        self.gameEnded = gameEnded
    }
}

// MARK: - Core Action Error

enum CoreActionError: Error {
    case gameNotInProgress
    case regionNotNeighbor(regionId: String)
    case healthTooLow
    case actionNotAvailableInRegion(action: String, regionState: String)
    case insufficientResources(resource: String, required: Int, available: Int)
    case invalidAction(reason: String)
}

// MARK: - Core State Change

enum CoreStateChange {
    case dayAdvanced(newDay: Int)
    case tensionChanged(delta: Int, newValue: Int)
    case regionChanged(regionId: String)
    case regionStateChanged(regionId: String, newState: RegionStateType)
    case healthChanged(delta: Int, newValue: Int)
    case faithChanged(delta: Int, newValue: Int)
    case balanceChanged(delta: Int, newValue: Int)
    case anchorIntegrityChanged(anchorId: String, delta: Int, newValue: Int)
    case flagSet(key: String, value: Bool)
    case eventTriggered(eventId: String)
    case eventCompleted(eventId: String)
    case questCompleted(questId: String)
}

// MARK: - Core Event Trigger

enum CoreEventTrigger {
    case arrival
    case exploration
    case combat
    case quest
    case time
}

// MARK: - Core Region State

/// Runtime state of a region (combines definition + runtime data)
struct CoreRegionState {
    let id: String
    let name: String
    var state: RegionStateType
    var anchor: CoreAnchorState?
    let neighborIds: [String]
    var canTrade: Bool
    var visited: Bool = false
    var reputation: Int = 0

    var canRest: Bool {
        state == .stable
    }
}

// MARK: - Core Anchor State

/// Runtime state of an anchor
struct CoreAnchorState {
    let id: String
    let name: String
    var integrity: Int
}

// MARK: - Core Event Log Entry

struct CoreEventLogEntry {
    let dayNumber: Int
    let regionName: String
    let eventTitle: String
    let choiceMade: String
    let outcome: String
}


// ==========================================
// FILE: Engine/Core/EconomyManager.swift
// ==========================================

import Foundation

// MARK: - Economy Manager Implementation
// Handles all resource transactions in a consistent way.

/// Default implementation of EconomyManagerProtocol
final class EconomyManager: EconomyManagerProtocol {
    // MARK: - Properties

    /// Track transaction history for debugging/analytics
    private var transactionHistory: [TransactionRecord] = []

    /// Maximum history size
    private let maxHistorySize: Int

    // MARK: - Initialization

    init(maxHistorySize: Int = 100) {
        self.maxHistorySize = maxHistorySize
    }

    // MARK: - EconomyManagerProtocol

    /// Check if a transaction can be afforded
    func canAfford(_ transaction: Transaction, resources: [String: Int]) -> Bool {
        for (resource, cost) in transaction.costs {
            let available = resources[resource] ?? 0
            if available < cost {
                return false
            }
        }
        return true
    }

    /// Process a transaction, modifying resources
    /// Returns true if successful, false if cannot afford
    func process(_ transaction: Transaction, resources: inout [String: Int]) -> Bool {
        // First check if affordable
        guard canAfford(transaction, resources: resources) else {
            return false
        }

        // Apply costs
        for (resource, cost) in transaction.costs {
            let current = resources[resource] ?? 0
            resources[resource] = current - cost
        }

        // Apply gains
        for (resource, gain) in transaction.gains {
            let current = resources[resource] ?? 0
            resources[resource] = current + gain
        }

        // Record transaction
        recordTransaction(transaction, success: true)

        return true
    }

    // MARK: - Extended Methods

    /// Process transaction with caps (e.g., max health)
    func processWithCaps(
        _ transaction: Transaction,
        resources: inout [String: Int],
        caps: [String: Int]
    ) -> Bool {
        guard process(transaction, resources: &resources) else {
            return false
        }

        // Apply caps
        for (resource, maxValue) in caps {
            if let current = resources[resource], current > maxValue {
                resources[resource] = maxValue
            }
        }

        return true
    }

    /// Preview transaction result without applying
    func preview(
        _ transaction: Transaction,
        resources: [String: Int]
    ) -> [String: Int]? {
        guard canAfford(transaction, resources: resources) else {
            return nil
        }

        var result = resources

        // Apply costs
        for (resource, cost) in transaction.costs {
            let current = result[resource] ?? 0
            result[resource] = current - cost
        }

        // Apply gains
        for (resource, gain) in transaction.gains {
            let current = result[resource] ?? 0
            result[resource] = current + gain
        }

        return result
    }

    /// Calculate net change from a transaction
    func netChange(_ transaction: Transaction) -> [String: Int] {
        var net: [String: Int] = [:]

        for (resource, cost) in transaction.costs {
            net[resource] = (net[resource] ?? 0) - cost
        }

        for (resource, gain) in transaction.gains {
            net[resource] = (net[resource] ?? 0) + gain
        }

        return net
    }

    // MARK: - History

    private func recordTransaction(_ transaction: Transaction, success: Bool) {
        let record = TransactionRecord(
            transaction: transaction,
            timestamp: Date(),
            success: success
        )

        transactionHistory.append(record)

        // Trim history if needed
        if transactionHistory.count > maxHistorySize {
            transactionHistory.removeFirst(transactionHistory.count - maxHistorySize)
        }
    }

    /// Get recent transaction history
    func getHistory(limit: Int = 10) -> [TransactionRecord] {
        return Array(transactionHistory.suffix(limit))
    }

    /// Clear history
    func clearHistory() {
        transactionHistory.removeAll()
    }
}

// MARK: - Transaction Record

/// Record of a processed transaction
struct TransactionRecord {
    let transaction: Transaction
    let timestamp: Date
    let success: Bool
}

// MARK: - Transaction Extensions

extension Transaction {
    /// Create a simple cost-only transaction
    static func cost(_ resource: String, amount: Int, description: String = "") -> Transaction {
        Transaction(costs: [resource: amount], description: description)
    }

    /// Create a simple gain-only transaction
    static func gain(_ resource: String, amount: Int, description: String = "") -> Transaction {
        Transaction(gains: [resource: amount], description: description)
    }

    /// Create a trade transaction (exchange one resource for another)
    static func trade(
        spend resource1: String,
        amount1: Int,
        gain resource2: String,
        amount2: Int,
        description: String = ""
    ) -> Transaction {
        Transaction(
            costs: [resource1: amount1],
            gains: [resource2: amount2],
            description: description
        )
    }

    /// Combine two transactions
    func combined(with other: Transaction) -> Transaction {
        var newCosts = self.costs
        var newGains = self.gains

        for (resource, cost) in other.costs {
            newCosts[resource] = (newCosts[resource] ?? 0) + cost
        }

        for (resource, gain) in other.gains {
            newGains[resource] = (newGains[resource] ?? 0) + gain
        }

        return Transaction(
            costs: newCosts,
            gains: newGains,
            description: "\(self.description); \(other.description)"
        )
    }
}

// MARK: - Standard Resource Types

/// Common resource identifiers (games can define their own)
enum StandardResource: String {
    case health
    case maxHealth
    case energy
    case faith
    case gold
    case experience
    case reputation

    var id: String { rawValue }
}


// ==========================================
// FILE: Engine/Core/EngineProtocols.swift
// ==========================================

import Foundation

// MARK: - Game Engine v1.0 Core Protocols
// Setting-agnostic contracts for the game engine.
// The engine is the "processor", the game content is the "cartridge".

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - 1. Time System
// ═══════════════════════════════════════════════════════════════════════════════

/// Delegate for time progression events
protocol TimeSystemDelegate: AnyObject {
    /// Called when time advances by one tick
    func onTimeTick(currentTime: Int, delta: Int)

    /// Called when a time threshold is crossed (e.g., every 3 days)
    func onTimeThreshold(currentTime: Int, threshold: Int)
}

/// Contract for time-consuming actions
protocol TimedAction {
    /// Cost in time units (0 = instant)
    var timeCost: Int { get }
}

/// Time engine protocol - manages game time progression
protocol TimeEngineProtocol {
    var currentTime: Int { get }
    var delegate: TimeSystemDelegate? { get set }

    /// Advance time by a cost. Invariant: cost > 0 (except instant actions)
    func advance(cost: Int)

    /// Check if a threshold interval has been reached
    func checkThreshold(_ interval: Int) -> Bool
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - 2. Pressure System
// ═══════════════════════════════════════════════════════════════════════════════

/// Defines the rules for pressure/tension escalation
protocol PressureRuleSet {
    var maxPressure: Int { get }
    var initialPressure: Int { get }

    /// Calculate pressure increase based on current state
    func calculateEscalation(currentPressure: Int, currentTime: Int) -> Int

    /// Check what effects trigger at current pressure level
    func checkThresholds(pressure: Int) -> [WorldEffect]

    /// Interval (in time units) for automatic pressure increase
    var escalationInterval: Int { get }

    /// Amount of pressure added per interval
    var escalationAmount: Int { get }
}

/// Effects that can be applied to the world
enum WorldEffect: Equatable {
    case regionDegradation(probability: Double)
    case globalEvent(eventId: String)
    case phaseChange(newPhase: String)
    case anchorWeakening(amount: Int)
    case custom(id: String, parameters: [String: Any])

    static func == (lhs: WorldEffect, rhs: WorldEffect) -> Bool {
        switch (lhs, rhs) {
        case (.regionDegradation(let p1), .regionDegradation(let p2)):
            return p1 == p2
        case (.globalEvent(let e1), .globalEvent(let e2)):
            return e1 == e2
        case (.phaseChange(let ph1), .phaseChange(let ph2)):
            return ph1 == ph2
        case (.anchorWeakening(let a1), .anchorWeakening(let a2)):
            return a1 == a2
        case (.custom(let id1, _), .custom(let id2, _)):
            return id1 == id2
        default:
            return false
        }
    }
}

/// Pressure engine protocol
protocol PressureEngineProtocol {
    var currentPressure: Int { get }
    var rules: PressureRuleSet { get }

    /// Escalate pressure based on rules
    func escalate(at currentTime: Int)

    /// Manually adjust pressure
    func adjust(by delta: Int)

    /// Get current threshold effects
    func currentEffects() -> [WorldEffect]
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - 3. Event System
// ═══════════════════════════════════════════════════════════════════════════════

/// Abstract event definition protocol (setting-agnostic)
/// Concrete implementation: Engine/Data/Definitions/EventDefinition.swift
protocol EventDefinitionProtocol {
    associatedtype ChoiceType: ChoiceDefinitionProtocol

    var id: String { get }
    var title: String { get }
    var description: String { get }
    var choices: [ChoiceType] { get }

    /// Whether this event consumes time
    var isInstant: Bool { get }

    /// Whether this event can only occur once
    var isOneTime: Bool { get }

    /// Check if event can occur given current context
    func canOccur(in context: EventContext) -> Bool
}

/// Abstract choice definition protocol
/// Concrete implementation: Engine/Data/Definitions/EventDefinition.swift (ChoiceDefinition struct)
protocol ChoiceDefinitionProtocol {
    associatedtype RequirementsType: RequirementsDefinitionProtocol
    associatedtype ConsequencesType: ConsequencesDefinitionProtocol

    var id: String { get }
    var text: String { get }
    var requirements: RequirementsType? { get }
    var consequences: ConsequencesType { get }
}

/// Abstract requirements protocol (gating conditions)
protocol RequirementsDefinitionProtocol {
    func canMeet(with resources: ResourceProvider) -> Bool
}

/// Abstract consequences protocol (outcomes)
protocol ConsequencesDefinitionProtocol {
    /// Resource changes (positive or negative)
    var resourceChanges: [String: Int] { get }

    /// Flags to set
    var flagsToSet: [String: Bool] { get }

    /// Custom effects
    var customEffects: [String] { get }
}

/// Context for event evaluation
struct EventContext {
    let currentLocation: String
    let locationState: String
    let pressure: Int
    let flags: [String: Bool]
    let resources: [String: Int]
    let completedEvents: Set<String>
}

/// Provider for checking resources
protocol ResourceProvider {
    func getValue(for resource: String) -> Int
    func hasFlag(_ flag: String) -> Bool
}

/// Event system protocol
protocol EventSystemProtocol {
    associatedtype Event: EventDefinitionProtocol

    /// Get available events for current context
    func getAvailableEvents(in context: EventContext) -> [Event]

    /// Mark event as completed
    func markCompleted(eventId: String)

    /// Check if event was completed
    func isCompleted(eventId: String) -> Bool
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - 4. Resolution System (Conflicts)
// ═══════════════════════════════════════════════════════════════════════════════

/// Types of challenges/conflicts
enum ChallengeType: String, Codable {
    case combat
    case skillCheck
    case socialEncounter
    case puzzle
    case tradeOff
    case sacrifice
}

/// Abstract challenge definition
protocol ChallengeDefinition {
    var type: ChallengeType { get }
    var difficulty: Int { get }
    var context: Any? { get }
}

/// Result of challenge resolution
enum ResolutionResult<Reward, Penalty> {
    case success(Reward)
    case failure(Penalty)
    case partial(reward: Reward, penalty: Penalty)
    case cancelled
}

/// Conflict resolver protocol - pluggable resolution mechanics
protocol ConflictResolverProtocol {
    associatedtype Challenge: ChallengeDefinition
    associatedtype Actor
    associatedtype Reward
    associatedtype Penalty

    /// Resolve a challenge. Can be async for animations/UI.
    func resolve(
        challenge: Challenge,
        actor: Actor
    ) async -> ResolutionResult<Reward, Penalty>
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - 5. Progression System
// ═══════════════════════════════════════════════════════════════════════════════

/// Player path/alignment tracking
protocol ProgressionPathProtocol {
    associatedtype PathType

    var currentPath: PathType { get }
    var pathValue: Int { get }

    /// Shift path by delta
    func shift(by delta: Int)

    /// Get unlocked capabilities for current path
    func unlockedCapabilities() -> [String]

    /// Get locked options for current path
    func lockedOptions() -> [String]
}

/// Progression tracker
protocol ProgressionTrackerProtocol {
    /// Track capability unlock
    func unlock(capability: String)

    /// Track capability lock (path trade-off)
    func lock(capability: String)

    /// Check if capability is available
    func isUnlocked(_ capability: String) -> Bool
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - 6. Victory/Defeat System
// ═══════════════════════════════════════════════════════════════════════════════

/// End condition types
enum EndConditionType: String, Codable {
    case objectiveBased    // Complete specific goals
    case pressureBased     // Pressure reaches threshold
    case resourceBased     // Resource hits 0 or max
    case pathBased         // Player path determines ending
    case timeBased         // Time limit reached
}

/// End condition definition
protocol EndConditionDefinition {
    var type: EndConditionType { get }
    var id: String { get }
    var isVictory: Bool { get }

    /// Check if condition is met
    func isMet(pressure: Int, resources: [String: Int], flags: [String: Bool], time: Int) -> Bool
}

/// Victory/Defeat checker protocol
protocol EndGameCheckerProtocol {
    associatedtype Condition: EndConditionDefinition

    var conditions: [Condition] { get }

    /// Check all conditions, return first met (or nil)
    func checkConditions(
        pressure: Int,
        resources: [String: Int],
        flags: [String: Bool],
        time: Int
    ) -> Condition?
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - 7. Economy System
// ═══════════════════════════════════════════════════════════════════════════════

/// Transaction for resource changes
struct Transaction {
    let costs: [String: Int]
    let gains: [String: Int]
    let description: String

    init(costs: [String: Int] = [:], gains: [String: Int] = [:], description: String = "") {
        self.costs = costs
        self.gains = gains
        self.description = description
    }
}

/// Economy manager protocol
protocol EconomyManagerProtocol {
    /// Check if transaction is affordable
    func canAfford(_ transaction: Transaction, resources: [String: Int]) -> Bool

    /// Process transaction, returns new resource values
    func process(_ transaction: Transaction, resources: inout [String: Int]) -> Bool
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - 8. World State System
// ═══════════════════════════════════════════════════════════════════════════════

/// Location state (abstract)
protocol LocationStateProtocol {
    var id: String { get }
    var name: String { get }
    var currentState: String { get }

    /// Can player rest here?
    var canRest: Bool { get }

    /// Can player trade here?
    var canTrade: Bool { get }

    /// Neighbor location IDs
    var neighborIds: [String] { get }
}

/// World state manager protocol
protocol WorldStateManagerProtocol {
    associatedtype Location: LocationStateProtocol

    var locations: [Location] { get }
    var currentLocationId: String? { get }
    var flags: [String: Bool] { get }

    /// Move to location
    func moveTo(locationId: String) -> Int // Returns time cost

    /// Set flag
    func setFlag(_ flag: String, value: Bool)

    /// Get flag
    func hasFlag(_ flag: String) -> Bool

    /// Degrade location
    func degradeLocation(_ locationId: String)

    /// Improve location
    func improveLocation(_ locationId: String)
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - 9. Quest System
// ═══════════════════════════════════════════════════════════════════════════════

/// Quest objective
protocol QuestObjectiveProtocol {
    var id: String { get }
    var description: String { get }
    var isCompleted: Bool { get }

    /// Check if objective is complete based on flags
    func checkCompletion(flags: [String: Bool]) -> Bool
}

/// Quest definition
protocol QuestDefinitionProtocol {
    associatedtype Objective: QuestObjectiveProtocol

    var id: String { get }
    var title: String { get }
    var isMain: Bool { get }
    var objectives: [Objective] { get }
    var isCompleted: Bool { get }

    /// Rewards on completion
    var rewardTransaction: Transaction { get }
}

/// Quest manager protocol
protocol QuestManagerProtocol {
    associatedtype Quest: QuestDefinitionProtocol

    var activeQuests: [Quest] { get }
    var completedQuests: [String] { get }

    /// Check quest progress based on flags
    func checkProgress(flags: [String: Bool])

    /// Complete a quest
    func completeQuest(_ questId: String) -> Transaction?
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - 10. Core Engine Protocol
// ═══════════════════════════════════════════════════════════════════════════════

/// Main game engine orchestrator protocol
protocol GameEngineProtocol {
    associatedtype PlayerState
    associatedtype WorldManager: WorldStateManagerProtocol
    associatedtype EventSystem: EventSystemProtocol
    associatedtype Resolver: ConflictResolverProtocol
    associatedtype QuestManager: QuestManagerProtocol
    associatedtype EndChecker: EndGameCheckerProtocol

    // Subsystems
    var timeEngine: any TimeEngineProtocol { get }
    var pressureEngine: any PressureEngineProtocol { get }
    var worldManager: WorldManager { get }
    var eventSystem: EventSystem { get }
    var resolver: Resolver { get }
    var questManager: QuestManager { get }
    var endChecker: EndChecker { get }
    var economyManager: any EconomyManagerProtocol { get }

    // State
    var playerState: PlayerState { get }
    var isGameOver: Bool { get }
    var isVictory: Bool { get }

    // Core Loop
    func performAction(_ action: any TimedAction) async
    func worldTick()
    func checkEndConditions()
    func save()
}


// ==========================================
// FILE: Engine/Core/EngineSave.swift
// ==========================================

import Foundation

// MARK: - Engine Save Structure
// Сериализуемое состояние для save/load (Engine-First Architecture)

/// Полное состояние игры для сохранения
/// Engine сохраняет/загружает через эту структуру, а не через WorldState
struct EngineSave: Codable {
    // MARK: - Metadata
    let version: Int
    let savedAt: Date
    let gameDuration: TimeInterval

    // MARK: - Pack Compatibility (Audit 2.0 Requirement)
    /// Core engine version for compatibility checking
    let coreVersion: String
    /// Active pack set with versions (packId → version string)
    let activePackSet: [String: String]
    /// Save format version for migration
    let formatVersion: Int

    // MARK: - Player State
    let playerName: String
    let playerHealth: Int
    let playerMaxHealth: Int
    let playerFaith: Int
    let playerMaxFaith: Int
    let playerBalance: Int

    // MARK: - Deck State (String IDs for stable serialization - Epic 3)
    let deckCardIds: [String]
    let handCardIds: [String]
    let discardCardIds: [String]

    // MARK: - World State
    let currentDay: Int
    let worldTension: Int
    let lightDarkBalance: Int
    let currentRegionId: String?  // Definition ID, not UUID

    // MARK: - Regions State
    let regions: [RegionSaveState]

    // MARK: - Quest State
    let mainQuestStage: Int
    let activeQuestIds: [String]
    let completedQuestIds: [String]
    let questStages: [String: Int]

    // MARK: - Events State (String IDs for stable serialization - Epic 3)
    let completedEventIds: [String]  // Definition IDs, not UUIDs
    let eventLog: [EventLogEntrySave]

    // MARK: - World Flags
    let worldFlags: [String: Bool]

    // MARK: - RNG State
    let rngSeed: UInt64?

    // MARK: - Current Version
    static let currentVersion = 1
    static let currentFormatVersion = 1
    static let currentCoreVersion = "1.2.0"

    // MARK: - Pack Compatibility Validation

    /// Check if save is compatible with current engine and loaded packs
    func validateCompatibility(with registry: ContentRegistry) -> SaveCompatibilityResult {
        var warnings: [String] = []
        var errors: [String] = []

        // Check core version
        if coreVersion != EngineSave.currentCoreVersion {
            warnings.append("Save was created with core version \(coreVersion), current is \(EngineSave.currentCoreVersion)")
        }

        // Check format version
        if formatVersion > EngineSave.currentFormatVersion {
            errors.append("Save format version \(formatVersion) is newer than supported \(EngineSave.currentFormatVersion)")
        }

        // Check pack versions
        for (packId, savedVersion) in activePackSet {
            if let loadedPack = registry.loadedPacks[packId] {
                let loadedVersion = loadedPack.manifest.version.description
                if loadedVersion != savedVersion {
                    warnings.append("Pack '\(packId)' version mismatch: save has \(savedVersion), loaded is \(loadedVersion)")
                }
            } else {
                errors.append("Required pack '\(packId)' (version \(savedVersion)) is not loaded")
            }
        }

        if !errors.isEmpty {
            return .incompatible(errors: errors)
        } else if !warnings.isEmpty {
            return .compatible(warnings: warnings)
        } else {
            return .fullyCompatible
        }
    }
}

/// Result of save compatibility validation
enum SaveCompatibilityResult {
    case fullyCompatible
    case compatible(warnings: [String])
    case incompatible(errors: [String])

    var isLoadable: Bool {
        switch self {
        case .fullyCompatible, .compatible:
            return true
        case .incompatible:
            return false
        }
    }
}

// MARK: - Region Save State

/// Состояние региона для сохранения (String IDs - Epic 3)
struct RegionSaveState: Codable {
    let definitionId: String  // Stable definition ID
    let name: String
    let type: String  // RegionType.rawValue
    let state: String  // RegionState.rawValue
    let anchorDefinitionId: String?
    let anchorIntegrity: Int?
    let neighborDefinitionIds: [String]
    let canTrade: Bool
    let visited: Bool
    let reputation: Int

    init(from region: EngineRegionState) {
        self.definitionId = region.definitionId ?? region.id.uuidString
        self.name = region.name
        self.type = region.type.rawValue
        self.state = region.state.rawValue
        self.anchorDefinitionId = region.anchor?.definitionId
        self.anchorIntegrity = region.anchor?.integrity
        self.neighborDefinitionIds = region.neighborDefinitionIds ?? []
        self.canTrade = region.canTrade
        self.visited = region.visited
        self.reputation = region.reputation
    }

    func toEngineRegionState() -> EngineRegionState {
        var anchor: EngineAnchorState? = nil
        if let anchorId = anchorDefinitionId {
            anchor = EngineAnchorState(
                id: UUID(),
                definitionId: anchorId,
                name: anchorId,
                integrity: anchorIntegrity ?? 100
            )
        }

        return EngineRegionState(
            id: UUID(),
            definitionId: definitionId,
            name: name,
            type: RegionType(rawValue: type) ?? .settlement,
            state: RegionState(rawValue: state) ?? .stable,
            anchor: anchor,
            neighborIds: [],
            neighborDefinitionIds: neighborDefinitionIds,
            canTrade: canTrade,
            visited: visited,
            reputation: reputation
        )
    }
}

// MARK: - Anchor Save State (Deprecated - anchors now stored inline in RegionSaveState)

// MARK: - Event Log Entry Save

/// Запись лога событий для сохранения
struct EventLogEntrySave: Codable {
    let id: UUID
    let dayNumber: Int
    let timestamp: Date
    let regionName: String
    let eventTitle: String
    let choiceMade: String
    let outcome: String
    let type: String  // EventLogType.rawValue

    init(from entry: EventLogEntry) {
        self.id = entry.id
        self.dayNumber = entry.dayNumber
        self.timestamp = entry.timestamp
        self.regionName = entry.regionName
        self.eventTitle = entry.eventTitle
        self.choiceMade = entry.choiceMade
        self.outcome = entry.outcome
        self.type = entry.type.rawValue
    }

    func toEventLogEntry() -> EventLogEntry {
        EventLogEntry(
            id: id,
            dayNumber: dayNumber,
            timestamp: timestamp,
            regionName: regionName,
            eventTitle: eventTitle,
            choiceMade: choiceMade,
            outcome: outcome,
            type: EventLogType(rawValue: type) ?? .exploration
        )
    }
}

// MARK: - TwilightGameEngine Save/Load
// NOTE: Save/Load methods moved to TwilightGameEngine.swift for proper access to internal state
// See TwilightGameEngine+Persistence.swift for implementation


// ==========================================
// FILE: Engine/Core/GameLoop.swift
// ==========================================

import Foundation

// MARK: - Game Loop / Engine Orchestrator
// The central coordinator that runs the game engine.
// This is the "processor" - specific games are the "cartridge".

/// Engine game phase enum (distinct from legacy GamePhase in Models/GameState.swift)
enum EngineGamePhase: String, Codable {
    case setup
    case playing
    case paused
    case ended
}

/// Game end result
enum GameEndResult: Equatable {
    case victory(endingId: String)
    case defeat(reason: String)
    case abandoned
}

// MARK: - Abstract Game Loop

/// Base class for game loop implementation
/// Subclass this for specific game implementations
class GameLoopBase: ObservableObject {
    // MARK: - Published State

    @Published private(set) var currentPhase: EngineGamePhase = .setup
    @Published private(set) var isGameOver: Bool = false
    @Published private(set) var endResult: GameEndResult?

    // MARK: - Core Subsystems

    let timeEngine: TimeEngine
    let pressureEngine: PressureEngine
    let economyManager: EconomyManager

    // MARK: - State

    /// Player resources (generic key-value store)
    @Published var playerResources: [String: Int] = [:]

    /// World flags
    @Published var worldFlags: [String: Bool] = [:]

    /// Completed event IDs
    private(set) var completedEvents: Set<String> = []

    // MARK: - Delegates

    weak var timeDelegate: TimeSystemDelegate? {
        didSet { timeEngine.delegate = timeDelegate }
    }

    // MARK: - Initialization

    init(
        pressureRules: PressureRuleSet,
        timeThresholdInterval: Int = 3
    ) {
        self.timeEngine = TimeEngine(thresholdInterval: timeThresholdInterval)
        self.pressureEngine = PressureEngine(rules: pressureRules)
        self.economyManager = EconomyManager()
    }

    // MARK: - Core Loop Methods

    /// Start a new game
    func startGame() {
        currentPhase = .playing
        isGameOver = false
        endResult = nil

        // Reset subsystems
        timeEngine.reset()
        pressureEngine.reset()
        economyManager.clearHistory()
        completedEvents.removeAll()

        // Subclass should override to set initial state
        setupInitialState()
    }

    /// Override in subclass to set initial player resources, world state, etc.
    func setupInitialState() {
        // Subclass implementation
    }

    /// Main action execution - the canonical core loop
    func performAction(_ action: any TimedAction) async {
        guard currentPhase == .playing else { return }

        // 1. Get time cost
        let cost = action.timeCost

        // 2. Advance time (triggers worldTick via delegate)
        timeEngine.advance(cost: cost)

        // 3. Check if time threshold crossed (every N days)
        if timeEngine.checkThreshold(pressureEngine.rules.escalationInterval) {
            // 4. Escalate pressure
            pressureEngine.escalate(at: timeEngine.currentTime)

            // 5. Apply world effects
            applyWorldEffects(pressureEngine.currentEffects())
        }

        // 6. Process action-specific logic (subclass)
        await processAction(action)

        // 7. Update quests (subclass)
        updateQuests()

        // 8. Check end conditions
        checkEndConditions()

        // 9. Auto-save (if configured)
        autoSave()
    }

    /// Override in subclass to handle specific actions
    func processAction(_ action: any TimedAction) async {
        // Subclass implementation
    }

    /// Override in subclass to update quest progress
    func updateQuests() {
        // Subclass implementation
    }

    /// Apply world effects from pressure thresholds
    func applyWorldEffects(_ effects: [WorldEffect]) {
        for effect in effects {
            applyWorldEffect(effect)
        }
    }

    /// Apply a single world effect - override in subclass for custom effects
    func applyWorldEffect(_ effect: WorldEffect) {
        switch effect {
        case .regionDegradation(let probability):
            // Subclass handles region degradation
            handleRegionDegradation(probability: probability)

        case .globalEvent(let eventId):
            // Trigger a global event
            triggerGlobalEvent(eventId)

        case .phaseChange(let newPhase):
            // Handle phase change
            handlePhaseChange(newPhase)

        case .anchorWeakening(let amount):
            // Weaken anchors
            weakenAnchors(amount: amount)

        case .custom(let id, let parameters):
            // Custom effect - subclass handles
            handleCustomEffect(id: id, parameters: parameters)
        }
    }

    // MARK: - Effect Handlers (Override in Subclass)

    func handleRegionDegradation(probability: Double) {
        // Subclass implementation
    }

    func triggerGlobalEvent(_ eventId: String) {
        // Subclass implementation
    }

    func handlePhaseChange(_ newPhase: String) {
        // Subclass implementation
    }

    func weakenAnchors(amount: Int) {
        // Subclass implementation
    }

    func handleCustomEffect(id: String, parameters: [String: Any]) {
        // Subclass implementation
    }

    // MARK: - End Conditions

    /// Check victory and defeat conditions
    func checkEndConditions() {
        // Check pressure-based defeat
        if pressureEngine.isAtMaximum {
            endGame(result: .defeat(reason: "pressure_maximum"))
            return
        }

        // Check resource-based defeat (e.g., health = 0)
        if let health = playerResources["health"], health <= 0 {
            endGame(result: .defeat(reason: "health_zero"))
            return
        }

        // Subclass should override for victory conditions
        checkVictoryConditions()
    }

    /// Override in subclass for game-specific victory conditions
    func checkVictoryConditions() {
        // Subclass implementation
    }

    /// End the game
    func endGame(result: GameEndResult) {
        currentPhase = .ended
        isGameOver = true
        endResult = result
    }

    // MARK: - Resource Management

    /// Get a resource value
    func getResource(_ key: String) -> Int {
        return playerResources[key] ?? 0
    }

    /// Set a resource value
    func setResource(_ key: String, value: Int) {
        playerResources[key] = value
    }

    /// Modify a resource by delta
    func modifyResource(_ key: String, by delta: Int) {
        let current = playerResources[key] ?? 0
        playerResources[key] = current + delta
    }

    /// Process a transaction
    func processTransaction(_ transaction: Transaction) -> Bool {
        return economyManager.process(transaction, resources: &playerResources)
    }

    // MARK: - Flag Management

    /// Set a world flag
    func setFlag(_ flag: String, value: Bool = true) {
        worldFlags[flag] = value
    }

    /// Check a world flag
    func hasFlag(_ flag: String) -> Bool {
        return worldFlags[flag] ?? false
    }

    // MARK: - Event Tracking

    /// Mark an event as completed
    func markEventCompleted(_ eventId: String) {
        completedEvents.insert(eventId)
    }

    /// Check if event was completed
    func isEventCompleted(_ eventId: String) -> Bool {
        return completedEvents.contains(eventId)
    }

    // MARK: - Save/Load

    func autoSave() {
        // Subclass implementation
    }

    func save() {
        // Subclass implementation
    }

    func load() {
        // Subclass implementation
    }

    // MARK: - Context Building

    /// Build event context for event filtering
    func buildEventContext(
        currentLocation: String,
        locationState: String
    ) -> EventContext {
        return EventContext(
            currentLocation: currentLocation,
            locationState: locationState,
            pressure: pressureEngine.currentPressure,
            flags: worldFlags,
            resources: playerResources,
            completedEvents: completedEvents
        )
    }
}

// MARK: - Action Types

/// Standard game actions
enum StandardAction: TimedAction {
    case travel(from: String, to: String, isNeighbor: Bool)
    case rest
    case explore(instant: Bool)
    case trade
    case interact(targetId: String)
    case combat(enemyId: String)
    case useAbility(abilityId: String)
    case custom(id: String, cost: Int)

    var timeCost: Int {
        switch self {
        case .travel(_, _, let isNeighbor):
            return isNeighbor ? 1 : 2
        case .rest:
            return 1
        case .explore(let instant):
            return instant ? 0 : 1
        case .trade:
            return 1
        case .interact:
            return 1
        case .combat:
            return 1
        case .useAbility:
            return 1
        case .custom(_, let cost):
            return cost
        }
    }
}


// ==========================================
// FILE: Engine/Core/PressureEngine.swift
// ==========================================

import Foundation

// MARK: - Pressure Engine Implementation
// Generic pressure/tension system that drives game escalation.

/// Default implementation of PressureEngineProtocol
final class PressureEngine: PressureEngineProtocol {
    // MARK: - Properties

    private(set) var currentPressure: Int
    let rules: PressureRuleSet

    /// Track which thresholds have been triggered
    private var triggeredThresholds: Set<Int> = []

    // MARK: - Initialization

    init(rules: PressureRuleSet) {
        self.rules = rules
        self.currentPressure = rules.initialPressure
    }

    // MARK: - PressureEngineProtocol

    /// Escalate pressure based on rules and current time
    func escalate(at currentTime: Int) {
        let delta = rules.calculateEscalation(currentPressure: currentPressure, currentTime: currentTime)
        adjust(by: delta)
    }

    /// Manually adjust pressure (can be positive or negative)
    func adjust(by delta: Int) {
        let newPressure = currentPressure + delta
        currentPressure = min(max(0, newPressure), rules.maxPressure)
    }

    /// Get effects that should trigger at current pressure level
    func currentEffects() -> [WorldEffect] {
        return rules.checkThresholds(pressure: currentPressure)
    }

    // MARK: - Utility

    /// Reset pressure (for new game)
    func reset() {
        currentPressure = rules.initialPressure
        triggeredThresholds.removeAll()
    }

    /// Set pressure directly (for save/load)
    func setPressure(_ value: Int) {
        currentPressure = min(max(0, value), rules.maxPressure)
    }

    // MARK: - Save/Load Support

    /// Get triggered thresholds for save
    func getTriggeredThresholds() -> Set<Int> {
        return triggeredThresholds
    }

    /// Restore triggered thresholds from save
    /// Call this after loading game to prevent duplicate threshold events
    func setTriggeredThresholds(_ thresholds: Set<Int>) {
        triggeredThresholds = thresholds
    }

    /// Reconstruct triggered thresholds from current pressure value
    /// Use this when loading a save that doesn't have explicit thresholds saved
    /// All thresholds below or equal to current pressure are marked as triggered
    func syncTriggeredThresholdsFromPressure() {
        triggeredThresholds.removeAll()
        // Use checkThresholds to find which effects would trigger at current pressure
        // Then mark standard threshold levels (10, 20, 30, etc.) as triggered
        // This is a heuristic - actual threshold levels depend on the rule set
        let standardThresholds = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
        for threshold in standardThresholds where threshold <= currentPressure {
            triggeredThresholds.insert(threshold)
        }
    }

    /// Get pressure as percentage (0.0 - 1.0)
    var pressurePercentage: Double {
        guard rules.maxPressure > 0 else { return 0 }
        return Double(currentPressure) / Double(rules.maxPressure)
    }

    /// Check if at maximum pressure (game over condition)
    var isAtMaximum: Bool {
        currentPressure >= rules.maxPressure
    }
}

// MARK: - Standard Pressure Rule Set

/// Basic pressure rules with configurable parameters
struct StandardPressureRules: PressureRuleSet {
    let maxPressure: Int
    let initialPressure: Int
    let escalationInterval: Int
    let escalationAmount: Int

    /// Thresholds that trigger effects [pressure: effects]
    let thresholds: [Int: [WorldEffect]]

    init(
        maxPressure: Int = 100,
        initialPressure: Int = 30,
        escalationInterval: Int = 3,
        escalationAmount: Int = 2,
        thresholds: [Int: [WorldEffect]] = [:]
    ) {
        self.maxPressure = maxPressure
        self.initialPressure = initialPressure
        self.escalationInterval = escalationInterval
        self.escalationAmount = escalationAmount
        self.thresholds = thresholds
    }

    func calculateEscalation(currentPressure: Int, currentTime: Int) -> Int {
        // Standard: add escalationAmount every escalationInterval
        return escalationAmount
    }

    func checkThresholds(pressure: Int) -> [WorldEffect] {
        var effects: [WorldEffect] = []

        for (threshold, thresholdEffects) in thresholds {
            if pressure >= threshold {
                effects.append(contentsOf: thresholdEffects)
            }
        }

        return effects
    }
}

// MARK: - Adaptive Pressure Rules

/// Pressure rules that adapt based on game state
struct AdaptivePressureRules: PressureRuleSet {
    let maxPressure: Int
    let initialPressure: Int
    let escalationInterval: Int
    let baseEscalationAmount: Int

    /// Multiplier based on current pressure (higher pressure = faster escalation)
    let accelerationFactor: Double

    /// Thresholds with effects
    let thresholds: [Int: [WorldEffect]]

    var escalationAmount: Int { baseEscalationAmount }

    init(
        maxPressure: Int = 100,
        initialPressure: Int = 30,
        escalationInterval: Int = 3,
        baseEscalationAmount: Int = 2,
        accelerationFactor: Double = 0.01,
        thresholds: [Int: [WorldEffect]] = [:]
    ) {
        self.maxPressure = maxPressure
        self.initialPressure = initialPressure
        self.escalationInterval = escalationInterval
        self.baseEscalationAmount = baseEscalationAmount
        self.accelerationFactor = accelerationFactor
        self.thresholds = thresholds
    }

    func calculateEscalation(currentPressure: Int, currentTime: Int) -> Int {
        // Adaptive: base amount + acceleration based on current pressure
        let acceleration = Int(Double(currentPressure) * accelerationFactor)
        return baseEscalationAmount + acceleration
    }

    func checkThresholds(pressure: Int) -> [WorldEffect] {
        var effects: [WorldEffect] = []

        for (threshold, thresholdEffects) in thresholds {
            if pressure >= threshold {
                effects.append(contentsOf: thresholdEffects)
            }
        }

        return effects
    }
}

// MARK: - Pressure Change Event

/// Event fired when pressure changes significantly
struct PressureChangeEvent {
    let oldValue: Int
    let newValue: Int
    let delta: Int
    let thresholdsCrossed: [Int]
    let effectsTriggered: [WorldEffect]
}


// ==========================================
// FILE: Engine/Core/RequirementsEvaluator.swift
// ==========================================

import Foundation

// MARK: - Requirements Evaluator
// Логика проверки требований, вынесенная из Definitions в Engine Core
// Definitions остаются "тупыми данными", а логика живёт здесь

/// Протокол для оценки требований
protocol RequirementsEvaluating {
    /// Проверяет, выполнены ли требования выбора
    func canMeet(
        requirements: ChoiceRequirements,
        resources: [String: Int],
        flags: Set<String>,
        balance: Int
    ) -> Bool

    /// Проверяет, доступен ли выбор в текущем контексте
    func isChoiceAvailable(
        choice: ChoiceDefinition,
        resources: [String: Int],
        flags: Set<String>,
        balance: Int
    ) -> Bool
}

/// Стандартный evaluator для проверки требований
struct RequirementsEvaluator: RequirementsEvaluating {

    /// Проверяет, выполнены ли требования
    func canMeet(
        requirements: ChoiceRequirements,
        resources: [String: Int],
        flags: Set<String>,
        balance: Int
    ) -> Bool {
        // Check resources
        for (resourceId, minValue) in requirements.minResources {
            if (resources[resourceId] ?? 0) < minValue {
                return false
            }
        }

        // Check required flags
        for flag in requirements.requiredFlags {
            if !flags.contains(flag) {
                return false
            }
        }

        // Check forbidden flags
        for flag in requirements.forbiddenFlags {
            if flags.contains(flag) {
                return false
            }
        }

        // Check balance range
        if let min = requirements.minBalance, balance < min {
            return false
        }
        if let max = requirements.maxBalance, balance > max {
            return false
        }

        return true
    }

    /// Проверяет, доступен ли выбор (если есть requirements - проверяет их)
    func isChoiceAvailable(
        choice: ChoiceDefinition,
        resources: [String: Int],
        flags: Set<String>,
        balance: Int
    ) -> Bool {
        guard let requirements = choice.requirements else {
            return true  // Нет требований = всегда доступен
        }
        return canMeet(
            requirements: requirements,
            resources: resources,
            flags: flags,
            balance: balance
        )
    }
}

// MARK: - Shared Instance

/// Глобальный evaluator для проверки требований
enum Requirements {
    static var evaluator: RequirementsEvaluating = RequirementsEvaluator()
}


// ==========================================
// FILE: Engine/Core/TimeEngine.swift
// ==========================================

import Foundation

// MARK: - Time Engine Implementation
// Generic time management system for turn-based games.

/// Default implementation of TimeEngineProtocol
final class TimeEngine: TimeEngineProtocol {
    // MARK: - Properties

    private(set) var currentTime: Int = 0
    weak var delegate: TimeSystemDelegate?

    /// Thresholds that have been triggered (to avoid re-triggering)
    private var triggeredThresholds: Set<Int> = []

    /// Configurable threshold intervals (e.g., [3, 6, 9] or just [3] for "every 3")
    private let thresholdInterval: Int

    // MARK: - Initialization

    /// Initialize with a threshold interval (e.g., 3 for "every 3 time units")
    init(thresholdInterval: Int = 3) {
        self.thresholdInterval = thresholdInterval
    }

    // MARK: - TimeEngineProtocol

    /// Advance time by cost units
    /// Invariant: Time cannot go backwards
    func advance(cost: Int) {
        guard cost > 0 else {
            // Instant actions (cost = 0) don't advance time
            return
        }

        let previousTime = currentTime
        currentTime += cost

        // Notify delegate of each tick
        delegate?.onTimeTick(currentTime: currentTime, delta: cost)

        // Check for threshold crossings
        checkThresholdCrossings(from: previousTime, to: currentTime)
    }

    /// Check if current time has passed a threshold interval
    func checkThreshold(_ interval: Int) -> Bool {
        guard interval > 0 else { return false }
        return currentTime % interval == 0 && currentTime > 0
    }

    // MARK: - Private Methods

    private func checkThresholdCrossings(from previousTime: Int, to newTime: Int) {
        guard thresholdInterval > 0 else { return }

        // Find all threshold crossings in the range
        let previousThreshold = previousTime / thresholdInterval
        let newThreshold = newTime / thresholdInterval

        if newThreshold > previousThreshold {
            for threshold in (previousThreshold + 1)...newThreshold {
                let thresholdTime = threshold * thresholdInterval
                delegate?.onTimeThreshold(currentTime: newTime, threshold: thresholdTime)
            }
        }
    }

    // MARK: - Utility

    /// Reset time (for new game)
    func reset() {
        currentTime = 0
        triggeredThresholds.removeAll()
    }

    /// Set time directly (for save/load)
    func setTime(_ time: Int) {
        currentTime = max(0, time)
    }
}

// MARK: - Time Cost Constants

/// Standard time costs for common actions
enum StandardTimeCost: Int, TimedAction {
    case instant = 0
    case quick = 1
    case standard = 2
    case extended = 3
    case long = 4

    var timeCost: Int { rawValue }
}

// MARK: - TimedAction Extensions

/// Simple timed action wrapper
struct SimpleTimedAction: TimedAction {
    let timeCost: Int
    let actionId: String

    init(cost: Int, id: String = "") {
        self.timeCost = cost
        self.actionId = id
    }
}

/// Travel action with variable cost
struct TravelAction: TimedAction {
    let fromLocation: String
    let toLocation: String
    let isNeighbor: Bool

    var timeCost: Int {
        isNeighbor ? 1 : 2
    }
}

/// Rest action
struct RestAction: TimedAction {
    let timeCost: Int = 1
}

/// Exploration action
struct ExploreAction: TimedAction {
    let isInstant: Bool
    var timeCost: Int { isInstant ? 0 : 1 }
}


// ==========================================
// FILE: Engine/Core/TwilightGameAction.swift
// ==========================================

import Foundation

// MARK: - Twilight Marches Game Actions
// All player actions go through these - UI never mutates state directly

/// All possible player actions in Twilight Marches
enum TwilightGameAction: TimedAction, Equatable {
    // MARK: - Movement
    /// Travel to another region
    case travel(toRegionId: UUID)

    // MARK: - Region Actions
    /// Rest in current region (heals, costs time)
    case rest

    /// Explore current region (triggers events)
    case explore

    /// Trade at market (if available)
    case trade

    /// Strengthen anchor in current region
    case strengthenAnchor

    // MARK: - Event Handling
    /// Choose an option in an event
    case chooseEventOption(eventId: UUID, choiceIndex: Int)

    /// Resolve a mini-game result
    case resolveMiniGame(input: MiniGameInput)

    // MARK: - Combat Setup
    /// Start combat with encounter
    case startCombat(encounterId: UUID)

    /// Initialize combat: shuffle deck and draw initial hand
    case combatInitialize

    // MARK: - Combat Actions
    /// Perform basic attack in combat
    case combatAttack(bonusDice: Int, bonusDamage: Int, isFirstAttack: Bool)

    /// Play a card in combat
    case playCard(cardId: UUID, targetId: UUID?)

    /// Apply card ability effect
    case combatApplyEffect(effect: CombatActionEffect)

    /// End combat turn (goes to enemy phase)
    case endCombatTurn

    /// Perform enemy attack
    case combatEnemyAttack(damage: Int)

    /// End turn phase: discard hand, draw new cards, restore faith
    case combatEndTurnPhase

    /// Flee from combat
    case combatFlee

    /// Finish combat with result
    case combatFinish(victory: Bool)

    // MARK: - UI Actions
    /// Dismiss current event (after UI handles it)
    case dismissCurrentEvent

    /// Dismiss day event notification
    case dismissDayEvent

    // MARK: - Special
    /// Skip/pass turn
    case skipTurn

    /// Custom action for extensibility
    case custom(id: String, timeCost: Int)

    // MARK: - TimedAction Conformance

    var timeCost: Int {
        switch self {
        case .travel:
            // Travel cost determined by engine based on distance
            // Default to 1, actual cost calculated in engine
            return 1

        case .rest:
            return 1

        case .explore:
            return 1

        case .trade:
            return 0  // Trading doesn't cost time

        case .strengthenAnchor:
            return 1

        case .chooseEventOption:
            return 0  // Events are part of explore/travel

        case .resolveMiniGame:
            return 0  // Mini-game is part of event

        case .startCombat:
            return 0  // Combat is part of event

        case .combatInitialize:
            return 0  // Setup, no time cost

        case .combatAttack:
            return 0  // Within combat turn

        case .playCard:
            return 0  // Cards are within combat turn

        case .combatApplyEffect:
            return 0  // Effect application

        case .endCombatTurn:
            return 0  // Turn management

        case .combatEnemyAttack:
            return 0  // Enemy phase

        case .combatEndTurnPhase:
            return 0  // End of turn

        case .combatFlee:
            return 0  // Escape

        case .combatFinish:
            return 0  // Combat end

        case .dismissCurrentEvent:
            return 0  // UI action, no time cost

        case .dismissDayEvent:
            return 0  // UI action, no time cost

        case .skipTurn:
            return 1

        case .custom(_, let cost):
            return cost
        }
    }
}

// MARK: - Mini-Game Input

/// Input data for resolving a mini-game action
/// Different from MiniGameResult in MiniGameChallengeDefinition.swift (serializable state diff)
struct MiniGameInput: Equatable {
    let challengeId: UUID
    let success: Bool
    let score: Int?
    let bonusRewards: [String: Int]

    init(challengeId: UUID, success: Bool, score: Int? = nil, bonusRewards: [String: Int] = [:]) {
        self.challengeId = challengeId
        self.success = success
        self.score = score
        self.bonusRewards = bonusRewards
    }
}

// MARK: - Combat Effect

/// Effect to apply during combat (from cards or abilities)
enum CombatActionEffect: Equatable {
    /// Heal player
    case heal(amount: Int)

    /// Deal damage to enemy
    case damageEnemy(amount: Int)

    /// Draw cards
    case drawCards(count: Int)

    /// Gain faith
    case gainFaith(amount: Int)

    /// Spend faith
    case spendFaith(amount: Int)

    /// Take damage (sacrifice)
    case takeDamage(amount: Int)

    /// Remove curse
    case removeCurse(type: String?)

    /// Shift balance
    case shiftBalance(towards: String, amount: Int)

    /// Add bonus dice for next attack
    case addBonusDice(count: Int)

    /// Add bonus damage for next attack
    case addBonusDamage(amount: Int)

    /// Summon spirit to attack enemy
    case summonSpirit(power: Int, realm: String)
}

// MARK: - Action Result

/// Result of performing a game action
struct ActionResult: Equatable {
    /// Whether the action succeeded
    let success: Bool

    /// Error if action failed
    let error: ActionError?

    /// State changes that occurred
    let stateChanges: [StateChange]

    /// Events triggered by this action
    let triggeredEvents: [UUID]

    /// New current event (if any)
    let currentEvent: UUID?

    /// Combat started (if any)
    let combatStarted: Bool

    /// Game ended (if any)
    let gameEnded: GameEndResult?

    // MARK: - Convenience Initializers

    static func success(
        changes: [StateChange] = [],
        triggeredEvents: [UUID] = [],
        currentEvent: UUID? = nil,
        combatStarted: Bool = false
    ) -> ActionResult {
        ActionResult(
            success: true,
            error: nil,
            stateChanges: changes,
            triggeredEvents: triggeredEvents,
            currentEvent: currentEvent,
            combatStarted: combatStarted,
            gameEnded: nil
        )
    }

    static func failure(_ error: ActionError) -> ActionResult {
        ActionResult(
            success: false,
            error: error,
            stateChanges: [],
            triggeredEvents: [],
            currentEvent: nil,
            combatStarted: false,
            gameEnded: nil
        )
    }

    static func gameOver(_ result: GameEndResult) -> ActionResult {
        ActionResult(
            success: true,
            error: nil,
            stateChanges: [],
            triggeredEvents: [],
            currentEvent: nil,
            combatStarted: false,
            gameEnded: result
        )
    }
}

// MARK: - Action Error

/// Errors that can occur when performing actions
enum ActionError: Error, Equatable {
    // Validation errors
    case invalidAction(reason: String)
    case regionNotAccessible(regionId: UUID)
    case regionNotNeighbor(regionId: UUID)
    case actionNotAvailableInRegion(action: String, regionType: String)

    // Resource errors
    case insufficientResources(resource: String, required: Int, available: Int)
    case healthTooLow

    // State errors
    case gameNotInProgress
    case combatInProgress
    case eventInProgress
    case noActiveEvent
    case noActiveCombat

    // Event errors
    case eventNotFound(eventId: UUID)
    case invalidChoiceIndex(index: Int, maxIndex: Int)
    case choiceRequirementsNotMet(reason: String)

    // Combat errors
    case cardNotInHand(cardId: UUID)
    case notEnoughActions
    case invalidTarget

    var localizedDescription: String {
        switch self {
        case .invalidAction(let reason):
            return L10n.errorInvalidAction.localized(with: reason)
        case .regionNotAccessible(let id):
            return L10n.errorRegionNotAccessible.localized(with: String(id.uuidString.prefix(8)))
        case .regionNotNeighbor(let id):
            return L10n.errorRegionNotNeighbor.localized(with: String(id.uuidString.prefix(8)))
        case .actionNotAvailableInRegion(let action, let type):
            return L10n.errorActionNotAvailable.localized(with: action, type)
        case .insufficientResources(let resource, let required, let available):
            return L10n.errorInsufficientResources.localized(with: resource, required, available)
        case .healthTooLow:
            return L10n.errorHealthTooLow.localized
        case .gameNotInProgress:
            return L10n.errorGameNotInProgress.localized
        case .combatInProgress:
            return L10n.errorCombatInProgress.localized
        case .eventInProgress:
            return L10n.errorEventInProgress.localized
        case .noActiveEvent:
            return L10n.errorNoActiveEvent.localized
        case .noActiveCombat:
            return L10n.errorNoActiveCombat.localized
        case .eventNotFound(let id):
            return L10n.errorEventNotFound.localized(with: String(id.uuidString.prefix(8)))
        case .invalidChoiceIndex(let index, let max):
            return L10n.errorInvalidChoiceIndex.localized(with: index, max)
        case .choiceRequirementsNotMet(let reason):
            return L10n.errorChoiceRequirementsNotMet.localized(with: reason)
        case .cardNotInHand(let id):
            return L10n.errorCardNotInHand.localized(with: String(id.uuidString.prefix(8)))
        case .notEnoughActions:
            return L10n.errorNotEnoughActions.localized
        case .invalidTarget:
            return L10n.errorInvalidTarget.localized
        }
    }
}

// MARK: - State Change

/// A single state change from an action
enum StateChange: Equatable {
    // Player changes
    case healthChanged(delta: Int, newValue: Int)
    case faithChanged(delta: Int, newValue: Int)
    case balanceChanged(delta: Int, newValue: Int)
    case strengthChanged(delta: Int, newValue: Int)

    // World changes
    case tensionChanged(delta: Int, newValue: Int)
    case dayAdvanced(newDay: Int)
    case regionChanged(regionId: UUID)
    case regionStateChanged(regionId: UUID, newState: String)
    case anchorIntegrityChanged(anchorId: UUID, delta: Int, newValue: Int)

    // Flags and progress
    case flagSet(key: String, value: Bool)
    case questProgressed(questId: String, newStage: Int)
    case eventCompleted(eventId: UUID)
    case questStarted(questId: String)
    case objectiveCompleted(questId: String, objectiveId: String)
    case questCompleted(questId: String)
    case questFailed(questId: String)

    // Cards and deck
    case cardAdded(cardId: UUID, zone: String)
    case cardRemoved(cardId: UUID, zone: String)
    case cardMoved(cardId: UUID, fromZone: String, toZone: String)

    // Combat
    case enemyDamaged(enemyId: UUID, damage: Int, newHealth: Int)
    case enemyDefeated(enemyId: UUID)
    case combatEnded(victory: Bool)

    // Custom
    case custom(key: String, description: String)
}


// ==========================================
// FILE: Engine/Core/TwilightGameEngine.swift
// ==========================================

import Foundation
import Combine

// MARK: - Twilight Marches Game Engine
// The central game orchestrator - ALL game actions go through here

/// Main game engine for Twilight Marches
/// UI should NEVER mutate state directly - always go through performAction()
final class TwilightGameEngine: ObservableObject {

    // MARK: - Published State (for UI binding)
    // Audit v1.1 Issue #1, #8: UI reads directly from Engine, not WorldState

    @Published private(set) var currentDay: Int = 0
    @Published private(set) var worldTension: Int = 30
    @Published private(set) var currentRegionId: UUID?
    @Published private(set) var isGameOver: Bool = false
    @Published private(set) var gameResult: GameEndResult?

    @Published private(set) var currentEventId: UUID?
    @Published private(set) var isInCombat: Bool = false

    @Published private(set) var lastActionResult: ActionResult?

    // MARK: - Published State for UI (Engine-First Architecture)

    /// All regions with their current state - UI reads this directly
    @Published private(set) var publishedRegions: [UUID: EngineRegionState] = [:]

    /// Player stats - UI reads these directly instead of Player model
    @Published private(set) var playerHealth: Int = 10
    @Published private(set) var playerMaxHealth: Int = 10
    @Published private(set) var playerFaith: Int = 3
    @Published private(set) var playerMaxFaith: Int = 10
    @Published private(set) var playerBalance: Int = 50
    @Published private(set) var playerName: String = "Герой"

    /// World flags - for quest/event conditions
    @Published private(set) var publishedWorldFlags: [String: Bool] = [:]

    /// Current event being displayed to player
    @Published private(set) var currentEvent: GameEvent?

    /// Day event notification (tension increase, degradation, etc.)
    @Published private(set) var lastDayEvent: DayEvent?

    /// Active quests
    @Published private(set) var publishedActiveQuests: [Quest] = []

    /// Event log (last 100 entries)
    @Published private(set) var publishedEventLog: [EventLogEntry] = []

    /// Light/Dark balance of the world
    @Published private(set) var lightDarkBalance: Int = 50

    /// Main quest stage (1-5)
    @Published private(set) var mainQuestStage: Int = 1

    // MARK: - UI Convenience Accessors (Engine-First Architecture)

    /// Get regions as sorted array for UI iteration
    var regionsArray: [EngineRegionState] {
        publishedRegions.values.sorted { $0.name < $1.name }
    }

    /// Get current region
    var currentRegion: EngineRegionState? {
        guard let id = currentRegionId else { return nil }
        return publishedRegions[id]
    }

    /// Check if player can afford faith cost
    func canAffordFaith(_ cost: Int) -> Bool {
        return playerFaith >= cost
    }

    /// Check if region is neighbor to current region
    func isNeighbor(regionId: UUID) -> Bool {
        guard let current = currentRegion else { return false }
        return current.neighborIds.contains(regionId)
    }

    /// Calculate travel cost to target region (1 = neighbor, 2 = distant)
    func calculateTravelCost(to targetId: UUID) -> Int {
        return isNeighbor(regionId: targetId) ? 1 : 2
    }

    /// Check if travel to region is allowed (only neighbors allowed)
    func canTravelTo(regionId: UUID) -> Bool {
        guard regionId != currentRegionId else { return false }
        return isNeighbor(regionId: regionId)
    }

    /// Get neighboring region names that connect to target (for routing hints)
    func getRoutingHint(to targetId: UUID) -> [String] {
        guard let current = currentRegion else { return [] }

        // If already neighbor, no hint needed
        if current.neighborIds.contains(targetId) { return [] }

        // Find which neighbors connect to target
        var connectingNeighbors: [String] = []
        for neighborId in current.neighborIds {
            guard let neighbor = regions[neighborId] else { continue }
            if neighbor.neighborIds.contains(targetId) {
                connectingNeighbors.append(neighbor.name)
            }
        }

        return connectingNeighbors
    }

    /// Player balance description for UI
    var playerBalanceDescription: String {
        switch playerBalance {
        case 70...100: return "Свет"
        case 31..<70: return "Равновесие"
        default: return "Тьма"
        }
    }

    /// World balance description
    var worldBalanceDescription: String {
        switch lightDarkBalance {
        case 70...100: return "Явь сильна"
        case 31..<70: return "Сумрак"
        default: return "Навь наступает"
        }
    }

    /// Check if region can rest
    func canRestInCurrentRegion() -> Bool {
        guard let region = currentRegion else { return false }
        return region.state == .stable
    }

    /// Check if region can trade
    func canTradeInCurrentRegion() -> Bool {
        guard let region = currentRegion else { return false }
        return region.canTrade
    }

    /// Check if exploration can find events in current region
    func hasAvailableEventsInCurrentRegion() -> Bool {
        guard let regionId = currentRegionId,
              let region = publishedRegions[regionId] else { return false }

        // Check via legacy adapter if available
        if let worldState = worldStateAdapter?.worldState,
           let legacyRegion = worldState.regions.first(where: { $0.id == regionId }) {
            let events = worldState.getAvailableEvents(for: legacyRegion)
            return !events.isEmpty
        }

        // Fallback: check content registry for events in this region type
        let events = contentRegistry.getAvailableEvents(
            forRegion: region.type.rawValue,
            pressure: worldTension
        )
        return !events.isEmpty
    }

    // MARK: - Core Subsystems

    private let timeEngine: TimeEngine
    private let pressureEngine: PressureEngine
    private let economyManager: EconomyManager
    private let questTriggerEngine: QuestTriggerEngine

    // MARK: - State Adapters

    /// Adapter to sync with legacy WorldState (during migration)
    /// Engine owns these adapters (not weak to prevent immediate deallocation)
    private var worldStateAdapter: WorldStateEngineAdapter?

    /// Player adapter
    private var playerAdapter: PlayerEngineAdapter?

    // MARK: - Internal State

    private var regions: [UUID: EngineRegionState] = [:]
    private var completedEventIds: Set<UUID> = []
    private var worldFlags: [String: Bool] = [:]
    private var questStages: [String: Int] = [:]

    /// All events in the game (from ContentProvider)
    private var allEvents: [GameEvent] = []

    /// Active quests
    private var activeQuests: [Quest] = []

    /// Completed quest IDs
    private var completedQuestIds: Set<String> = []

    /// Event log
    private var eventLog: [EventLogEntry] = []

    /// Player deck (for save/load)
    private var playerDeck: [Card] = []
    /// Player's hand cards (Published for UI binding)
    @Published private(set) var playerHand: [Card] = []
    private var playerDiscard: [Card] = []

    // MARK: - Combat State

    /// Current enemy card in combat
    @Published private(set) var combatEnemy: Card?

    /// Enemy current health
    @Published private(set) var combatEnemyHealth: Int = 0

    /// Combat actions remaining this turn
    @Published private(set) var combatActionsRemaining: Int = 3

    /// Combat turn number
    @Published private(set) var combatTurnNumber: Int = 1

    /// Bonus dice for next attack (from cards)
    private var combatBonusDice: Int = 0

    /// Bonus damage for next attack (from cards)
    private var combatBonusDamage: Int = 0

    /// Is this the first attack in this combat (for abilities)
    private var combatIsFirstAttack: Bool = true

    // MARK: - Content Registry

    /// Content registry for loading content packs
    private let contentRegistry: ContentRegistry

    /// Balance configuration from content pack
    private var balanceConfig: BalanceConfiguration

    // MARK: - Configuration Constants (from BalanceConfiguration)

    private var tensionTickInterval: Int { balanceConfig.pressure.effectiveTickInterval }
    private var restHealAmount: Int { balanceConfig.resources.restHealAmount ?? 3 }
    private var anchorStrengthenCost: Int { balanceConfig.anchor.strengthenCost }
    private var anchorStrengthenAmount: Int { balanceConfig.anchor.strengthenAmount }

    // MARK: - Initialization

    init(registry: ContentRegistry = .shared) {
        self.contentRegistry = registry
        self.balanceConfig = registry.getBalanceConfig() ?? .default
        self.timeEngine = TimeEngine(thresholdInterval: 3)
        self.pressureEngine = PressureEngine(rules: TwilightPressureRules())
        self.economyManager = EconomyManager()
        self.questTriggerEngine = QuestTriggerEngine(contentRegistry: registry)
    }

    // MARK: - Setup

    /// Connect to legacy WorldState for bidirectional sync
    func connectToLegacy(worldState: WorldState, player: Player) {
        // Reset critical game state flags when connecting (supports new game flow)
        resetGameState()

        self.worldStateAdapter = WorldStateEngineAdapter(worldState: worldState, engine: self)
        self.playerAdapter = PlayerEngineAdapter(player: player, engine: self)

        // Initial sync from legacy
        syncFromLegacy()
    }

    /// Reset critical game state flags (called when starting new game or loading save)
    func resetGameState() {
        isGameOver = false
        gameResult = nil
        currentEventId = nil
        currentEvent = nil
        lastDayEvent = nil
        isInCombat = false
        combatEnemy = nil
        combatEnemyHealth = 0
        combatTurnNumber = 0
    }

    /// Sync engine state from legacy models
    func syncFromLegacy() {
        guard let adapter = worldStateAdapter else { return }

        currentDay = adapter.worldState.daysPassed
        worldTension = adapter.worldState.worldTension
        currentRegionId = adapter.worldState.currentRegionId

        // Sync regions (both internal and published)
        var newRegions: [UUID: EngineRegionState] = [:]
        for region in adapter.worldState.regions {
            newRegions[region.id] = EngineRegionState(from: region)
        }
        regions = newRegions
        publishedRegions = newRegions  // Audit v1.1: publish for UI

        // Sync flags (both internal and published)
        worldFlags = adapter.worldState.worldFlags
        publishedWorldFlags = worldFlags  // Audit v1.1: publish for UI

        // Sync completed events from GameEvent.completed
        for event in adapter.worldState.allEvents where event.completed {
            completedEventIds.insert(event.id)
        }

        // Sync player stats (Audit v1.1: publish for UI)
        if let player = playerAdapter?.player {
            playerHealth = player.health
            playerMaxHealth = player.maxHealth
            playerFaith = player.faith
            playerBalance = player.balance
            playerHand = player.hand
        }

        // CRITICAL: Sync pressure engine state to prevent duplicate threshold events
        // PressureEngine tracks which thresholds have fired to avoid repeats
        // After load, we reconstruct this from the current pressure value
        pressureEngine.setPressure(worldTension)
        pressureEngine.syncTriggeredThresholdsFromPressure()

        // Sync additional state for Engine-First architecture
        lightDarkBalance = adapter.worldState.lightDarkBalance
        mainQuestStage = adapter.worldState.mainQuestStage
        allEvents = adapter.worldState.allEvents
        activeQuests = adapter.worldState.activeQuests
        eventLog = adapter.worldState.eventLog
        publishedActiveQuests = activeQuests
        publishedEventLog = eventLog
    }

    /// Sync player hand from legacy Player model
    /// Call this after modifying player.hand directly (e.g., in CombatView)
    func syncPlayerHand() {
        if let player = playerAdapter?.player {
            playerHand = player.hand
        }
    }

    // MARK: - Engine-First Initialization

    /// Initialize a new game without legacy WorldState
    /// This is the Engine-First way to start a game
    func initializeNewGame(playerName: String = "Герой") {
        // Reset state
        isGameOver = false
        gameResult = nil
        currentEventId = nil
        currentEvent = nil
        lastDayEvent = nil
        isInCombat = false

        // Load balance config from content registry
        balanceConfig = contentRegistry.getBalanceConfig() ?? .default

        // Setup player from balance config
        self.playerName = playerName
        playerHealth = balanceConfig.resources.startingHealth
        playerMaxHealth = balanceConfig.resources.maxHealth
        playerFaith = balanceConfig.resources.startingFaith
        playerMaxFaith = balanceConfig.resources.maxFaith
        playerBalance = 50

        // Setup world from balance config
        currentDay = 0
        worldTension = balanceConfig.pressure.startingPressure
        lightDarkBalance = 50
        mainQuestStage = 1
        worldFlags = [:]
        completedEventIds = []
        completedQuestIds = []
        eventLog = []

        // Load regions from ContentRegistry
        setupRegionsFromRegistry()

        // Load events
        allEvents = createInitialEvents()

        // Load quests and start main quest
        let initialQuests = createInitialQuests()
        if let mainQuest = initialQuests.first(where: { $0.questType == .main }) {
            activeQuests = [mainQuest]
        }

        // Setup pressure engine
        pressureEngine.setPressure(worldTension)
        pressureEngine.syncTriggeredThresholdsFromPressure()

        // Update all published state
        updatePublishedState()
    }

    /// Setup regions from ContentProvider
    private func setupRegionsFromProvider(_ provider: ContentProvider) {
        let regionDefs = provider.getAllRegionDefinitions()
        var newRegions: [UUID: EngineRegionState] = [:]
        var stringToUUID: [String: UUID] = [:]  // Map string IDs to UUIDs

        // Determine entry region from manifest (no hardcoded "village")
        let entryRegionId = contentRegistry.loadedPacks.values.first?.manifest.entryRegionId

        // First pass: create regions and map IDs
        for def in regionDefs {
            let regionUUID = UUID()
            stringToUUID[def.id] = regionUUID

            let anchor = createEngineAnchor(from: provider.getAnchorDefinition(forRegion: def.id))
            let regionType = mapRegionType(fromString: def.regionType)
            let regionState = mapRegionState(def.initialState)

            let engineRegion = EngineRegionState(
                id: regionUUID,
                name: def.title.localized,
                type: regionType,
                state: regionState,
                anchor: anchor,
                neighborIds: [],  // Will be set in second pass
                canTrade: regionState == .stable && regionType == .settlement
            )
            newRegions[regionUUID] = engineRegion

            // Set starting region from manifest entryRegionId
            if def.id == entryRegionId {
                currentRegionId = regionUUID
            }
        }

        // Second pass: resolve neighbor IDs
        for def in regionDefs {
            guard let regionUUID = stringToUUID[def.id],
                  var region = newRegions[regionUUID] else { continue }

            let neighborUUIDs = def.neighborIds.compactMap { stringToUUID[$0] }
            region = EngineRegionState(
                id: region.id,
                name: region.name,
                type: region.type,
                state: region.state,
                anchor: region.anchor,
                neighborIds: neighborUUIDs,
                canTrade: region.canTrade,
                visited: region.visited,
                reputation: region.reputation
            )
            newRegions[regionUUID] = region
        }

        regions = newRegions
        publishedRegions = newRegions
    }

    /// Setup regions from ContentRegistry (Engine-First architecture)
    private func setupRegionsFromRegistry() {
        let regionDefs = contentRegistry.getAllRegions()
        var newRegions: [UUID: EngineRegionState] = [:]
        var stringToUUID: [String: UUID] = [:]  // Map string IDs to UUIDs

        // Determine entry region from loaded pack manifest (no hardcoded fallback)
        let entryRegionId = contentRegistry.loadedPacks.values.first?.manifest.entryRegionId

        // First pass: create regions and map IDs
        for def in regionDefs {
            let regionUUID = UUID()
            stringToUUID[def.id] = regionUUID

            let anchor = contentRegistry.getAnchor(forRegion: def.id).map { anchorDef in
                EngineAnchorState(
                    id: UUID(),
                    name: anchorDef.title.localized,
                    integrity: anchorDef.initialIntegrity
                )
            }

            let regionType = mapRegionType(fromString: def.regionType)
            let regionState = mapRegionState(def.initialState)

            let engineRegion = EngineRegionState(
                id: regionUUID,
                name: def.title.localized,
                type: regionType,
                state: regionState,
                anchor: anchor,
                neighborIds: [],  // Will be set in second pass
                canTrade: regionState == .stable && regionType == .settlement
            )
            newRegions[regionUUID] = engineRegion

            // Set starting region
            if def.id == entryRegionId {
                currentRegionId = regionUUID
            }
        }

        // Second pass: resolve neighbor IDs
        for def in regionDefs {
            guard let regionUUID = stringToUUID[def.id],
                  var region = newRegions[regionUUID] else { continue }

            let neighborUUIDs = def.neighborIds.compactMap { stringToUUID[$0] }
            region = EngineRegionState(
                id: region.id,
                name: region.name,
                type: region.type,
                state: region.state,
                anchor: region.anchor,
                neighborIds: neighborUUIDs,
                canTrade: region.canTrade,
                visited: region.visited,
                reputation: region.reputation
            )
            newRegions[regionUUID] = region
        }

        regions = newRegions
        publishedRegions = newRegions

        // Set first region as current if none set
        if currentRegionId == nil {
            currentRegionId = newRegions.keys.first
        }
    }

    /// Create EngineAnchorState from AnchorDefinition
    private func createEngineAnchor(from def: AnchorDefinition?) -> EngineAnchorState? {
        guard let def = def else { return nil }
        return EngineAnchorState(
            id: UUID(),
            name: def.title.localized,
            integrity: def.initialIntegrity
        )
    }

    /// Resolve neighbor region IDs from string IDs to UUIDs
    private func resolveNeighborIds(_ neighborStringIds: [String], from defs: [RegionDefinition]) -> [UUID] {
        // This would need to be implemented properly with a mapping
        // For now, return empty - neighbors will be set up separately
        return []
    }

    /// Map region type string from ContentPack to RegionType enum
    /// The type comes from JSON/manifest, not hardcoded IDs
    private func mapRegionType(fromString typeString: String) -> RegionType {
        switch typeString.lowercased() {
        case "settlement": return .settlement
        case "forest": return .forest
        case "swamp": return .swamp
        case "wasteland": return .wasteland
        case "sacred": return .sacred
        case "mountain": return .mountain
        case "water": return .water
        default: return .forest
        }
    }

    /// Map RegionStateType to RegionState
    private func mapRegionState(_ stateType: RegionStateType) -> RegionState {
        switch stateType {
        case .stable: return .stable
        case .borderland: return .borderland
        case .breach: return .breach
        }
    }

    /// Create initial events from ContentRegistry
    private func createInitialEvents() -> [GameEvent] {
        return contentRegistry.getAllEvents().map { $0.toGameEvent() }
    }

    /// Create initial quests from ContentRegistry
    private func createInitialQuests() -> [Quest] {
        return contentRegistry.getAllQuests().map { $0.toQuest() }
    }

    // MARK: - Main Action Entry Point

    /// Perform a game action - THE ONLY WAY to change game state
    /// Returns result with all state changes
    @discardableResult
    func performAction(_ action: TwilightGameAction) -> ActionResult {
        // 0. Pre-validation
        guard !isGameOver else {
            return .failure(.gameNotInProgress)
        }

        // 1. Validate action
        let validationResult = validateAction(action)
        if let error = validationResult {
            return .failure(error)
        }

        // 2. Calculate actual time cost
        let timeCost = calculateTimeCost(for: action)

        // 3. Execute action and collect state changes
        var stateChanges: [StateChange] = []
        var triggeredEvents: [UUID] = []
        var newCurrentEvent: UUID? = nil
        var combatStarted = false

        // 4. Advance time (if action costs time)
        if timeCost > 0 {
            let timeChanges = advanceTime(by: timeCost)
            stateChanges.append(contentsOf: timeChanges)
        }

        // 5. Execute action-specific logic
        switch action {
        case .travel(let toRegionId):
            let (changes, events) = executeTravel(to: toRegionId)
            stateChanges.append(contentsOf: changes)
            triggeredEvents.append(contentsOf: events)
            if let event = events.first {
                newCurrentEvent = event
            }

        case .rest:
            let changes = executeRest()
            stateChanges.append(contentsOf: changes)

        case .explore:
            let (changes, events) = executeExplore()
            stateChanges.append(contentsOf: changes)
            triggeredEvents.append(contentsOf: events)
            if let event = events.first {
                newCurrentEvent = event
            }

        case .trade:
            // Trade handled by UI directly for now (market system)
            break

        case .strengthenAnchor:
            let changes = executeStrengthenAnchor()
            stateChanges.append(contentsOf: changes)

        case .chooseEventOption(let eventId, let choiceIndex):
            let changes = executeEventChoice(eventId: eventId, choiceIndex: choiceIndex)
            stateChanges.append(contentsOf: changes)
            currentEventId = nil

        case .resolveMiniGame(let input):
            let changes = executeMiniGameInput(input)
            stateChanges.append(contentsOf: changes)

        case .startCombat:
            combatStarted = true
            isInCombat = true
            combatTurnNumber = 1
            combatActionsRemaining = 3
            combatBonusDice = 0
            combatBonusDamage = 0
            combatIsFirstAttack = true
            // Enemy setup done when combat view appears

        case .combatInitialize:
            // Shuffle deck and draw initial hand
            if let player = playerAdapter?.player {
                player.shuffleDeck()
                player.drawCards(count: player.maxHandSize)
                playerHand = player.hand
            }
            combatActionsRemaining = 3

        case .combatAttack(let bonusDice, let bonusDamage, let isFirstAttack):
            guard combatActionsRemaining > 0 else { break }
            combatActionsRemaining -= 1
            let changes = executeCombatAttack(bonusDice: bonusDice, bonusDamage: bonusDamage, isFirstAttack: isFirstAttack)
            stateChanges.append(contentsOf: changes)
            combatIsFirstAttack = false
            // Check if enemy defeated
            if combatEnemyHealth <= 0 {
                // Victory will be handled by combatFinish
            }

        case .playCard(let cardId, _):
            guard combatActionsRemaining > 0 else { break }
            if let player = playerAdapter?.player,
               let cardIndex = player.hand.firstIndex(where: { $0.id == cardId }) {
                let card = player.hand[cardIndex]
                // Check faith cost
                if let cost = card.cost, cost > 0 {
                    guard player.faith >= cost else { break }
                    _ = player.spendFaith(cost)
                    playerFaith = player.faith
                    stateChanges.append(.faithChanged(delta: -cost, newValue: playerFaith))
                }
                combatActionsRemaining -= 1
                player.playCard(card)
                playerHand = player.hand
            }

        case .combatApplyEffect(let effect):
            let changes = executeCombatEffect(effect)
            stateChanges.append(contentsOf: changes)

        case .endCombatTurn:
            // Player ended their turn, enemy attacks next
            break

        case .combatEnemyAttack(let damage):
            // Enemy deals damage to player
            if let player = playerAdapter?.player {
                let healthBefore = player.health
                player.takeDamageWithCurses(damage)
                let actualDamage = healthBefore - player.health
                playerHealth = player.health
                stateChanges.append(.healthChanged(delta: -actualDamage, newValue: playerHealth))
            }

        case .combatEndTurnPhase:
            // End of turn: discard hand, draw new cards, restore faith
            if let player = playerAdapter?.player {
                // Discard hand
                while !player.hand.isEmpty {
                    player.playCard(player.hand[0])
                }
                // Draw new hand
                player.drawCards(count: player.maxHandSize)
                playerHand = player.hand
                // Restore faith
                player.gainFaith(1)
                playerFaith = player.faith
                stateChanges.append(.faithChanged(delta: 1, newValue: playerFaith))
                // Ability: extra faith at end of turn
                if player.shouldGainFaithEndOfTurn {
                    player.gainFaith(1)
                    playerFaith = player.faith
                    stateChanges.append(.faithChanged(delta: 1, newValue: playerFaith))
                }
            }
            // Reset for next turn
            combatTurnNumber += 1
            combatActionsRemaining = 3
            combatBonusDice = 0
            combatBonusDamage = 0

        case .combatFlee:
            isInCombat = false
            combatEnemy = nil
            stateChanges.append(.combatEnded(victory: false))

        case .combatFinish(let victory):
            isInCombat = false
            combatEnemy = nil
            stateChanges.append(.combatEnded(victory: victory))
            if victory {
                stateChanges.append(.enemyDefeated(enemyId: UUID()))
            }

        case .dismissCurrentEvent:
            currentEvent = nil
            currentEventId = nil

        case .dismissDayEvent:
            lastDayEvent = nil

        case .skipTurn:
            // Just time passes
            break

        case .custom:
            // Custom action handling
            break
        }

        // 6. Check quest progress
        let questChanges = checkQuestProgress()
        stateChanges.append(contentsOf: questChanges)

        // 7. Check end conditions
        if let endResult = checkEndConditions() {
            isGameOver = true
            gameResult = endResult
            return .gameOver(endResult)
        }

        // 8. Sync to legacy (during migration period)
        syncToLegacy(changes: stateChanges)

        // 9. Update published state for UI (Audit v1.1)
        updatePublishedState()

        // 10. Build and return result
        let result = ActionResult(
            success: true,
            error: nil,
            stateChanges: stateChanges,
            triggeredEvents: triggeredEvents,
            currentEvent: newCurrentEvent,
            combatStarted: combatStarted,
            gameEnded: nil
        )

        lastActionResult = result
        return result
    }

    // MARK: - Validation

    private func validateAction(_ action: TwilightGameAction) -> ActionError? {
        switch action {
        case .travel(let toRegionId):
            return validateTravel(to: toRegionId)

        case .rest:
            return validateRest()

        case .explore:
            if isInCombat { return .combatInProgress }
            return nil

        case .trade:
            return validateTrade()

        case .strengthenAnchor:
            return validateStrengthenAnchor()

        case .chooseEventOption(let eventId, let choiceIndex):
            return validateEventChoice(eventId: eventId, choiceIndex: choiceIndex)

        case .startCombat:
            if isInCombat { return .combatInProgress }
            return nil

        case .playCard, .endCombatTurn:
            if !isInCombat { return .noActiveCombat }
            return nil

        default:
            return nil
        }
    }

    private func validateTravel(to regionId: UUID) -> ActionError? {
        guard let currentId = currentRegionId,
              let currentRegion = regions[currentId] else {
            return .invalidAction(reason: "No current region")
        }

        // Check if target is neighbor
        if !currentRegion.neighborIds.contains(regionId) {
            return .regionNotNeighbor(regionId: regionId)
        }

        // Check if player can travel (health > 0, etc.)
        if let player = playerAdapter?.player, player.health <= 0 {
            return .healthTooLow
        }

        return nil
    }

    private func validateRest() -> ActionError? {
        guard let currentId = currentRegionId,
              let region = regions[currentId] else {
            return .invalidAction(reason: "No current region")
        }

        // Check if region allows rest
        if region.state == .breach {
            return .actionNotAvailableInRegion(action: "rest", regionType: "breach")
        }

        return nil
    }

    private func validateTrade() -> ActionError? {
        guard let currentId = currentRegionId,
              let region = regions[currentId] else {
            return .invalidAction(reason: "No current region")
        }

        if !region.canTrade {
            return .actionNotAvailableInRegion(action: "trade", regionType: region.type.rawValue)
        }

        return nil
    }

    private func validateStrengthenAnchor() -> ActionError? {
        guard let currentId = currentRegionId,
              let region = regions[currentId] else {
            return .invalidAction(reason: "No current region")
        }

        if region.anchor == nil {
            return .actionNotAvailableInRegion(action: "strengthen anchor", regionType: "no anchor")
        }

        // Check resource cost
        let cost = anchorStrengthenCost
        if let player = playerAdapter?.player, player.faith < cost {
            return .insufficientResources(resource: "faith", required: cost, available: player.faith)
        }

        return nil
    }

    private func validateEventChoice(eventId: UUID, choiceIndex: Int) -> ActionError? {
        guard currentEventId == eventId else {
            return .eventNotFound(eventId: eventId)
        }

        // Additional choice validation would go here
        return nil
    }

    // MARK: - Time Cost Calculation

    private func calculateTimeCost(for action: TwilightGameAction) -> Int {
        switch action {
        case .travel(let toRegionId):
            guard let currentId = currentRegionId,
                  let currentRegion = regions[currentId] else {
                return 1
            }
            // Neighbor = 1 day, far = 2 days
            return currentRegion.neighborIds.contains(toRegionId) ? 1 : 2

        default:
            return action.timeCost
        }
    }

    // MARK: - Time Advancement

    private func advanceTime(by days: Int) -> [StateChange] {
        var changes: [StateChange] = []

        for _ in 0..<days {
            currentDay += 1
            changes.append(.dayAdvanced(newDay: currentDay))

            // Check tension tick (every 3 days)
            if currentDay > 0 && currentDay % tensionTickInterval == 0 {
                let tensionIncrease = calculateTensionIncrease()
                worldTension = min(100, worldTension + tensionIncrease)
                changes.append(.tensionChanged(delta: tensionIncrease, newValue: worldTension))

                // World degradation
                let degradationChanges = processWorldDegradation()
                changes.append(contentsOf: degradationChanges)
            }
        }

        return changes
    }

    private func calculateTensionIncrease() -> Int {
        // Use TwilightPressureRules as single source of truth (Audit v1.1 Issue #6)
        return TwilightPressureRules.calculateTensionIncrease(daysPassed: currentDay)
    }

    private func processWorldDegradation() -> [StateChange] {
        var changes: [StateChange] = []

        // Degradation probability increases with world tension
        // (probability logic can be used when implementing random degradation checks)

        // Select region to degrade based on weights
        let degradableRegions = regions.values.filter {
            $0.state == .borderland || $0.state == .breach
        }

        guard !degradableRegions.isEmpty else { return changes }

        // Weighted selection using WorldRNG
        let weights = degradableRegions.map { DegradationRules.current.selectionWeight(for: $0.state) }
        let totalWeight = weights.reduce(0, +)

        if totalWeight > 0 {
            let roll = WorldRNG.shared.nextInt(in: 0..<totalWeight)
            var cumulative = 0
            for (index, weight) in weights.enumerated() {
                cumulative += weight
                if roll < cumulative {
                    let region = Array(degradableRegions)[index]

                    // Check anchor resistance using probability
                    let anchorIntegrity = region.anchor?.integrity ?? 0
                    let resistProb = DegradationRules.current.resistanceProbability(anchorIntegrity: anchorIntegrity)
                    let resistRoll = Double(WorldRNG.shared.nextInt(in: 0..<100)) / 100.0

                    if resistRoll >= resistProb {
                        // Anchor failed to resist - degrade region
                        if var mutableRegion = regions[region.id] {
                            let newState = degradeState(mutableRegion.state)
                            mutableRegion.state = newState
                            regions[region.id] = mutableRegion
                            changes.append(.regionStateChanged(regionId: region.id, newState: newState.rawValue))
                        }
                    }
                    break
                }
            }
        }

        return changes
    }

    private func degradeState(_ state: RegionState) -> RegionState {
        switch state {
        case .stable: return .borderland
        case .borderland: return .breach
        case .breach: return .breach  // Can't degrade further
        }
    }

    // MARK: - Action Execution

    private func executeTravel(to regionId: UUID) -> ([StateChange], [UUID]) {
        var changes: [StateChange] = []
        let events: [UUID] = []

        // Update current region
        currentRegionId = regionId
        changes.append(.regionChanged(regionId: regionId))

        // Note: Events are NOT auto-generated on arrival.
        // Player must explicitly choose to Explore to trigger events.
        // This allows player to Rest, Trade, or Strengthen Anchor first.

        return (changes, events)
    }

    private func executeRest() -> [StateChange] {
        var changes: [StateChange] = []

        // Heal player
        if let player = playerAdapter?.player {
            let healAmount = restHealAmount
            let newHealth = min(player.maxHealth, player.health + healAmount)
            let delta = newHealth - player.health
            playerAdapter?.updateHealth(newHealth)
            changes.append(.healthChanged(delta: delta, newValue: newHealth))
        }

        return changes
    }

    private func executeExplore() -> ([StateChange], [UUID]) {
        let changes: [StateChange] = []
        var events: [UUID] = []

        guard let regionId = currentRegionId else {
            return (changes, events)
        }

        // Generate exploration event
        if let event = generateEvent(for: regionId, trigger: .exploration) {
            events.append(event)
            currentEventId = event
        }

        return (changes, events)
    }

    private func executeStrengthenAnchor() -> [StateChange] {
        var changes: [StateChange] = []

        guard let regionId = currentRegionId,
              var region = regions[regionId],
              var anchor = region.anchor else {
            return changes
        }

        // Spend faith
        let cost = anchorStrengthenCost
        if let player = playerAdapter?.player {
            let newFaith = player.faith - cost
            playerAdapter?.updateFaith(newFaith)
            changes.append(.faithChanged(delta: -cost, newValue: newFaith))
        }

        // Strengthen anchor
        let strengthAmount = anchorStrengthenAmount
        let newIntegrity = min(100, anchor.integrity + strengthAmount)
        let delta = newIntegrity - anchor.integrity
        anchor.integrity = newIntegrity
        region.anchor = anchor
        regions[regionId] = region

        changes.append(.anchorIntegrityChanged(anchorId: anchor.id, delta: delta, newValue: newIntegrity))

        return changes
    }

    private func executeEventChoice(eventId: UUID, choiceIndex: Int) -> [StateChange] {
        var changes: [StateChange] = []

        // Get event and choice consequences from adapter
        if let consequences = worldStateAdapter?.getEventConsequences(eventId: eventId, choiceIndex: choiceIndex) {
            // Apply consequences
            changes.append(contentsOf: applyConsequences(consequences))
        }

        // Mark event completed if oneTime
        completedEventIds.insert(eventId)
        changes.append(.eventCompleted(eventId: eventId))

        currentEventId = nil

        return changes
    }

    private func executeMiniGameInput(_ input: MiniGameInput) -> [StateChange] {
        var changes: [StateChange] = []

        // Apply bonus rewards
        for (resource, amount) in input.bonusRewards {
            switch resource {
            case "health":
                if let player = playerAdapter?.player {
                    let newHealth = min(player.maxHealth, player.health + amount)
                    playerAdapter?.updateHealth(newHealth)
                    changes.append(.healthChanged(delta: amount, newValue: newHealth))
                }
            case "faith":
                if let player = playerAdapter?.player {
                    let newFaith = player.faith + amount
                    playerAdapter?.updateFaith(newFaith)
                    changes.append(.faithChanged(delta: amount, newValue: newFaith))
                }
            default:
                break
            }
        }

        return changes
    }

    // MARK: - Consequences

    private func applyConsequences(_ consequences: EventConsequences) -> [StateChange] {
        var changes: [StateChange] = []

        if let player = playerAdapter?.player {
            // Health
            if let healthDelta = consequences.healthChange, healthDelta != 0 {
                let newHealth = max(0, min(player.maxHealth, player.health + healthDelta))
                playerAdapter?.updateHealth(newHealth)
                changes.append(.healthChanged(delta: healthDelta, newValue: newHealth))
            }

            // Faith
            if let faithDelta = consequences.faithChange, faithDelta != 0 {
                let newFaith = max(0, player.faith + faithDelta)
                playerAdapter?.updateFaith(newFaith)
                changes.append(.faithChanged(delta: faithDelta, newValue: newFaith))
            }

            // Balance
            if let balanceDelta = consequences.balanceChange, balanceDelta != 0 {
                let newBalance = max(0, min(100, player.balance + balanceDelta))
                playerAdapter?.updateBalance(newBalance)
                changes.append(.balanceChanged(delta: balanceDelta, newValue: newBalance))
            }
        }

        // Tension
        if let tensionDelta = consequences.tensionChange, tensionDelta != 0 {
            worldTension = max(0, min(100, worldTension + tensionDelta))
            changes.append(.tensionChanged(delta: tensionDelta, newValue: worldTension))
        }

        // Flags (setFlags is [String: Bool]?)
        if let flagsToSet = consequences.setFlags {
            for (flag, value) in flagsToSet {
                worldFlags[flag] = value
                changes.append(.flagSet(key: flag, value: value))
            }
        }

        return changes
    }

    // MARK: - Event Generation

    private func generateEvent(for regionId: UUID, trigger: EventTrigger) -> UUID? {
        // Delegate to WorldState adapter for now (uses existing event system)
        return worldStateAdapter?.generateEvent(for: regionId, trigger: trigger)
    }

    // MARK: - Quest Progress

    private func checkQuestProgress() -> [StateChange] {
        // Use new QuestTriggerEngine if available, fall back to legacy adapter
        // During migration, both systems may be active
        return worldStateAdapter?.checkQuestProgress() ?? []
    }

    /// Process a quest trigger action through the new data-driven QuestTriggerEngine
    private func processQuestTriggerAction(_ action: QuestTriggerAction) -> [StateChange] {
        var changes: [StateChange] = []

        // Build context from current state
        let context = buildQuestTriggerContext()

        // Process through quest trigger engine
        let updates = questTriggerEngine.processAction(action, context: context)

        // Apply updates
        for update in updates {
            switch update.type {
            case .questStarted:
                // Start new quest
                if let questDef = contentRegistry.getQuest(id: update.questId) {
                    let quest = questDef.toQuest()
                    activeQuests.append(quest)
                    publishedActiveQuests = activeQuests
                    changes.append(.questStarted(questId: update.questId))
                }

            case .objectiveCompleted:
                // Update quest progress
                if let index = activeQuests.firstIndex(where: { $0.id.uuidString == update.questId || String(describing: $0.id) == update.questId }),
                   let objectiveId = update.objectiveId {
                    // Mark objective as completed
                    changes.append(.objectiveCompleted(questId: update.questId, objectiveId: objectiveId))

                    // Set flags
                    for flag in update.flagsToSet {
                        worldFlags[flag] = true
                        publishedWorldFlags = worldFlags
                        changes.append(.flagSet(key: flag, value: true))
                    }

                    // Check if quest completed (no next objective)
                    if update.nextObjectiveId == nil {
                        activeQuests[index].completed = true
                        completedQuestIds.insert(update.questId)
                        changes.append(.questCompleted(questId: update.questId))
                    }
                }

            case .questCompleted:
                // Quest fully completed
                completedQuestIds.insert(update.questId)
                changes.append(.questCompleted(questId: update.questId))

            case .questFailed:
                // Quest failed
                changes.append(.questFailed(questId: update.questId))
            }
        }

        return changes
    }

    /// Build QuestTriggerContext from current engine state
    private func buildQuestTriggerContext() -> QuestTriggerContext {
        // Build active quest states
        let questStates = activeQuests.compactMap { quest -> QuestState? in
            guard let questDef = contentRegistry.getQuest(id: quest.definitionId ?? quest.id.uuidString) else {
                return nil
            }

            // Determine current objective (simplified - uses stage)
            let currentObjectiveId = questDef.objectives.indices.contains(quest.stage - 1)
                ? questDef.objectives[quest.stage - 1].id
                : questDef.objectives.first?.id

            // Completed objectives are those before current stage
            let completedIds = Set(questDef.objectives.prefix(max(0, quest.stage - 1)).map { $0.id })

            return QuestState(
                definitionId: questDef.id,
                currentObjectiveId: currentObjectiveId,
                completedObjectiveIds: completedIds
            )
        }

        // Build resources dictionary
        let resources: [String: Int] = [
            "health": playerHealth,
            "faith": playerFaith,
            "balance": playerBalance,
            "tension": worldTension
        ]

        // Get current region ID as string
        let currentRegionStringId: String
        if let regionId = currentRegionId,
           let region = regions[regionId] {
            // Try to find matching definition by name
            if let def = contentRegistry.getAllRegions().first(where: { $0.title.localized == region.name }) {
                currentRegionStringId = def.id
            } else {
                currentRegionStringId = regionId.uuidString
            }
        } else {
            currentRegionStringId = ""
        }

        return QuestTriggerContext(
            activeQuests: questStates,
            completedQuestIds: completedQuestIds,
            worldFlags: worldFlags,
            resources: resources,
            currentDay: currentDay,
            currentRegionId: currentRegionStringId
        )
    }

    // MARK: - End Conditions

    private func checkEndConditions() -> GameEndResult? {
        // Defeat: tension 100%
        if worldTension >= 100 {
            return .defeat(reason: "Напряжение мира достигло максимума")
        }

        // Defeat: health 0
        if let player = playerAdapter?.player, player.health <= 0 {
            return .defeat(reason: "Герой погиб")
        }

        // Victory: main quest completed (check flags)
        if worldFlags["act1_completed"] == true {
            return .victory(endingId: "act1_standard")
        }

        return nil
    }

    // MARK: - Legacy Sync

    private func syncToLegacy(changes: [StateChange]) {
        worldStateAdapter?.applyChanges(changes)
        playerAdapter?.syncFromEngine()
    }

    // MARK: - Published State Update (Engine-First Architecture)

    /// Update all published properties from internal state
    /// Called after actions to keep UI in sync
    private func updatePublishedState() {
        // Update regions
        publishedRegions = regions

        // Update flags
        publishedWorldFlags = worldFlags

        // Update quests and log
        publishedActiveQuests = activeQuests
        publishedEventLog = Array(eventLog.suffix(100))

        // Update current event from ID (Bridge UUID to GameEvent object)
        if let eventId = currentEventId,
           let event = worldStateAdapter?.worldState.allEvents.first(where: { $0.id == eventId }) {
            currentEvent = event
        } else if currentEventId == nil {
            currentEvent = nil
        }

        // Update player stats from adapter (legacy mode)
        if let player = playerAdapter?.player {
            playerHealth = player.health
            playerMaxHealth = player.maxHealth
            playerFaith = player.faith
            playerBalance = player.balance
        }
        // In Engine-First mode, player stats are updated directly
    }

    // MARK: - Event Log

    /// Add entry to event log
    func addLogEntry(
        regionName: String,
        eventTitle: String,
        choiceMade: String,
        outcome: String,
        type: EventLogType
    ) {
        let entry = EventLogEntry(
            dayNumber: currentDay,
            regionName: regionName,
            eventTitle: eventTitle,
            choiceMade: choiceMade,
            outcome: outcome,
            type: type
        )
        eventLog.append(entry)

        // Trim log to 100 entries
        if eventLog.count > 100 {
            eventLog.removeFirst(eventLog.count - 100)
        }

        publishedEventLog = eventLog
    }

    // MARK: - Day Events

    /// Trigger day event (tension increase, degradation, etc.)
    private func triggerDayEvent(_ event: DayEvent) {
        lastDayEvent = event
    }

    // MARK: - Combat Helper Methods

    /// Execute a combat attack with bonus dice and damage
    private func executeCombatAttack(bonusDice: Int, bonusDamage: Int, isFirstAttack: Bool) -> [StateChange] {
        var changes: [StateChange] = []

        guard let enemy = combatEnemy,
              let player = playerAdapter?.player else {
            return changes
        }

        let monsterDef = enemy.defense ?? 10
        let monsterCurrentHP = combatEnemyHealth
        let monsterMaxHP = enemy.health ?? 10

        // Use CombatCalculator for attack calculation
        let result = CombatCalculator.calculatePlayerAttack(
            player: player,
            monsterDefense: monsterDef,
            monsterCurrentHP: monsterCurrentHP,
            monsterMaxHP: monsterMaxHP,
            bonusDice: bonusDice + combatBonusDice,
            bonusDamage: bonusDamage + combatBonusDamage,
            isFirstAttack: isFirstAttack
        )

        if result.isHit, let damageCalc = result.damageCalculation {
            let damage = damageCalc.total
            combatEnemyHealth = max(0, combatEnemyHealth - damage)
            changes.append(.enemyDamaged(enemyId: enemy.id, damage: damage, newHealth: combatEnemyHealth))
        }

        // Reset bonuses after attack
        combatBonusDice = 0
        combatBonusDamage = 0

        return changes
    }

    /// Execute a combat effect from card or ability
    private func executeCombatEffect(_ effect: CombatActionEffect) -> [StateChange] {
        var changes: [StateChange] = []

        switch effect {
        case .heal(let amount):
            if let player = playerAdapter?.player {
                let newHealth = min(player.maxHealth, player.health + amount)
                let delta = newHealth - player.health
                playerAdapter?.updateHealth(newHealth)
                playerHealth = newHealth
                changes.append(.healthChanged(delta: delta, newValue: newHealth))
            }

        case .damageEnemy(let amount):
            if let player = playerAdapter?.player, let enemy = combatEnemy {
                let actualDamage = player.calculateDamageDealt(amount)
                combatEnemyHealth = max(0, combatEnemyHealth - actualDamage)
                changes.append(.enemyDamaged(enemyId: enemy.id, damage: actualDamage, newHealth: combatEnemyHealth))
            }

        case .drawCards(let count):
            if let player = playerAdapter?.player {
                player.drawCards(count: count)
                playerHand = player.hand
            }

        case .gainFaith(let amount):
            if let player = playerAdapter?.player {
                player.gainFaith(amount)
                playerFaith = player.faith
                changes.append(.faithChanged(delta: amount, newValue: playerFaith))
            }

        case .spendFaith(let amount):
            if let player = playerAdapter?.player {
                _ = player.spendFaith(amount)
                playerFaith = player.faith
                changes.append(.faithChanged(delta: -amount, newValue: playerFaith))
            }

        case .takeDamage(let amount):
            if let player = playerAdapter?.player {
                let healthBefore = player.health
                player.takeDamage(amount)
                let actualDamage = healthBefore - player.health
                playerHealth = player.health
                changes.append(.healthChanged(delta: -actualDamage, newValue: playerHealth))
            }

        case .removeCurse(let type):
            if let player = playerAdapter?.player {
                // Convert String to CurseType
                let curseType: CurseType? = type.flatMap { CurseType(rawValue: $0) }
                player.removeCurse(type: curseType)
            }

        case .shiftBalance(let towards, let amount):
            if let player = playerAdapter?.player {
                let direction: CardBalance
                switch towards.lowercased() {
                case "light", "свет": direction = .light
                case "dark", "тьма": direction = .dark
                default: direction = .neutral
                }
                player.shiftBalance(towards: direction, amount: amount)
                playerBalance = player.balance
                changes.append(.balanceChanged(delta: amount, newValue: playerBalance))
            }

        case .addBonusDice(let count):
            combatBonusDice += count

        case .addBonusDamage(let amount):
            combatBonusDamage += amount

        case .summonSpirit(let power, _):
            // Spirit attacks enemy immediately
            if let enemy = combatEnemy {
                combatEnemyHealth = max(0, combatEnemyHealth - power)
                changes.append(.enemyDamaged(enemyId: enemy.id, damage: power, newHealth: combatEnemyHealth))
            }
        }

        return changes
    }

    // MARK: - Combat Setup Methods

    /// Setup enemy for combat
    func setupCombatEnemy(_ enemy: Card) {
        combatEnemy = enemy
        combatEnemyHealth = enemy.health ?? 10
        combatTurnNumber = 1
        combatActionsRemaining = 3
        combatBonusDice = 0
        combatBonusDamage = 0
        combatIsFirstAttack = true
        isInCombat = true
    }

    /// Get current combat state for UI
    var combatState: CombatState? {
        guard isInCombat, let enemy = combatEnemy else { return nil }
        return CombatState(
            enemy: enemy,
            enemyHealth: combatEnemyHealth,
            turnNumber: combatTurnNumber,
            actionsRemaining: combatActionsRemaining,
            bonusDice: combatBonusDice,
            bonusDamage: combatBonusDamage,
            isFirstAttack: combatIsFirstAttack,
            playerHand: playerAdapter?.player.hand ?? []
        )
    }

    /// Access to legacy player for UI compatibility
    var legacyPlayer: Player? {
        playerAdapter?.player
    }

    // MARK: - Save/Load Support Methods

    /// Get completed quest IDs for save
    func getCompletedQuestIds() -> Set<String> {
        return completedQuestIds
    }

    /// Get quest stages for save
    func getQuestStages() -> [String: Int] {
        return questStages
    }

    /// Get completed event IDs for save
    func getCompletedEventIds() -> Set<UUID> {
        return completedEventIds
    }

    /// Set regions from save
    func setRegions(_ newRegions: [UUID: EngineRegionState]) {
        regions = newRegions
        publishedRegions = newRegions
    }

    /// Set world flags from save
    func setWorldFlags(_ newFlags: [String: Bool]) {
        worldFlags = newFlags
        publishedWorldFlags = newFlags
    }

    /// Set completed event IDs from save
    func setCompletedEventIds(_ ids: Set<UUID>) {
        completedEventIds = ids
    }

    /// Set event log from save
    func setEventLog(_ log: [EventLogEntry]) {
        eventLog = log
        publishedEventLog = Array(log.suffix(100))
    }

    /// Set main quest stage from save
    func setMainQuestStage(_ stage: Int) {
        mainQuestStage = stage
    }

    /// Set completed quest IDs from save
    func setCompletedQuestIds(_ ids: Set<String>) {
        completedQuestIds = ids
    }

    /// Set quest stages from save
    func setQuestStages(_ stages: [String: Int]) {
        questStages = stages
    }

    /// Update published state after loading
    func updatePublishedStateAfterLoad() {
        updatePublishedState()
    }
}

// MARK: - Event Trigger

enum EventTrigger {
    case arrival
    case exploration
    case combat
    case quest
    case time
}

// MARK: - Engine Region State (Bridge from Legacy)

/// Объединённое состояние региона для UI (Audit v1.1 Issue #9)
///
/// Это ПРЕДПОЧТИТЕЛЬНАЯ модель для UI:
/// - Создаётся из legacy Region через TwilightGameEngine.syncFromLegacy()
/// - Публикуется через engine.publishedRegions
/// - UI должен использовать engine.regionsArray или engine.currentRegion
///
/// Архитектура моделей:
/// - `RegionDefinition` - статические данные (ContentProvider)
/// - `RegionRuntimeState` - изменяемое состояние (WorldRuntimeState)
/// - `EngineRegionState` - объединённое для UI (этот struct)
/// - `Region` (legacy) - persistence и совместимость
struct EngineRegionState: Identifiable {
    let id: UUID
    let definitionId: String?  // Stable definition ID for serialization (Epic 3)
    let name: String
    let type: RegionType
    var state: RegionState
    var anchor: EngineAnchorState?
    let neighborIds: [UUID]
    let neighborDefinitionIds: [String]?  // Stable neighbor IDs for serialization (Epic 3)
    var canTrade: Bool
    var visited: Bool = false
    var reputation: Int = 0

    /// Create from legacy Region (for migration)
    init(from region: Region) {
        self.id = region.id
        self.definitionId = nil  // Legacy regions don't have definition IDs
        self.name = region.name
        self.type = region.type
        self.state = region.state
        self.anchor = region.anchor.map { EngineAnchorState(from: $0) }
        self.neighborIds = region.neighborIds
        self.neighborDefinitionIds = nil
        self.canTrade = region.canTrade
        self.visited = region.visited
        self.reputation = region.reputation
    }

    /// Create directly (Engine-First)
    init(
        id: UUID = UUID(),
        definitionId: String? = nil,
        name: String,
        type: RegionType,
        state: RegionState,
        anchor: EngineAnchorState? = nil,
        neighborIds: [UUID] = [],
        neighborDefinitionIds: [String]? = nil,
        canTrade: Bool = false,
        visited: Bool = false,
        reputation: Int = 0
    ) {
        self.id = id
        self.definitionId = definitionId
        self.name = name
        self.type = type
        self.state = state
        self.anchor = anchor
        self.neighborIds = neighborIds
        self.neighborDefinitionIds = neighborDefinitionIds
        self.canTrade = canTrade
        self.visited = visited
        self.reputation = reputation
    }

    /// Can rest in this region
    var canRest: Bool {
        state == .stable && (type == .settlement || type == .sacred)
    }
}

// MARK: - Engine Anchor State (Bridge from Legacy)

/// Internal state for engine anchor tracking (bridges from legacy Anchor model)
struct EngineAnchorState {
    let id: UUID
    let definitionId: String?  // Stable definition ID for serialization (Epic 3)
    let name: String
    var integrity: Int

    /// Create from legacy Anchor (for migration)
    init(from anchor: Anchor) {
        self.id = anchor.id
        self.definitionId = nil  // Legacy anchors don't have definition IDs
        self.name = anchor.name
        self.integrity = anchor.integrity
    }

    /// Create directly (Engine-First)
    init(id: UUID = UUID(), definitionId: String? = nil, name: String, integrity: Int) {
        self.id = id
        self.definitionId = definitionId
        self.name = name
        self.integrity = max(0, min(100, integrity))
    }
}

// MARK: - Combat State (for UI)

/// Read-only combat state for UI binding
struct CombatState {
    let enemy: Card
    let enemyHealth: Int
    let turnNumber: Int
    let actionsRemaining: Int
    let bonusDice: Int
    let bonusDamage: Int
    let isFirstAttack: Bool
    let playerHand: [Card]

    var enemyMaxHealth: Int {
        enemy.health ?? 10
    }

    var enemyDefense: Int {
        enemy.defense ?? 10
    }

    var enemyPower: Int {
        enemy.power ?? 3
    }
}


// ==========================================
// FILE: Engine/Combat/CombatCalculator.swift
// ==========================================

import Foundation

/// Результат атаки с полной разбивкой факторов
struct CombatResult {
    let isHit: Bool
    let attackRoll: AttackRoll
    let defenseValue: Int
    let damageCalculation: DamageCalculation?
    let specialEffects: [CombatEffect]

    /// Текстовое описание для лога
    var logDescription: String {
        var lines: [String] = []

        // Заголовок результата
        if isHit {
            lines.append("✅ ПОПАДАНИЕ!")
        } else {
            lines.append("❌ ПРОМАХ!")
        }

        // Бросок атаки
        lines.append("📊 Атака: \(attackRoll.total) vs Защита: \(defenseValue)")

        // Разбивка атаки
        var attackParts: [String] = []
        attackParts.append("Сила \(attackRoll.baseStrength)")

        if attackRoll.diceRolls.count == 1 {
            attackParts.append("🎲\(attackRoll.diceRolls[0])")
        } else {
            let diceStr = attackRoll.diceRolls.map { "🎲\($0)" }.joined(separator: "+")
            attackParts.append("(\(diceStr)=\(attackRoll.diceTotal))")
        }

        if attackRoll.bonusDice > 0 {
            attackParts.append("+\(attackRoll.bonusDice) бонус кубиков")
        }
        if attackRoll.bonusDamage > 0 {
            attackParts.append("+\(attackRoll.bonusDamage) бонус урона")
        }

        lines.append("   = \(attackParts.joined(separator: " + "))")

        // Модификаторы
        for effect in attackRoll.modifiers {
            lines.append("   \(effect.icon) \(effect.description): \(effect.value > 0 ? "+" : "")\(effect.value)")
        }

        // Расчёт урона (если попадание)
        if isHit, let damage = damageCalculation {
            lines.append("💥 Урон: \(damage.total)")
            lines.append("   Базовый: \(damage.base) (атака - защита + 2)")

            for modifier in damage.modifiers {
                lines.append("   \(modifier.icon) \(modifier.description): \(modifier.value > 0 ? "+" : "")\(modifier.value)")
            }
        }

        // Спецэффекты
        for effect in specialEffects {
            lines.append("\(effect.icon) \(effect.description)")
        }

        return lines.joined(separator: "\n")
    }
}

/// Бросок атаки
struct AttackRoll {
    let baseStrength: Int
    let diceRolls: [Int]
    let bonusDice: Int
    let bonusDamage: Int
    let modifiers: [CombatModifier]

    var diceTotal: Int {
        diceRolls.reduce(0, +)
    }

    var total: Int {
        baseStrength + diceTotal + bonusDamage + modifiers.reduce(0) { $0 + $1.value }
    }
}

/// Расчёт урона
struct DamageCalculation {
    let base: Int
    let modifiers: [CombatModifier]

    var total: Int {
        max(1, base + modifiers.reduce(0) { $0 + $1.value })
    }
}

/// Модификатор боя
struct CombatModifier {
    let source: ModifierSource
    let value: Int
    let description: String

    var icon: String {
        switch source {
        case .heroAbility: return "⭐"
        case .curse: return "💀"
        case .card: return "🃏"
        case .equipment: return "🛡️"
        case .buff: return "✨"
        case .debuff: return "⚡"
        case .spirit: return "👻"
        case .environment: return "🌍"
        }
    }
}

/// Источник модификатора
enum ModifierSource {
    case heroAbility
    case curse
    case card
    case equipment
    case buff
    case debuff
    case spirit
    case environment
}

/// Боевой эффект (события в бою)
struct CombatEffect {
    let icon: String
    let description: String
    let type: CombatEffectType
}

/// Тип боевого эффекта
enum CombatEffectType {
    case damage
    case heal
    case buff
    case debuff
    case summon
    case special
}

/// Калькулятор боя - вычисляет результат атаки с полной разбивкой
struct CombatCalculator {

    /// Рассчитать атаку игрока по монстру
    static func calculatePlayerAttack(
        player: Player,
        monsterDefense: Int,
        monsterCurrentHP: Int,
        monsterMaxHP: Int,
        bonusDice: Int,
        bonusDamage: Int,
        isFirstAttack: Bool
    ) -> CombatResult {

        var modifiers: [CombatModifier] = []
        var damageModifiers: [CombatModifier] = []
        let specialEffects: [CombatEffect] = []

        let isTargetFullHP = monsterCurrentHP == monsterMaxHP

        // Бросок кубиков
        var totalDice = 1 + bonusDice

        // Способность героя: бонус кубиков (например, Следопыт при первой атаке)
        let heroBonusDice = player.getHeroBonusDice(isFirstAttack: isFirstAttack)
        if heroBonusDice > 0 {
            totalDice += heroBonusDice
            modifiers.append(CombatModifier(
                source: .heroAbility,
                value: 0,  // Не добавляет к атаке напрямую, только кубик
                description: "Способность героя (+\(heroBonusDice) кубик)"
            ))
        }

        var diceRolls: [Int] = []
        for _ in 0..<totalDice {
            diceRolls.append(WorldRNG.shared.nextInt(in: 1...6))
        }

        // Создаём бросок атаки
        let attackRoll = AttackRoll(
            baseStrength: player.strength,
            diceRolls: diceRolls,
            bonusDice: bonusDice,
            bonusDamage: bonusDamage,
            modifiers: modifiers
        )

        let isHit = attackRoll.total >= monsterDefense

        var damageCalculation: DamageCalculation? = nil

        if isHit {
            let baseDamage = max(1, attackRoll.total - monsterDefense + 2)

            // Модификаторы урона от проклятий
            if player.hasCurse(.weakness) {
                damageModifiers.append(CombatModifier(
                    source: .curse,
                    value: -1,
                    description: "Слабость"
                ))
            }

            if player.hasCurse(.shadowOfNav) {
                damageModifiers.append(CombatModifier(
                    source: .curse,
                    value: +3,
                    description: "Тень Нави"
                ))
            }

            // Бонус урона от способности героя (учитывает условия типа HP < 50% или цель на полном HP)
            let heroDamageBonus = player.getHeroDamageBonus(targetFullHP: isTargetFullHP)
            if heroDamageBonus > 0 {
                damageModifiers.append(CombatModifier(
                    source: .heroAbility,
                    value: heroDamageBonus,
                    description: "Способность героя"
                ))
            }

            damageCalculation = DamageCalculation(
                base: baseDamage,
                modifiers: damageModifiers
            )
        }

        return CombatResult(
            isHit: isHit,
            attackRoll: attackRoll,
            defenseValue: monsterDefense,
            damageCalculation: damageCalculation,
            specialEffects: specialEffects
        )
    }
}


// ==========================================
// FILE: Engine/Config/DegradationRules.swift
// ==========================================

import Foundation

// MARK: - Degradation Rules
// Правила деградации регионов, вынесенные из WorldState в Engine Config
// Позволяет настраивать поведение деградации без изменения кода

/// Протокол правил деградации для разных конфигураций игры
protocol DegradationRuleSet {
    /// Вес региона для выбора кандидата на деградацию
    func selectionWeight(for regionState: RegionState) -> Int

    /// Вероятность сопротивления якоря (0.0 - 1.0)
    /// Возвращает вероятность того, что якорь сопротивляется деградации
    func resistanceProbability(anchorIntegrity: Int) -> Double

    /// Урон якорю при деградации
    var degradationAmount: Int { get }

    /// Минимальный Tension для запуска деградации
    var minimumTensionForDegradation: Int { get }
}

/// Правила деградации для "Сумрачных Пределов" (Twilight Marches)
struct TwilightDegradationRules: DegradationRuleSet {

    /// Веса выбора региона:
    /// - Stable (70-100%): 0 — не деградирует напрямую
    /// - Borderland (30-69%): 1 — умеренный приоритет
    /// - Breach (0-29%): 2 — высокий приоритет (уже слабые регионы ухудшаются быстрее)
    func selectionWeight(for regionState: RegionState) -> Int {
        switch regionState {
        case .stable:
            return 0
        case .borderland:
            return 1
        case .breach:
            return 2
        }
    }

    /// Вероятность сопротивления: чем выше integrity, тем больше шанс сопротивляться
    /// Формула: P(resist) = integrity / 100
    /// - integrity 100% → 100% сопротивление
    /// - integrity 50% → 50% сопротивление
    /// - integrity 0% → 0% сопротивление
    func resistanceProbability(anchorIntegrity: Int) -> Double {
        return Double(anchorIntegrity) / 100.0
    }

    /// Урон якорю при деградации: -20% integrity
    let degradationAmount: Int = 20

    /// Деградация происходит только при Tension >= 0 (всегда возможна)
    let minimumTensionForDegradation: Int = 0
}

// MARK: - Shared Instance

/// Глобальные правила деградации (по умолчанию TwilightDegradationRules)
enum DegradationRules {
    static var current: DegradationRuleSet = TwilightDegradationRules()

    /// Сбросить на дефолтные правила
    static func reset() {
        current = TwilightDegradationRules()
    }
}


// ==========================================
// FILE: Engine/Config/TwilightMarchesConfig.swift
// ==========================================

import Foundation

// MARK: - Twilight Marches Configuration
// Game-specific configuration for "Сумрачные Пределы" (Twilight Marches)
// This is the "cartridge" that configures the generic engine.

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - Resources
// ═══════════════════════════════════════════════════════════════════════════════

/// Resources used in Twilight Marches
enum TwilightResource: String, CaseIterable {
    case health
    case maxHealth
    case faith
    case maxFaith
    case balance  // 0 = Dark, 100 = Light

    var id: String { rawValue }

    /// Default starting values
    var defaultValue: Int {
        switch self {
        case .health: return 10
        case .maxHealth: return 10
        case .faith: return 3
        case .maxFaith: return 10
        case .balance: return 50
        }
    }
}

/// Build initial resources dictionary
func twilightInitialResources() -> [String: Int] {
    var resources: [String: Int] = [:]
    for resource in TwilightResource.allCases {
        resources[resource.id] = resource.defaultValue
    }
    return resources
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - Pressure Rules (WorldTension)
// ═══════════════════════════════════════════════════════════════════════════════

/// Twilight Marches pressure (WorldTension) rules
/// SINGLE SOURCE OF TRUTH for tension escalation formula (Audit v1.1 Issue #6)
struct TwilightPressureRules: PressureRuleSet {
    let maxPressure: Int = 100
    let initialPressure: Int = 30
    let escalationInterval: Int = 3  // Every 3 days
    let escalationAmount: Int = 3    // Base +3 tension (increased for balance)

    /// Thresholds and their effects
    var thresholds: [Int: [WorldEffect]] {
        return [
            50: [.regionDegradation(probability: 0.3)],
            75: [.regionDegradation(probability: 0.5), .globalEvent(eventId: "world_shift_warning")],
            90: [.regionDegradation(probability: 0.7), .anchorWeakening(amount: 10)]
        ]
    }

    /// Canonical escalation formula: base + (daysPassed / 10)
    /// - Day 1-9: +3
    /// - Day 10-19: +4
    /// - Day 20-29: +5
    /// Creates increasing urgency as game progresses
    func calculateEscalation(currentPressure: Int, currentTime: Int) -> Int {
        let escalationBonus = currentTime / 10
        return escalationAmount + escalationBonus
    }

    /// Static helper for use outside of PressureEngine context
    /// Both WorldState and TwilightGameEngine should use this
    static func calculateTensionIncrease(daysPassed: Int) -> Int {
        let base = 3  // escalationAmount
        let escalationBonus = daysPassed / 10
        return base + escalationBonus
    }

    func checkThresholds(pressure: Int) -> [WorldEffect] {
        var effects: [WorldEffect] = []

        for (threshold, thresholdEffects) in thresholds {
            if pressure >= threshold {
                effects.append(contentsOf: thresholdEffects)
            }
        }

        return effects
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - Region Configuration
// ═══════════════════════════════════════════════════════════════════════════════

/// Region states in Twilight Marches
enum TwilightRegionState: String, Codable, CaseIterable {
    case stable
    case borderland
    case breach

    /// Degradation weight (higher = degrades faster)
    var degradationWeight: Int {
        switch self {
        case .stable: return 0
        case .borderland: return 1
        case .breach: return 2
        }
    }

    /// Can player rest in this state?
    var canRest: Bool {
        self == .stable
    }

    /// Can player trade in this state?
    var canTrade: Bool {
        self == .stable
    }

    /// Combat modifier
    var combatModifier: Int {
        switch self {
        case .stable: return 0
        case .borderland: return 1
        case .breach: return 2
        }
    }

    /// Next degraded state
    var degraded: TwilightRegionState? {
        switch self {
        case .stable: return .borderland
        case .borderland: return .breach
        case .breach: return nil
        }
    }

    /// Previous improved state
    var improved: TwilightRegionState? {
        switch self {
        case .stable: return nil
        case .borderland: return .stable
        case .breach: return .borderland
        }
    }
}

/// Region type
enum TwilightRegionType: String, Codable, CaseIterable {
    case village
    case forest
    case fortress
    case swamp
    case ruins
    case sanctuary
    case cursedLand
}

/// Region definition (static data)
struct TwilightRegionDefinition: Codable {
    let id: String
    let name: String
    let type: TwilightRegionType
    let initialState: TwilightRegionState
    let neighborIds: [String]
    let hasAnchor: Bool
    let anchorName: String?

    /// Initial anchor integrity (if has anchor)
    var initialAnchorIntegrity: Int { hasAnchor ? 100 : 0 }
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - Curse Configuration
// ═══════════════════════════════════════════════════════════════════════════════

/// Curse types in Twilight Marches
enum TwilightCurseType: String, Codable, CaseIterable {
    case weakness
    case fear
    case exhaustion
    case greed
    case shadowOfNav
    case bloodCurse
    case sealOfNav
}

/// Curse definition (static data)
struct TwilightCurseDefinition {
    let type: TwilightCurseType
    let name: String
    let description: String
    let removalCost: Int
    let damageModifier: Int      // Modifier to damage dealt
    let damageTakenModifier: Int // Modifier to damage received
    let actionModifier: Int      // Modifier to actions per turn
    let specialEffect: String?   // ID of special effect

    static let definitions: [TwilightCurseType: TwilightCurseDefinition] = [
        .weakness: TwilightCurseDefinition(
            type: .weakness,
            name: L10n.curseWeaknessName.localized,
            description: L10n.curseWeaknessDescription.localized,
            removalCost: 2,
            damageModifier: -1,
            damageTakenModifier: 0,
            actionModifier: 0,
            specialEffect: nil
        ),
        .fear: TwilightCurseDefinition(
            type: .fear,
            name: L10n.curseFearName.localized,
            description: L10n.curseFearDescription.localized,
            removalCost: 2,
            damageModifier: 0,
            damageTakenModifier: 1,
            actionModifier: 0,
            specialEffect: nil
        ),
        .exhaustion: TwilightCurseDefinition(
            type: .exhaustion,
            name: L10n.curseExhaustionName.localized,
            description: L10n.curseExhaustionDescription.localized,
            removalCost: 3,
            damageModifier: 0,
            damageTakenModifier: 0,
            actionModifier: -1,
            specialEffect: nil
        ),
        .greed: TwilightCurseDefinition(
            type: .greed,
            name: L10n.curseGreedName.localized,
            description: L10n.curseGreedDescription.localized,
            removalCost: 4,
            damageModifier: 0,
            damageTakenModifier: 0,
            actionModifier: 0,
            specialEffect: "balance_shift_dark"
        ),
        .shadowOfNav: TwilightCurseDefinition(
            type: .shadowOfNav,
            name: L10n.curseShadowOfNavName.localized,
            description: L10n.curseShadowOfNavDescription.localized,
            removalCost: 5,
            damageModifier: 3,
            damageTakenModifier: 0,
            actionModifier: 0,
            specialEffect: "balance_shift_dark_on_combat"
        ),
        .bloodCurse: TwilightCurseDefinition(
            type: .bloodCurse,
            name: L10n.curseBloodCurseName.localized,
            description: L10n.curseBloodCurseDescription.localized,
            removalCost: 6,
            damageModifier: 0,
            damageTakenModifier: 0,
            actionModifier: 0,
            specialEffect: "heal_on_kill_dark"
        ),
        .sealOfNav: TwilightCurseDefinition(
            type: .sealOfNav,
            name: L10n.curseSealOfNavName.localized,
            description: L10n.curseSealOfNavDescription.localized,
            removalCost: 8,
            damageModifier: 0,
            damageTakenModifier: 0,
            actionModifier: 0,
            specialEffect: "block_sustain_cards"
        )
    ]

    static func get(_ type: TwilightCurseType) -> TwilightCurseDefinition? {
        return definitions[type]
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - Balance (Light/Dark) Configuration
// ═══════════════════════════════════════════════════════════════════════════════

/// Balance state classification
enum TwilightBalanceState: String {
    case light
    case neutral
    case dark

    static func classify(balance: Int) -> TwilightBalanceState {
        if balance >= 70 { return .light }
        if balance <= 30 { return .dark }
        return .neutral
    }
}

/// Balance thresholds
struct TwilightBalanceConfig {
    static let min = 0
    static let max = 100
    static let initial = 50
    static let lightThreshold = 70
    static let darkThreshold = 30
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - Combat Configuration
// ═══════════════════════════════════════════════════════════════════════════════

/// Combat configuration for Twilight Marches
struct TwilightCombatConfig {
    /// Dice type (e.g., d6)
    static let diceMax = 6

    /// Base damage bonus
    static let baseDamageBonus = 2

    /// Actions per combat turn
    static let actionsPerTurn = 3

    /// Cards drawn at turn start
    static let cardsDrawnPerTurn = 5

    /// Maximum hand size
    static let maxHandSize = 7

    /// Calculate damage: playerPower + diceRoll - enemyDefense + bonus
    static func calculateDamage(
        playerPower: Int,
        diceRoll: Int,
        enemyDefense: Int,
        curseModifier: Int,
        regionModifier: Int
    ) -> Int {
        let baseDamage = playerPower + diceRoll - enemyDefense + baseDamageBonus
        let modifiedDamage = baseDamage + curseModifier
        return max(1, modifiedDamage) // Minimum 1 damage
    }

    /// Roll dice (deterministic via WorldRNG)
    static func rollDice() -> Int {
        return WorldRNG.shared.nextInt(in: 1...diceMax)
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - Anchor Configuration
// ═══════════════════════════════════════════════════════════════════════════════

/// Anchor integrity thresholds
struct TwilightAnchorConfig {
    static let maxIntegrity = 100
    static let stableThreshold = 70   // Above = region stable
    static let breachThreshold = 30   // Below = region breach

    static let strengthenAmount = 20
    static let degradeAmount = 20

    /// Determine region state based on anchor integrity
    static func regionStateForIntegrity(_ integrity: Int) -> TwilightRegionState {
        if integrity >= stableThreshold { return .stable }
        if integrity > breachThreshold { return .borderland }
        return .breach
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - Time Configuration
// ═══════════════════════════════════════════════════════════════════════════════

/// Time-related configuration
struct TwilightTimeConfig {
    /// Days for tension increase
    static let tensionIncreaseInterval = 3

    /// Tension increase amount (increased from 2 to 3 for balance)
    static let tensionIncreaseAmount = 3

    /// Travel costs
    static let neighborTravelCost = 1
    static let distantTravelCost = 2

    /// Action costs
    static let restCost = 1
    static let strengthenAnchorCost = 1
    static let exploreCost = 1
    static let instantCost = 0
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - Victory/Defeat Conditions
// ═══════════════════════════════════════════════════════════════════════════════

/// Victory conditions for Twilight Marches
struct TwilightVictoryConfig {
    /// Main quest completion flag
    static let mainQuestCompleteFlag = "act5_completed"

    /// Main quest final stage
    static let mainQuestFinalStage = 5
}

/// Defeat conditions for Twilight Marches
struct TwilightDefeatConfig {
    /// Health defeat threshold
    static let healthDefeatThreshold = 0

    /// Tension defeat threshold
    static let tensionDefeatThreshold = 100

    /// Critical anchor destruction flag
    static let criticalAnchorDestroyedFlag = "critical_anchor_destroyed"
}

// ═══════════════════════════════════════════════════════════════════════════════
// MARK: - Factory
// ═══════════════════════════════════════════════════════════════════════════════

/// Factory for creating Twilight Marches game components
enum TwilightMarchesFactory {
    /// Create pressure rules
    static func createPressureRules() -> TwilightPressureRules {
        return TwilightPressureRules()
    }

    /// Create initial player resources
    static func createInitialResources() -> [String: Int] {
        return twilightInitialResources()
    }

    /// Create resource caps
    static func createResourceCaps() -> [String: Int] {
        return [
            TwilightResource.health.id: TwilightResource.maxHealth.defaultValue,
            TwilightResource.faith.id: TwilightResource.maxFaith.defaultValue,
            TwilightResource.balance.id: TwilightBalanceConfig.max
        ]
    }
}


// ==========================================
// FILE: Engine/Heroes/AbilityRegistry.swift
// ==========================================

import Foundation

/// Реестр способностей героев - data-driven загрузка из JSON
/// Заменяет хардкод в HeroAbility.forAbilityId()
final class AbilityRegistry {

    // MARK: - Singleton

    static let shared = AbilityRegistry()

    // MARK: - Storage

    /// Зарегистрированные способности по ID
    private var abilities: [String: HeroAbility] = [:]

    // MARK: - Init

    private init() {
        // Способности загружаются из ContentPack (hero_abilities.json)
        // Пустой init - данные загружаются через loadFromJSON()
    }

    // MARK: - Registration

    /// Зарегистрировать способность
    func register(_ ability: HeroAbility) {
        abilities[ability.id] = ability
    }

    /// Зарегистрировать несколько способностей
    func registerAll(_ newAbilities: [HeroAbility]) {
        for ability in newAbilities {
            register(ability)
        }
    }

    /// Очистить реестр
    func clear() {
        abilities.removeAll()
    }

    /// Перезагрузить реестр (очистка для повторной загрузки)
    func reload() {
        clear()
    }

    // MARK: - Queries

    /// Получить способность по ID
    func ability(id: String) -> HeroAbility? {
        return abilities[id]
    }

    /// Все доступные способности
    var allAbilities: [HeroAbility] {
        return Array(abilities.values)
    }

    /// Количество зарегистрированных способностей
    var count: Int {
        return abilities.count
    }

    // MARK: - JSON Loading

    /// Загрузить способности из JSON файла
    func loadFromJSON(at url: URL) {
        guard let data = try? Data(contentsOf: url) else {
            #if DEBUG
            print("AbilityRegistry: Failed to load JSON from \(url)")
            #endif
            return
        }

        do {
            let decoder = JSONDecoder()
            decoder.keyDecodingStrategy = .convertFromSnakeCase
            let jsonAbilities = try decoder.decode([JSONAbilityDefinition].self, from: data)
            let converted = jsonAbilities.compactMap { $0.toHeroAbility() }
            registerAll(converted)
            #if DEBUG
            print("AbilityRegistry: Loaded \(converted.count) abilities from \(url.lastPathComponent)")
            #endif
        } catch {
            #if DEBUG
            print("AbilityRegistry: Failed to decode abilities: \(error)")
            #endif
        }
    }

}

// MARK: - JSON Ability Definition

/// JSON структура для способности
struct JSONAbilityDefinition: Codable {
    let id: String
    let name: LocalizedString
    let description: LocalizedString
    let icon: String
    let type: String
    let trigger: String
    let condition: JSONAbilityCondition?
    let effects: [JSONAbilityEffect]
    let cooldown: Int
    let cost: JSONAbilityCost?

    func toHeroAbility() -> HeroAbility? {
        // Конвертируем тип
        guard let abilityType = HeroAbilityType(rawValue: type) else {
            #if DEBUG
            print("AbilityRegistry: Unknown ability type '\(type)' for '\(id)'")
            #endif
            return nil
        }

        // Конвертируем триггер
        let abilityTrigger = AbilityTrigger.fromString(trigger) ?? .always

        // Конвертируем условие
        let abilityCondition = condition?.toAbilityCondition()

        // Конвертируем эффекты
        let abilityEffects = effects.compactMap { $0.toHeroAbilityEffect() }

        // Конвертируем стоимость
        let abilityCost = cost?.toAbilityCost()

        return HeroAbility(
            id: id,
            name: name.localized,
            description: description.localized,
            icon: icon,
            type: abilityType,
            trigger: abilityTrigger,
            condition: abilityCondition,
            effects: abilityEffects,
            cooldown: cooldown,
            cost: abilityCost
        )
    }
}

/// JSON структура для условия способности
struct JSONAbilityCondition: Codable {
    let type: String
    let value: Int?
    let stringValue: String?

    func toAbilityCondition() -> AbilityCondition? {
        guard let conditionType = AbilityConditionType(rawValue: type) else {
            // Try converting from snake_case
            let camelType = type.replacingOccurrences(of: "_", with: "")
            for enumCase in AbilityConditionType.allCases {
                if enumCase.rawValue.lowercased() == camelType.lowercased() {
                    return AbilityCondition(type: enumCase, value: value, stringValue: stringValue)
                }
            }
            #if DEBUG
            print("AbilityRegistry: Unknown condition type '\(type)'")
            #endif
            return nil
        }
        return AbilityCondition(type: conditionType, value: value, stringValue: stringValue)
    }
}

/// JSON структура для эффекта способности
struct JSONAbilityEffect: Codable {
    let type: String
    let value: Int
    let description: String?

    func toHeroAbilityEffect() -> HeroAbilityEffect? {
        guard let effectType = HeroAbilityEffectType(rawValue: type) else {
            // Try converting from snake_case
            let camelType = type.replacingOccurrences(of: "_", with: "")
            for enumCase in HeroAbilityEffectType.allCases {
                if enumCase.rawValue.lowercased() == camelType.lowercased() {
                    return HeroAbilityEffect(type: enumCase, value: value, description: description)
                }
            }
            #if DEBUG
            print("AbilityRegistry: Unknown effect type '\(type)'")
            #endif
            return nil
        }
        return HeroAbilityEffect(type: effectType, value: value, description: description)
    }
}

/// JSON структура для стоимости способности
struct JSONAbilityCost: Codable {
    let type: String
    let value: Int

    func toAbilityCost() -> AbilityCost? {
        guard let costType = AbilityCostType(rawValue: type) else {
            #if DEBUG
            print("AbilityRegistry: Unknown cost type '\(type)'")
            #endif
            return nil
        }
        return AbilityCost(type: costType, value: value)
    }
}

// MARK: - AbilityTrigger Extension

extension AbilityTrigger {
    /// Конвертация из snake_case строки
    static func fromString(_ string: String) -> AbilityTrigger? {
        // Прямое совпадение
        if let trigger = AbilityTrigger(rawValue: string) {
            return trigger
        }

        // Конвертация snake_case -> camelCase
        let mapping: [String: AbilityTrigger] = [
            "always": .always,
            "turn_start": .turnStart,
            "turn_end": .turnEnd,
            "on_attack": .onAttack,
            "on_damage_received": .onDamageReceived,
            "on_damage_dealt": .onDamageDealt,
            "on_card_played": .onCardPlayed,
            "on_combat_start": .onCombatStart,
            "on_combat_end": .onCombatEnd,
            "on_explore": .onExplore,
            "manual": .manual
        ]

        return mapping[string]
    }
}



// ==========================================
// FILE: Engine/Heroes/HeroAbility.swift
// ==========================================

import Foundation

/// Способность героя
/// Определяет уникальные действия и пассивные эффекты героя
struct HeroAbility: Codable, Equatable {
    /// Уникальный идентификатор способности
    let id: String

    /// Название способности
    let name: String

    /// Описание для UI
    let description: String

    /// Иконка (SF Symbol или emoji)
    let icon: String

    /// Тип способности
    let type: HeroAbilityType

    /// Триггер активации (для пассивных)
    let trigger: AbilityTrigger

    /// Условие активации
    let condition: AbilityCondition?

    /// Эффекты способности
    let effects: [HeroAbilityEffect]

    /// Кулдаун (в ходах, 0 = нет кулдауна)
    let cooldown: Int

    /// Стоимость активации (для активных способностей)
    let cost: AbilityCost?
}

/// Тип способности героя
enum HeroAbilityType: String, Codable {
    /// Пассивная - работает автоматически
    case passive

    /// Активная - требует ручной активации
    case active

    /// Реактивная - срабатывает в ответ на событие
    case reactive

    /// Ультимейт - мощная способность с долгим кулдауном
    case ultimate
}

/// Триггер активации способности
enum AbilityTrigger: String, Codable {
    /// Всегда активна
    case always

    /// В начале хода
    case turnStart

    /// В конце хода
    case turnEnd

    /// При атаке
    case onAttack

    /// При получении урона
    case onDamageReceived

    /// При нанесении урона
    case onDamageDealt

    /// При использовании карты
    case onCardPlayed

    /// При входе в бой
    case onCombatStart

    /// При выходе из боя
    case onCombatEnd

    /// При исследовании
    case onExplore

    /// Ручная активация
    case manual
}

/// Условие активации способности
struct AbilityCondition: Codable, Equatable {
    let type: AbilityConditionType
    let value: Int?
    let stringValue: String?

    init(type: AbilityConditionType, value: Int? = nil, stringValue: String? = nil) {
        self.type = type
        self.value = value
        self.stringValue = stringValue
    }
}

/// Тип условия
enum AbilityConditionType: String, Codable, CaseIterable {
    /// HP ниже процента
    case hpBelowPercent

    /// HP выше процента
    case hpAbovePercent

    /// Цель на полном HP
    case targetFullHP

    /// Первая атака в бою
    case firstAttack

    /// Источник урона - тьма
    case damageSourceDark

    /// Источник урона - свет
    case damageSourceLight

    /// Есть определённое проклятие
    case hasCurse

    /// Баланс выше значения
    case balanceAbove

    /// Баланс ниже значения
    case balanceBelow

    /// Есть карта в руке
    case hasCardInHand
}

/// Эффект способности героя
struct HeroAbilityEffect: Codable, Equatable {
    let type: HeroAbilityEffectType
    let value: Int
    let description: String?

    init(type: HeroAbilityEffectType, value: Int, description: String? = nil) {
        self.type = type
        self.value = value
        self.description = description
    }
}

/// Тип эффекта способности
enum HeroAbilityEffectType: String, Codable, CaseIterable {
    /// Бонус к урону
    case bonusDamage

    /// Снижение получаемого урона
    case damageReduction

    /// Дополнительный кубик атаки
    case bonusDice

    /// Восстановление HP
    case heal

    /// Восстановление веры
    case gainFaith

    /// Потеря веры
    case loseFaith

    /// Сдвиг баланса к Свету
    case shiftLight

    /// Сдвиг баланса к Тьме
    case shiftDark

    /// Взять карту
    case drawCard

    /// Сбросить карту
    case discardCard

    /// Применить проклятие к врагу
    case applyCurseToEnemy

    /// Снять проклятие с себя
    case removeCurse

    /// Бонус к защите
    case bonusDefense

    /// Вызов духа
    case summonSpirit

    /// Бонус к следующей атаке
    case bonusNextAttack

    /// Перебросить кубик
    case rerollDice
}

/// Стоимость активации способности
struct AbilityCost: Codable, Equatable {
    let type: AbilityCostType
    let value: Int
}

/// Тип стоимости
enum AbilityCostType: String, Codable {
    case health
    case faith
    case card
    case action
}

// MARK: - Ability Lookup

extension HeroAbility {
    /// Получить способность по ID (data-driven через AbilityRegistry)
    /// Способности загружаются из hero_abilities.json в ContentPack
    static func forAbilityId(_ id: String) -> HeroAbility? {
        return AbilityRegistry.shared.ability(id: id)
    }
}


// ==========================================
// FILE: Engine/Heroes/HeroDefinition.swift
// ==========================================

import Foundation

/// Структура с характеристиками героя
struct HeroStats: Codable, Equatable {
    let health: Int
    let maxHealth: Int
    let strength: Int
    let dexterity: Int
    let constitution: Int
    let intelligence: Int
    let wisdom: Int
    let charisma: Int
    let faith: Int
    let maxFaith: Int
    let startingBalance: Int
}

/// Протокол определения героя (Data Layer)
/// Описывает статические данные героя, которые не меняются во время игры
/// Герои загружаются из Content Pack - без хардкода классов
protocol HeroDefinition {
    /// Уникальный идентификатор (из JSON)
    var id: String { get }

    /// Локализованное имя
    var name: String { get }

    /// Описание героя для UI
    var description: String { get }

    /// Иконка героя (SF Symbol или emoji)
    var icon: String { get }

    /// Базовые характеристики
    var baseStats: HeroStats { get }

    /// Особая способность героя
    var specialAbility: HeroAbility { get }

    /// Стартовая колода (ID карт)
    var startingDeckCardIDs: [String] { get }

    /// Доступность героя (для DLC/разблокировки)
    var availability: HeroAvailability { get }
}

/// Доступность героя
enum HeroAvailability: Codable, Equatable {
    case alwaysAvailable
    case requiresUnlock(condition: String)
    case dlc(packID: String)
}

/// Стандартная реализация определения героя
struct StandardHeroDefinition: HeroDefinition, Codable {
    let id: String
    let name: String
    let description: String
    let icon: String
    let baseStats: HeroStats
    let specialAbility: HeroAbility
    let startingDeckCardIDs: [String]
    let availability: HeroAvailability

    init(
        id: String,
        name: String,
        description: String,
        icon: String,
        baseStats: HeroStats,
        specialAbility: HeroAbility,
        startingDeckCardIDs: [String] = [],
        availability: HeroAvailability = .alwaysAvailable
    ) {
        self.id = id
        self.name = name
        self.description = description
        self.icon = icon
        self.baseStats = baseStats
        self.specialAbility = specialAbility
        self.startingDeckCardIDs = startingDeckCardIDs
        self.availability = availability
    }
}


// ==========================================
// FILE: Engine/Heroes/HeroRegistry.swift
// ==========================================

import Foundation

/// Реестр героев - централизованное хранилище всех определений героев
/// Герои загружаются из Content Pack (JSON) - без хардкода классов
final class HeroRegistry {

    // MARK: - Singleton

    static let shared = HeroRegistry()

    // MARK: - Storage

    /// Зарегистрированные определения героев
    private var definitions: [String: HeroDefinition] = [:]

    /// Порядок отображения героев в UI
    private var displayOrder: [String] = []

    /// Источники данных героев (для модульности)
    private var dataSources: [HeroDataSource] = []

    // MARK: - Init

    private init() {
        registerBuiltInHeroes()
    }

    // MARK: - Registration

    /// Зарегистрировать определение героя
    func register(_ definition: HeroDefinition) {
        definitions[definition.id] = definition
        if !displayOrder.contains(definition.id) {
            displayOrder.append(definition.id)
        }
    }

    /// Зарегистрировать несколько героев
    func registerAll(_ definitions: [HeroDefinition]) {
        for definition in definitions {
            register(definition)
        }
    }

    /// Удалить героя из реестра
    func unregister(id: String) {
        definitions.removeValue(forKey: id)
        displayOrder.removeAll { $0 == id }
    }

    /// Очистить реестр
    func clear() {
        definitions.removeAll()
        displayOrder.removeAll()
    }

    /// Перезагрузить реестр из источников данных
    func reload() {
        clear()
        registerBuiltInHeroes()
        for source in dataSources {
            registerAll(source.loadHeroes())
        }
    }

    // MARK: - Data Sources

    /// Добавить источник данных героев
    func addDataSource(_ source: HeroDataSource) {
        dataSources.append(source)
        registerAll(source.loadHeroes())
    }

    /// Удалить источник данных
    func removeDataSource(_ source: HeroDataSource) {
        if let index = dataSources.firstIndex(where: { $0.id == source.id }) {
            let source = dataSources.remove(at: index)
            for hero in source.loadHeroes() {
                unregister(id: hero.id)
            }
        }
    }

    // MARK: - Queries

    /// Получить героя по ID
    func hero(id: String) -> HeroDefinition? {
        return definitions[id]
    }

    /// Все доступные герои
    var allHeroes: [HeroDefinition] {
        return displayOrder.compactMap { definitions[$0] }
    }

    /// Первый доступный герой (для дефолта)
    var firstHero: HeroDefinition? {
        return allHeroes.first
    }

    /// Доступные герои (не заблокированные)
    func availableHeroes(unlockedConditions: Set<String> = [], ownedDLCs: Set<String> = []) -> [HeroDefinition] {
        return allHeroes.filter { hero in
            switch hero.availability {
            case .alwaysAvailable:
                return true
            case .requiresUnlock(let condition):
                return unlockedConditions.contains(condition)
            case .dlc(let packID):
                return ownedDLCs.contains(packID)
            }
        }
    }

    /// Количество зарегистрированных героев
    var count: Int {
        return definitions.count
    }

    // MARK: - Built-in Heroes

    /// Загрузка героев из JSON файла в бандле
    private func registerBuiltInHeroes() {
        // Сначала пробуем загрузить из ContentPacks (новая структура)
        if let heroesURL = Bundle.main.url(
            forResource: "heroes",
            withExtension: "json",
            subdirectory: "ContentPacks/TwilightMarches/Characters"
        ) {
            let dataSource = JSONHeroDataSource(
                id: "bundle_heroes",
                name: "Bundle Heroes",
                fileURL: heroesURL
            )
            registerAll(dataSource.loadHeroes())
            return
        }

        // Fallback: старый путь (heroes.json в корне bundle)
        if let heroesURL = Bundle.main.url(forResource: "heroes", withExtension: "json") {
            let dataSource = JSONHeroDataSource(
                id: "bundle_heroes",
                name: "Bundle Heroes",
                fileURL: heroesURL
            )
            registerAll(dataSource.loadHeroes())
            return
        }

        #if DEBUG
        print("HeroRegistry: ERROR - heroes.json not found in bundle!")
        #endif
    }
}

// MARK: - Hero Data Source Protocol

/// Протокол источника данных героев
/// Позволяет загружать героев из разных источников (JSON, сервер, DLC)
protocol HeroDataSource {
    /// Уникальный идентификатор источника
    var id: String { get }

    /// Название источника (для отладки)
    var name: String { get }

    /// Загрузить героев из источника
    func loadHeroes() -> [HeroDefinition]
}

// MARK: - JSON Data Source

/// Загрузчик героев из JSON файла
struct JSONHeroDataSource: HeroDataSource {
    let id: String
    let name: String
    let fileURL: URL

    func loadHeroes() -> [HeroDefinition] {
        guard let data = try? Data(contentsOf: fileURL) else {
            #if DEBUG
            print("HeroRegistry: Failed to load JSON from \(fileURL)")
            #endif
            return []
        }

        do {
            let decoder = JSONDecoder()
            decoder.keyDecodingStrategy = .convertFromSnakeCase
            let decoded = try decoder.decode([JSONHeroDefinition].self, from: data)
            return decoded.map { $0.toStandard() }
        } catch {
            #if DEBUG
            print("HeroRegistry: Failed to decode heroes: \(error)")
            #endif
            return []
        }
    }
}

/// JSON структура для stats
struct JSONHeroStats: Codable {
    let health: Int
    let maxHealth: Int
    let strength: Int
    let dexterity: Int
    let constitution: Int
    let intelligence: Int
    let wisdom: Int
    let charisma: Int
    let faith: Int
    let maxFaith: Int
    let startingBalance: Int

    func toHeroStats() -> HeroStats {
        HeroStats(
            health: health,
            maxHealth: maxHealth,
            strength: strength,
            dexterity: dexterity,
            constitution: constitution,
            intelligence: intelligence,
            wisdom: wisdom,
            charisma: charisma,
            faith: faith,
            maxFaith: maxFaith,
            startingBalance: startingBalance
        )
    }
}

/// JSON-совместимое определение героя (data-driven)
struct JSONHeroDefinition: Codable {
    let id: String
    let name: String
    let nameRu: String?
    let description: String
    let descriptionRu: String?
    let icon: String
    let baseStats: JSONHeroStats
    let abilityId: String
    let startingDeckCardIds: [String]
    let availability: String?

    func toStandard() -> StandardHeroDefinition {
        // Локализация
        let isRussian = Locale.current.language.languageCode?.identifier == "ru"
        let localizedName = isRussian ? (nameRu ?? name) : name
        let localizedDescription = isRussian ? (descriptionRu ?? description) : description

        // Определяем доступность
        let heroAvailability: HeroAvailability
        switch availability?.lowercased() {
        case "always_available", nil:
            heroAvailability = .alwaysAvailable
        case let str where str?.hasPrefix("requires_unlock:") == true:
            let condition = String(str!.dropFirst("requires_unlock:".count))
            heroAvailability = .requiresUnlock(condition: condition)
        case let str where str?.hasPrefix("dlc:") == true:
            let packId = String(str!.dropFirst("dlc:".count))
            heroAvailability = .dlc(packID: packId)
        default:
            heroAvailability = .alwaysAvailable
        }

        // Получаем способность по ID
        guard let ability = HeroAbility.forAbilityId(abilityId) else {
            #if DEBUG
            print("HeroRegistry: ERROR - Unknown ability ID '\(abilityId)' for hero '\(id)'")
            #endif
            fatalError("Missing ability definition for '\(abilityId)'. Add it to HeroAbility.forAbilityId() or hero_abilities.json")
        }

        return StandardHeroDefinition(
            id: id,
            name: localizedName,
            description: localizedDescription,
            icon: icon,
            baseStats: baseStats.toHeroStats(),
            specialAbility: ability,
            startingDeckCardIDs: startingDeckCardIds,
            availability: heroAvailability
        )
    }
}

// MARK: - DLC Data Source

/// Источник героев из DLC пакета
struct DLCHeroDataSource: HeroDataSource {
    let id: String
    let name: String
    let packID: String
    let heroes: [HeroDefinition]

    func loadHeroes() -> [HeroDefinition] {
        return heroes
    }
}


// ==========================================
// FILE: Engine/Cards/CardDefinition.swift
// ==========================================

import Foundation

/// Протокол определения карты (Data Layer)
/// Описывает статические данные карты, которые не меняются во время игры
protocol CardDefinition {
    /// Уникальный идентификатор карты
    var id: String { get }

    /// Локализованное название
    var name: String { get }

    /// Тип карты
    var cardType: CardType { get }

    /// Редкость
    var rarity: CardRarity { get }

    /// Описание для UI
    var description: String { get }

    /// Иконка карты (SF Symbol или emoji)
    var icon: String { get }

    /// Набор/дополнение
    var expansionSet: ExpansionSet { get }

    /// Принадлежность карты (кому доступна)
    var ownership: CardOwnership { get }

    /// Эффекты карты
    var abilities: [CardAbility] { get }

    /// Стоимость веры для покупки
    var faithCost: Int { get }

    /// Баланс Свет/Тьма
    var balance: CardBalance? { get }

    /// Роль карты в кампании
    var role: CardRole? { get }
}

/// Принадлежность карты - определяет кто может использовать карту
/// Аналог системы сигнатурных карт из Arkham Horror LCG
enum CardOwnership: Equatable {
    /// Базовая карта - доступна всем
    case universal

    /// Сигнатурная карта героя - привязана к конкретному герою по ID
    /// Как в Arkham Horror LCG, где у каждого следователя есть свои уникальные карты
    case heroSignature(heroID: String)

    /// Карта класса - доступна героям определённого класса
    case classSpecific(className: String)

    /// Карта набора/дополнения - требует владения DLC
    case expansion(setID: String)

    /// Карта с требованием разблокировки
    case requiresUnlock(condition: String)

    /// Карта с несколькими условиями (все должны выполняться)
    case composite([CardOwnership])
}

// MARK: - CardOwnership Codable

extension CardOwnership: Codable {
    private enum CodingKeys: String, CodingKey {
        case universal
        case heroSignature = "hero_signature"
        case classSpecific = "class_specific"
        case expansion
        case requiresUnlock = "requires_unlock"
        case composite
    }

    init(from decoder: Decoder) throws {
        // Try string first (for "universal")
        if let container = try? decoder.singleValueContainer(),
           let stringValue = try? container.decode(String.self) {
            if stringValue == "universal" {
                self = .universal
                return
            }
        }

        // Try keyed container for complex types
        let container = try decoder.container(keyedBy: CodingKeys.self)

        if let heroID = try container.decodeIfPresent(String.self, forKey: .heroSignature) {
            self = .heroSignature(heroID: heroID)
        } else if let className = try container.decodeIfPresent(String.self, forKey: .classSpecific) {
            self = .classSpecific(className: className)
        } else if let setID = try container.decodeIfPresent(String.self, forKey: .expansion) {
            self = .expansion(setID: setID)
        } else if let condition = try container.decodeIfPresent(String.self, forKey: .requiresUnlock) {
            self = .requiresUnlock(condition: condition)
        } else if let items = try container.decodeIfPresent([CardOwnership].self, forKey: .composite) {
            self = .composite(items)
        } else {
            self = .universal
        }
    }

    func encode(to encoder: Encoder) throws {
        switch self {
        case .universal:
            var container = encoder.singleValueContainer()
            try container.encode("universal")

        case .heroSignature(let heroID):
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(heroID, forKey: .heroSignature)

        case .classSpecific(let className):
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(className, forKey: .classSpecific)

        case .expansion(let setID):
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(setID, forKey: .expansion)

        case .requiresUnlock(let condition):
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(condition, forKey: .requiresUnlock)

        case .composite(let items):
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(items, forKey: .composite)
        }
    }
}

/// Стандартная реализация определения карты
struct StandardCardDefinition: CardDefinition, Codable {
    let id: String
    let name: String
    let cardType: CardType
    let rarity: CardRarity
    let description: String
    let icon: String
    let expansionSet: ExpansionSet
    let ownership: CardOwnership
    let abilities: [CardAbility]
    let faithCost: Int
    let balance: CardBalance?
    let role: CardRole?

    // Дополнительные параметры
    let power: Int?
    let defense: Int?
    let health: Int?
    let realm: Realm?
    let curseType: CurseType?

    init(
        id: String,
        name: String,
        cardType: CardType,
        rarity: CardRarity = .common,
        description: String,
        icon: String = "🃏",
        expansionSet: ExpansionSet = .baseSet,
        ownership: CardOwnership = .universal,
        abilities: [CardAbility] = [],
        faithCost: Int = 3,
        balance: CardBalance? = nil,
        role: CardRole? = nil,
        power: Int? = nil,
        defense: Int? = nil,
        health: Int? = nil,
        realm: Realm? = nil,
        curseType: CurseType? = nil
    ) {
        self.id = id
        self.name = name
        self.cardType = cardType
        self.rarity = rarity
        self.description = description
        self.icon = icon
        self.expansionSet = expansionSet
        self.ownership = ownership
        self.abilities = abilities
        self.faithCost = faithCost
        self.balance = balance
        self.role = role
        self.power = power
        self.defense = defense
        self.health = health
        self.realm = realm
        self.curseType = curseType
    }

    /// Конвертация в игровую Card
    func toCard() -> Card {
        return Card(
            id: UUID(),
            definitionId: id,  // Content Pack ID
            name: name,
            type: cardType,
            rarity: rarity,
            description: description,
            power: power,
            defense: defense,
            health: health,
            abilities: abilities,
            balance: balance,
            realm: realm,
            curseType: curseType,
            expansionSet: expansionSet.rawValue,
            role: role,
            faithCost: faithCost
        )
    }
}

// MARK: - Card Ownership Extensions

extension CardOwnership {
    /// Проверить, доступна ли карта для героя
    func isAvailable(
        forHeroID heroID: String?,
        heroClass: String? = nil,
        ownedExpansions: Set<String> = [],
        unlockedConditions: Set<String> = []
    ) -> Bool {
        switch self {
        case .universal:
            return true

        case .heroSignature(let requiredHeroID):
            return heroID == requiredHeroID

        case .classSpecific(let className):
            return heroClass == className

        case .expansion(let setID):
            return ownedExpansions.contains(setID)

        case .requiresUnlock(let condition):
            return unlockedConditions.contains(condition)

        case .composite(let requirements):
            return requirements.allSatisfy { requirement in
                requirement.isAvailable(
                    forHeroID: heroID,
                    heroClass: heroClass,
                    ownedExpansions: ownedExpansions,
                    unlockedConditions: unlockedConditions
                )
            }
        }
    }

    /// Описание условий доступа для UI
    var accessDescription: String {
        switch self {
        case .universal:
            return "Доступна всем"

        case .heroSignature(let heroID):
            return "Сигнатурная карта героя: \(heroID)"

        case .classSpecific(let className):
            return "Карта класса: \(className)"

        case .expansion(let setID):
            return "Требуется дополнение: \(setID)"

        case .requiresUnlock(let condition):
            return "Требуется: \(condition)"

        case .composite(let requirements):
            let descriptions = requirements.map { $0.accessDescription }
            return descriptions.joined(separator: " + ")
        }
    }
}

// MARK: - Signature Card Set

/// Набор сигнатурных карт героя
/// Каждый герой может иметь уникальные карты, которые начинают в его колоде
/// или могут быть добавлены только этому герою
struct HeroSignatureCards {
    /// ID героя
    let heroID: String

    /// Обязательные сигнатурные карты (начинают в колоде)
    let requiredCards: [CardDefinition]

    /// Опциональные сигнатурные карты (можно добавить во время кампании)
    let optionalCards: [CardDefinition]

    /// Слабость героя (негативная сигнатурная карта)
    /// Как в Arkham Horror LCG, где у каждого следователя есть своя слабость
    let weakness: CardDefinition?

    /// Все карты ID
    var allCardIDs: [String] {
        var ids = requiredCards.map { $0.id }
        ids.append(contentsOf: optionalCards.map { $0.id })
        if let weakness = weakness {
            ids.append(weakness.id)
        }
        return ids
    }
}

// MARK: - Hero Card Pool

/// Пул карт героя
/// Карты, доступные конкретному герою
struct HeroCardPool {
    /// ID героя
    let heroID: String

    /// Стартовые карты (добавляются в начальную колоду)
    let startingCards: [CardDefinition]

    /// Карты для покупки (доступны в магазине только этому герою)
    let purchasableCards: [CardDefinition]

    /// Карты улучшения (замена базовых карт на улучшенные)
    let upgradeCards: [CardDefinition]

    /// Все карты ID
    var allCardIDs: [String] {
        var ids = startingCards.map { $0.id }
        ids.append(contentsOf: purchasableCards.map { $0.id })
        ids.append(contentsOf: upgradeCards.map { $0.id })
        return ids
    }
}


// ==========================================
// FILE: Engine/Cards/CardFactory.swift
// ==========================================

import Foundation

// MARK: - Card Factory

/// Factory for creating runtime Card instances from Content Pack definitions
/// This is the ONLY authorized way to create Card instances at runtime.
///
/// The factory reads from ContentRegistry (which loads from JSON packs)
/// and converts definitions to runtime Card instances.
///
/// IMPORTANT: TwilightMarchesCards.swift must NOT be used at runtime.
/// All card creation must go through this factory.
final class CardFactory {

    // MARK: - Singleton

    static let shared = CardFactory()

    // MARK: - Dependencies

    private let contentRegistry: ContentRegistry
    private let cardRegistry: CardRegistry

    // MARK: - Initialization

    init(contentRegistry: ContentRegistry = .shared, cardRegistry: CardRegistry = .shared) {
        self.contentRegistry = contentRegistry
        self.cardRegistry = cardRegistry
    }

    // MARK: - Card Creation

    /// Get a runtime Card by ID
    /// - Parameter id: Card definition ID
    /// - Returns: Runtime Card instance or nil if not found
    func getCard(id: String) -> Card? {
        // First try ContentRegistry (from JSON packs)
        if let cardDef = contentRegistry.getCard(id: id) {
            return cardDef.toCard()
        }

        // Fallback to CardRegistry (built-in cards)
        if let cardDef = cardRegistry.card(id: id) as? StandardCardDefinition {
            return cardDef.toCard()
        }

        return nil
    }

    /// Get multiple cards by IDs
    /// - Parameter ids: Array of card IDs
    /// - Returns: Array of runtime Card instances (skipping not found)
    func getCards(ids: [String]) -> [Card] {
        return ids.compactMap { getCard(id: $0) }
    }

    /// Get all available cards
    /// - Returns: Array of all runtime Card instances
    func getAllCards() -> [Card] {
        var cards: [Card] = []

        // From ContentRegistry
        for cardDef in contentRegistry.getAllCards() {
            cards.append(cardDef.toCard())
        }

        // From CardRegistry (built-in)
        for cardDef in cardRegistry.allCards {
            if let stdDef = cardDef as? StandardCardDefinition {
                // Avoid duplicates
                if !cards.contains(where: { $0.name == stdDef.name }) {
                    cards.append(stdDef.toCard())
                }
            }
        }

        return cards
    }

    /// Get cards by type
    /// - Parameter type: Card type to filter
    /// - Returns: Array of runtime Card instances of that type
    func getCards(ofType type: CardType) -> [Card] {
        var cards: [Card] = []

        // From ContentRegistry
        for cardDef in contentRegistry.getCards(ofType: type) {
            cards.append(cardDef.toCard())
        }

        // From CardRegistry (built-in)
        for cardDef in cardRegistry.allCards where cardDef.cardType == type {
            if let stdDef = cardDef as? StandardCardDefinition {
                if !cards.contains(where: { $0.name == stdDef.name }) {
                    cards.append(stdDef.toCard())
                }
            }
        }

        return cards
    }

    // MARK: - Starting Decks

    /// Create starting deck for a hero
    /// - Parameter heroId: Hero definition ID
    /// - Returns: Array of runtime Card instances for starting deck
    func createStartingDeck(forHero heroId: String) -> [Card] {
        // Try ContentRegistry first (from Character Pack)
        let cards = contentRegistry.getStartingDeck(forHero: heroId)
        if !cards.isEmpty {
            return cards.map { $0.toCard() }
        }

        // Fallback to CardRegistry
        let registryDeck = cardRegistry.startingDeck(forHeroID: heroId)
        if !registryDeck.isEmpty {
            return registryDeck
        }

        // Final fallback: generic starter deck
        return createGenericStarterDeck()
    }

    /// Create starting deck for a hero by name (legacy compatibility)
    /// - Parameter heroName: Hero name
    /// - Returns: Array of runtime Card instances for starting deck
    func createStartingDeck(forHeroName heroName: String) -> [Card] {
        // Map name to hero ID
        let heroId = mapHeroNameToId(heroName)
        return createStartingDeck(forHero: heroId)
    }

    /// Create generic starter deck (fallback)
    private func createGenericStarterDeck() -> [Card] {
        var deck: [Card] = []

        // Add basic cards from registry
        let basicCardIds = ["strike_basic", "defend_basic", "heal_basic", "draw_basic"]
        for id in basicCardIds {
            if let card = getCard(id: id) {
                // Add 2 copies of each basic card
                deck.append(card)
                deck.append(getCard(id: id)!) // New instance
            }
        }

        return deck
    }

    // MARK: - Encounter Deck

    /// Create encounter deck from content packs
    /// - Returns: Array of monster cards for encounters
    func createEncounterDeck() -> [Card] {
        var deck: [Card] = []

        // Get all enemies from ContentRegistry
        for enemy in contentRegistry.getAllEnemies() {
            deck.append(enemy.toCard())
        }

        return deck
    }

    // MARK: - Market Cards

    /// Create market cards for purchasing
    /// - Parameter heroId: Optional hero ID for filtering
    /// - Returns: Array of purchasable cards
    func createMarketCards(forHeroId heroId: String? = nil) -> [Card] {
        var cards: [Card] = []

        // Get shop cards from CardRegistry
        let shopDefs = cardRegistry.shopCards(
            forHeroID: heroId,
            ownedExpansions: [],
            unlockedConditions: []
        )

        for cardDef in shopDefs {
            if let stdDef = cardDef as? StandardCardDefinition {
                cards.append(stdDef.toCard())
            }
        }

        return cards
    }

    // MARK: - Character Cards

    /// Create guardian characters for character selection
    /// - Returns: Array of hero cards for selection screen
    func createGuardians() -> [Card] {
        var guardians: [Card] = []

        // Get heroes from ContentRegistry
        for hero in contentRegistry.getAllHeroes() {
            guardians.append(heroToCard(hero))
        }

        // Fallback: if no heroes in packs, use hardcoded fallback
        if guardians.isEmpty {
            guardians = createFallbackGuardians()
        }

        return guardians
    }

    /// Convert hero definition to Card for UI display
    private func heroToCard(_ hero: StandardHeroDefinition) -> Card {
        return Card(
            id: UUID(),
            name: hero.name,
            type: .character,
            rarity: .legendary,
            description: hero.description,
            imageURL: nil,
            power: hero.baseStats.strength,
            defense: 0,
            health: hero.baseStats.health,
            abilities: [
                CardAbility(
                    name: hero.specialAbility.name,
                    description: hero.specialAbility.description,
                    effect: .custom(hero.specialAbility.description)
                )
            ],
            faithCost: 0
        )
    }

    /// Fallback guardians when no packs loaded
    private func createFallbackGuardians() -> [Card] {
        // This provides minimal fallback when no packs are loaded
        // In production, packs should always be loaded
        return [
            Card(
                name: "Велеслава",
                type: .character,
                rarity: .legendary,
                description: "Жрица Света. Мастер исцеления и защиты.",
                defense: 2,
                health: 12,
                abilities: [],
                faithCost: 0
            ),
            Card(
                name: "Ратибор",
                type: .character,
                rarity: .legendary,
                description: "Воин. Сильный боец ближнего боя.",
                power: 4,
                health: 14,
                abilities: [],
                faithCost: 0
            ),
            Card(
                name: "Мирослав",
                type: .character,
                rarity: .legendary,
                description: "Следопыт. Быстрый и точный.",
                power: 3,
                health: 10,
                abilities: [],
                faithCost: 0
            ),
            Card(
                name: "Забава",
                type: .character,
                rarity: .legendary,
                description: "Ведьма. Мастер тёмных искусств.",
                power: 5,
                health: 8,
                abilities: [],
                faithCost: 0
            )
        ]
    }

    // MARK: - Boss Creation

    /// Create boss card by enemy ID
    /// - Parameter enemyId: Enemy definition ID
    /// - Returns: Boss card or nil
    func createBoss(enemyId: String) -> Card? {
        if let enemy = contentRegistry.getEnemy(id: enemyId) {
            return enemy.toCard()
        }
        return nil
    }

    /// Create Leshy Guardian boss (Act I final boss)
    func createLeshyGuardianBoss() -> Card? {
        // Try to get from ContentRegistry first
        if let boss = createBoss(enemyId: "leshy_guardian") {
            return boss
        }

        // Fallback boss
        return Card(
            name: "Леший-Хранитель",
            type: .monster,
            rarity: .legendary,
            description: "Древний страж Сумрачных Пределов. Босс Акта I.",
            power: 7,
            defense: 4,
            health: 25,
            abilities: [
                CardAbility(
                    name: "Гнев Природы",
                    description: "Регенерация 3 HP каждый ход",
                    effect: .heal(amount: 3)
                ),
                CardAbility(
                    name: "Древняя Броня",
                    description: "+2 к защите",
                    effect: .custom( "Дополнительная защита")
                )
            ],
            faithCost: 0
        )
    }

    // MARK: - Helper Methods

    /// Map hero name to ID for legacy compatibility
    private func mapHeroNameToId(_ name: String) -> String {
        switch name.lowercased() {
        case "велеслава": return "veleslava"
        case "ратибор": return "ratibor"
        case "мирослав": return "miroslav"
        case "забава": return "zabava"
        default: return name.lowercased().replacingOccurrences(of: " ", with: "_")
        }
    }

}


// ==========================================
// FILE: Engine/Cards/CardRegistry.swift
// ==========================================

import Foundation

/// Реестр карт - централизованное хранилище всех определений карт
/// Поддерживает:
/// - Универсальные карты (доступны всем)
/// - Сигнатурные карты героя (уникальные карты конкретного персонажа по heroID)
/// - DLC/Expansion карты
final class CardRegistry {

    // MARK: - Singleton

    static let shared = CardRegistry()

    // MARK: - Storage

    /// Все зарегистрированные карты
    private var definitions: [String: CardDefinition] = [:]

    /// Пулы карт героев (по heroID)
    private var heroPools: [String: HeroCardPool] = [:]

    /// Сигнатурные карты героев
    private var signatureCards: [String: HeroSignatureCards] = [:]

    /// Источники данных карт
    private var dataSources: [CardDataSource] = []

    // MARK: - Init

    private init() {
        registerBuiltInCards()
    }

    // MARK: - Registration

    /// Зарегистрировать определение карты
    func register(_ definition: CardDefinition) {
        definitions[definition.id] = definition
    }

    /// Зарегистрировать несколько карт
    func registerAll(_ definitions: [CardDefinition]) {
        for definition in definitions {
            register(definition)
        }
    }

    /// Зарегистрировать пул карт героя
    func registerHeroPool(_ pool: HeroCardPool) {
        heroPools[pool.heroID] = pool
        registerAll(pool.startingCards)
        registerAll(pool.purchasableCards)
        registerAll(pool.upgradeCards)
    }

    /// Зарегистрировать сигнатурные карты героя
    func registerSignatureCards(_ cards: HeroSignatureCards) {
        signatureCards[cards.heroID] = cards
        registerAll(cards.requiredCards)
        registerAll(cards.optionalCards)
        if let weakness = cards.weakness {
            register(weakness)
        }
    }

    /// Удалить карту из реестра
    func unregister(id: String) {
        definitions.removeValue(forKey: id)
    }

    /// Очистить реестр
    func clear() {
        definitions.removeAll()
        heroPools.removeAll()
        signatureCards.removeAll()
    }

    /// Перезагрузить реестр
    func reload() {
        clear()
        registerBuiltInCards()
        for source in dataSources {
            registerAll(source.loadCards())
        }
    }

    // MARK: - Data Sources

    /// Добавить источник данных
    func addDataSource(_ source: CardDataSource) {
        dataSources.append(source)
        registerAll(source.loadCards())
    }

    /// Удалить источник данных
    func removeDataSource(_ source: CardDataSource) {
        if let index = dataSources.firstIndex(where: { $0.id == source.id }) {
            let source = dataSources.remove(at: index)
            for card in source.loadCards() {
                unregister(id: card.id)
            }
        }
    }

    // MARK: - Queries

    /// Получить карту по ID
    func card(id: String) -> CardDefinition? {
        return definitions[id]
    }

    /// Все карты
    var allCards: [CardDefinition] {
        return Array(definitions.values)
    }

    /// Карты доступные для героя
    func availableCards(
        forHeroID heroID: String?,
        ownedExpansions: Set<String> = [],
        unlockedConditions: Set<String> = []
    ) -> [CardDefinition] {
        return allCards.filter { card in
            card.ownership.isAvailable(
                forHeroID: heroID,
                ownedExpansions: ownedExpansions,
                unlockedConditions: unlockedConditions
            )
        }
    }

    /// Универсальные карты (доступны всем)
    var universalCards: [CardDefinition] {
        return allCards.filter { card in
            if case .universal = card.ownership { return true }
            return false
        }
    }

    /// Сигнатурные карты героя
    func signatureCards(forHeroID heroID: String) -> HeroSignatureCards? {
        return signatureCards[heroID]
    }

    /// Пул карт героя
    func heroPool(for heroID: String) -> HeroCardPool? {
        return heroPools[heroID]
    }

    /// Стартовая колода для героя
    func startingDeck(forHeroID heroID: String) -> [Card] {
        var deck: [Card] = []

        // 1. Базовые универсальные карты
        let basicCards = universalCards.filter { $0.rarity == .common }
        for cardDef in basicCards.prefix(5) {
            if let def = cardDef as? StandardCardDefinition {
                deck.append(def.toCard())
            }
        }

        // 2. Карты героя (из пула)
        if let pool = heroPools[heroID] {
            for cardDef in pool.startingCards {
                if let def = cardDef as? StandardCardDefinition {
                    deck.append(def.toCard())
                }
            }
        }

        // 3. Сигнатурные карты героя
        if let signature = signatureCards[heroID] {
            for cardDef in signature.requiredCards {
                if let def = cardDef as? StandardCardDefinition {
                    deck.append(def.toCard())
                }
            }
            // Добавляем слабость
            if let weakness = signature.weakness as? StandardCardDefinition {
                deck.append(weakness.toCard())
            }
        }

        return deck
    }

    /// Карты для магазина (с учётом доступности)
    func shopCards(
        forHeroID heroID: String?,
        ownedExpansions: Set<String> = [],
        unlockedConditions: Set<String> = [],
        maxRarity: CardRarity = .epic
    ) -> [CardDefinition] {
        return availableCards(
            forHeroID: heroID,
            ownedExpansions: ownedExpansions,
            unlockedConditions: unlockedConditions
        ).filter { card in
            // Исключаем сигнатурные карты из магазина
            if case .heroSignature = card.ownership { return false }
            // Исключаем легендарные (добываются только из данжей)
            if card.rarity == .legendary { return false }
            return card.rarity.order <= maxRarity.order
        }
    }

    /// Количество карт в реестре
    var count: Int {
        return definitions.count
    }

    // MARK: - Built-in Cards

    private func registerBuiltInCards() {
        // Базовые универсальные карты (доступны всем)
        registerBaseCards()

        // Сигнатурные карты героев
        registerSignatureCardsForBuiltInHeroes()
    }

    private func registerBaseCards() {
        // Базовый удар
        register(StandardCardDefinition(
            id: "strike_basic",
            name: "Удар",
            cardType: .attack,
            rarity: .common,
            description: "Нанести 3 урона",
            icon: "⚔️",
            abilities: [CardAbility(
                name: "Удар",
                description: "Нанести 3 урона",
                effect: .damage(amount: 3, type: .physical)
            )],
            faithCost: 1,
            balance: .neutral
        ))

        // Базовая защита
        register(StandardCardDefinition(
            id: "defend_basic",
            name: "Защита",
            cardType: .defense,
            rarity: .common,
            description: "Получить 3 защиты",
            icon: "🛡️",
            abilities: [],
            faithCost: 1,
            balance: .neutral,
            defense: 3
        ))

        // Восстановление
        register(StandardCardDefinition(
            id: "heal_basic",
            name: "Лечение",
            cardType: .spell,
            rarity: .common,
            description: "Восстановить 2 HP",
            icon: "💚",
            abilities: [CardAbility(
                name: "Исцеление",
                description: "Восстановить 2 HP",
                effect: .heal(amount: 2)
            )],
            faithCost: 2,
            balance: .light,
            role: .sustain
        ))

        // Взять карты
        register(StandardCardDefinition(
            id: "draw_basic",
            name: "Подготовка",
            cardType: .special,
            rarity: .common,
            description: "Взять 2 карты",
            icon: "📜",
            abilities: [CardAbility(
                name: "Подготовка",
                description: "Взять 2 карты",
                effect: .drawCards(count: 2)
            )],
            faithCost: 2,
            balance: .neutral,
            role: .utility
        ))
    }

    private func registerSignatureCardsForBuiltInHeroes() {
        // Рагнар - Воин
        registerSignatureCards(HeroSignatureCards(
            heroID: "warrior_ragnar",
            requiredCards: [
                StandardCardDefinition(
                    id: "ragnar_ancestral_axe",
                    name: "Топор предков",
                    cardType: .weapon,
                    rarity: .rare,
                    description: "Легендарное оружие Рагнара. +2 к урону, +1 кубик",
                    icon: "🪓",
                    ownership: .heroSignature(heroID: "warrior_ragnar"),
                    abilities: [CardAbility(
                        name: "Наследие",
                        description: "+1 кубик атаки",
                        effect: .addDice(count: 1)
                    )],
                    faithCost: 0,
                    balance: .neutral,
                    power: 2
                )
            ],
            optionalCards: [],
            weakness: StandardCardDefinition(
                id: "ragnar_blood_rage",
                name: "Кровавая ярость",
                cardType: .curse,
                rarity: .rare,
                description: "Слабость Рагнара. При HP < 25% атакует ближайшую цель",
                icon: "💢",
                ownership: .heroSignature(heroID: "warrior_ragnar"),
                abilities: [],
                faithCost: 0,
                balance: .dark,
                curseType: .bloodCurse
            )
        ))

        // Умбра - Тень
        registerSignatureCards(HeroSignatureCards(
            heroID: "shadow_umbra",
            requiredCards: [
                StandardCardDefinition(
                    id: "umbra_shadow_cloak",
                    name: "Плащ теней",
                    cardType: .armor,
                    rarity: .rare,
                    description: "Артефакт Умбры. Невидимость на 1 ход после убийства",
                    icon: "🌑",
                    ownership: .heroSignature(heroID: "shadow_umbra"),
                    abilities: [],
                    faithCost: 0,
                    balance: .dark,
                    defense: 1
                )
            ],
            optionalCards: [],
            weakness: StandardCardDefinition(
                id: "umbra_dark_pact",
                name: "Тёмный договор",
                cardType: .curse,
                rarity: .rare,
                description: "Слабость Умбры. Каждые 3 убийства: баланс -10 к Тьме",
                icon: "📜",
                ownership: .heroSignature(heroID: "shadow_umbra"),
                abilities: [CardAbility(
                    name: "Договор",
                    description: "Сдвиг к Тьме",
                    effect: .shiftBalance(towards: .dark, amount: 10)
                )],
                faithCost: 0,
                balance: .dark
            )
        ))
    }
}

// MARK: - Card Data Source Protocol

/// Протокол источника данных карт
protocol CardDataSource {
    var id: String { get }
    var name: String { get }
    func loadCards() -> [CardDefinition]
}

// MARK: - JSON Data Source

/// Загрузчик карт из JSON
struct JSONCardDataSource: CardDataSource {
    let id: String
    let name: String
    let fileURL: URL

    func loadCards() -> [CardDefinition] {
        guard let data = try? Data(contentsOf: fileURL) else {
            #if DEBUG
            print("CardRegistry: Failed to load JSON from \(fileURL)")
            #endif
            return []
        }

        do {
            let decoded = try JSONDecoder().decode([JSONCardDefinition].self, from: data)
            return decoded.map { $0.toStandard() }
        } catch {
            #if DEBUG
            print("CardRegistry: Failed to decode cards: \(error)")
            #endif
            return []
        }
    }
}

/// JSON-совместимое определение карты
struct JSONCardDefinition: Codable {
    let id: String
    let name: String
    let cardType: CardType
    let rarity: CardRarity
    let description: String
    let icon: String?
    let expansionSet: ExpansionSet?
    let faithCost: Int
    let balance: CardBalance?
    let role: CardRole?
    let power: Int?
    let defense: Int?
    let health: Int?
    // Simplified ownership for JSON
    let ownershipType: String?  // "universal", "hero:warrior_ragnar"

    func toStandard() -> StandardCardDefinition {
        let ownership: CardOwnership
        if let ownershipType = ownershipType {
            if ownershipType == "universal" {
                ownership = .universal
            } else if ownershipType.hasPrefix("hero:") {
                let heroID = String(ownershipType.dropFirst(5))
                ownership = .heroSignature(heroID: heroID)
            } else {
                ownership = .universal
            }
        } else {
            ownership = .universal
        }

        return StandardCardDefinition(
            id: id,
            name: name,
            cardType: cardType,
            rarity: rarity,
            description: description,
            icon: icon ?? "🃏",
            expansionSet: expansionSet ?? .baseSet,
            ownership: ownership,
            faithCost: faithCost,
            balance: balance,
            role: role,
            power: power,
            defense: defense,
            health: health
        )
    }
}

// MARK: - CardRarity Extension

extension CardRarity {
    /// Порядок редкости для сравнения
    var order: Int {
        switch self {
        case .common: return 0
        case .uncommon: return 1
        case .rare: return 2
        case .epic: return 3
        case .legendary: return 4
        }
    }
}


// ==========================================
// FILE: Engine/Cards/TwilightMarchesCards.swift
// ==========================================

import Foundation

// Twilight Marches (Сумрачные Пределы)
// Original Slavic dark fantasy card game
// NOTE: Heroes are now loaded from Content Pack (heroes.json) via HeroRegistry

struct TwilightMarchesCards {

    // MARK: - Enemies from Slavic Mythology

    static func createNavMonsters() -> [Card] {
        return [
            // Навий - Дух мертвого (Navii - Spirit of the Dead)
            Card(
                name: "tm.enemy.navii.name".localized,
                type: .monster,
                rarity: .common,
                description: "tm.enemy.navii.desc".localized,
                power: 3,
                defense: 2,
                health: 5,
                abilities: [
                    CardAbility(
                        name: "tm.ability.soul.touch".localized,
                        description: "tm.ability.soul.touch.desc".localized,
                        effect: .applyCurse(type: .weakness, duration: 2)
                    )
                ],
                traits: ["tm.trait.undead".localized, "tm.trait.spirit".localized, "tm.trait.nav".localized],
                damageType: .mental,
                balance: .dark,
                realm: .nav,
                expansionSet: "baseSet"
            ),

            // Упырь (Upyr - Vampire)
            Card(
                name: "tm.enemy.upyr.name".localized,
                type: .monster,
                rarity: .uncommon,
                description: "tm.enemy.upyr.desc".localized,
                power: 6,
                defense: 4,
                health: 8,
                abilities: [
                    CardAbility(
                        name: "tm.ability.blood.drain".localized,
                        description: "tm.ability.blood.drain.desc".localized,
                        effect: .damage(amount: 4, type: .mental)
                    ),
                    CardAbility(
                        name: "tm.ability.life.steal".localized,
                        description: "tm.ability.life.steal.desc".localized,
                        effect: .heal(amount: 2)
                    )
                ],
                traits: ["tm.trait.undead".localized, "tm.trait.upyr".localized, "tm.trait.nav".localized],
                damageType: .mental,
                balance: .dark,
                realm: .nav,
                expansionSet: "baseSet"
            ),

            // Леший (Leshiy - Forest Spirit)
            Card(
                name: "tm.enemy.leshiy.name".localized,
                type: .monster,
                rarity: .uncommon,
                description: "tm.enemy.leshiy.desc".localized,
                power: 5,
                defense: 6,
                health: 10,
                abilities: [
                    CardAbility(
                        name: "tm.ability.forest.maze".localized,
                        description: "tm.ability.forest.maze.desc".localized,
                        effect: .applyCurse(type: .exhaustion, duration: 3)
                    ),
                    CardAbility(
                        name: "tm.ability.natures.wrath".localized,
                        description: "tm.ability.natures.wrath.desc".localized,
                        effect: .damage(amount: 3, type: .physical)
                    )
                ],
                traits: ["tm.trait.spirit".localized, "tm.trait.nature".localized, "tm.trait.leshiy".localized],
                damageType: .physical,
                balance: .dark,
                realm: .yav,
                expansionSet: "baseSet"
            ),

            // Русалка (Rusalka - Water Spirit)
            Card(
                name: "tm.enemy.rusalka.name".localized,
                type: .monster,
                rarity: .rare,
                description: "tm.enemy.rusalka.desc".localized,
                power: 4,
                defense: 3,
                health: 7,
                abilities: [
                    CardAbility(
                        name: "tm.ability.drowning.song".localized,
                        description: "tm.ability.drowning.song.desc".localized,
                        effect: .applyCurse(type: .fear, duration: 2)
                    ),
                    CardAbility(
                        name: "tm.ability.water.grasp".localized,
                        description: "tm.ability.water.grasp.desc".localized,
                        effect: .damage(amount: 3, type: .cold)
                    )
                ],
                traits: ["tm.trait.spirit".localized, "tm.trait.water".localized, "tm.trait.rusalka".localized],
                damageType: .cold,
                balance: .dark,
                realm: .nav,
                expansionSet: "baseSet"
            ),

            // Змей Горыныч (Zmey Gorynych - Three-Headed Dragon)
            Card(
                name: "tm.enemy.zmey.name".localized,
                type: .monster,
                rarity: .legendary,
                description: "tm.enemy.zmey.desc".localized,
                power: 15,
                defense: 12,
                health: 30,
                abilities: [
                    CardAbility(
                        name: "tm.ability.three.breaths".localized,
                        description: "tm.ability.three.breaths.desc".localized,
                        effect: .damage(amount: 10, type: .fire)
                    ),
                    CardAbility(
                        name: "tm.ability.ancient.curse".localized,
                        description: "tm.ability.ancient.curse.desc".localized,
                        effect: .applyCurse(type: .shadowOfNav, duration: 5)
                    )
                ],
                traits: ["tm.trait.dragon".localized, "tm.trait.ancient".localized, "tm.trait.zmey".localized],
                damageType: .fire,
                balance: .dark,
                realm: .prav,
                expansionSet: "baseSet"
            )
        ]
    }

    // MARK: - Spirit Cards

    static func createSpirits() -> [Card] {
        return [
            // Домовой (Domovoy - House Spirit)
            Card(
                name: "tm.spirit.domovoy.name".localized,
                type: .spirit,
                rarity: .common,
                description: "tm.spirit.domovoy.desc".localized,
                power: 2,
                defense: 3,
                health: 5,
                cost: 2,
                abilities: [
                    CardAbility(
                        name: "tm.ability.home.guard".localized,
                        description: "tm.ability.home.guard.desc".localized,
                        effect: .addDice(count: 1)
                    )
                ],
                traits: ["tm.trait.spirit".localized, "tm.trait.guardian".localized, "tm.trait.light".localized],
                balance: .light,
                realm: .yav,
                expansionSet: "baseSet"
            ),

            // Берегиня (Bereginya - Protective Spirit)
            Card(
                name: "tm.spirit.bereginya.name".localized,
                type: .spirit,
                rarity: .uncommon,
                description: "tm.spirit.bereginya.desc".localized,
                power: 3,
                defense: 5,
                health: 8,
                cost: 3,
                abilities: [
                    CardAbility(
                        name: "tm.ability.protective.aura".localized,
                        description: "tm.ability.protective.aura.desc".localized,
                        effect: .removeCurse(type: nil)
                    ),
                    CardAbility(
                        name: "tm.ability.blessing.shield".localized,
                        description: "tm.ability.blessing.shield.desc".localized,
                        effect: .shiftBalance(towards: .light, amount: 2)
                    )
                ],
                traits: ["tm.trait.spirit".localized, "tm.trait.bereginya".localized, "tm.trait.light".localized],
                balance: .light,
                realm: .prav,
                expansionSet: "baseSet"
            )
        ]
    }

    // MARK: - Curse Cards

    static func createCurses() -> [Card] {
        return [
            // Черная метка (Black Mark)
            Card(
                name: "tm.curse.black.mark.name".localized,
                type: .curse,
                rarity: .common,
                description: "tm.curse.black.mark.desc".localized,
                cost: 0,
                abilities: [
                    CardAbility(
                        name: "tm.ability.mark.of.nav".localized,
                        description: "tm.ability.mark.of.nav.desc".localized,
                        effect: .applyCurse(type: .weakness, duration: 3)
                    )
                ],
                traits: ["tm.trait.curse".localized, "tm.trait.nav".localized],
                balance: .dark,
                realm: .nav,
                curseType: .weakness,
                expansionSet: "baseSet"
            ),

            // Безумие (Madness)
            Card(
                name: "tm.curse.madness.name".localized,
                type: .curse,
                rarity: .uncommon,
                description: "tm.curse.madness.desc".localized,
                cost: 0,
                abilities: [
                    CardAbility(
                        name: "tm.ability.lose.sanity".localized,
                        description: "tm.ability.lose.sanity.desc".localized,
                        effect: .applyCurse(type: .fear, duration: 4)
                    )
                ],
                traits: ["tm.trait.curse".localized, "tm.trait.mental".localized],
                balance: .dark,
                realm: .nav,
                curseType: .fear,
                expansionSet: "baseSet"
            )
        ]
    }

    // MARK: - Artifact Cards

    static func createArtifacts() -> [Card] {
        return [
            // Калинов Меч (Kalinov Sword - Legendary Blade)
            Card(
                name: "tm.artifact.kalinov.sword.name".localized,
                type: .artifact,
                rarity: .legendary,
                description: "tm.artifact.kalinov.sword.desc".localized,
                power: 10,
                cost: 5,
                abilities: [
                    CardAbility(
                        name: "tm.ability.cleaving.strike".localized,
                        description: "tm.ability.cleaving.strike.desc".localized,
                        effect: .damage(amount: 8, type: .physical)
                    ),
                    CardAbility(
                        name: "tm.ability.banish.darkness".localized,
                        description: "tm.ability.banish.darkness.desc".localized,
                        effect: .shiftBalance(towards: .light, amount: 3)
                    )
                ],
                traits: ["tm.trait.artifact".localized, "tm.trait.weapon".localized, "tm.trait.legendary".localized],
                damageType: .physical,
                balance: .light,
                realm: .prav,
                expansionSet: "baseSet"
            ),

            // Алатырь-камень (Alatyr Stone - Sacred Stone)
            Card(
                name: "tm.artifact.alatyr.stone.name".localized,
                type: .artifact,
                rarity: .epic,
                description: "tm.artifact.alatyr.stone.desc".localized,
                defense: 5,
                cost: 4,
                abilities: [
                    CardAbility(
                        name: "tm.ability.realm.anchor".localized,
                        description: "tm.ability.realm.anchor.desc".localized,
                        effect: .travelRealm(to: .yav)
                    ),
                    CardAbility(
                        name: "tm.ability.restore.balance".localized,
                        description: "tm.ability.restore.balance.desc".localized,
                        effect: .shiftBalance(towards: .neutral, amount: 5)
                    )
                ],
                traits: ["tm.trait.artifact".localized, "tm.trait.sacred".localized, "tm.trait.ancient".localized],
                balance: .neutral,
                realm: .prav,
                expansionSet: "baseSet"
            )
        ]
    }

    // MARK: - Encounter Deck
    // NOTE: Starting decks are now loaded from CardRegistry (data-driven)

    static func createEncounterDeck() -> [Card] {
        var deck: [Card] = []

        let monsters = createNavMonsters()
        let curses = createCurses()

        deck.append(contentsOf: monsters)
        deck.append(contentsOf: monsters)  // Add duplicates
        deck.append(contentsOf: curses)
        deck.append(contentsOf: curses)
        deck.append(contentsOf: curses)  // More curses

        return deck
    }

    // MARK: - Card Registry (for event rewards)

    /// Returns a card by its string ID used in events and quests
    static func getCardByID(_ cardID: String) -> Card? {
        // Create a dictionary mapping card IDs to cards
        let rewardCards = createRewardCards()
        let artifactCards = createArtifactCards()

        // Map cards by their names or custom IDs
        let cardMapping: [String: Card] = [
            // Reward cards from events
            "dark_power_card": rewardCards[0],     // Темная Сила
            "ancient_blessing": rewardCards[1],    // Древнее Благословение
            "merchant_blessing": rewardCards[2],   // Благословение Торговца
            "witch_knowledge": rewardCards[3],     // Знание Ведьмы
            "dark_pact": rewardCards[4],           // Темный Пакт
            "ancestral_blessing": rewardCards[5],  // Благословение Предков
            "realm_power": rewardCards[6],         // Сила Реальности
            "nav_essence": rewardCards[7],         // Эссенция Нави
            "village_gratitude": rewardCards[8],   // Благодарность Деревни
            "merchant_discount": rewardCards[9],   // Торговая Скидка
            "trade_blessing": rewardCards[10],     // Благословение Торговли
            "warrior_spirit": rewardCards[11],     // Дух Воина
            "inner_peace": rewardCards[12],        // Внутренний Покой
            "spiritual_armor": rewardCards[13],    // Духовная Броня
            "mountain_blessing": rewardCards[14],  // Благословение Гор
            "stone_armor": rewardCards[15],        // Каменная Броня
            "defender_blessing": rewardCards[16],  // Благословение Защитника (from reward cards)
            "anchor_power": rewardCards[17],       // Сила Якоря (from reward cards)

            // Artifact cards (legendary items from quests and boss)
            "guardian_seal": artifactCards[0],     // Печать Защитника
            "ancient_relic": artifactCards[1],     // Древняя Реликвия
            "corrupted_power": artifactCards[2]    // Развращённая Сила
        ]

        return cardMapping[cardID]
    }

    // MARK: - Event and Quest Reward Cards

    static func createRewardCards() -> [Card] {
        return [
            // 1. Dark Power Card - from desecrating shrine ritual
            Card(
                id: UUID(),
                name: "Темная Сила",
                type: .special,
                rarity: .rare,
                description: "Сила, полученная осквернением святилища. Мощная, но опасная.",
                cost: 3,
                abilities: [
                    CardAbility(
                        name: "Темная Мощь",
                        description: "Наносит 6 урона и восстанавливает 2 веры.",
                        effect: .damage(amount: 6, type: .arcane)
                    ),
                    CardAbility(
                        name: "Цена Силы",
                        description: "Сдвигает баланс к тьме.",
                        effect: .shiftBalance(towards: .dark, amount: 5)
                    )
                ],
                balance: .dark,
                realm: .nav
            ),

            // 2. Ancient Blessing - from wanderer event
            Card(
                id: UUID(),
                name: "Древнее Благословение",
                type: .special,
                rarity: .uncommon,
                description: "Древняя реликвия, найденная в путешествии.",
                cost: 4,
                abilities: [
                    CardAbility(
                        name: "Дар Предков",
                        description: "Восстанавливает 4 здоровья и даёт 2 веры.",
                        effect: .heal(amount: 4)
                    )
                ],
                balance: .light,
                realm: .yav
            ),

            // 3. Merchant Blessing - from trader event
            Card(
                id: UUID(),
                name: "Благословение Торговца",
                type: .resource,
                rarity: .common,
                description: "Талисман удачи от благодарного торговца.",
                cost: 2,
                abilities: [
                    CardAbility(
                        name: "Торговая Удача",
                        description: "Даёт 3 веры и восстанавливает 2 здоровья.",
                        effect: .gainFaith(amount: 3)
                    )
                ],
                balance: .neutral,
                realm: .yav
            ),

            // 4. Witch Knowledge - from witch event and quest
            Card(
                id: UUID(),
                name: "Знание Ведьмы",
                type: .special,
                rarity: .rare,
                description: "Тайные знания болотной ведьмы. Могущественны, но опасны.",
                cost: 4,
                abilities: [
                    CardAbility(
                        name: "Темная Мудрость",
                        description: "Берёте 3 карты.",
                        effect: .drawCards(count: 3)
                    ),
                    CardAbility(
                        name: "Цена Знания",
                        description: "Сдвигает баланс к тьме.",
                        effect: .shiftBalance(towards: .dark, amount: 3)
                    )
                ],
                balance: .dark,
                realm: .nav
            ),

            // 5. Dark Pact - from witch event
            Card(
                id: UUID(),
                name: "Темный Пакт",
                type: .curse,
                rarity: .rare,
                description: "Пакт с тёмными силами. Даёт мощь ценой души.",
                cost: 5,
                abilities: [
                    CardAbility(
                        name: "Сила Пакта",
                        description: "Даёт 5 веры и наносит 7 урона врагу.",
                        effect: .damage(amount: 7, type: .arcane)
                    ),
                    CardAbility(
                        name: "Проклятие Пакта",
                        description: "Накладывает слабость на 2 хода.",
                        effect: .applyCurse(type: .weakness, duration: 2)
                    )
                ],
                balance: .dark,
                realm: .nav,
                curseType: .weakness
            ),

            // 6. Ancestral Blessing - from multiple events/quests
            Card(
                id: UUID(),
                name: "Благословение Предков",
                type: .special,
                rarity: .rare,
                description: "Благословение духов предков. Защищает и направляет.",
                cost: 4,
                abilities: [
                    CardAbility(
                        name: "Защита Предков",
                        description: "Блокирует 6 урона и снимает одно проклятие.",
                        effect: .removeCurse(type: nil)
                    ),
                    CardAbility(
                        name: "Свет Предков",
                        description: "Сдвигает баланс к свету.",
                        effect: .shiftBalance(towards: .light, amount: 5)
                    )
                ],
                balance: .light,
                realm: .prav
            ),

            // 7. Realm Power - from realm shift event
            Card(
                id: UUID(),
                name: "Сила Реальности",
                type: .special,
                rarity: .epic,
                description: "Необработанная сила границы миров. Непредсказуема и опасна.",
                cost: 6,
                abilities: [
                    CardAbility(
                        name: "Разлом Реальности",
                        description: "Наносит 10 урона всем врагам.",
                        effect: .damage(amount: 10, type: .arcane)
                    ),
                    CardAbility(
                        name: "Искажение",
                        description: "Случайный эффект на баланс.",
                        effect: .shiftBalance(towards: .dark, amount: 10)
                    )
                ],
                balance: .dark,
                realm: .nav
            ),

            // 8. Nav Essence - from realm shift event
            Card(
                id: UUID(),
                name: "Эссенция Нави",
                type: .resource,
                rarity: .rare,
                description: "Чистая эссенция мира мёртвых. Источник тёмной силы.",
                cost: 3,
                abilities: [
                    CardAbility(
                        name: "Сила Нави",
                        description: "Даёт 5 веры.",
                        effect: .gainFaith(amount: 5)
                    ),
                    CardAbility(
                        name: "Развращение",
                        description: "Сдвигает баланс к тьме на 8.",
                        effect: .shiftBalance(towards: .dark, amount: 8)
                    )
                ],
                balance: .dark,
                realm: .nav
            ),

            // 9. Village Gratitude - from lost child quest
            Card(
                id: UUID(),
                name: "Благодарность Деревни",
                type: .special,
                rarity: .uncommon,
                description: "Жители деревни благодарны за спасение ребёнка.",
                cost: 2,
                abilities: [
                    CardAbility(
                        name: "Дар Общины",
                        description: "Восстанавливает 5 здоровья и даёт 3 веры.",
                        effect: .heal(amount: 5)
                    ),
                    CardAbility(
                        name: "Добрая Воля",
                        description: "Сдвигает баланс к свету.",
                        effect: .shiftBalance(towards: .light, amount: 3)
                    )
                ],
                balance: .light,
                realm: .yav
            ),

            // 10. Merchant Discount - from trade routes quest
            Card(
                id: UUID(),
                name: "Торговая Скидка",
                type: .resource,
                rarity: .common,
                description: "Особая скидка от торговцев за защиту путей.",
                cost: 1,
                abilities: [
                    CardAbility(
                        name: "Выгодная Сделка",
                        description: "Следующая карта стоит на 2 веры меньше.",
                        effect: .gainFaith(amount: 2)
                    )
                ],
                balance: .neutral,
                realm: .yav
            ),

            // 11. Trade Blessing - from trade routes quest
            Card(
                id: UUID(),
                name: "Благословение Торговли",
                type: .special,
                rarity: .uncommon,
                description: "Благословение купеческой гильдии.",
                cost: 3,
                abilities: [
                    CardAbility(
                        name: "Процветание",
                        description: "Даёт 4 веры и берёте 2 карты.",
                        effect: .gainFaith(amount: 4)
                    )
                ],
                balance: .neutral,
                realm: .yav
            ),

            // 12. Warrior Spirit - from barrow quest
            Card(
                id: UUID(),
                name: "Дух Воина",
                type: .spirit,
                rarity: .rare,
                description: "Дух древнего воина, освобождённый из кургана.",
                power: 6,
                defense: 4,
                health: 8,
                cost: 4,
                abilities: [
                    CardAbility(
                        name: "Воинская Доблесть",
                        description: "Наносит 6 урона и получает +2 к защите.",
                        effect: .damage(amount: 6, type: .physical)
                    )
                ],
                balance: .neutral,
                realm: .yav
            ),

            // 13. Inner Peace - from monk quest
            Card(
                id: UUID(),
                name: "Внутренний Покой",
                type: .special,
                rarity: .rare,
                description: "Состояние духовного равновесия, дарованное монахом.",
                cost: 3,
                abilities: [
                    CardAbility(
                        name: "Просветление",
                        description: "Восстанавливает 6 здоровья и снимает все проклятия.",
                        effect: .heal(amount: 6)
                    ),
                    CardAbility(
                        name: "Баланс Духа",
                        description: "Восстанавливает баланс к нейтральному.",
                        effect: .shiftBalance(towards: .neutral, amount: 10)
                    )
                ],
                balance: .light,
                realm: .prav
            ),

            // 14. Spiritual Armor - from monk quest
            Card(
                id: UUID(),
                name: "Духовная Броня",
                type: .defense,
                rarity: .rare,
                description: "Незримая защита духа и тела.",
                defense: 8,
                cost: 4,
                abilities: [
                    CardAbility(
                        name: "Защита Духа",
                        description: "Блокирует 8 урона и предотвращает проклятия.",
                        effect: .removeCurse(type: nil)
                    )
                ],
                balance: .light,
                realm: .prav
            ),

            // 15. Mountain Blessing - from mountain spirit quest
            Card(
                id: UUID(),
                name: "Благословение Гор",
                type: .special,
                rarity: .uncommon,
                description: "Благословение горного духа. Даёт силу и стойкость.",
                cost: 3,
                abilities: [
                    CardAbility(
                        name: "Сила Гор",
                        description: "Наносит 5 урона и восстанавливает 3 здоровья.",
                        effect: .damage(amount: 5, type: .physical)
                    )
                ],
                balance: .neutral,
                realm: .yav
            ),

            // 16. Stone Armor - from mountain spirit quest
            Card(
                id: UUID(),
                name: "Каменная Броня",
                type: .defense,
                rarity: .uncommon,
                description: "Магическая броня из камня горного духа.",
                defense: 6,
                cost: 3,
                abilities: [
                    CardAbility(
                        name: "Несокрушимость",
                        description: "Блокирует 6 урона. Не может быть разрушена эффектами.",
                        effect: .shiftBalance(towards: .neutral, amount: 0)
                    )
                ],
                balance: .neutral,
                realm: .yav
            ),

            // 17. Defender Blessing - from main quest
            Card(
                id: UUID(),
                name: "Благословение Защитника",
                type: .special,
                rarity: .legendary,
                description: "Величайшее благословение за защиту мира от Нави.",
                cost: 5,
                abilities: [
                    CardAbility(
                        name: "Защитник Миров",
                        description: "Восстанавливает 10 здоровья, даёт 5 веры, берёте 2 карты.",
                        effect: .heal(amount: 10)
                    ),
                    CardAbility(
                        name: "Сила Света",
                        description: "Сильно сдвигает баланс к свету.",
                        effect: .shiftBalance(towards: .light, amount: 15)
                    )
                ],
                balance: .light,
                realm: .prav
            ),

            // 18. Anchor Power - from main quest
            Card(
                id: UUID(),
                name: "Сила Якоря",
                type: .artifact,
                rarity: .legendary,
                description: "Сила священных якорей, держащих границу миров.",
                power: 8,
                defense: 8,
                cost: 6,
                abilities: [
                    CardAbility(
                        name: "Якорь Реальности",
                        description: "Наносит 12 урона существам Нави. Восстанавливает якорь региона.",
                        effect: .damage(amount: 12, type: .arcane)
                    ),
                    CardAbility(
                        name: "Стабилизация",
                        description: "Снимает все проклятия и сдвигает баланс к свету.",
                        effect: .removeCurse(type: nil)
                    )
                ],
                balance: .light,
                realm: .prav
            )
        ]
    }

    // MARK: - Boss Cards

    /// Creates the final boss for Act I: Леший-Хранитель (Leshy-Guardian)
    /// This boss is encountered in the Чёрная Низина (Black Lowlands) as the final challenge
    static func createLeshyGuardianBoss() -> Card {
        return Card(
            id: UUID(),
            name: "Леший-Хранитель",
            type: .monster,
            rarity: .legendary,
            description: "Древний страж Сумрачных Пределов. Его сила неимоверна, корни уходят глубоко в землю, а глаза горят зелёным пламенем вечности.",
            power: 6,
            defense: 12,
            health: 25,
            cost: nil,
            abilities: [
                CardAbility(
                    name: "Регенерация",
                    description: "Восстанавливает 2 здоровья в начале каждого хода.",
                    effect: .heal(amount: 2)
                ),
                CardAbility(
                    name: "Удар Корнями",
                    description: "Наносит 8 урона и оглушает противника.",
                    effect: .damage(amount: 8, type: .physical)
                ),
                CardAbility(
                    name: "Гнев Природы",
                    description: "Призывает духов леса, наносящих 4 урона.",
                    effect: .damage(amount: 4, type: .physical)
                )
            ],
            balance: .neutral,
            realm: .nav
        )
    }

    // MARK: - Artifact Cards

    /// Creates legendary artifact cards - powerful unique items from quests
    static func createArtifactCards() -> [Card] {
        return [
            // 1. Guardian Seal - main quest reward, peaceful boss resolution
            Card(
                id: UUID(),
                name: "Печать Защитника",
                type: .special,
                rarity: .legendary,
                description: "Древняя печать, дарованная Лешим-Хранителем. Символизует союз с силами природы.",
                cost: 3,
                abilities: [
                    CardAbility(
                        name: "Защита Якоря",
                        description: "Восстанавливает целостность якоря на 25 пунктов.",
                        effect: .heal(amount: 10)
                    ),
                    CardAbility(
                        name: "Благословение Хранителя",
                        description: "Снижает напряжение мира на 10 пунктов.",
                        effect: .gainFaith(amount: 8)
                    ),
                    CardAbility(
                        name: "Связь с Природой",
                        description: "Сдвигает баланс к свету.",
                        effect: .shiftBalance(towards: .light, amount: 10)
                    )
                ],
                balance: .light,
                realm: .prav
            ),

            // 2. Ancient Relic - powerful neutral artifact
            Card(
                id: UUID(),
                name: "Древняя Реликвия",
                type: .special,
                rarity: .legendary,
                description: "Таинственный артефакт из времён до разделения миров. Пульсирует неизвестной силой.",
                cost: 4,
                abilities: [
                    CardAbility(
                        name: "Власть над Реальностью",
                        description: "Наносит 10 урона врагу или восстанавливает 10 здоровья.",
                        effect: .damage(amount: 10, type: .arcane)
                    ),
                    CardAbility(
                        name: "Временной Резонанс",
                        description: "Позволяет разыграть дополнительную карту.",
                        effect: .gainFaith(amount: 5)
                    )
                ],
                balance: .neutral,
                realm: .prav
            ),

            // 3. Corrupted Power - dark path from boss
            Card(
                id: UUID(),
                name: "Развращённая Сила",
                type: .special,
                rarity: .legendary,
                description: "Частица сущности Хранителя, искажённая тёмной магией. Могущественна, но опасна.",
                cost: 2,
                abilities: [
                    CardAbility(
                        name: "Пожирание Жизни",
                        description: "Наносит 12 урона врагу, но отнимает 3 здоровья у вас.",
                        effect: .damage(amount: 12, type: .arcane)
                    ),
                    CardAbility(
                        name: "Тёмное Влияние",
                        description: "Сильно сдвигает баланс к тьме.",
                        effect: .shiftBalance(towards: .dark, amount: 15)
                    )
                ],
                balance: .dark,
                realm: .nav
            )
        ]
    }

    // MARK: - Market Cards (for purchase during game)

    static func createMarketCards() -> [Card] {
        return [
            // Common Resource cards (cost 2 faith, give 2 faith when played)
            Card(name: "Молитва", type: .resource, rarity: .common,
                 description: "Молитва богам. Дает 2 веры.",
                 cost: 2, abilities: [], balance: .light, realm: .prav),
            Card(name: "Молитва", type: .resource, rarity: .common,
                 description: "Молитва богам. Дает 2 веры.",
                 cost: 2, abilities: [], balance: .light, realm: .prav),

            // Uncommon Resource cards (cost 4, give 3 faith)
            Card(name: "Древний Ритуал", type: .resource, rarity: .uncommon,
                 description: "Древний ритуал призыва силы. Дает 3 веры.",
                 cost: 4, abilities: [], balance: .neutral, realm: .prav),

            // Common Attack cards (cost 3, deal 4 damage)
            Card(name: "Меч Света", type: .attack, rarity: .common,
                 description: "Светлый меч. Наносит 4 урона.",
                 power: 4, cost: 3, abilities: [], balance: .light, realm: .yav),
            Card(name: "Меч Света", type: .attack, rarity: .common,
                 description: "Светлый меч. Наносит 4 урона.",
                 power: 4, cost: 3, abilities: [], balance: .light, realm: .yav),

            // Uncommon Attack cards (cost 5, deal 6 damage)
            Card(name: "Огненный Шар", type: .attack, rarity: .uncommon,
                 description: "Мощный огненный шар. Наносит 6 урона.",
                 power: 6, cost: 5, abilities: [], damageType: .fire, balance: .neutral, realm: .yav),

            // Rare Attack cards (cost 7, deal 8 damage + effect)
            Card(name: "Божественный Удар", type: .attack, rarity: .rare,
                 description: "Удар божественной силы. Наносит 8 урона и восстанавливает 2 здоровья.",
                 power: 8, cost: 7, abilities: [
                     CardAbility(name: "Исцеление", description: "Восстанавливает 2 здоровья.", effect: .heal(amount: 2))
                 ], balance: .light, realm: .prav),

            // Common Defense cards (cost 2, block 3 damage)
            Card(name: "Щит Веры", type: .defense, rarity: .common,
                 description: "Защитный щит. Блокирует 3 урона.",
                 defense: 3, cost: 2, abilities: [], balance: .light, realm: .yav),
            Card(name: "Щит Веры", type: .defense, rarity: .common,
                 description: "Защитный щит. Блокирует 3 урона.",
                 defense: 3, cost: 2, abilities: [], balance: .light, realm: .yav),

            // Uncommon Defense cards (cost 4, block 5 damage)
            Card(name: "Каменная Кожа", type: .defense, rarity: .uncommon,
                 description: "Магическая защита. Блокирует 5 урона.",
                 defense: 5, cost: 4, abilities: [], balance: .neutral, realm: .yav),

            // Common Special cards (cost 3, draw 2 cards)
            Card(name: "Прозрение", type: .special, rarity: .common,
                 description: "Видение будущего. Берете 2 карты.",
                 cost: 3, abilities: [
                     CardAbility(name: "Карты", description: "Берете 2 карты.", effect: .drawCards(count: 2))
                 ], balance: .light, realm: .prav),

            // Uncommon Special cards (cost 5, heal 5 health)
            Card(name: "Великое Исцеление", type: .special, rarity: .uncommon,
                 description: "Мощное целебное заклинание. Восстанавливает 5 здоровья.",
                 cost: 5, abilities: [
                     CardAbility(name: "Исцеление", description: "Восстанавливает 5 здоровья.", effect: .heal(amount: 5))
                 ], balance: .light, realm: .prav),

            // Rare Special cards (cost 6, powerful effects)
            Card(name: "Перерождение", type: .special, rarity: .rare,
                 description: "Древнее заклинание перерождения. Восстанавливает 7 здоровья и дает 2 веры.",
                 cost: 6, abilities: [
                     CardAbility(name: "Перерождение", description: "Восстанавливает 7 здоровья.", effect: .heal(amount: 7)),
                     CardAbility(name: "Сила", description: "Дает 2 веры.", effect: .gainFaith(amount: 2))
                 ], balance: .light, realm: .prav),

            // Legendary cards (cost 10, extremely powerful)
            Card(name: "Дар Богов", type: .special, rarity: .legendary,
                 description: "Величайший дар от богов. Берете 3 карты, восстанавливаете 5 здоровья, получаете 3 веры.",
                 cost: 10, abilities: [
                     CardAbility(name: "Дар", description: "Берете 3 карты.", effect: .drawCards(count: 3)),
                     CardAbility(name: "Исцеление", description: "Восстанавливаете 5 здоровья.", effect: .heal(amount: 5)),
                     CardAbility(name: "Сила", description: "Получаете 3 веры.", effect: .gainFaith(amount: 3))
                 ], balance: .light, realm: .prav)
        ]
    }
}


// ==========================================
// FILE: Engine/Runtime/EventRuntimeState.swift
// ==========================================

import Foundation

// MARK: - Event Runtime State
// Reference: Docs/EVENT_MODULE_ARCHITECTURE.md, Section 5
// Reference: Docs/MIGRATION_PLAN.md, Feature A2

/// Mutable runtime state for the event system.
/// Tracks which events have been completed, cooldowns, etc.
struct EventRuntimeState: Codable, Equatable {
    // MARK: - Completion Tracking

    /// Set of completed one-time event IDs
    var completedOneTimeEvents: Set<String>

    /// Count of times each event has occurred
    var eventOccurrenceCount: [String: Int]

    // MARK: - Cooldowns

    /// Cooldown remaining for each event (turns until available)
    var eventCooldowns: [String: Int]

    // MARK: - Current Event

    /// Currently active event ID (nil if no event active)
    var activeEventId: String?

    /// Currently active mini-game challenge (nil if no mini-game active)
    var activeMiniGameId: String?

    // MARK: - Selection State

    /// Last used random seed for deterministic replay
    var lastSelectionSeed: UInt64

    // MARK: - Initialization

    init(
        completedOneTimeEvents: Set<String> = [],
        eventOccurrenceCount: [String: Int] = [:],
        eventCooldowns: [String: Int] = [:],
        activeEventId: String? = nil,
        activeMiniGameId: String? = nil,
        lastSelectionSeed: UInt64 = 0
    ) {
        self.completedOneTimeEvents = completedOneTimeEvents
        self.eventOccurrenceCount = eventOccurrenceCount
        self.eventCooldowns = eventCooldowns
        self.activeEventId = activeEventId
        self.activeMiniGameId = activeMiniGameId
        self.lastSelectionSeed = lastSelectionSeed
    }

    // MARK: - Completion Operations

    /// Mark an event as completed
    mutating func markCompleted(_ eventId: String, isOneTime: Bool) {
        eventOccurrenceCount[eventId, default: 0] += 1
        if isOneTime {
            completedOneTimeEvents.insert(eventId)
        }
    }

    /// Check if a one-time event is completed
    func isOneTimeCompleted(_ eventId: String) -> Bool {
        return completedOneTimeEvents.contains(eventId)
    }

    /// Get occurrence count for an event
    func occurrenceCount(for eventId: String) -> Int {
        return eventOccurrenceCount[eventId] ?? 0
    }

    // MARK: - Cooldown Operations

    /// Set cooldown for an event
    mutating func setCooldown(_ eventId: String, turns: Int) {
        if turns > 0 {
            eventCooldowns[eventId] = turns
        }
    }

    /// Check if event is on cooldown
    func isOnCooldown(_ eventId: String) -> Bool {
        return (eventCooldowns[eventId] ?? 0) > 0
    }

    /// Tick all cooldowns (call each turn)
    mutating func tickCooldowns() {
        for (eventId, remaining) in eventCooldowns {
            if remaining > 1 {
                eventCooldowns[eventId] = remaining - 1
            } else {
                eventCooldowns.removeValue(forKey: eventId)
            }
        }
    }

    // MARK: - Active Event Operations

    /// Start an event
    mutating func startEvent(_ eventId: String) {
        activeEventId = eventId
    }

    /// End the current event
    mutating func endEvent() {
        activeEventId = nil
        activeMiniGameId = nil
    }

    /// Start a mini-game within current event
    mutating func startMiniGame(_ challengeId: String) {
        activeMiniGameId = challengeId
    }

    /// End the current mini-game
    mutating func endMiniGame() {
        activeMiniGameId = nil
    }
}


// ==========================================
// FILE: Engine/Runtime/GameRuntimeState.swift
// ==========================================

import Foundation

// MARK: - Game Runtime State
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.2
// Reference: Docs/MIGRATION_PLAN.md, Feature A2

/// Combined runtime state for the entire game.
/// This is the single source of truth for game state.
/// All changes go through GameEngine.performAction().
struct GameRuntimeState: Codable, Equatable {
    // MARK: - Component States

    /// World state (regions, anchors, flags, pressure, time)
    var world: WorldRuntimeState

    /// Player state (resources, deck, balance, curses)
    var player: PlayerRuntimeState

    /// Event state (completion tracking, cooldowns)
    var events: EventRuntimeState

    /// Quest state (progress, completion)
    var quests: QuestRuntimeState

    // MARK: - Game Meta

    /// Current game phase
    var phase: EngineGamePhase

    /// Random seed for this playthrough
    let playthroughSeed: UInt64

    /// Save slot identifier
    var saveSlot: Int?

    // MARK: - Initialization

    init(
        world: WorldRuntimeState,
        player: PlayerRuntimeState,
        events: EventRuntimeState = EventRuntimeState(),
        quests: QuestRuntimeState = QuestRuntimeState(),
        phase: EngineGamePhase = .playing,
        playthroughSeed: UInt64 = 0,
        saveSlot: Int? = nil
    ) {
        self.world = world
        self.player = player
        self.events = events
        self.quests = quests
        self.phase = phase
        self.playthroughSeed = playthroughSeed
        self.saveSlot = saveSlot
    }

    // MARK: - Convenience Accessors

    /// Current region ID
    var currentRegionId: String {
        return world.currentRegionId
    }

    /// Current time (days)
    var currentTime: Int {
        return world.currentTime
    }

    /// Current pressure
    var currentPressure: Int {
        return world.pressure
    }

    /// Check game over conditions
    var isGameOver: Bool {
        // Pressure maximum
        if world.isPressureMaximum {
            return true
        }
        // Player death (health <= 0)
        if player.getResource("health") <= 0 {
            return true
        }
        return false
    }

    /// Get combined flags (world + player)
    func getAllFlags() -> Set<String> {
        var allFlags = Set<String>()
        for (key, value) in world.flags where value {
            allFlags.insert(key)
        }
        for (key, value) in player.flags where value {
            allFlags.insert(key)
        }
        return allFlags
    }
}

// MARK: - Factory Methods

extension GameRuntimeState {
    /// Create a new game state with default values
    static func newGame(
        startingRegionId: String,
        startingResources: [String: Int],
        startingDeck: [String],
        seed: UInt64? = nil
    ) -> GameRuntimeState {
        let actualSeed = seed ?? UInt64.random(in: 0...UInt64.max)

        let world = WorldRuntimeState(
            currentRegionId: startingRegionId,
            currentTime: 0,
            pressure: 0
        )

        let player = PlayerRuntimeState(
            resources: startingResources,
            balance: 0,
            drawPile: startingDeck
        )

        return GameRuntimeState(
            world: world,
            player: player,
            playthroughSeed: actualSeed
        )
    }
}

// MARK: - Snapshot for Regression Testing

extension GameRuntimeState {
    /// Create a snapshot for comparison
    struct Snapshot: Equatable {
        let pressure: Int
        let time: Int
        let health: Int
        let faith: Int
        let balance: Int
        let currentRegionId: String
        let visitedRegionsCount: Int
        let completedEventsCount: Int
        let activeQuestsCount: Int
        let deckSize: Int
        let flagCount: Int
    }

    /// Generate snapshot for testing
    func snapshot() -> Snapshot {
        let visitedCount = world.regionsState.values.filter { $0.visitCount > 0 }.count

        return Snapshot(
            pressure: world.pressure,
            time: world.currentTime,
            health: player.getResource("health"),
            faith: player.getResource("faith"),
            balance: player.balance,
            currentRegionId: world.currentRegionId,
            visitedRegionsCount: visitedCount,
            completedEventsCount: events.completedOneTimeEvents.count,
            activeQuestsCount: quests.activeQuests.count,
            deckSize: player.totalCardCount,
            flagCount: getAllFlags().count
        )
    }
}


// ==========================================
// FILE: Engine/Runtime/PlayerRuntimeState.swift
// ==========================================

import Foundation

// MARK: - Player Runtime State
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.2
// Reference: Docs/MIGRATION_PLAN.md, Feature A2

/// Mutable runtime state of the player.
/// Tracks resources, deck, balance, curses, etc.
struct PlayerRuntimeState: Codable, Equatable {
    // MARK: - Resources

    /// Player resources (health, faith, etc.)
    var resources: [String: Int]

    // MARK: - Balance/Path

    /// Balance between Nav and Prav (-100 to +100)
    /// Negative = Nav (chaos), Positive = Prav (order)
    var balance: Int

    // MARK: - Deck State

    /// Cards in draw pile (by card ID)
    var drawPile: [String]

    /// Cards in hand
    var hand: [String]

    /// Cards in discard pile
    var discardPile: [String]

    /// Cards in exile (removed from game)
    var exilePile: [String]

    // MARK: - Curses

    /// Active curse IDs
    var activeCurses: Set<String>

    // MARK: - Player Flags

    /// Player-specific flags
    var flags: [String: Bool]

    // MARK: - Initialization

    init(
        resources: [String: Int] = [:],
        balance: Int = 0,
        drawPile: [String] = [],
        hand: [String] = [],
        discardPile: [String] = [],
        exilePile: [String] = [],
        activeCurses: Set<String> = [],
        flags: [String: Bool] = [:]
    ) {
        self.resources = resources
        self.balance = balance
        self.drawPile = drawPile
        self.hand = hand
        self.discardPile = discardPile
        self.exilePile = exilePile
        self.activeCurses = activeCurses
        self.flags = flags
    }

    // MARK: - Resource Operations

    /// Get resource value (0 if not set)
    func getResource(_ resourceId: String) -> Int {
        return resources[resourceId] ?? 0
    }

    /// Set resource value
    mutating func setResource(_ resourceId: String, value: Int) {
        resources[resourceId] = value
    }

    /// Modify resource by delta
    mutating func modifyResource(_ resourceId: String, by delta: Int) {
        resources[resourceId] = (resources[resourceId] ?? 0) + delta
    }

    /// Check if player can afford a cost
    func canAfford(_ costs: [String: Int]) -> Bool {
        for (resourceId, cost) in costs {
            if getResource(resourceId) < cost {
                return false
            }
        }
        return true
    }

    // MARK: - Balance Operations

    /// Shift balance (clamped to -100...100)
    mutating func shiftBalance(by delta: Int) {
        balance = max(-100, min(100, balance + delta))
    }

    /// Check if balance is within range
    func isBalanceInRange(_ range: ClosedRange<Int>) -> Bool {
        return range.contains(balance)
    }

    /// Balance alignment
    var alignment: BalanceAlignment {
        if balance < -30 {
            return .nav
        } else if balance > 30 {
            return .prav
        } else {
            return .neutral
        }
    }

    // MARK: - Deck Operations

    /// Total cards in deck (all zones)
    var totalCardCount: Int {
        return drawPile.count + hand.count + discardPile.count + exilePile.count
    }

    /// Add card to draw pile
    mutating func addCardToDrawPile(_ cardId: String) {
        drawPile.append(cardId)
    }

    /// Add card to discard pile
    mutating func addCardToDiscard(_ cardId: String) {
        discardPile.append(cardId)
    }

    /// Move card from hand to discard
    mutating func discardFromHand(_ cardId: String) -> Bool {
        if let index = hand.firstIndex(of: cardId) {
            hand.remove(at: index)
            discardPile.append(cardId)
            return true
        }
        return false
    }

    /// Exile a card (remove from game)
    mutating func exileCard(_ cardId: String, from zone: DeckZone) -> Bool {
        switch zone {
        case .draw:
            if let index = drawPile.firstIndex(of: cardId) {
                drawPile.remove(at: index)
                exilePile.append(cardId)
                return true
            }
        case .hand:
            if let index = hand.firstIndex(of: cardId) {
                hand.remove(at: index)
                exilePile.append(cardId)
                return true
            }
        case .discard:
            if let index = discardPile.firstIndex(of: cardId) {
                discardPile.remove(at: index)
                exilePile.append(cardId)
                return true
            }
        case .exile:
            return false // Already exiled
        }
        return false
    }

    /// Shuffle discard into draw pile
    /// Uses deterministic RNG for reproducibility
    mutating func shuffleDiscardIntoDraw() {
        drawPile.append(contentsOf: discardPile)
        discardPile.removeAll()
        WorldRNG.shared.shuffle(&drawPile)
    }

    // MARK: - Curse Operations

    /// Add a curse
    mutating func addCurse(_ curseId: String) {
        activeCurses.insert(curseId)
    }

    /// Remove a curse
    mutating func removeCurse(_ curseId: String) {
        activeCurses.remove(curseId)
    }

    /// Check if player has a curse
    func hasCurse(_ curseId: String) -> Bool {
        return activeCurses.contains(curseId)
    }
}

// MARK: - Supporting Types

/// Deck zones
enum DeckZone: String, Codable, Hashable {
    case draw
    case hand
    case discard
    case exile
}

/// Balance alignment
enum BalanceAlignment: String, Codable, Hashable {
    case nav      // Chaos side
    case neutral
    case prav     // Order side
}


// ==========================================
// FILE: Engine/Runtime/QuestRuntimeState.swift
// ==========================================

import Foundation

// MARK: - Quest Runtime State
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.2
// Reference: Docs/MIGRATION_PLAN.md, Feature A2

/// Mutable runtime state for the quest system.
/// Tracks quest progress, completion, etc.
struct QuestRuntimeState: Codable, Equatable {
    // MARK: - Quest Tracking

    /// State of each quest (keyed by quest definition ID)
    var questStates: [String: SingleQuestState]

    // MARK: - Initialization

    init(questStates: [String: SingleQuestState] = [:]) {
        self.questStates = questStates
    }

    // MARK: - Quest Operations

    /// Get state for a specific quest
    func getQuestState(_ questId: String) -> SingleQuestState? {
        return questStates[questId]
    }

    /// Start a new quest
    mutating func startQuest(_ questId: String, firstObjectiveId: String) {
        questStates[questId] = SingleQuestState(
            definitionId: questId,
            status: .active,
            currentObjectiveId: firstObjectiveId
        )
    }

    /// Update quest state
    mutating func updateQuest(_ questId: String, update: (inout SingleQuestState) -> Void) {
        if var state = questStates[questId] {
            update(&state)
            questStates[questId] = state
        }
    }

    /// Get all active quests
    var activeQuests: [SingleQuestState] {
        return questStates.values.filter { $0.status == .active }
    }

    /// Get all completed quests
    var completedQuests: [SingleQuestState] {
        return questStates.values.filter { $0.status == .completed }
    }
}

// MARK: - Single Quest State

/// Runtime state of a single quest.
struct SingleQuestState: Codable, Equatable {
    /// Reference to quest definition
    let definitionId: String

    /// Current quest status
    var status: QuestStatus

    /// Current objective ID (nil if completed or failed)
    var currentObjectiveId: String?

    /// Completed objective IDs
    var completedObjectiveIds: Set<String>

    /// Failed objective IDs
    var failedObjectiveIds: Set<String>

    /// Quest-specific flags
    var flags: [String: Bool]

    /// Progress values for objectives (e.g., "kill_count": 3)
    var progressValues: [String: Int]

    init(
        definitionId: String,
        status: QuestStatus = .locked,
        currentObjectiveId: String? = nil,
        completedObjectiveIds: Set<String> = [],
        failedObjectiveIds: Set<String> = [],
        flags: [String: Bool] = [:],
        progressValues: [String: Int] = [:]
    ) {
        self.definitionId = definitionId
        self.status = status
        self.currentObjectiveId = currentObjectiveId
        self.completedObjectiveIds = completedObjectiveIds
        self.failedObjectiveIds = failedObjectiveIds
        self.flags = flags
        self.progressValues = progressValues
    }

    // MARK: - Objective Operations

    /// Complete current objective and move to next
    mutating func completeCurrentObjective(nextObjectiveId: String?) {
        if let currentId = currentObjectiveId {
            completedObjectiveIds.insert(currentId)
        }
        currentObjectiveId = nextObjectiveId

        // If no next objective, quest is complete
        if nextObjectiveId == nil {
            status = .completed
        }
    }

    /// Fail current objective
    mutating func failCurrentObjective() {
        if let currentId = currentObjectiveId {
            failedObjectiveIds.insert(currentId)
        }
        status = .failed
        currentObjectiveId = nil
    }

    /// Increment progress for a key
    mutating func incrementProgress(_ key: String, by amount: Int = 1) {
        progressValues[key, default: 0] += amount
    }

    /// Check progress against target
    func checkProgress(_ key: String, target: Int) -> Bool {
        return (progressValues[key] ?? 0) >= target
    }
}

// MARK: - Quest Status

/// Possible statuses for a quest
enum QuestStatus: String, Codable, Hashable {
    /// Quest not yet available/visible
    case locked

    /// Quest available but not started
    case available

    /// Quest in progress
    case active

    /// Quest successfully completed
    case completed

    /// Quest failed
    case failed
}


// ==========================================
// FILE: Engine/Runtime/WorldRuntimeState.swift
// ==========================================

import Foundation

// MARK: - World Runtime State
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.2
// Reference: Docs/MIGRATION_PLAN.md, Feature A2

/// Mutable runtime state of the game world.
/// References Definitions by ID, never stores Definition data.
struct WorldRuntimeState: Codable, Equatable {
    // MARK: - Current Position

    /// Current region ID
    var currentRegionId: String

    // MARK: - Time

    /// Current game time (days passed)
    var currentTime: Int

    // MARK: - Pressure

    /// Current world tension/pressure (0-100)
    var pressure: Int

    /// Days since last pressure escalation
    var daysSinceEscalation: Int

    // MARK: - Regions State

    /// Runtime state of each region (keyed by definition ID)
    var regionsState: [String: RegionRuntimeState]

    // MARK: - Anchors State

    /// Runtime state of each anchor (keyed by definition ID)
    var anchorsState: [String: AnchorRuntimeState]

    // MARK: - World Flags

    /// Global world flags
    var flags: [String: Bool]

    // MARK: - Initialization

    init(
        currentRegionId: String,
        currentTime: Int = 0,
        pressure: Int = 0,
        daysSinceEscalation: Int = 0,
        regionsState: [String: RegionRuntimeState] = [:],
        anchorsState: [String: AnchorRuntimeState] = [:],
        flags: [String: Bool] = [:]
    ) {
        self.currentRegionId = currentRegionId
        self.currentTime = currentTime
        self.pressure = pressure
        self.daysSinceEscalation = daysSinceEscalation
        self.regionsState = regionsState
        self.anchorsState = anchorsState
        self.flags = flags
    }

    // MARK: - Flag Operations

    mutating func setFlag(_ flag: String, value: Bool = true) {
        flags[flag] = value
    }

    func hasFlag(_ flag: String) -> Bool {
        return flags[flag] ?? false
    }

    // MARK: - Region Operations

    func getRegionState(_ regionId: String) -> RegionRuntimeState? {
        return regionsState[regionId]
    }

    mutating func updateRegion(_ regionId: String, update: (inout RegionRuntimeState) -> Void) {
        if var state = regionsState[regionId] {
            update(&state)
            regionsState[regionId] = state
        }
    }

    // MARK: - Pressure Operations

    /// Check if pressure is at maximum (game over condition)
    var isPressureMaximum: Bool {
        return pressure >= 100
    }
}

// MARK: - Region Runtime State

/// Mutable runtime state of a single region.
struct RegionRuntimeState: Codable, Equatable {
    /// Reference to the region definition
    let definitionId: String

    /// Current state (stable/borderland/breach)
    var currentState: RegionStateType

    /// Number of times player has visited
    var visitCount: Int

    /// Whether region is discovered/visible on map
    var isDiscovered: Bool

    /// Region-specific flags
    var flags: [String: Bool]

    init(
        definitionId: String,
        currentState: RegionStateType = .stable,
        visitCount: Int = 0,
        isDiscovered: Bool = false,
        flags: [String: Bool] = [:]
    ) {
        self.definitionId = definitionId
        self.currentState = currentState
        self.visitCount = visitCount
        self.isDiscovered = isDiscovered
        self.flags = flags
    }

    // MARK: - Operations

    mutating func visit() {
        visitCount += 1
        isDiscovered = true
    }

    mutating func degrade() -> Bool {
        guard let newState = currentState.degraded else { return false }
        currentState = newState
        return true
    }

    mutating func restore() -> Bool {
        guard let newState = currentState.restored else { return false }
        currentState = newState
        return true
    }
}

// MARK: - Anchor Runtime State

/// Mutable runtime state of a single anchor.
struct AnchorRuntimeState: Codable, Equatable {
    /// Reference to the anchor definition
    let definitionId: String

    /// Current integrity (0-100)
    var integrity: Int

    /// Whether anchor is active/usable
    var isActive: Bool

    init(
        definitionId: String,
        integrity: Int = 50,
        isActive: Bool = true
    ) {
        self.definitionId = definitionId
        self.integrity = integrity
        self.isActive = isActive
    }

    // MARK: - Operations

    mutating func strengthen(amount: Int, maxIntegrity: Int) {
        integrity = min(maxIntegrity, integrity + amount)
    }

    mutating func weaken(amount: Int) {
        integrity = max(0, integrity - amount)
        if integrity == 0 {
            isActive = false
        }
    }

    /// Calculate resistance chance (0.0 to 1.0)
    func resistanceChance(divisor: Int = 100) -> Double {
        guard isActive else { return 0 }
        return Double(integrity) / Double(divisor)
    }
}


// ==========================================
// FILE: Engine/ContentPacks/ContentRegistry.swift
// ==========================================

import Foundation

// MARK: - Content Registry

/// Central registry for all loaded game content
/// This is the primary interface for accessing content from loaded packs
final class ContentRegistry {
    // MARK: - Singleton

    static let shared = ContentRegistry()

    // MARK: - State

    /// All loaded packs, keyed by pack ID
    private(set) var loadedPacks: [String: LoadedPack] = [:]

    /// Combined content from all packs (merged by priority)
    private var mergedRegions: [String: RegionDefinition] = [:]
    private var mergedEvents: [String: EventDefinition] = [:]
    private var mergedQuests: [String: QuestDefinition] = [:]
    private var mergedAnchors: [String: AnchorDefinition] = [:]
    private var mergedHeroes: [String: StandardHeroDefinition] = [:]
    private var mergedCards: [String: StandardCardDefinition] = [:]
    private var mergedEnemies: [String: EnemyDefinition] = [:]

    /// Active balance configuration (from highest priority pack)
    private var activeBalanceConfig: BalanceConfiguration?

    /// Pack load order (for priority resolution)
    private var loadOrder: [String] = []

    // MARK: - Initialization

    private init() {}

    // MARK: - Pack Loading

    /// Load a pack from URL
    /// - Parameter url: URL to pack directory or .pack file
    /// - Returns: The loaded pack
    /// - Throws: PackLoadError if loading fails
    @discardableResult
    func loadPack(from url: URL) throws -> LoadedPack {
        // Check if already loaded
        let manifest = try PackManifest.load(from: url)
        if loadedPacks[manifest.packId] != nil {
            throw PackLoadError.packAlreadyLoaded(packId: manifest.packId)
        }

        // Verify Core compatibility
        guard manifest.isCompatibleWithCore() else {
            throw PackLoadError.incompatibleCoreVersion(
                required: manifest.coreVersionMin,
                current: CoreVersion.current
            )
        }

        // Check dependencies
        try validateDependencies(for: manifest)

        // Load the pack content
        let pack = try PackLoader.load(manifest: manifest, from: url)

        // Register the pack
        loadedPacks[manifest.packId] = pack
        loadOrder.append(manifest.packId)

        // Merge content
        mergeContent(from: pack)

        return pack
    }

    /// Unload a pack
    /// - Parameter packId: ID of pack to unload
    func unloadPack(_ packId: String) {
        guard loadedPacks[packId] != nil else { return }

        loadedPacks.removeValue(forKey: packId)
        loadOrder.removeAll { $0 == packId }

        // Rebuild merged content
        rebuildMergedContent()
    }

    /// Unload all packs
    func unloadAllPacks() {
        loadedPacks.removeAll()
        loadOrder.removeAll()
        clearMergedContent()
    }

    // MARK: - Content Access

    /// Get region definition by ID
    func getRegion(id: String) -> RegionDefinition? {
        return mergedRegions[id]
    }

    /// Get all region definitions
    func getAllRegions() -> [RegionDefinition] {
        return Array(mergedRegions.values)
    }

    /// Get event definition by ID
    func getEvent(id: String) -> EventDefinition? {
        return mergedEvents[id]
    }

    /// Get all event definitions
    func getAllEvents() -> [EventDefinition] {
        return Array(mergedEvents.values)
    }

    /// Get quest definition by ID
    func getQuest(id: String) -> QuestDefinition? {
        return mergedQuests[id]
    }

    /// Get all quest definitions
    func getAllQuests() -> [QuestDefinition] {
        return Array(mergedQuests.values)
    }

    /// Get anchor definition by ID
    func getAnchor(id: String) -> AnchorDefinition? {
        return mergedAnchors[id]
    }

    /// Get anchor for a specific region
    func getAnchor(forRegion regionId: String) -> AnchorDefinition? {
        return mergedAnchors.values.first { $0.regionId == regionId }
    }

    /// Get all anchor definitions
    func getAllAnchors() -> [AnchorDefinition] {
        return Array(mergedAnchors.values)
    }

    /// Get hero definition by ID
    func getHero(id: String) -> StandardHeroDefinition? {
        return mergedHeroes[id]
    }

    /// Get all hero definitions
    func getAllHeroes() -> [StandardHeroDefinition] {
        return Array(mergedHeroes.values)
    }

    /// Get card definition by ID
    func getCard(id: String) -> StandardCardDefinition? {
        return mergedCards[id]
    }

    /// Get all card definitions
    func getAllCards() -> [StandardCardDefinition] {
        return Array(mergedCards.values)
    }

    /// Get cards by type
    func getCards(ofType type: CardType) -> [StandardCardDefinition] {
        return mergedCards.values.filter { $0.cardType == type }
    }

    /// Get enemy definition by ID
    func getEnemy(id: String) -> EnemyDefinition? {
        return mergedEnemies[id]
    }

    /// Get all enemy definitions
    func getAllEnemies() -> [EnemyDefinition] {
        return Array(mergedEnemies.values)
    }

    /// Get the active balance configuration
    func getBalanceConfig() -> BalanceConfiguration? {
        return activeBalanceConfig
    }

    // MARK: - Query Methods

    /// Get events available for a region with given pressure
    func getAvailableEvents(forRegion regionId: String, pressure: Int) -> [EventDefinition] {
        return mergedEvents.values.filter { event in
            let regionMatches = event.availability.regionIds?.contains(regionId) ?? true
            let pressureMatches: Bool
            if let minPressure = event.availability.minPressure,
               let maxPressure = event.availability.maxPressure {
                pressureMatches = (minPressure...maxPressure).contains(pressure)
            } else if let minPressure = event.availability.minPressure {
                pressureMatches = pressure >= minPressure
            } else if let maxPressure = event.availability.maxPressure {
                pressureMatches = pressure <= maxPressure
            } else {
                pressureMatches = true
            }
            return regionMatches && pressureMatches
        }
    }

    /// Get starting deck for a hero
    func getStartingDeck(forHero heroId: String) -> [StandardCardDefinition] {
        guard let hero = getHero(id: heroId) else { return [] }
        return hero.startingDeckCardIDs.compactMap { getCard(id: $0) }
    }

    // MARK: - Validation

    /// Validate all loaded content for cross-references
    func validateAllContent() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []

        // Validate region neighbor references
        for (id, region) in mergedRegions {
            for neighborId in region.neighborIds {
                if mergedRegions[neighborId] == nil {
                    errors.append(ContentValidationError(
                        type: .brokenReference,
                        definitionId: id,
                        message: "Region references non-existent neighbor '\(neighborId)'"
                    ))
                }
            }
        }

        // Validate event region references
        for (id, event) in mergedEvents {
            if let regionIds = event.availability.regionIds {
                for regionId in regionIds {
                    if mergedRegions[regionId] == nil {
                        errors.append(ContentValidationError(
                            type: .brokenReference,
                            definitionId: id,
                            message: "Event references non-existent region '\(regionId)'"
                        ))
                    }
                }
            }
        }

        // Validate anchor region references
        for (id, anchor) in mergedAnchors {
            if mergedRegions[anchor.regionId] == nil {
                errors.append(ContentValidationError(
                    type: .brokenReference,
                    definitionId: id,
                    message: "Anchor references non-existent region '\(anchor.regionId)'"
                ))
            }
        }

        // Validate hero starting deck references
        for (id, hero) in mergedHeroes {
            for cardId in hero.startingDeckCardIDs {
                if mergedCards[cardId] == nil {
                    errors.append(ContentValidationError(
                        type: .brokenReference,
                        definitionId: id,
                        message: "Hero references non-existent card '\(cardId)'"
                    ))
                }
            }
        }

        // Check for duplicate IDs within same type (shouldn't happen with maps, but check pack sources)
        errors.append(contentsOf: checkDuplicateIds())

        return errors
    }

    // MARK: - Statistics

    /// Get combined inventory of all loaded content
    var totalInventory: ContentInventory {
        ContentInventory(
            regionCount: mergedRegions.count,
            eventCount: mergedEvents.count,
            questCount: mergedQuests.count,
            heroCount: mergedHeroes.count,
            cardCount: mergedCards.count,
            anchorCount: mergedAnchors.count,
            enemyCount: 0, // TODO: Add enemy support
            hasBalanceConfig: activeBalanceConfig != nil,
            hasRulesExtension: false,
            hasCampaignContent: !mergedRegions.isEmpty || !mergedEvents.isEmpty,
            supportedLocales: collectSupportedLocales()
        )
    }

    /// Get list of all loaded pack IDs in load order
    var loadedPackIds: [String] {
        return loadOrder
    }

    // MARK: - Private Methods

    private func validateDependencies(for manifest: PackManifest) throws {
        for dependency in manifest.dependencies {
            if dependency.isOptional { continue }

            guard let loadedPack = loadedPacks[dependency.packId] else {
                throw PackLoadError.missingDependency(
                    packId: dependency.packId,
                    required: dependency.minVersion
                )
            }

            let loadedVersion = loadedPack.manifest.version
            if loadedVersion < dependency.minVersion {
                throw PackLoadError.dependencyVersionMismatch(
                    packId: dependency.packId,
                    required: dependency.minVersion,
                    found: loadedVersion
                )
            }

            if let maxVersion = dependency.maxVersion, loadedVersion > maxVersion {
                throw PackLoadError.dependencyVersionMismatch(
                    packId: dependency.packId,
                    required: dependency.minVersion,
                    found: loadedVersion
                )
            }
        }
    }

    private func mergeContent(from pack: LoadedPack) {
        // Merge regions (later packs override earlier)
        for (id, region) in pack.regions {
            mergedRegions[id] = region
        }

        // Merge events
        for (id, event) in pack.events {
            mergedEvents[id] = event
        }

        // Merge quests
        for (id, quest) in pack.quests {
            mergedQuests[id] = quest
        }

        // Merge anchors
        for (id, anchor) in pack.anchors {
            mergedAnchors[id] = anchor
        }

        // Merge heroes
        for (id, hero) in pack.heroes {
            mergedHeroes[id] = hero
        }

        // Merge cards
        for (id, card) in pack.cards {
            mergedCards[id] = card
        }

        // Merge enemies
        for (id, enemy) in pack.enemies {
            mergedEnemies[id] = enemy
        }

        // Update balance config if pack provides one
        if let balanceConfig = pack.balanceConfig {
            activeBalanceConfig = balanceConfig
        }
    }

    private func rebuildMergedContent() {
        clearMergedContent()

        // Re-merge in load order
        for packId in loadOrder {
            if let pack = loadedPacks[packId] {
                mergeContent(from: pack)
            }
        }
    }

    private func clearMergedContent() {
        mergedRegions.removeAll()
        mergedEvents.removeAll()
        mergedQuests.removeAll()
        mergedAnchors.removeAll()
        mergedHeroes.removeAll()
        mergedCards.removeAll()
        mergedEnemies.removeAll()
        activeBalanceConfig = nil
    }

    private func checkDuplicateIds() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []

        // Track which pack each ID came from
        var regionSources: [String: [String]] = [:]
        var eventSources: [String: [String]] = [:]

        for packId in loadOrder {
            guard let pack = loadedPacks[packId] else { continue }

            for regionId in pack.regions.keys {
                regionSources[regionId, default: []].append(packId)
            }

            for eventId in pack.events.keys {
                eventSources[eventId, default: []].append(packId)
            }
        }

        // Report duplicates (informational - later packs override earlier)
        for (id, sources) in regionSources where sources.count > 1 {
            errors.append(ContentValidationError(
                type: .duplicateId,
                definitionId: id,
                message: "Region defined in multiple packs: \(sources.joined(separator: ", ")) (later overrides earlier)"
            ))
        }

        for (id, sources) in eventSources where sources.count > 1 {
            errors.append(ContentValidationError(
                type: .duplicateId,
                definitionId: id,
                message: "Event defined in multiple packs: \(sources.joined(separator: ", ")) (later overrides earlier)"
            ))
        }

        return errors
    }

    private func collectSupportedLocales() -> [String] {
        var locales = Set<String>()
        for pack in loadedPacks.values {
            for locale in pack.manifest.supportedLocales {
                locales.insert(locale)
            }
        }
        return Array(locales).sorted()
    }
}

// MARK: - Content Provider Protocol Conformance

extension ContentRegistry: ContentProvider {
    func getRegionDefinition(id: String) -> RegionDefinition? {
        return getRegion(id: id)
    }

    func getAllRegionDefinitions() -> [RegionDefinition] {
        return getAllRegions()
    }

    func getEventDefinition(id: String) -> EventDefinition? {
        return getEvent(id: id)
    }

    func getAllEventDefinitions() -> [EventDefinition] {
        return getAllEvents()
    }

    func getAnchorDefinition(id: String) -> AnchorDefinition? {
        return getAnchor(id: id)
    }

    func getAnchorDefinition(forRegion regionId: String) -> AnchorDefinition? {
        return getAnchor(forRegion: regionId)
    }

    func getAllAnchorDefinitions() -> [AnchorDefinition] {
        return getAllAnchors()
    }

    func getEventDefinitions(forRegion regionId: String) -> [EventDefinition] {
        return mergedEvents.values.filter { event in
            event.availability.regionIds?.contains(regionId) ?? false
        }
    }

    func getEventDefinitions(forPool poolId: String) -> [EventDefinition] {
        return mergedEvents.values.filter { event in
            event.poolIds.contains(poolId)
        }
    }

    func getAllQuestDefinitions() -> [QuestDefinition] {
        return getAllQuests()
    }

    func getQuestDefinition(id: String) -> QuestDefinition? {
        return getQuest(id: id)
    }

    func getAllMiniGameChallenges() -> [MiniGameChallengeDefinition] {
        // Extract from events that have mini-game challenges
        return mergedEvents.values.compactMap { $0.miniGameChallenge }
    }

    func getMiniGameChallenge(id: String) -> MiniGameChallengeDefinition? {
        return mergedEvents.values.compactMap { $0.miniGameChallenge }.first { $0.id == id }
    }

    func validate() -> [ContentValidationError] {
        // Use ContentValidator for full validation
        let validator = ContentValidator(provider: self)
        return validator.validate()
    }
}

// MARK: - Testing Support

extension ContentRegistry {
    /// Reset registry for testing
    /// - Warning: Only use in tests!
    func resetForTesting() {
        unloadAllPacks()
    }

    /// Register mock content for testing
    /// - Warning: Only use in tests!
    func registerMockContent(
        regions: [String: RegionDefinition] = [:],
        events: [String: EventDefinition] = [:],
        anchors: [String: AnchorDefinition] = [:],
        heroes: [String: StandardHeroDefinition] = [:],
        cards: [String: StandardCardDefinition] = [:],
        enemies: [String: EnemyDefinition] = [:]
    ) {
        mergedRegions = regions
        mergedEvents = events
        mergedAnchors = anchors
        mergedHeroes = heroes
        mergedCards = cards
        mergedEnemies = enemies
    }
}


// ==========================================
// FILE: Engine/ContentPacks/PackLoader.swift
// ==========================================

import Foundation
import CryptoKit

// MARK: - Pack Loader

/// Loads content pack data from disk
/// Supports JSON format (Protobuf support planned)
enum PackLoader {
    // MARK: - Main Loading

    /// Load a pack from a manifest and source URL
    /// - Parameters:
    ///   - manifest: The pack manifest
    ///   - url: URL to the pack directory
    /// - Returns: Fully loaded pack
    /// - Throws: PackLoadError if loading fails
    static func load(manifest: PackManifest, from url: URL) throws -> LoadedPack {
        // Verify checksums before loading content (Epic 0.3)
        if let checksums = manifest.checksums {
            try verifyChecksums(checksums, in: url)
        }

        var pack = LoadedPack(
            manifest: manifest,
            sourceURL: url,
            loadedAt: Date()
        )

        // Load regions
        if let regionsPath = manifest.regionsPath {
            pack.regions = try loadRegions(from: url.appendingPathComponent(regionsPath))
        }

        // Load events
        if let eventsPath = manifest.eventsPath {
            pack.events = try loadEvents(from: url.appendingPathComponent(eventsPath))
        }

        // Load quests
        if let questsPath = manifest.questsPath {
            pack.quests = try loadQuests(from: url.appendingPathComponent(questsPath))
        }

        // Load anchors
        if let anchorsPath = manifest.anchorsPath {
            pack.anchors = try loadAnchors(from: url.appendingPathComponent(anchorsPath))
        }

        // Load hero abilities (before heroes, so abilities are available)
        if let abilitiesPath = manifest.abilitiesPath {
            loadAbilities(from: url.appendingPathComponent(abilitiesPath))
        }

        // Load heroes
        if let heroesPath = manifest.heroesPath {
            pack.heroes = try loadHeroes(from: url.appendingPathComponent(heroesPath))
        }

        // Load cards
        if let cardsPath = manifest.cardsPath {
            pack.cards = try loadCards(from: url.appendingPathComponent(cardsPath))
        }

        // Load balance configuration
        if let balancePath = manifest.balancePath {
            pack.balanceConfig = try loadBalanceConfig(from: url.appendingPathComponent(balancePath))
        }

        // Load enemies
        if let enemiesPath = manifest.enemiesPath {
            pack.enemies = try loadEnemies(from: url.appendingPathComponent(enemiesPath))
        }

        return pack
    }

    // MARK: - Content Loading

    /// Load regions from path (file or directory)
    private static func loadRegions(from url: URL) throws -> [String: RegionDefinition] {
        var regions: [String: RegionDefinition] = [:]

        if isDirectory(url) {
            // Load all JSON files in directory
            let files = try jsonFiles(in: url)
            for file in files {
                let fileRegions = try loadJSONArray(RegionDefinition.self, from: file)
                for region in fileRegions {
                    regions[region.id] = region
                }
            }
        } else {
            // Load single file
            let fileRegions = try loadJSONArray(RegionDefinition.self, from: url)
            for region in fileRegions {
                regions[region.id] = region
            }
        }

        return regions
    }

    /// Load events from path (file or directory)
    private static func loadEvents(from url: URL) throws -> [String: EventDefinition] {
        var events: [String: EventDefinition] = [:]

        if isDirectory(url) {
            let files = try jsonFiles(in: url)
            for file in files {
                let fileEvents = try loadJSONArray(EventDefinition.self, from: file)
                for event in fileEvents {
                    events[event.id] = event
                }
            }
        } else {
            let fileEvents = try loadJSONArray(EventDefinition.self, from: url)
            for event in fileEvents {
                events[event.id] = event
            }
        }

        return events
    }

    /// Load quests from path (file or directory)
    private static func loadQuests(from url: URL) throws -> [String: QuestDefinition] {
        var quests: [String: QuestDefinition] = [:]

        if isDirectory(url) {
            let files = try jsonFiles(in: url)
            for file in files {
                let fileQuests = try loadJSONArray(QuestDefinition.self, from: file)
                for quest in fileQuests {
                    quests[quest.id] = quest
                }
            }
        } else {
            let fileQuests = try loadJSONArray(QuestDefinition.self, from: url)
            for quest in fileQuests {
                quests[quest.id] = quest
            }
        }

        return quests
    }

    /// Load anchors from path (file or directory)
    private static func loadAnchors(from url: URL) throws -> [String: AnchorDefinition] {
        var anchors: [String: AnchorDefinition] = [:]

        if isDirectory(url) {
            let files = try jsonFiles(in: url)
            for file in files {
                let fileAnchors = try loadJSONArray(AnchorDefinition.self, from: file)
                for anchor in fileAnchors {
                    anchors[anchor.id] = anchor
                }
            }
        } else {
            let fileAnchors = try loadJSONArray(AnchorDefinition.self, from: url)
            for anchor in fileAnchors {
                anchors[anchor.id] = anchor
            }
        }

        return anchors
    }

    /// Load abilities from JSON file (registers in AbilityRegistry)
    private static func loadAbilities(from url: URL) {
        // Abilities are registered globally in AbilityRegistry
        AbilityRegistry.shared.loadFromJSON(at: url)
    }

    /// Load heroes from path (file or directory)
    private static func loadHeroes(from url: URL) throws -> [String: StandardHeroDefinition] {
        var heroes: [String: StandardHeroDefinition] = [:]

        if isDirectory(url) {
            let files = try jsonFiles(in: url)
            for file in files {
                let fileHeroes = try loadJSONArray(PackHeroDefinition.self, from: file)
                for hero in fileHeroes {
                    let standard = hero.toStandard()
                    heroes[standard.id] = standard
                }
            }
        } else {
            let fileHeroes = try loadJSONArray(PackHeroDefinition.self, from: url)
            for hero in fileHeroes {
                let standard = hero.toStandard()
                heroes[standard.id] = standard
            }
        }

        return heroes
    }

    /// Load cards from path (file or directory)
    private static func loadCards(from url: URL) throws -> [String: StandardCardDefinition] {
        var cards: [String: StandardCardDefinition] = [:]

        if isDirectory(url) {
            let files = try jsonFiles(in: url)
            for file in files {
                let fileCards = try loadJSONArray(StandardCardDefinition.self, from: file)
                for card in fileCards {
                    cards[card.id] = card
                }
            }
        } else {
            let fileCards = try loadJSONArray(StandardCardDefinition.self, from: url)
            for card in fileCards {
                cards[card.id] = card
            }
        }

        return cards
    }

    /// Load balance configuration
    private static func loadBalanceConfig(from url: URL) throws -> BalanceConfiguration {
        return try loadJSON(BalanceConfiguration.self, from: url)
    }

    /// Load enemies from path (file or directory)
    private static func loadEnemies(from url: URL) throws -> [String: EnemyDefinition] {
        var enemies: [String: EnemyDefinition] = [:]

        if isDirectory(url) {
            let files = try jsonFiles(in: url)
            for file in files {
                let fileEnemies = try loadJSONArray(EnemyDefinition.self, from: file)
                for enemy in fileEnemies {
                    enemies[enemy.id] = enemy
                }
            }
        } else {
            let fileEnemies = try loadJSONArray(EnemyDefinition.self, from: url)
            for enemy in fileEnemies {
                enemies[enemy.id] = enemy
            }
        }

        return enemies
    }

    // MARK: - JSON Helpers

    /// Load a single JSON object
    private static func loadJSON<T: Decodable>(_ type: T.Type, from url: URL) throws -> T {
        do {
            let data = try Data(contentsOf: url)
            let decoder = JSONDecoder()
            decoder.dateDecodingStrategy = .iso8601
            decoder.keyDecodingStrategy = .convertFromSnakeCase
            return try decoder.decode(T.self, from: data)
        } catch {
            throw PackLoadError.contentLoadFailed(file: url.lastPathComponent, underlyingError: error)
        }
    }

    /// Load a JSON array (or single object as array)
    private static func loadJSONArray<T: Decodable>(_ type: T.Type, from url: URL) throws -> [T] {
        let data: Data
        do {
            data = try Data(contentsOf: url)
        } catch {
            throw PackLoadError.contentLoadFailed(file: url.lastPathComponent, underlyingError: error)
        }

        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        decoder.keyDecodingStrategy = .convertFromSnakeCase

        // Try array first
        do {
            return try decoder.decode([T].self, from: data)
        } catch let arrayError {
            #if DEBUG
            // Detailed error diagnostics
            print("PackLoader: Failed to decode \(url.lastPathComponent) as [\(T.self)]")
            if let decodingError = arrayError as? DecodingError {
                switch decodingError {
                case .typeMismatch(let type, let context):
                    print("  → typeMismatch: expected \(type)")
                    print("  → path: \(context.codingPath.map { $0.stringValue }.joined(separator: "."))")
                    print("  → description: \(context.debugDescription)")
                case .valueNotFound(let type, let context):
                    print("  → valueNotFound: \(type)")
                    print("  → path: \(context.codingPath.map { $0.stringValue }.joined(separator: "."))")
                case .keyNotFound(let key, let context):
                    print("  → keyNotFound: \(key.stringValue)")
                    print("  → path: \(context.codingPath.map { $0.stringValue }.joined(separator: "."))")
                case .dataCorrupted(let context):
                    print("  → dataCorrupted: \(context.debugDescription)")
                    print("  → path: \(context.codingPath.map { $0.stringValue }.joined(separator: "."))")
                @unknown default:
                    print("  → unknown error: \(decodingError)")
                }
            }
            #endif

            // Try single object as fallback
            do {
                let single = try decoder.decode(T.self, from: data)
                return [single]
            } catch {
                // Report the array error since that's what we expected
                throw PackLoadError.contentLoadFailed(file: url.lastPathComponent, underlyingError: arrayError)
            }
        }
    }

    // MARK: - File System Helpers

    /// Check if URL is a directory
    private static func isDirectory(_ url: URL) -> Bool {
        var isDir: ObjCBool = false
        return FileManager.default.fileExists(atPath: url.path, isDirectory: &isDir) && isDir.boolValue
    }

    /// Get all JSON files in a directory
    private static func jsonFiles(in url: URL) throws -> [URL] {
        let contents = try FileManager.default.contentsOfDirectory(
            at: url,
            includingPropertiesForKeys: nil
        )
        return contents.filter { $0.pathExtension.lowercased() == "json" }
    }

    // MARK: - Checksum Verification (Epic 0.3)

    /// Verify file checksums against manifest
    /// - Parameters:
    ///   - checksums: Dictionary of relative paths to expected SHA256 hashes
    ///   - packURL: Root URL of the pack
    /// - Throws: PackLoadError.checksumMismatch if verification fails
    private static func verifyChecksums(_ checksums: [String: String], in packURL: URL) throws {
        for (relativePath, expectedHash) in checksums {
            let fileURL = packURL.appendingPathComponent(relativePath)

            guard FileManager.default.fileExists(atPath: fileURL.path) else {
                throw PackLoadError.fileNotFound(relativePath)
            }

            let actualHash = try computeSHA256(of: fileURL)

            if actualHash.lowercased() != expectedHash.lowercased() {
                throw PackLoadError.checksumMismatch(
                    file: relativePath,
                    expected: expectedHash,
                    actual: actualHash
                )
            }
        }
    }

    /// Compute SHA256 hash of a file
    /// - Parameter url: File URL
    /// - Returns: Hex-encoded SHA256 hash string
    static func computeSHA256(of url: URL) throws -> String {
        let data = try Data(contentsOf: url)
        let hash = SHA256.hash(data: data)
        return hash.map { String(format: "%02x", $0) }.joined()
    }
}

// MARK: - Balance Configuration

/// Configuration for game balance parameters
/// This replaces hardcoded balance values like TwilightMarchesConfig
struct BalanceConfiguration: Codable {
    // MARK: - Resources

    /// Resource definitions
    let resources: ResourceBalanceConfig

    // MARK: - Pressure/Tension

    /// Pressure system configuration
    let pressure: PressureBalanceConfig

    // MARK: - Combat

    /// Combat system configuration
    let combat: CombatBalanceConfig?

    // MARK: - Time

    /// Time system configuration
    let time: TimeBalanceConfig

    // MARK: - Anchors

    /// Anchor system configuration
    let anchor: AnchorBalanceConfig

    // MARK: - End Conditions

    /// Game end conditions
    let endConditions: EndConditionConfig

    // MARK: - Balance System (optional)

    /// Light/Dark balance system configuration
    let balanceSystem: BalanceSystemConfig?

    // MARK: - Defaults

    static let `default` = BalanceConfiguration(
        resources: .default,
        pressure: .default,
        combat: nil,
        time: .default,
        anchor: .default,
        endConditions: .default,
        balanceSystem: nil
    )
}

/// Resource balance configuration
struct ResourceBalanceConfig: Codable {
    /// Starting health
    let startingHealth: Int

    /// Maximum health
    let maxHealth: Int

    /// Starting faith
    let startingFaith: Int

    /// Maximum faith
    let maxFaith: Int

    /// Starting supplies
    let startingSupplies: Int

    /// Maximum supplies
    let maxSupplies: Int

    /// Starting gold
    let startingGold: Int

    /// Maximum gold
    let maxGold: Int

    /// Health restored when resting (optional, default 3)
    let restHealAmount: Int?

    /// Starting balance value (optional)
    let startingBalance: Int?

    static let `default` = ResourceBalanceConfig(
        startingHealth: 20,
        maxHealth: 30,
        startingFaith: 10,
        maxFaith: 20,
        startingSupplies: 5,
        maxSupplies: 10,
        startingGold: 0,
        maxGold: 100,
        restHealAmount: 3,
        startingBalance: 50
    )
}

/// Pressure system balance configuration
struct PressureBalanceConfig: Codable {
    /// Starting pressure level
    let startingPressure: Int

    /// Minimum pressure
    let minPressure: Int

    /// Maximum pressure
    let maxPressure: Int

    /// Pressure gain per turn
    let pressurePerTurn: Int

    /// Days between tension ticks (when tension increases automatically)
    /// Also accepts escalation_interval from JSON
    let tensionTickInterval: Int?

    /// Escalation interval (alias for tensionTickInterval)
    let escalationInterval: Int?

    /// Pressure thresholds for escalation
    let thresholds: PressureThresholds

    /// Degradation settings
    let degradation: DegradationConfig

    /// Get the effective tick interval
    var effectiveTickInterval: Int {
        tensionTickInterval ?? escalationInterval ?? 3
    }

    static let `default` = PressureBalanceConfig(
        startingPressure: 0,
        minPressure: 0,
        maxPressure: 100,
        pressurePerTurn: 5,
        tensionTickInterval: 3,
        escalationInterval: nil,
        thresholds: .default,
        degradation: .default
    )
}

/// Pressure thresholds
struct PressureThresholds: Codable {
    /// Threshold for increased event danger
    let warning: Int

    /// Threshold for critical pressure
    let critical: Int

    /// Threshold for game loss
    let catastrophic: Int

    static let `default` = PressureThresholds(
        warning: 30,
        critical: 60,
        catastrophic: 100
    )
}

/// Degradation configuration
struct DegradationConfig: Codable {
    /// Chance for region degradation at each threshold
    let warningChance: Double

    /// Chance at critical level
    let criticalChance: Double

    /// Chance at catastrophic level (optional)
    let catastrophicChance: Double?

    /// Base chance for anchor integrity loss per turn
    let anchorDecayChance: Double

    static let `default` = DegradationConfig(
        warningChance: 0.1,
        criticalChance: 0.25,
        catastrophicChance: nil,
        anchorDecayChance: 0.05
    )
}

/// Combat balance configuration
struct CombatBalanceConfig: Codable {
    /// Base damage for attacks
    let baseDamage: Int

    /// Damage modifier per power point
    let powerModifier: Double

    /// Defense damage reduction
    let defenseReduction: Double

    /// Maximum dice value (optional)
    let diceMax: Int?

    /// Actions per turn (optional)
    let actionsPerTurn: Int?

    /// Cards drawn per turn (optional)
    let cardsDrawnPerTurn: Int?

    /// Maximum hand size (optional)
    let maxHandSize: Int?

    static let `default` = CombatBalanceConfig(
        baseDamage: 3,
        powerModifier: 1.0,
        defenseReduction: 0.5,
        diceMax: 6,
        actionsPerTurn: 3,
        cardsDrawnPerTurn: 5,
        maxHandSize: 7
    )
}

/// Time system balance configuration
struct TimeBalanceConfig: Codable {
    /// Time units per day
    let unitsPerDay: Int

    /// Starting time of day
    let startingTime: Int

    /// Maximum days for campaign
    let maxDays: Int?

    /// Time cost for travel
    let travelCost: Int

    /// Time cost for exploration
    let exploreCost: Int

    /// Time cost for rest
    let restCost: Int

    /// Time cost for strengthening anchor (optional)
    let strengthenAnchorCost: Int?

    /// Time cost for instant actions (optional)
    let instantCost: Int?

    static let `default` = TimeBalanceConfig(
        unitsPerDay: 24,
        startingTime: 8,
        maxDays: nil,
        travelCost: 2,
        exploreCost: 1,
        restCost: 4,
        strengthenAnchorCost: 1,
        instantCost: 0
    )
}

/// End condition configuration
struct EndConditionConfig: Codable {
    /// Health threshold for death
    let deathHealth: Int

    /// Pressure threshold for loss
    let pressureLoss: Int?

    /// Breach count for loss
    let breachLoss: Int?

    /// Victory conditions (quest IDs)
    let victoryQuests: [String]

    /// Flag set when main quest completes (optional)
    let mainQuestCompleteFlag: String?

    /// Flag set when critical anchor destroyed (optional)
    let criticalAnchorDestroyedFlag: String?

    static let `default` = EndConditionConfig(
        deathHealth: 0,
        pressureLoss: 100,
        breachLoss: nil,
        victoryQuests: [],
        mainQuestCompleteFlag: nil,
        criticalAnchorDestroyedFlag: nil
    )
}

/// Anchor system balance configuration
struct AnchorBalanceConfig: Codable {
    /// Maximum anchor integrity
    let maxIntegrity: Int

    /// Amount to strengthen per action
    let strengthenAmount: Int

    /// Faith cost to strengthen
    let strengthenCost: Int

    /// Integrity threshold for stable status
    let stableThreshold: Int

    /// Integrity threshold for breach
    let breachThreshold: Int

    /// Base decay rate per turn in threatened regions
    let decayPerTurn: Int

    static let `default` = AnchorBalanceConfig(
        maxIntegrity: 100,
        strengthenAmount: 15,
        strengthenCost: 5,
        stableThreshold: 70,
        breachThreshold: 0,
        decayPerTurn: 5
    )
}

/// Balance system configuration for Light/Dark alignment
struct BalanceSystemConfig: Codable {
    /// Minimum balance value
    let min: Int

    /// Maximum balance value
    let max: Int

    /// Initial balance value
    let initial: Int

    /// Threshold for light alignment
    let lightThreshold: Int

    /// Threshold for dark alignment
    let darkThreshold: Int

    static let `default` = BalanceSystemConfig(
        min: 0,
        max: 100,
        initial: 50,
        lightThreshold: 70,
        darkThreshold: 30
    )
}

// MARK: - Pack Hero Definition

/// JSON структура для stats героя
private struct PackHeroStats: Codable {
    let health: Int
    let maxHealth: Int
    let strength: Int
    let dexterity: Int
    let constitution: Int
    let intelligence: Int
    let wisdom: Int
    let charisma: Int
    let faith: Int
    let maxFaith: Int
    let startingBalance: Int

    func toHeroStats() -> HeroStats {
        HeroStats(
            health: health,
            maxHealth: maxHealth,
            strength: strength,
            dexterity: dexterity,
            constitution: constitution,
            intelligence: intelligence,
            wisdom: wisdom,
            charisma: charisma,
            faith: faith,
            maxFaith: maxFaith,
            startingBalance: startingBalance
        )
    }
}

/// JSON-совместимое определение героя для загрузки из Content Pack
/// Статы загружаются из JSON (data-driven)
private struct PackHeroDefinition: Codable {
    let id: String
    let name: String
    let nameRu: String?
    let description: String
    let descriptionRu: String?
    let icon: String
    let baseStats: PackHeroStats
    let abilityId: String
    let startingDeckCardIds: [String]
    let availability: String?

    /// Конвертация в StandardHeroDefinition
    func toStandard() -> StandardHeroDefinition {
        // Определяем доступность
        let heroAvailability: HeroAvailability
        switch availability?.lowercased() {
        case "always_available", nil:
            heroAvailability = .alwaysAvailable
        case let str where str?.hasPrefix("requires_unlock:") == true:
            let condition = String(str!.dropFirst("requires_unlock:".count))
            heroAvailability = .requiresUnlock(condition: condition)
        case let str where str?.hasPrefix("dlc:") == true:
            let packId = String(str!.dropFirst("dlc:".count))
            heroAvailability = .dlc(packID: packId)
        default:
            heroAvailability = .alwaysAvailable
        }

        // Локализованное имя и описание
        let localizedName = Locale.current.language.languageCode?.identifier == "ru" ? (nameRu ?? name) : name
        let localizedDescription = Locale.current.language.languageCode?.identifier == "ru" ? (descriptionRu ?? description) : description

        // Получаем способность по ID
        guard let ability = HeroAbility.forAbilityId(abilityId) else {
            #if DEBUG
            print("PackLoader: ERROR - Unknown ability ID '\(abilityId)' for hero '\(id)'")
            #endif
            fatalError("Missing ability definition for '\(abilityId)'. Add it to HeroAbility.forAbilityId() or hero_abilities.json")
        }

        return StandardHeroDefinition(
            id: id,
            name: localizedName,
            description: localizedDescription,
            icon: icon,
            baseStats: baseStats.toHeroStats(),
            specialAbility: ability,
            startingDeckCardIDs: startingDeckCardIds,
            availability: heroAvailability
        )
    }
}


// ==========================================
// FILE: Engine/ContentPacks/PackManifest.swift
// ==========================================

import Foundation

// MARK: - Pack Manifest

/// Metadata describing a content pack
/// This is the entry point for pack loading - every pack must have a manifest
struct PackManifest: Codable {
    // MARK: - Identity

    /// Unique pack identifier (e.g., "twilight-marches-act1")
    let packId: String

    /// Human-readable display name
    let displayName: LocalizedString

    /// Pack description
    let description: LocalizedString

    /// Pack version
    let version: SemanticVersion

    /// Type of content this pack provides
    let packType: PackType

    // MARK: - Compatibility

    /// Minimum required Core engine version
    let coreVersionMin: SemanticVersion

    /// Maximum tested Core version (nil = any future version)
    let coreVersionMax: SemanticVersion?

    /// Required dependencies on other packs
    let dependencies: [PackDependency]

    /// Capabilities this pack requires from Core (for rules extensions)
    let requiredCapabilities: [String]

    // MARK: - Content Entry Points

    /// Starting region ID for campaign packs
    let entryRegionId: String?

    /// Starting quest ID for campaign packs
    let entryQuestId: String?

    /// Recommended hero IDs for this campaign
    let recommendedHeroes: [String]

    // MARK: - Metadata

    /// Pack author/publisher
    let author: String

    /// License identifier
    let license: String?

    /// Release date
    let releaseDate: Date?

    /// Supported locales
    let supportedLocales: [String]

    /// File checksums for integrity verification
    let checksums: [String: String]?

    // MARK: - Content Paths (relative to pack root)

    /// Path to regions content
    let regionsPath: String?

    /// Path to events content
    let eventsPath: String?

    /// Path to quests content
    let questsPath: String?

    /// Path to anchors content
    let anchorsPath: String?

    /// Path to heroes content
    let heroesPath: String?

    /// Path to hero abilities content
    let abilitiesPath: String?

    /// Path to cards content
    let cardsPath: String?

    /// Path to enemies content
    let enemiesPath: String?

    /// Path to balance configuration
    let balancePath: String?

    /// Path to localization files
    let localizationPath: String?

    // MARK: - Coding Keys

    enum CodingKeys: String, CodingKey {
        case packId = "id"
        case displayName = "name"
        case description
        case version
        case packType = "type"
        case coreVersionMin = "core_version_min"
        case coreVersionMax = "core_version_max"
        case dependencies
        case requiredCapabilities = "required_capabilities"
        case entryRegionId = "entry_region"
        case entryQuestId = "entry_quest"
        case recommendedHeroes = "recommended_heroes"
        case author
        case license
        case releaseDate = "release_date"
        case supportedLocales = "locales"
        case checksums
        case regionsPath = "regions_path"
        case eventsPath = "events_path"
        case questsPath = "quests_path"
        case anchorsPath = "anchors_path"
        case heroesPath = "heroes_path"
        case abilitiesPath = "abilities_path"
        case cardsPath = "cards_path"
        case enemiesPath = "enemies_path"
        case balancePath = "balance_path"
        case localizationPath = "localization_path"
    }

    // MARK: - Initialization

    init(
        packId: String,
        displayName: LocalizedString,
        description: LocalizedString,
        version: SemanticVersion,
        packType: PackType,
        coreVersionMin: SemanticVersion,
        coreVersionMax: SemanticVersion? = nil,
        dependencies: [PackDependency] = [],
        requiredCapabilities: [String] = [],
        entryRegionId: String? = nil,
        entryQuestId: String? = nil,
        recommendedHeroes: [String] = [],
        author: String,
        license: String? = nil,
        releaseDate: Date? = nil,
        supportedLocales: [String] = ["en"],
        checksums: [String: String]? = nil,
        regionsPath: String? = nil,
        eventsPath: String? = nil,
        questsPath: String? = nil,
        anchorsPath: String? = nil,
        heroesPath: String? = nil,
        abilitiesPath: String? = nil,
        cardsPath: String? = nil,
        enemiesPath: String? = nil,
        balancePath: String? = nil,
        localizationPath: String? = nil
    ) {
        self.packId = packId
        self.displayName = displayName
        self.description = description
        self.version = version
        self.packType = packType
        self.coreVersionMin = coreVersionMin
        self.coreVersionMax = coreVersionMax
        self.dependencies = dependencies
        self.requiredCapabilities = requiredCapabilities
        self.entryRegionId = entryRegionId
        self.entryQuestId = entryQuestId
        self.recommendedHeroes = recommendedHeroes
        self.author = author
        self.license = license
        self.releaseDate = releaseDate
        self.supportedLocales = supportedLocales
        self.checksums = checksums
        self.regionsPath = regionsPath
        self.eventsPath = eventsPath
        self.questsPath = questsPath
        self.anchorsPath = anchorsPath
        self.heroesPath = heroesPath
        self.abilitiesPath = abilitiesPath
        self.cardsPath = cardsPath
        self.enemiesPath = enemiesPath
        self.balancePath = balancePath
        self.localizationPath = localizationPath
    }

    // MARK: - Validation

    /// Validate manifest structure
    func validate() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []

        // Check required fields
        if packId.isEmpty {
            errors.append(ContentValidationError(
                type: .missingRequired,
                definitionId: "manifest",
                message: "Pack ID is required"
            ))
        }

        if displayName.localized.isEmpty {
            errors.append(ContentValidationError(
                type: .missingRequired,
                definitionId: "manifest",
                message: "Display name is required"
            ))
        }

        // Validate pack ID format (lowercase, alphanumeric, hyphens)
        let validIdPattern = "^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        if !packId.isEmpty,
           let regex = try? NSRegularExpression(pattern: validIdPattern),
           regex.firstMatch(in: packId, range: NSRange(packId.startIndex..., in: packId)) == nil {
            errors.append(ContentValidationError(
                type: .invalidRange,
                definitionId: "manifest.packId",
                message: "Pack ID must be lowercase alphanumeric with hyphens"
            ))
        }

        // Validate locales
        if supportedLocales.isEmpty {
            errors.append(ContentValidationError(
                type: .missingRequired,
                definitionId: "manifest.locales",
                message: "At least one locale must be supported"
            ))
        }

        // Campaign packs should have entry points (informational)
        // Note: This is a warning, not a blocking error

        return errors
    }

    /// Check if this pack is compatible with current Core version
    func isCompatibleWithCore() -> Bool {
        let current = CoreVersion.current

        // Must meet minimum requirement
        guard current >= coreVersionMin else { return false }

        // If max is specified, must not exceed it
        if let max = coreVersionMax, current > max {
            return false
        }

        return true
    }
}

// MARK: - Manifest File Loading

extension PackManifest {
    /// Standard manifest filename
    static let filename = "manifest.json"

    /// Custom date formatter that handles both "2026-01-01" and "2026-01-01T00:00:00Z"
    private static let flexibleDateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd"
        formatter.locale = Locale(identifier: "en_US_POSIX")
        formatter.timeZone = TimeZone(secondsFromGMT: 0)
        return formatter
    }()

    /// Load manifest from URL
    static func load(from url: URL) throws -> PackManifest {
        let manifestURL = url.appendingPathComponent(filename)

        guard FileManager.default.fileExists(atPath: manifestURL.path) else {
            throw PackLoadError.manifestNotFound(path: manifestURL.path)
        }

        do {
            let data = try Data(contentsOf: manifestURL)
            let decoder = JSONDecoder()
            // Use custom strategy that handles both date-only and ISO8601 formats
            decoder.dateDecodingStrategy = .custom { decoder in
                let container = try decoder.singleValueContainer()
                let dateString = try container.decode(String.self)

                // Try ISO8601 first
                if let date = ISO8601DateFormatter().date(from: dateString) {
                    return date
                }

                // Fallback to date-only format "yyyy-MM-dd"
                if let date = flexibleDateFormatter.date(from: dateString) {
                    return date
                }

                throw DecodingError.dataCorruptedError(
                    in: container,
                    debugDescription: "Invalid date format: \(dateString)"
                )
            }
            return try decoder.decode(PackManifest.self, from: data)
        } catch let error as DecodingError {
            throw PackLoadError.invalidManifest(reason: error.localizedDescription)
        }
    }

    /// Save manifest to URL
    func save(to url: URL) throws {
        let manifestURL = url.appendingPathComponent(Self.filename)
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        encoder.dateEncodingStrategy = .iso8601
        let data = try encoder.encode(self)
        try data.write(to: manifestURL)
    }
}


// ==========================================
// FILE: Engine/ContentPacks/PackTypes.swift
// ==========================================

import Foundation

// MARK: - Semantic Versioning

/// Semantic version for Core and Packs
/// Format: MAJOR.MINOR.PATCH
struct SemanticVersion: Comparable, Hashable, CustomStringConvertible {
    let major: Int
    let minor: Int
    let patch: Int

    var description: String { "\(major).\(minor).\(patch)" }

    init(major: Int, minor: Int, patch: Int) {
        self.major = major
        self.minor = minor
        self.patch = patch
    }

    init?(string: String) {
        let parts = string.split(separator: ".").compactMap { Int($0) }
        guard parts.count == 3 else { return nil }
        self.major = parts[0]
        self.minor = parts[1]
        self.patch = parts[2]
    }

    static func < (lhs: SemanticVersion, rhs: SemanticVersion) -> Bool {
        if lhs.major != rhs.major { return lhs.major < rhs.major }
        if lhs.minor != rhs.minor { return lhs.minor < rhs.minor }
        return lhs.patch < rhs.patch
    }

    /// Check if this version is compatible with required version
    /// - Same MAJOR version required
    /// - MINOR can be >= required
    func isCompatible(with required: SemanticVersion) -> Bool {
        return major == required.major && (minor > required.minor || (minor == required.minor && patch >= required.patch))
    }
}

// MARK: - SemanticVersion Codable

extension SemanticVersion: Codable {
    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let string = try container.decode(String.self)
        let parts = string.split(separator: ".").compactMap { Int($0) }
        guard parts.count == 3 else {
            throw DecodingError.dataCorruptedError(
                in: container,
                debugDescription: "Invalid version format: \(string). Expected MAJOR.MINOR.PATCH"
            )
        }
        self.major = parts[0]
        self.minor = parts[1]
        self.patch = parts[2]
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(description)
    }
}

// MARK: - Pack Types

/// Types of content packs
enum PackType: String, Codable {
    /// Campaign content: regions, events, quests, enemies, story
    case campaign

    /// Character/Hero content: heroes, starting decks, player cards
    /// Note: Called "Character Pack" (not "Investigator Pack" as in Arkham Horror)
    /// to match Twilight Marches theme
    case character

    /// Balance tuning: numbers, weights, costs (no new content)
    case balance

    /// Rules extension: new game mechanics, capabilities
    case rulesExtension = "rules_extension"

    /// Full standalone pack: complete game content
    case full
}

/// Pack dependency declaration
struct PackDependency: Codable, Hashable {
    /// ID of required pack
    let packId: String

    /// Minimum required version
    let minVersion: SemanticVersion

    /// Maximum compatible version (nil = any)
    let maxVersion: SemanticVersion?

    /// Is this dependency optional?
    let isOptional: Bool

    init(packId: String, minVersion: SemanticVersion, maxVersion: SemanticVersion? = nil, isOptional: Bool = false) {
        self.packId = packId
        self.minVersion = minVersion
        self.maxVersion = maxVersion
        self.isOptional = isOptional
    }
}

// MARK: - Content Inventory

/// Summary of content provided by a pack
struct ContentInventory: Codable {
    let regionCount: Int
    let eventCount: Int
    let questCount: Int
    let heroCount: Int
    let cardCount: Int
    let anchorCount: Int
    let enemyCount: Int

    let hasBalanceConfig: Bool
    let hasRulesExtension: Bool
    let hasCampaignContent: Bool

    /// Supported locales (e.g., ["en", "ru"])
    let supportedLocales: [String]

    static let empty = ContentInventory(
        regionCount: 0, eventCount: 0, questCount: 0,
        heroCount: 0, cardCount: 0, anchorCount: 0, enemyCount: 0,
        hasBalanceConfig: false, hasRulesExtension: false, hasCampaignContent: false,
        supportedLocales: []
    )
}

// MARK: - Pack Load Errors

/// Errors that can occur during pack loading
enum PackLoadError: Error, LocalizedError {
    case manifestNotFound(path: String)
    case invalidManifest(reason: String)
    case incompatibleCoreVersion(required: SemanticVersion, current: SemanticVersion)
    case missingDependency(packId: String, required: SemanticVersion)
    case dependencyVersionMismatch(packId: String, required: SemanticVersion, found: SemanticVersion)
    case contentLoadFailed(file: String, underlyingError: Error)
    case validationFailed(errorCount: Int, firstError: String)
    case checksumMismatch(file: String, expected: String, actual: String)
    case fileNotFound(_ path: String)  // Epic 0.3: checksum verification
    case packAlreadyLoaded(packId: String)
    case circularDependency(chain: [String])

    var errorDescription: String? {
        switch self {
        case .manifestNotFound(let path):
            return "Pack manifest not found at: \(path)"
        case .invalidManifest(let reason):
            return "Invalid pack manifest: \(reason)"
        case .incompatibleCoreVersion(let required, let current):
            return "Pack requires Core \(required), but running \(current)"
        case .missingDependency(let packId, let version):
            return "Missing dependency: \(packId) >= \(version)"
        case .dependencyVersionMismatch(let packId, let required, let found):
            return "Dependency \(packId) requires \(required), found \(found)"
        case .contentLoadFailed(let file, let error):
            return "Failed to load \(file): \(error.localizedDescription)"
        case .validationFailed(let errorCount, let firstError):
            return "Validation failed with \(errorCount) errors. First: \(firstError)"
        case .checksumMismatch(let file, let expected, let actual):
            return "Checksum mismatch for \(file): expected \(expected), got \(actual)"
        case .fileNotFound(let path):
            return "File not found: \(path)"
        case .packAlreadyLoaded(let packId):
            return "Pack already loaded: \(packId)"
        case .circularDependency(let chain):
            return "Circular dependency detected: \(chain.joined(separator: " -> "))"
        }
    }
}

// MARK: - Loaded Pack

/// Represents a successfully loaded pack
struct LoadedPack {
    let manifest: PackManifest
    let sourceURL: URL
    let loadedAt: Date

    /// Content provided by this pack (indexed by ID)
    var regions: [String: RegionDefinition] = [:]
    var events: [String: EventDefinition] = [:]
    var quests: [String: QuestDefinition] = [:]
    var anchors: [String: AnchorDefinition] = [:]
    var heroes: [String: StandardHeroDefinition] = [:]
    var cards: [String: StandardCardDefinition] = [:]
    var enemies: [String: EnemyDefinition] = [:]

    /// Balance configuration (if pack provides one)
    var balanceConfig: BalanceConfiguration?

    /// Computed inventory
    var inventory: ContentInventory {
        ContentInventory(
            regionCount: regions.count,
            eventCount: events.count,
            questCount: quests.count,
            heroCount: heroes.count,
            cardCount: cards.count,
            anchorCount: anchors.count,
            enemyCount: enemies.count,
            hasBalanceConfig: balanceConfig != nil,
            hasRulesExtension: false, // TODO: Add rules extension support
            hasCampaignContent: !regions.isEmpty || !events.isEmpty || !quests.isEmpty,
            supportedLocales: manifest.supportedLocales
        )
    }
}

// MARK: - Core Version

/// Current version of the Core engine
/// This is the single source of truth for engine version
struct CoreVersion {
    static let current = SemanticVersion(major: 1, minor: 0, patch: 0)

    /// Minimum pack version that current core supports
    static let minSupportedPackVersion = SemanticVersion(major: 1, minor: 0, patch: 0)
}


// ==========================================
// FILE: Engine/ContentPacks/PackValidator.swift
// ==========================================

import Foundation

// MARK: - Pack Validator

/// Comprehensive validator for content packs
/// Validates structure, references, balance, and content integrity
final class PackValidator {
    // MARK: - Types

    /// Validation severity level
    enum Severity: String, CaseIterable {
        case error = "ERROR"      // Pack cannot be loaded
        case warning = "WARNING"  // Pack loads but may have issues
        case info = "INFO"        // Informational, not a problem
    }

    /// Validation result for a single check
    struct ValidationResult {
        let severity: Severity
        let category: String
        let message: String
        let file: String?
        let line: Int?

        var description: String {
            var desc = "[\(severity.rawValue)] \(category): \(message)"
            if let file = file {
                desc += " (in \(file)"
                if let line = line {
                    desc += ":\(line)"
                }
                desc += ")"
            }
            return desc
        }
    }

    /// Summary of validation results
    struct ValidationSummary {
        let packId: String
        let results: [ValidationResult]
        let duration: TimeInterval

        var errorCount: Int { results.filter { $0.severity == .error }.count }
        var warningCount: Int { results.filter { $0.severity == .warning }.count }
        var infoCount: Int { results.filter { $0.severity == .info }.count }

        var isValid: Bool { errorCount == 0 }

        var description: String {
            var lines: [String] = []
            lines.append("=== Pack Validation: \(packId) ===")
            lines.append("Duration: \(String(format: "%.2f", duration))s")
            lines.append("Errors: \(errorCount), Warnings: \(warningCount), Info: \(infoCount)")
            lines.append("")

            if !results.isEmpty {
                for result in results {
                    lines.append(result.description)
                }
            } else {
                lines.append("No issues found.")
            }

            lines.append("")
            lines.append(isValid ? "VALIDATION PASSED" : "VALIDATION FAILED")
            return lines.joined(separator: "\n")
        }
    }

    // MARK: - Properties

    private var results: [ValidationResult] = []
    private let packURL: URL
    private var manifest: PackManifest?
    private var loadedPack: LoadedPack?

    // MARK: - Initialization

    init(packURL: URL) {
        self.packURL = packURL
    }

    // MARK: - Public API

    /// Validate a pack at the given URL
    /// - Returns: Validation summary with all results
    func validate() -> ValidationSummary {
        let startTime = Date()
        results.removeAll()

        // Phase 1: Validate manifest
        validateManifest()

        // Phase 2: Validate file structure
        if manifest != nil {
            validateFileStructure()
        }

        // Phase 3: Load and validate content
        if manifest != nil {
            validateContent()
        }

        // Phase 4: Validate cross-references
        if loadedPack != nil {
            validateCrossReferences()
        }

        // Phase 5: Validate balance configuration
        if let pack = loadedPack, pack.balanceConfig != nil {
            validateBalanceConfig()
        }

        let duration = Date().timeIntervalSince(startTime)
        return ValidationSummary(
            packId: manifest?.packId ?? "unknown",
            results: results,
            duration: duration
        )
    }

    /// Validate pack and return just the error/warning count
    static func quickValidate(packURL: URL) -> (errors: Int, warnings: Int) {
        let validator = PackValidator(packURL: packURL)
        let summary = validator.validate()
        return (summary.errorCount, summary.warningCount)
    }

    // MARK: - Phase 1: Manifest Validation

    private func validateManifest() {
        let manifestURL = packURL.appendingPathComponent("manifest.json")

        // Check manifest exists
        guard FileManager.default.fileExists(atPath: manifestURL.path) else {
            addError("Manifest", "manifest.json not found at pack root")
            return
        }

        // Try to load manifest
        do {
            manifest = try PackManifest.load(from: packURL)
        } catch {
            addError("Manifest", "Failed to parse manifest.json: \(error.localizedDescription)")
            return
        }

        guard let manifest = manifest else { return }

        // Validate required fields
        if manifest.packId.isEmpty {
            addError("Manifest", "packId is required")
        }

        if manifest.packId.contains(" ") {
            addWarning("Manifest", "packId should not contain spaces: '\(manifest.packId)'")
        }

        if manifest.displayName.en.isEmpty {
            addError("Manifest", "displayName.en is required")
        }

        // Validate version
        if manifest.version.major == 0 && manifest.version.minor == 0 && manifest.version.patch == 0 {
            addWarning("Manifest", "Version 0.0.0 suggests pack is not properly versioned")
        }

        // Validate Core compatibility
        if !manifest.isCompatibleWithCore() {
            addError("Manifest", "Pack requires Core version \(manifest.coreVersionMin), but current is \(CoreVersion.current)")
        }

        // Validate entry points for campaign packs
        if manifest.packType == .campaign || manifest.packType == .full {
            if manifest.entryRegionId == nil {
                addWarning("Manifest", "Campaign pack should specify entryRegionId")
            }
        }

        // Validate paths exist
        validateManifestPaths(manifest)

        addInfo("Manifest", "Loaded pack '\(manifest.packId)' v\(manifest.version)")
    }

    private func validateManifestPaths(_ manifest: PackManifest) {
        let paths = [
            ("regionsPath", manifest.regionsPath),
            ("eventsPath", manifest.eventsPath),
            ("heroesPath", manifest.heroesPath),
            ("cardsPath", manifest.cardsPath),
            ("balancePath", manifest.balancePath),
            ("localizationPath", manifest.localizationPath)
        ]

        for (name, path) in paths {
            if let path = path {
                let fullPath = packURL.appendingPathComponent(path)
                if !FileManager.default.fileExists(atPath: fullPath.path) {
                    addWarning("Manifest", "\(name) points to non-existent path: \(path)")
                }
            }
        }
    }

    // MARK: - Phase 2: File Structure Validation

    private func validateFileStructure() {
        guard let manifest = manifest else { return }

        // Check for required directories based on pack type
        switch manifest.packType {
        case .campaign, .full:
            checkDirectory("Campaign content", manifest.regionsPath)
            checkDirectory("Events", manifest.eventsPath)

        case .character:
            checkDirectory("Heroes", manifest.heroesPath)
            checkDirectory("Cards", manifest.cardsPath)

        case .balance:
            checkDirectory("Balance", manifest.balancePath)

        case .rulesExtension:
            break // No specific requirements
        }

        // Check localization
        if let locPath = manifest.localizationPath {
            let locURL = packURL.appendingPathComponent(locPath)
            if FileManager.default.fileExists(atPath: locURL.path) {
                for locale in manifest.supportedLocales {
                    let localeFile = locURL.appendingPathComponent("\(locale).json")
                    if !FileManager.default.fileExists(atPath: localeFile.path) {
                        addWarning("Localization", "Missing localization file for locale '\(locale)'")
                    }
                }
            }
        }
    }

    private func checkDirectory(_ name: String, _ path: String?) {
        guard let path = path else {
            addWarning("Structure", "\(name) path not specified in manifest")
            return
        }

        let fullPath = packURL.appendingPathComponent(path)
        var isDirectory: ObjCBool = false

        if !FileManager.default.fileExists(atPath: fullPath.path, isDirectory: &isDirectory) {
            addWarning("Structure", "\(name) directory not found: \(path)")
        } else if !isDirectory.boolValue {
            // Check if it's a file (like regions.json instead of regions/)
            if !fullPath.pathExtension.isEmpty {
                addInfo("Structure", "\(name) is a file: \(path)")
            }
        }
    }

    // MARK: - Phase 3: Content Validation

    private func validateContent() {
        guard let manifest = manifest else { return }

        do {
            loadedPack = try PackLoader.load(manifest: manifest, from: packURL)
            addInfo("Content", "Loaded \(loadedPack?.regions.count ?? 0) regions, \(loadedPack?.events.count ?? 0) events, \(loadedPack?.heroes.count ?? 0) heroes, \(loadedPack?.cards.count ?? 0) cards")
        } catch {
            addError("Content", "Failed to load pack content: \(error.localizedDescription)")
            return
        }

        guard let pack = loadedPack else { return }

        // Validate regions
        for (id, region) in pack.regions {
            validateRegion(id: id, region: region)
        }

        // Validate events
        for (id, event) in pack.events {
            validateEvent(id: id, event: event)
        }

        // Validate heroes
        for (id, hero) in pack.heroes {
            validateHero(id: id, hero: hero)
        }

        // Validate cards
        for (id, card) in pack.cards {
            validateCard(id: id, card: card)
        }

        // Validate anchors
        for (id, anchor) in pack.anchors {
            validateAnchor(id: id, anchor: anchor)
        }
    }

    private func validateRegion(id: String, region: RegionDefinition) {
        if region.title.en.isEmpty {
            addError("Region", "Region '\(id)' has empty English title")
        }

        if region.neighborIds.isEmpty {
            addWarning("Region", "Region '\(id)' has no neighbors (isolated)")
        }

        // Check for self-reference
        if region.neighborIds.contains(id) {
            addError("Region", "Region '\(id)' lists itself as neighbor")
        }
    }

    private func validateEvent(id: String, event: EventDefinition) {
        if event.title.en.isEmpty {
            addError("Event", "Event '\(id)' has empty English title")
        }

        if event.choices.isEmpty {
            addWarning("Event", "Event '\(id)' has no choices")
        }

        // Validate choices
        var choiceIds = Set<String>()
        for choice in event.choices {
            if choiceIds.contains(choice.id) {
                addError("Event", "Event '\(id)' has duplicate choice ID: \(choice.id)")
            }
            choiceIds.insert(choice.id)

            if choice.label.en.isEmpty {
                addWarning("Event", "Event '\(id)' choice '\(choice.id)' has empty label")
            }
        }

        // Validate weight
        if event.weight <= 0 {
            addWarning("Event", "Event '\(id)' has non-positive weight: \(event.weight)")
        }
    }

    private func validateHero(id: String, hero: StandardHeroDefinition) {
        if hero.name.isEmpty {
            addError("Hero", "Hero '\(id)' has empty name")
        }

        if hero.startingDeckCardIDs.isEmpty {
            addWarning("Hero", "Hero '\(id)' has empty starting deck")
        }

        // Check for duplicate cards in starting deck
        let uniqueCards = Set(hero.startingDeckCardIDs)
        if uniqueCards.count != hero.startingDeckCardIDs.count {
            addInfo("Hero", "Hero '\(id)' has duplicate cards in starting deck")
        }
    }

    private func validateCard(id: String, card: StandardCardDefinition) {
        if card.name.isEmpty {
            addError("Card", "Card '\(id)' has empty name")
        }

        if card.faithCost < 0 {
            addError("Card", "Card '\(id)' has negative faith cost: \(card.faithCost)")
        }
    }

    private func validateAnchor(id: String, anchor: AnchorDefinition) {
        if anchor.title.en.isEmpty {
            addError("Anchor", "Anchor '\(id)' has empty English title")
        }

        if anchor.initialIntegrity < 0 || anchor.initialIntegrity > anchor.maxIntegrity {
            addError("Anchor", "Anchor '\(id)' has invalid initial integrity: \(anchor.initialIntegrity) (max: \(anchor.maxIntegrity))")
        }

        if anchor.maxIntegrity <= 0 {
            addError("Anchor", "Anchor '\(id)' has non-positive max integrity: \(anchor.maxIntegrity)")
        }
    }

    // MARK: - Phase 4: Cross-Reference Validation

    private func validateCrossReferences() {
        guard let pack = loadedPack else { return }

        // Region neighbor references
        for (id, region) in pack.regions {
            for neighborId in region.neighborIds {
                if pack.regions[neighborId] == nil {
                    addError("Reference", "Region '\(id)' references non-existent neighbor '\(neighborId)'")
                }
            }
        }

        // Check bidirectional neighbors
        for (id, region) in pack.regions {
            for neighborId in region.neighborIds {
                if let neighbor = pack.regions[neighborId] {
                    if !neighbor.neighborIds.contains(id) {
                        addWarning("Reference", "Region '\(id)' → '\(neighborId)' is not bidirectional")
                    }
                }
            }
        }

        // Anchor region references
        for (id, anchor) in pack.anchors {
            if pack.regions[anchor.regionId] == nil {
                addError("Reference", "Anchor '\(id)' references non-existent region '\(anchor.regionId)'")
            }
        }

        // Event region references
        for (id, event) in pack.events {
            if let regionIds = event.availability.regionIds {
                for regionId in regionIds {
                    if pack.regions[regionId] == nil {
                        addError("Reference", "Event '\(id)' references non-existent region '\(regionId)'")
                    }
                }
            }
        }

        // Hero starting deck references
        for (id, hero) in pack.heroes {
            for cardId in hero.startingDeckCardIDs {
                if pack.cards[cardId] == nil {
                    addError("Reference", "Hero '\(id)' references non-existent card '\(cardId)'")
                }
            }
        }

        // Entry region validation
        if let manifest = manifest, let entryRegionId = manifest.entryRegionId {
            if pack.regions[entryRegionId] == nil {
                addError("Reference", "Manifest entryRegionId '\(entryRegionId)' not found in regions")
            }
        }
    }

    // MARK: - Phase 5: Balance Validation

    private func validateBalanceConfig() {
        guard let pack = loadedPack, let balance = pack.balanceConfig else { return }

        // Resource validation
        if balance.resources.maxHealth <= 0 {
            addError("Balance", "maxHealth must be positive: \(balance.resources.maxHealth)")
        }

        if balance.resources.startingHealth > balance.resources.maxHealth {
            addError("Balance", "startingHealth (\(balance.resources.startingHealth)) exceeds maxHealth (\(balance.resources.maxHealth))")
        }

        if balance.resources.startingHealth <= 0 {
            addWarning("Balance", "startingHealth is non-positive: \(balance.resources.startingHealth)")
        }

        if balance.resources.maxFaith <= 0 {
            addError("Balance", "maxFaith must be positive: \(balance.resources.maxFaith)")
        }

        if balance.resources.startingFaith > balance.resources.maxFaith {
            addError("Balance", "startingFaith (\(balance.resources.startingFaith)) exceeds maxFaith (\(balance.resources.maxFaith))")
        }

        // Pressure validation
        if balance.pressure.maxPressure <= 0 {
            addError("Balance", "maxPressure must be positive: \(balance.pressure.maxPressure)")
        }

        if balance.pressure.startingPressure < 0 {
            addWarning("Balance", "startingPressure is negative: \(balance.pressure.startingPressure)")
        }

        if balance.pressure.startingPressure > balance.pressure.maxPressure {
            addError("Balance", "startingPressure (\(balance.pressure.startingPressure)) exceeds maxPressure (\(balance.pressure.maxPressure))")
        }

        // Anchor validation
        if balance.anchor.maxIntegrity <= 0 {
            addError("Balance", "anchor.maxIntegrity must be positive: \(balance.anchor.maxIntegrity)")
        }

        if balance.anchor.strengthenCost < 0 {
            addError("Balance", "anchor.strengthenCost cannot be negative: \(balance.anchor.strengthenCost)")
        }

        if balance.anchor.strengthenAmount <= 0 {
            addWarning("Balance", "anchor.strengthenAmount is non-positive: \(balance.anchor.strengthenAmount)")
        }

        // Time validation
        if balance.time.unitsPerDay <= 0 {
            addError("Balance", "unitsPerDay must be positive: \(balance.time.unitsPerDay)")
        }

        addInfo("Balance", "Balance configuration validated")
    }

    // MARK: - Helper Methods

    private func addError(_ category: String, _ message: String, file: String? = nil, line: Int? = nil) {
        results.append(ValidationResult(severity: .error, category: category, message: message, file: file, line: line))
    }

    private func addWarning(_ category: String, _ message: String, file: String? = nil, line: Int? = nil) {
        results.append(ValidationResult(severity: .warning, category: category, message: message, file: file, line: line))
    }

    private func addInfo(_ category: String, _ message: String, file: String? = nil, line: Int? = nil) {
        results.append(ValidationResult(severity: .info, category: category, message: message, file: file, line: line))
    }
}

// MARK: - CLI Support

extension PackValidator {
    /// Run validation and print results to console (DEBUG only)
    static func validateAndPrint(packURL: URL) -> Bool {
        let validator = PackValidator(packURL: packURL)
        let summary = validator.validate()
        #if DEBUG
        print(summary.description)
        #endif
        return summary.isValid
    }

    /// Validate multiple packs (DEBUG only for console output)
    static func validateMultiple(packURLs: [URL]) -> Bool {
        var allValid = true

        for url in packURLs {
            #if DEBUG
            print("\n" + String(repeating: "=", count: 60))
            #endif
            let isValid = validateAndPrint(packURL: url)
            allValid = allValid && isValid
        }

        #if DEBUG
        print("\n" + String(repeating: "=", count: 60))
        print(allValid ? "ALL PACKS VALID" : "SOME PACKS HAVE ERRORS")
        #endif

        return allValid
    }
}


// ==========================================
// FILE: Engine/Quest/QuestTriggerEngine.swift
// ==========================================

import Foundation

// MARK: - Quest Trigger Engine
// Data-driven quest progression system
// Replaces hardcoded checkQuestObjectives* methods in WorldState

/// Engine for evaluating quest triggers and updating quest progress
/// All quest logic is data-driven from QuestDefinition/ObjectiveDefinition
final class QuestTriggerEngine {

    // MARK: - Dependencies

    private let contentRegistry: ContentRegistry

    // MARK: - Initialization

    init(contentRegistry: ContentRegistry = .shared) {
        self.contentRegistry = contentRegistry
    }

    // MARK: - Action Processing

    /// Process a game action and return quest progress updates
    /// Called after every action to check if any quest objectives are triggered
    func processAction(
        _ action: QuestTriggerAction,
        context: QuestTriggerContext
    ) -> [QuestProgressUpdate] {
        var updates: [QuestProgressUpdate] = []

        // Get all active quests
        let activeQuests = context.activeQuests

        for questState in activeQuests {
            guard let questDef = contentRegistry.getQuest(id: questState.definitionId) else {
                continue
            }

            // Check current objective
            guard let currentObjectiveId = questState.currentObjectiveId,
                  let objectiveDef = questDef.objectives.first(where: { $0.id == currentObjectiveId }) else {
                continue
            }

            // Evaluate if objective is completed by this action
            if evaluateCondition(objectiveDef.completionCondition, action: action, context: context) {
                let update = QuestProgressUpdate(
                    questId: questDef.id,
                    objectiveId: currentObjectiveId,
                    type: .objectiveCompleted,
                    nextObjectiveId: objectiveDef.nextObjectiveId,
                    flagsToSet: extractFlagsToSet(from: objectiveDef, questDef: questDef)
                )
                updates.append(update)
            }
        }

        // Check for newly available quests
        let newQuestUpdates = checkForNewQuests(action: action, context: context)
        updates.append(contentsOf: newQuestUpdates)

        return updates
    }

    // MARK: - Condition Evaluation

    /// Evaluate a single completion condition against an action
    func evaluateCondition(
        _ condition: CompletionCondition,
        action: QuestTriggerAction,
        context: QuestTriggerContext
    ) -> Bool {
        switch condition {
        case .flagSet(let flagName):
            return context.worldFlags[flagName] == true

        case .visitRegion(let regionId):
            if case .visitedRegion(let visitedId) = action {
                return visitedId == regionId
            }
            return false

        case .eventCompleted(let eventId):
            if case .completedEvent(let completedId, _) = action {
                return completedId == eventId
            }
            return false

        case .choiceMade(let eventId, let choiceId):
            if case .completedEvent(let completedEventId, let selectedChoiceId) = action {
                return completedEventId == eventId && selectedChoiceId == choiceId
            }
            return false

        case .resourceThreshold(let resourceId, let minValue):
            let currentValue = context.resources[resourceId] ?? 0
            return currentValue >= minValue

        case .defeatEnemy(let enemyId):
            if case .defeatedEnemy(let defeatedId) = action {
                return defeatedId == enemyId
            }
            return false

        case .collectItem(let itemId):
            if case .collectedItem(let collectedId) = action {
                return collectedId == itemId
            }
            return false

        case .manual:
            if case .manualProgress = action {
                // Manual triggers need explicit objective ID match
                return true
            }
            return false
        }
    }

    // MARK: - New Quest Availability

    /// Check if any new quests become available after this action
    private func checkForNewQuests(
        action: QuestTriggerAction,
        context: QuestTriggerContext
    ) -> [QuestProgressUpdate] {
        var updates: [QuestProgressUpdate] = []

        let allQuests = contentRegistry.getAllQuests()
        let activeQuestIds = Set(context.activeQuests.map { $0.definitionId })
        let completedQuestIds = context.completedQuestIds

        for questDef in allQuests {
            // Skip already active or completed quests
            if activeQuestIds.contains(questDef.id) || completedQuestIds.contains(questDef.id) {
                continue
            }

            // Check availability conditions
            if isQuestAvailable(questDef, context: context) {
                if questDef.autoStart {
                    let update = QuestProgressUpdate(
                        questId: questDef.id,
                        objectiveId: questDef.objectives.first?.id,
                        type: .questStarted,
                        nextObjectiveId: questDef.objectives.first?.id,
                        flagsToSet: []
                    )
                    updates.append(update)
                }
            }
        }

        return updates
    }

    /// Check if a quest's availability conditions are met
    private func isQuestAvailable(_ quest: QuestDefinition, context: QuestTriggerContext) -> Bool {
        return checkAvailability(quest.availability, context: context)
    }

    // MARK: - Flag Extraction

    /// Extract flags that should be set when objective completes
    private func extractFlagsToSet(
        from objective: ObjectiveDefinition,
        questDef: QuestDefinition
    ) -> [String] {
        var flags: [String] = []

        // Check if this is the final objective
        if objective.nextObjectiveId == nil && objective.alternativeNextIds.isEmpty {
            // Quest completion - add completion flags from rewards
            flags.append(contentsOf: questDef.completionRewards.setFlags)
        }

        return flags
    }
}

// MARK: - Quest Trigger Action

/// Actions that can trigger quest progression
enum QuestTriggerAction {
    /// Player visited a region
    case visitedRegion(regionId: String)

    /// Player completed an event with a specific choice
    case completedEvent(eventId: String, choiceId: String)

    /// Player defeated an enemy
    case defeatedEnemy(enemyId: String)

    /// Player collected an item
    case collectedItem(itemId: String)

    /// Flag was set (can trigger flag-based conditions)
    case flagSet(flagName: String)

    /// Manual progress trigger (for special cases)
    case manualProgress(objectiveId: String)

    /// Resource changed (can trigger threshold conditions)
    case resourceChanged(resourceId: String, newValue: Int)
}

// MARK: - Quest Trigger Context

/// Context needed for evaluating quest triggers
struct QuestTriggerContext {
    /// Currently active quests with their state
    let activeQuests: [QuestState]

    /// IDs of completed quests
    let completedQuestIds: Set<String>

    /// Current world flags
    let worldFlags: [String: Bool]

    /// Current resources (health, faith, etc.)
    let resources: [String: Int]

    /// Current game day
    let currentDay: Int

    /// Current region ID
    let currentRegionId: String
}

/// Minimal quest state for trigger evaluation
struct QuestState {
    let definitionId: String
    let currentObjectiveId: String?
    let completedObjectiveIds: Set<String>
}

// MARK: - Quest Progress Update

/// Result of quest trigger evaluation
struct QuestProgressUpdate {
    /// Quest that was updated
    let questId: String

    /// Objective that was completed (if any)
    let objectiveId: String?

    /// Type of update
    let type: QuestUpdateType

    /// Next objective to activate (if any)
    let nextObjectiveId: String?

    /// Flags to set as a result of this update
    let flagsToSet: [String]
}

/// Type of quest update
enum QuestUpdateType {
    case questStarted
    case objectiveCompleted
    case questCompleted
    case questFailed
}

// MARK: - Availability Check

extension QuestTriggerEngine {
    /// Check if availability conditions are met
    func checkAvailability(_ availability: Availability, context: QuestTriggerContext) -> Bool {
        // Check required flags
        for flag in availability.requiredFlags {
            if context.worldFlags[flag] != true {
                return false
            }
        }

        // Check forbidden flags
        for flag in availability.forbiddenFlags {
            if context.worldFlags[flag] == true {
                return false
            }
        }

        // Check pressure/tension range
        if let minPressure = availability.minPressure {
            let tension = context.resources["tension"] ?? 0
            if tension < minPressure {
                return false
            }
        }
        if let maxPressure = availability.maxPressure {
            let tension = context.resources["tension"] ?? 0
            if tension > maxPressure {
                return false
            }
        }

        return true
    }
}


// ==========================================
// FILE: Engine/Events/EventPipeline.swift
// ==========================================

import Foundation

// MARK: - Event Pipeline
// Handles the complete flow: Selection → Resolution → Consequences

/// Main event processing pipeline
final class EventPipeline {
    // MARK: - Dependencies

    private let selector: EventSelector
    private let resolver: EventResolver

    // MARK: - Initialization

    init(
        selector: EventSelector = EventSelector(),
        resolver: EventResolver = EventResolver()
    ) {
        self.selector = selector
        self.resolver = resolver
    }

    // MARK: - Pipeline Methods

    /// Process a trigger and return available events
    func getAvailableEvents(
        for context: EventContext,
        from events: [GameEvent]
    ) -> [GameEvent] {
        return selector.selectAvailableEvents(from: events, context: context)
    }

    /// Select a single event based on weights
    func selectEvent(
        from events: [GameEvent],
        context: EventContext
    ) -> GameEvent? {
        let available = selector.selectAvailableEvents(from: events, context: context)
        return selector.weightedSelect(from: available)
    }

    /// Resolve an event choice and return state changes
    func resolveChoice(
        event: GameEvent,
        choiceIndex: Int,
        context: EventResolutionContext
    ) -> EventResolutionResult {
        return resolver.resolve(event: event, choiceIndex: choiceIndex, context: context)
    }

    /// Check if a choice is available
    func canChoose(
        event: GameEvent,
        choiceIndex: Int,
        context: EventContext
    ) -> (available: Bool, reason: String?) {
        guard choiceIndex < event.choices.count else {
            return (false, "Invalid choice index")
        }

        let choice = event.choices[choiceIndex]

        // Check requirements if present
        guard let requirements = choice.requirements else {
            return (true, nil)  // No requirements = always available
        }

        // Check minimum faith
        if let minFaith = requirements.minimumFaith {
            let currentFaith = context.resources["faith"] ?? 0
            if currentFaith < minFaith {
                return (false, "Недостаточно веры (нужно \(minFaith))")
            }
        }

        // Check minimum health
        if let minHealth = requirements.minimumHealth {
            let currentHealth = context.resources["health"] ?? 0
            if currentHealth < minHealth {
                return (false, "Недостаточно здоровья (нужно \(minHealth))")
            }
        }

        // Check required flags
        if let requiredFlags = requirements.requiredFlags {
            for flag in requiredFlags {
                if context.flags[flag] != true {
                    return (false, "Требуется флаг: \(flag)")
                }
            }
        }

        return (true, nil)
    }
}

// MARK: - Event Selector

/// Handles event filtering and weighted selection
final class EventSelector {
    // MARK: - Selection

    /// Filter events by availability criteria
    func selectAvailableEvents(
        from events: [GameEvent],
        context: EventContext
    ) -> [GameEvent] {
        return events.filter { event in
            isEventAvailable(event, context: context)
        }
    }

    /// Check if single event is available based on GameEvent's actual properties
    func isEventAvailable(_ event: GameEvent, context: EventContext) -> Bool {
        // Check if already completed (for oneTime events)
        if event.oneTime && event.completed {
            return false
        }

        // Also check against context's completed set
        if event.oneTime && context.completedEvents.contains(event.id.uuidString) {
            return false
        }

        // Check region type requirements (empty = any region)
        if !event.regionTypes.isEmpty {
            guard let regionType = RegionType(rawValue: context.currentLocation) else {
                return false
            }
            if !event.regionTypes.contains(regionType) {
                return false
            }
        }

        // Check region state requirements (empty = any state)
        if !event.regionStates.isEmpty {
            guard let regionState = RegionState(rawValue: context.locationState) else {
                return false
            }
            if !event.regionStates.contains(regionState) {
                return false
            }
        }

        // Check event's required flags against context flags
        if let eventRequiredFlags = event.requiredFlags {
            for flag in eventRequiredFlags where context.flags[flag] != true {
                return false
            }
        }

        // Check event's forbidden flags
        if let forbiddenFlags = event.forbiddenFlags {
            for flag in forbiddenFlags where context.flags[flag] == true {
                return false
            }
        }

        return true
    }

    /// Select event using weighted random selection
    func weightedSelect(from events: [GameEvent]) -> GameEvent? {
        guard !events.isEmpty else { return nil }

        let totalWeight = events.reduce(0) { $0 + $1.weight }

        guard totalWeight > 0 else {
            // If all weights are 0, select randomly
            let index = WorldRNG.shared.nextInt(in: 0..<events.count)
            return events[index]
        }

        let roll = WorldRNG.shared.nextInt(in: 0..<totalWeight)
        var cumulative = 0

        for event in events {
            cumulative += event.weight
            if roll < cumulative {
                return event
            }
        }

        // Fallback (shouldn't reach here)
        return events.last
    }
}

// MARK: - Event Resolver

/// Handles event resolution and consequence calculation
final class EventResolver {
    // MARK: - Resolution

    /// Resolve an event choice
    func resolve(
        event: GameEvent,
        choiceIndex: Int,
        context: EventResolutionContext
    ) -> EventResolutionResult {
        guard choiceIndex < event.choices.count else {
            return EventResolutionResult(
                success: false,
                error: "Invalid choice index",
                stateChanges: [],
                triggeredCombat: nil,
                triggeredMiniGame: nil,
                narrativeText: nil
            )
        }

        let choice = event.choices[choiceIndex]
        var stateChanges: [StateChange] = []

        // Apply consequences
        let consequences = choice.consequences

        // Health changes (optional Int?)
        if let healthDelta = consequences.healthChange, healthDelta != 0 {
            let newHealth = max(0, context.currentHealth + healthDelta)
            stateChanges.append(.healthChanged(
                delta: healthDelta,
                newValue: newHealth
            ))
        }

        // Faith changes (optional Int?)
        if let faithDelta = consequences.faithChange, faithDelta != 0 {
            let newFaith = max(0, context.currentFaith + faithDelta)
            stateChanges.append(.faithChanged(
                delta: faithDelta,
                newValue: newFaith
            ))
        }

        // Balance changes (optional Int?)
        if let balanceDelta = consequences.balanceChange, balanceDelta != 0 {
            let newBalance = max(0, min(100, context.currentBalance + balanceDelta))
            stateChanges.append(.balanceChanged(
                delta: balanceDelta,
                newValue: newBalance
            ))
        }

        // Tension changes (optional Int?)
        if let tensionDelta = consequences.tensionChange, tensionDelta != 0 {
            let newTension = max(0, min(100, context.currentTension + tensionDelta))
            stateChanges.append(.tensionChanged(
                delta: tensionDelta,
                newValue: newTension
            ))
        }

        // Set flags (optional dictionary)
        if let flagsToSet = consequences.setFlags {
            for (flag, value) in flagsToSet {
                stateChanges.append(.flagSet(key: flag, value: value))
            }
        }

        // Check for triggered combat (monster card in event)
        var triggeredCombat: UUID? = nil
        if event.monsterCard != nil {
            // Combat events have monsterCard, use event ID as combat trigger
            triggeredCombat = event.id
        }

        // Check for triggered mini-game (not directly in EventConsequences,
        // would be triggered through specific event types or flags)
        let triggeredMiniGame: UUID? = nil

        // Mark event as completed if oneTime
        if event.oneTime {
            stateChanges.append(.eventCompleted(eventId: event.id))
        }

        return EventResolutionResult(
            success: true,
            error: nil,
            stateChanges: stateChanges,
            triggeredCombat: triggeredCombat,
            triggeredMiniGame: triggeredMiniGame,
            narrativeText: consequences.message
        )
    }
}

// MARK: - Supporting Types
// Note: EventContext is defined in EngineProtocols.swift

/// Context for event resolution
struct EventResolutionContext {
    let currentHealth: Int
    let currentFaith: Int
    let currentBalance: Int
    let currentTension: Int
    let currentFlags: [String: Bool]
}

/// Result of event resolution
struct EventResolutionResult {
    let success: Bool
    let error: String?
    let stateChanges: [StateChange]
    let triggeredCombat: UUID?
    let triggeredMiniGame: UUID?
    let narrativeText: String?
}

/// Event filter criteria for selection (different from EventRequirements in ExplorationModels)
struct EventFilterCriteria {
    var location: String?
    var locationState: String?
    var pressureRange: ClosedRange<Int>?
    var requiredFlags: [String] = []
    var forbiddenFlags: [String] = []
    var minResources: [String: Int] = [:]

    static let none = EventFilterCriteria()
}

// MARK: - GameEvent Extension

extension GameEvent {
    /// Event filter criteria for engine filtering
    var filterCriteria: EventFilterCriteria {
        // Build filter criteria from event data
        // Note: Full implementation would extract criteria from regionTypes/regionStates
        let criteria = EventFilterCriteria()
        return criteria
    }
}

// Note: EventConsequences doesn't have triggeredEncounter or triggeredMiniGame
// Combat is triggered through GameEvent.monsterCard != nil
// Mini-games are triggered through specific event types or game logic


// ==========================================
// FILE: Engine/Events/MiniGameDispatcher.swift
// ==========================================

import Foundation

// MARK: - MiniGame Dispatcher
// Routes mini-game challenges to appropriate resolvers
// Returns result as StateChange diff (no direct state mutation)

/// Dispatches mini-game challenges to resolvers
final class MiniGameDispatcher {
    // MARK: - Resolvers

    private let combatResolver: CombatMiniGameResolver
    private let puzzleResolver: PuzzleMiniGameResolver
    private let skillCheckResolver: SkillCheckResolver

    // MARK: - Initialization

    init() {
        self.combatResolver = CombatMiniGameResolver()
        self.puzzleResolver = PuzzleMiniGameResolver()
        self.skillCheckResolver = SkillCheckResolver()
    }

    // MARK: - Dispatch

    /// Dispatch a mini-game challenge and return result
    func dispatch(
        challenge: MiniGameChallenge,
        context: MiniGameContext
    ) -> MiniGameDispatchResult {

        switch challenge.type {
        case .combat:
            return combatResolver.resolve(challenge: challenge, context: context)

        case .puzzle:
            return puzzleResolver.resolve(challenge: challenge, context: context)

        case .skillCheck:
            return skillCheckResolver.resolve(challenge: challenge, context: context)

        case .cardGame:
            // Card-based mini-game (future)
            return MiniGameDispatchResult.notImplemented(type: "cardGame")

        case .custom(let type):
            // Custom mini-game type
            return MiniGameDispatchResult.notImplemented(type: type)
        }
    }

    /// Check if challenge can be started
    func canStartChallenge(
        _ challenge: MiniGameChallenge,
        context: MiniGameContext
    ) -> (canStart: Bool, reason: String?) {

        // Check health minimum
        if context.playerHealth <= 0 {
            return (false, "Player health too low")
        }

        // Check type-specific requirements
        switch challenge.type {
        case .combat:
            // Combat requires health > 0
            return (true, nil)

        case .skillCheck:
            // Skill checks may require specific resources
            if let requiredResource = challenge.requirements["resource"],
               let required = challenge.requirements["amount"] as? Int,
               (context.playerResources[requiredResource as? String ?? ""] ?? 0) < required {
                return (false, "Insufficient \(requiredResource)")
            }
            return (true, nil)

        default:
            return (true, nil)
        }
    }
}

// MARK: - Mini-Game Challenge

/// Definition of a mini-game challenge
struct MiniGameChallenge {
    let id: UUID
    let type: MiniGameType
    let difficulty: Int
    let requirements: [String: Any]
    let rewards: MiniGameRewards
    let penalties: MiniGamePenalties

    init(
        id: UUID = UUID(),
        type: MiniGameType,
        difficulty: Int = 1,
        requirements: [String: Any] = [:],
        rewards: MiniGameRewards = MiniGameRewards(),
        penalties: MiniGamePenalties = MiniGamePenalties()
    ) {
        self.id = id
        self.type = type
        self.difficulty = difficulty
        self.requirements = requirements
        self.rewards = rewards
        self.penalties = penalties
    }
}

/// Types of mini-games
enum MiniGameType: Equatable {
    case combat
    case puzzle
    case skillCheck
    case cardGame
    case custom(String)
}

/// Rewards for completing mini-game
struct MiniGameRewards {
    var healthGain: Int = 0
    var faithGain: Int = 0
    var tensionReduction: Int = 0
    var flagsToSet: [String] = []
    var cardsToGain: [UUID] = []
}

/// Penalties for failing mini-game
struct MiniGamePenalties {
    var healthLoss: Int = 0
    var faithLoss: Int = 0
    var tensionIncrease: Int = 0
    var balanceShift: Int = 0
}

// MARK: - Mini-Game Context

/// Context for mini-game resolution
struct MiniGameContext {
    let playerHealth: Int
    let playerMaxHealth: Int
    let playerStrength: Int
    let playerFaith: Int
    let playerBalance: Int
    let playerResources: [String: Int]
    let worldTension: Int
    let currentFlags: [String: Bool]

    /// Build from Player and WorldState
    static func from(player: Player, worldState: WorldState) -> MiniGameContext {
        MiniGameContext(
            playerHealth: player.health,
            playerMaxHealth: player.maxHealth,
            playerStrength: player.strength,
            playerFaith: player.faith,
            playerBalance: player.balance,
            playerResources: ["faith": player.faith, "health": player.health],
            worldTension: worldState.worldTension,
            currentFlags: worldState.worldFlags
        )
    }
}

// MARK: - Mini-Game Dispatch Result

/// Result of mini-game dispatch
struct MiniGameDispatchResult {
    let success: Bool
    let completed: Bool
    let stateChanges: [StateChange]
    let narrativeText: String?
    let error: String?

    static func victory(changes: [StateChange], narrative: String? = nil) -> MiniGameDispatchResult {
        MiniGameDispatchResult(
            success: true,
            completed: true,
            stateChanges: changes,
            narrativeText: narrative,
            error: nil
        )
    }

    static func defeat(changes: [StateChange], narrative: String? = nil) -> MiniGameDispatchResult {
        MiniGameDispatchResult(
            success: true,
            completed: true,
            stateChanges: changes,
            narrativeText: narrative,
            error: nil
        )
    }

    static func inProgress(changes: [StateChange]) -> MiniGameDispatchResult {
        MiniGameDispatchResult(
            success: true,
            completed: false,
            stateChanges: changes,
            narrativeText: nil,
            error: nil
        )
    }

    static func notImplemented(type: String) -> MiniGameDispatchResult {
        MiniGameDispatchResult(
            success: false,
            completed: false,
            stateChanges: [],
            narrativeText: nil,
            error: "Mini-game type '\(type)' not implemented"
        )
    }

    static func failure(_ error: String) -> MiniGameDispatchResult {
        MiniGameDispatchResult(
            success: false,
            completed: false,
            stateChanges: [],
            narrativeText: nil,
            error: error
        )
    }
}

// MARK: - Combat Mini-Game Resolver

/// Resolves combat mini-games
final class CombatMiniGameResolver {
    func resolve(
        challenge: MiniGameChallenge,
        context: MiniGameContext
    ) -> MiniGameDispatchResult {

        var changes: [StateChange] = []

        // Simple combat resolution using WorldRNG
        let playerRoll = WorldRNG.shared.nextInt(in: 1...6) + context.playerStrength
        let enemyRoll = WorldRNG.shared.nextInt(in: 1...6) + challenge.difficulty

        if playerRoll >= enemyRoll {
            // Victory
            // Apply rewards
            if challenge.rewards.healthGain > 0 {
                let newHealth = min(context.playerMaxHealth, context.playerHealth + challenge.rewards.healthGain)
                changes.append(.healthChanged(delta: challenge.rewards.healthGain, newValue: newHealth))
            }

            if challenge.rewards.faithGain > 0 {
                let newFaith = context.playerFaith + challenge.rewards.faithGain
                changes.append(.faithChanged(delta: challenge.rewards.faithGain, newValue: newFaith))
            }

            for flag in challenge.rewards.flagsToSet {
                changes.append(.flagSet(key: flag, value: true))
            }

            return .victory(changes: changes, narrative: "Победа в бою!")
        } else {
            // Defeat
            // Apply penalties
            if challenge.penalties.healthLoss > 0 {
                let newHealth = max(0, context.playerHealth - challenge.penalties.healthLoss)
                changes.append(.healthChanged(delta: -challenge.penalties.healthLoss, newValue: newHealth))
            }

            if challenge.penalties.balanceShift != 0 {
                let newBalance = max(0, min(100, context.playerBalance + challenge.penalties.balanceShift))
                changes.append(.balanceChanged(delta: challenge.penalties.balanceShift, newValue: newBalance))
            }

            return .defeat(changes: changes, narrative: "Поражение в бою...")
        }
    }
}

// MARK: - Puzzle Mini-Game Resolver

/// Resolves puzzle mini-games
final class PuzzleMiniGameResolver {
    func resolve(
        challenge: MiniGameChallenge,
        context: MiniGameContext
    ) -> MiniGameDispatchResult {

        var changes: [StateChange] = []

        // Simple puzzle resolution based on faith/wisdom
        let successChance = min(90, 50 + context.playerFaith * 5)
        let roll = WorldRNG.shared.nextInt(in: 1...100)

        if roll <= successChance {
            // Success
            if challenge.rewards.faithGain > 0 {
                let newFaith = context.playerFaith + challenge.rewards.faithGain
                changes.append(.faithChanged(delta: challenge.rewards.faithGain, newValue: newFaith))
            }

            for flag in challenge.rewards.flagsToSet {
                changes.append(.flagSet(key: flag, value: true))
            }

            return .victory(changes: changes, narrative: "Загадка разгадана!")
        } else {
            // Failure
            if challenge.penalties.tensionIncrease > 0 {
                let newTension = min(100, context.worldTension + challenge.penalties.tensionIncrease)
                changes.append(.tensionChanged(delta: challenge.penalties.tensionIncrease, newValue: newTension))
            }

            return .defeat(changes: changes, narrative: "Загадка осталась неразгаданной...")
        }
    }
}

// MARK: - Skill Check Resolver

/// Resolves skill check mini-games
final class SkillCheckResolver {
    func resolve(
        challenge: MiniGameChallenge,
        context: MiniGameContext
    ) -> MiniGameDispatchResult {

        var changes: [StateChange] = []

        // Skill check based on relevant stat
        let targetNumber = challenge.difficulty * 3
        let roll = WorldRNG.shared.nextInt(in: 1...20) + context.playerStrength

        if roll >= targetNumber {
            // Success
            for flag in challenge.rewards.flagsToSet {
                changes.append(.flagSet(key: flag, value: true))
            }

            return .victory(changes: changes, narrative: "Проверка навыка пройдена!")
        } else {
            // Failure
            return .defeat(changes: changes, narrative: "Проверка навыка провалена...")
        }
    }
}


// ==========================================
// FILE: Engine/Modules/CombatModule.swift
// ==========================================

import Foundation

// MARK: - Combat Module
// Engine integration for combat system
// Wraps CombatCalculator and provides state change diffs

/// Combat module for engine integration
final class CombatModule {
    // MARK: - State

    private(set) var isInCombat: Bool = false
    private(set) var currentEncounter: CombatEncounter?
    private(set) var combatLog: [CombatLogEntry] = []
    private(set) var turnNumber: Int = 0
    private(set) var playerActionsRemaining: Int = 3

    // MARK: - Combat Entry

    /// Start combat with an encounter
    func startCombat(encounter: CombatEncounter) -> [StateChange] {
        isInCombat = true
        currentEncounter = encounter
        combatLog = []
        turnNumber = 1
        playerActionsRemaining = 3

        return [
            .custom(key: "combat_started", description: "Combat started with \(encounter.name)")
        ]
    }

    /// End combat
    func endCombat(victory: Bool) -> [StateChange] {
        let changes: [StateChange] = [
            .combatEnded(victory: victory)
        ]

        isInCombat = false
        currentEncounter = nil
        combatLog = []
        turnNumber = 0
        playerActionsRemaining = 0

        return changes
    }

    // MARK: - Combat Actions

    /// Execute player attack
    func executeAttack(
        player: Player,
        bonusDice: Int = 0,
        bonusDamage: Int = 0,
        isFirstAttack: Bool = false
    ) -> CombatActionResult {

        guard let encounter = currentEncounter else {
            return CombatActionResult.failure("No active encounter")
        }

        guard playerActionsRemaining > 0 else {
            return CombatActionResult.failure("No actions remaining")
        }

        playerActionsRemaining -= 1

        // Use CombatCalculator
        let result = CombatCalculator.calculatePlayerAttack(
            player: player,
            monsterDefense: encounter.defense,
            monsterCurrentHP: encounter.currentHP,
            monsterMaxHP: encounter.maxHP,
            bonusDice: bonusDice,
            bonusDamage: bonusDamage,
            isFirstAttack: isFirstAttack
        )

        var stateChanges: [StateChange] = []
        var logEntry = CombatLogEntry(
            turn: turnNumber,
            actor: .player,
            action: "Attack",
            result: result.isHit ? "Hit" : "Miss",
            details: result.logDescription
        )

        if result.isHit, let damage = result.damageCalculation {
            // Apply damage to encounter
            currentEncounter?.currentHP -= damage.total
            stateChanges.append(.enemyDamaged(
                enemyId: encounter.id,
                damage: damage.total,
                newHealth: currentEncounter?.currentHP ?? 0
            ))

            // Check if defeated
            if currentEncounter?.currentHP ?? 0 <= 0 {
                stateChanges.append(.enemyDefeated(enemyId: encounter.id))
                logEntry.result = "Defeat!"
            }
        }

        combatLog.append(logEntry)

        return CombatActionResult.success(
            stateChanges: stateChanges,
            combatResult: result,
            encounterDefeated: currentEncounter?.currentHP ?? 0 <= 0
        )
    }

    /// Execute player card play
    func playCard(
        cardId: UUID,
        player: Player,
        effects: [CardEffect]
    ) -> CombatActionResult {

        guard currentEncounter != nil else {
            return CombatActionResult.failure("No active encounter")
        }

        guard playerActionsRemaining > 0 else {
            return CombatActionResult.failure("No actions remaining")
        }

        playerActionsRemaining -= 1

        var stateChanges: [StateChange] = []

        // Apply card effects
        for effect in effects {
            switch effect {
            case .damage(let amount, _):
                currentEncounter?.currentHP -= amount
                if let encounter = currentEncounter {
                    stateChanges.append(.enemyDamaged(
                        enemyId: encounter.id,
                        damage: amount,
                        newHealth: encounter.currentHP
                    ))
                }

            case .heal(let amount):
                let newHealth = min(player.maxHealth, player.health + amount)
                stateChanges.append(.healthChanged(delta: amount, newValue: newHealth))

            case .drawCards(let count):
                stateChanges.append(.custom(key: "draw_cards", description: "Draw \(count) cards"))

            case .gainFaith(let amount):
                stateChanges.append(.faithChanged(delta: amount, newValue: player.faith + amount))

            case .bonusDice(let count):
                stateChanges.append(.custom(key: "bonus_dice", description: "Gained \(count) bonus dice"))

            case .bonusDamage(let amount):
                stateChanges.append(.custom(key: "bonus_damage", description: "Gained \(amount) bonus damage"))

            case .balanceShift(let amount):
                let newBalance = max(0, min(100, player.balance + amount))
                stateChanges.append(.balanceChanged(delta: amount, newValue: newBalance))
            }
        }

        // Check if encounter defeated
        if currentEncounter?.currentHP ?? 0 <= 0 {
            if let encounter = currentEncounter {
                stateChanges.append(.enemyDefeated(enemyId: encounter.id))
            }
        }

        let logEntry = CombatLogEntry(
            turn: turnNumber,
            actor: .player,
            action: "Card",
            result: "Applied",
            details: "Card effects applied"
        )
        combatLog.append(logEntry)

        return CombatActionResult.success(
            stateChanges: stateChanges,
            combatResult: nil,
            encounterDefeated: currentEncounter?.currentHP ?? 0 <= 0
        )
    }

    /// End player turn
    func endPlayerTurn(player: Player) -> CombatActionResult {
        guard let encounter = currentEncounter else {
            return CombatActionResult.failure("No active encounter")
        }

        var stateChanges: [StateChange] = []

        // Enemy attack
        let enemyAttack = calculateEnemyAttack(encounter: encounter, player: player)
        stateChanges.append(contentsOf: enemyAttack.stateChanges)

        // Check if player defeated
        let playerDefeated = player.health + (enemyAttack.healthChange) <= 0

        // Start new turn
        turnNumber += 1
        playerActionsRemaining = 3

        // Apply exhaustion curse if present
        if player.hasCurse(.exhaustion) {
            playerActionsRemaining -= 1
            stateChanges.append(.custom(key: "exhaustion", description: "Exhaustion: -1 action"))
        }

        let logEntry = CombatLogEntry(
            turn: turnNumber - 1,
            actor: .enemy,
            action: "Attack",
            result: enemyAttack.hit ? "Hit" : "Miss",
            details: enemyAttack.description
        )
        combatLog.append(logEntry)

        return CombatActionResult.success(
            stateChanges: stateChanges,
            combatResult: nil,
            encounterDefeated: false,
            playerDefeated: playerDefeated
        )
    }

    // MARK: - Enemy AI

    private func calculateEnemyAttack(
        encounter: CombatEncounter,
        player: Player
    ) -> (stateChanges: [StateChange], hit: Bool, healthChange: Int, description: String) {

        var stateChanges: [StateChange] = []

        // Enemy attack roll
        let attackRoll = WorldRNG.shared.nextInt(in: 1...6) + encounter.strength
        let playerDefense = 5 + (player.strength / 2)

        let hit = attackRoll >= playerDefense
        var healthChange = 0

        if hit {
            var damage = max(1, encounter.strength - 2)

            // Hero ability may reduce damage (e.g., Priest vs dark sources)
            let heroReduction = player.getHeroDamageReduction(fromDarkSource: true)
            damage = max(1, damage - heroReduction)

            healthChange = -damage
            stateChanges.append(.healthChanged(delta: -damage, newValue: player.health - damage))
        }

        let description = hit
            ? "Enemy hit for \(-healthChange) damage"
            : "Enemy missed"

        return (stateChanges, hit, healthChange, description)
    }
}

// MARK: - Combat Encounter

/// Combat encounter state
struct CombatEncounter {
    let id: UUID
    let name: String
    let maxHP: Int
    var currentHP: Int
    let strength: Int
    let defense: Int
    let isBoss: Bool

    init(
        id: UUID = UUID(),
        name: String,
        maxHP: Int,
        strength: Int,
        defense: Int,
        isBoss: Bool = false
    ) {
        self.id = id
        self.name = name
        self.maxHP = maxHP
        self.currentHP = maxHP
        self.strength = strength
        self.defense = defense
        self.isBoss = isBoss
    }

    /// Create from Card (monster)
    /// Maps Card stats: health -> maxHP, power -> strength, defense -> defense
    /// Boss detection: legendary rarity or "boss" trait
    static func from(card: Card) -> CombatEncounter {
        // Determine if card is a boss (legendary rarity or has boss trait)
        let isBoss = card.rarity == .legendary || card.traits.contains("boss")

        return CombatEncounter(
            id: card.id,
            name: card.name,
            maxHP: card.health ?? 10,
            strength: card.power ?? 3,
            defense: card.defense ?? 5,
            isBoss: isBoss
        )
    }
}

// MARK: - Combat Action Result

/// Result of combat action
struct CombatActionResult {
    let success: Bool
    let error: String?
    let stateChanges: [StateChange]
    let combatResult: CombatResult?
    let encounterDefeated: Bool
    let playerDefeated: Bool

    static func success(
        stateChanges: [StateChange],
        combatResult: CombatResult?,
        encounterDefeated: Bool,
        playerDefeated: Bool = false
    ) -> CombatActionResult {
        CombatActionResult(
            success: true,
            error: nil,
            stateChanges: stateChanges,
            combatResult: combatResult,
            encounterDefeated: encounterDefeated,
            playerDefeated: playerDefeated
        )
    }

    static func failure(_ error: String) -> CombatActionResult {
        CombatActionResult(
            success: false,
            error: error,
            stateChanges: [],
            combatResult: nil,
            encounterDefeated: false,
            playerDefeated: false
        )
    }
}

// MARK: - Combat Log Entry

/// Entry in combat log
struct CombatLogEntry {
    let turn: Int
    let actor: CombatActor
    var action: String
    var result: String
    let details: String
}

enum CombatActor {
    case player
    case enemy
}

// MARK: - Card Effect

/// Effects that cards can have in combat
enum CardEffect {
    case damage(amount: Int, type: CombatDamageKind)
    case heal(amount: Int)
    case drawCards(count: Int)
    case gainFaith(amount: Int)
    case bonusDice(count: Int)
    case bonusDamage(amount: Int)
    case balanceShift(amount: Int)
}

/// Simplified damage categories for combat resolution
/// Different from DamageType in CardType.swift (detailed card damage types)
enum CombatDamageKind {
    case physical
    case magical
    case light
    case dark
}


// ==========================================
// FILE: Engine/Data/Providers/CodeContentProvider.swift
// ==========================================

import Foundation

// MARK: - Code Content Provider
// Reference: Docs/MIGRATION_PLAN.md, Feature A3
// Adapter for existing TwilightMarchesConfig content

/// Content provider that loads definitions from Swift code.
/// This is an adapter for the existing TwilightMarchesConfig.swift content.
/// Will be replaced/augmented by JSONContentProvider in Phase 5.
class CodeContentProvider: ContentProvider {
    // MARK: - Cached Definitions

    private var regions: [String: RegionDefinition] = [:]
    private var anchors: [String: AnchorDefinition] = [:]
    private var events: [String: EventDefinition] = [:]
    private var quests: [String: QuestDefinition] = [:]
    private var miniGameChallenges: [String: MiniGameChallengeDefinition] = [:]

    // MARK: - Event Pool Index

    private var eventsByPool: [String: [EventDefinition]] = [:]
    private var eventsByRegion: [String: [EventDefinition]] = [:]

    // MARK: - Initialization

    init() {
        loadContent()
    }

    /// Load all content from code definitions
    private func loadContent() {
        loadRegions()
        loadAnchors()
        loadEvents()
        loadQuests()
        loadMiniGameChallenges()
        buildEventIndices()
    }

    // MARK: - Content Loading (Override in subclass for actual content)

    /// Load region definitions
    /// Subclass should override to provide actual regions
    func loadRegions() {
        // Default implementation - subclass overrides with actual content
        // Example region for testing (uses generic IDs, not game-specific):
        let testRegion = RegionDefinition(
            id: "test_region",
            title: LocalizedString(en: "Test Region", ru: "Тестовый Регион"),
            description: LocalizedString(en: "A test region", ru: "Тестовый регион"),
            regionType: "forest",
            neighborIds: ["test_neighbor"],
            initiallyDiscovered: true,
            anchorId: "test_anchor",
            eventPoolIds: ["pool_common"],
            initialState: .stable
        )
        regions[testRegion.id] = testRegion
    }

    /// Load anchor definitions
    func loadAnchors() {
        // Default implementation - subclass overrides (uses generic IDs, not game-specific)
        let testAnchor = AnchorDefinition(
            id: "test_anchor",
            title: LocalizedString(en: "Test Anchor", ru: "Тестовый Якорь"),
            description: LocalizedString(en: "A test anchor", ru: "Тестовый якорь"),
            regionId: "test_region"
        )
        anchors[testAnchor.id] = testAnchor
    }

    /// Load event definitions
    func loadEvents() {
        // Default implementation - subclass overrides
        let testEvent = EventDefinition(
            id: "event_test",
            title: LocalizedString(en: "Test Event", ru: "Тестовое Событие"),
            body: LocalizedString(en: "A test event", ru: "Тестовое событие"),
            eventKind: .inline,
            poolIds: ["pool_common"],
            choices: [
                ChoiceDefinition(
                    id: "choice_a",
                    label: LocalizedString(en: "Choice A", ru: "Выбор А"),
                    consequences: ChoiceConsequences(resourceChanges: ["faith": -2])
                ),
                ChoiceDefinition(
                    id: "choice_b",
                    label: LocalizedString(en: "Choice B", ru: "Выбор Б"),
                    consequences: ChoiceConsequences(resourceChanges: ["health": -3])
                )
            ]
        )
        events[testEvent.id] = testEvent
    }

    /// Load quest definitions
    func loadQuests() {
        // Default implementation - subclass overrides
        let testQuest = QuestDefinition(
            id: "quest_test",
            title: LocalizedString(en: "Test Quest", ru: "Тестовое Задание"),
            description: LocalizedString(en: "A test quest", ru: "Тестовое задание"),
            objectives: [
                ObjectiveDefinition(
                    id: "obj_1",
                    description: LocalizedString(en: "Objective 1", ru: "Цель 1"),
                    completionCondition: .manual,
                    nextObjectiveId: "obj_2"
                ),
                ObjectiveDefinition(
                    id: "obj_2",
                    description: LocalizedString(en: "Objective 2", ru: "Цель 2"),
                    completionCondition: .manual
                )
            ]
        )
        quests[testQuest.id] = testQuest
    }

    /// Load mini-game challenge definitions
    func loadMiniGameChallenges() {
        // Default implementation - subclass overrides
        let testCombat = MiniGameChallengeDefinition(
            id: "combat_test",
            challengeKind: .combat,
            difficulty: 5
        )
        miniGameChallenges[testCombat.id] = testCombat
    }

    /// Build event indices for fast lookup
    private func buildEventIndices() {
        eventsByPool.removeAll()
        eventsByRegion.removeAll()

        for event in events.values {
            // Index by pool
            for poolId in event.poolIds {
                eventsByPool[poolId, default: []].append(event)
            }

            // Index by region (from availability)
            if let regionIds = event.availability.regionIds {
                for regionId in regionIds {
                    eventsByRegion[regionId, default: []].append(event)
                }
            }
        }
    }

    // MARK: - JSON Event Loading Utility

    /// Load events from a JSON file URL
    /// - Parameter url: URL to the events.json file
    /// - Throws: Decoding errors
    func loadEventsFromJSON(url: URL) throws {
        let data = try Data(contentsOf: url)
        let jsonEvents = try JSONDecoder().decode([JSONEventForLoading].self, from: data)
        for jsonEvent in jsonEvents {
            events[jsonEvent.id] = jsonEvent.toDefinition()
        }
        buildEventIndices()
    }

    // MARK: - Registration (for building content)

    func registerRegion(_ region: RegionDefinition) {
        regions[region.id] = region
    }

    func registerAnchor(_ anchor: AnchorDefinition) {
        anchors[anchor.id] = anchor
    }

    func registerEvent(_ event: EventDefinition) {
        events[event.id] = event
    }

    func registerQuest(_ quest: QuestDefinition) {
        quests[quest.id] = quest
    }

    func registerMiniGameChallenge(_ challenge: MiniGameChallengeDefinition) {
        miniGameChallenges[challenge.id] = challenge
    }

    func rebuildIndices() {
        buildEventIndices()
    }

    // MARK: - ContentProvider Implementation

    func getAllRegionDefinitions() -> [RegionDefinition] {
        return Array(regions.values)
    }

    func getRegionDefinition(id: String) -> RegionDefinition? {
        return regions[id]
    }

    func getAllAnchorDefinitions() -> [AnchorDefinition] {
        return Array(anchors.values)
    }

    func getAnchorDefinition(id: String) -> AnchorDefinition? {
        return anchors[id]
    }

    func getAnchorDefinition(forRegion regionId: String) -> AnchorDefinition? {
        return anchors.values.first { $0.regionId == regionId }
    }

    func getAllEventDefinitions() -> [EventDefinition] {
        return Array(events.values)
    }

    func getEventDefinition(id: String) -> EventDefinition? {
        return events[id]
    }

    func getEventDefinitions(forRegion regionId: String) -> [EventDefinition] {
        // Get events from region's pools
        guard let region = regions[regionId] else { return [] }

        var result: [EventDefinition] = []
        for poolId in region.eventPoolIds {
            result.append(contentsOf: eventsByPool[poolId] ?? [])
        }

        // Add events specifically for this region
        result.append(contentsOf: eventsByRegion[regionId] ?? [])

        // Remove duplicates while preserving order
        var seen = Set<String>()
        return result.filter { seen.insert($0.id).inserted }
    }

    func getEventDefinitions(forPool poolId: String) -> [EventDefinition] {
        return eventsByPool[poolId] ?? []
    }

    func getAllQuestDefinitions() -> [QuestDefinition] {
        return Array(quests.values)
    }

    func getQuestDefinition(id: String) -> QuestDefinition? {
        return quests[id]
    }

    func getAllMiniGameChallenges() -> [MiniGameChallengeDefinition] {
        return Array(miniGameChallenges.values)
    }

    func getMiniGameChallenge(id: String) -> MiniGameChallengeDefinition? {
        return miniGameChallenges[id]
    }

    func validate() -> [ContentValidationError] {
        let validator = ContentValidator(provider: self)
        return validator.validate()
    }
}

// MARK: - JSON Event Loading Structures

/// Simplified event_kind that can be either "inline" string or {"mini_game": "combat"} object
enum JSONEventKindForLoading: Codable {
    case inline
    case miniGame(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let stringValue = try? container.decode(String.self) {
            self = stringValue == "inline" ? .inline : .miniGame(stringValue)
            return
        }
        if let dictValue = try? container.decode([String: String].self),
           let miniGameType = dictValue["mini_game"] {
            self = .miniGame(miniGameType)
            return
        }
        self = .inline
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .inline: try container.encode("inline")
        case .miniGame(let type): try container.encode(["mini_game": type])
        }
    }

    func toEventKind() -> EventKind {
        switch self {
        case .inline: return .inline
        case .miniGame(let type):
            switch type.lowercased() {
            case "combat": return .miniGame(.combat)
            case "ritual": return .miniGame(.ritual)
            case "exploration": return .miniGame(.exploration)
            case "dialogue": return .miniGame(.dialogue)
            case "puzzle": return .miniGame(.puzzle)
            default: return .miniGame(.combat)
            }
        }
    }
}

/// JSON structure for loading events from file
struct JSONEventForLoading: Codable {
    let id: String
    let title: LocalizedString
    let body: LocalizedString
    let eventKind: JSONEventKindForLoading?
    let eventType: String?
    let poolIds: [String]?
    let availability: JSONAvailabilityForLoading?
    let weight: Int?
    let isOneTime: Bool?
    let isInstant: Bool?
    let cooldown: Int?
    let choices: [JSONChoiceForLoading]?
    let miniGameChallenge: JSONMiniGameChallengeForLoading?

    enum CodingKeys: String, CodingKey {
        case id, title, body, availability, weight, choices
        case eventKind = "event_kind"
        case eventType = "event_type"
        case poolIds = "pool_ids"
        case isOneTime = "is_one_time"
        case isInstant = "is_instant"
        case cooldown
        case miniGameChallenge = "mini_game_challenge"
    }

    func toDefinition() -> EventDefinition {
        let kind: EventKind
        if let ek = eventKind { kind = ek.toEventKind() }
        else if let et = eventType {
            switch et.lowercased() {
            case "combat": kind = .miniGame(.combat)
            case "ritual": kind = .miniGame(.ritual)
            case "exploration": kind = .miniGame(.exploration)
            default: kind = .inline
            }
        } else { kind = .inline }

        let avail = availability?.toAvailability() ?? .always
        let choiceDefs = choices?.map { $0.toDefinition() } ?? []

        let challenge: MiniGameChallengeDefinition?
        if let json = miniGameChallenge, let enemyId = json.enemyId {
            challenge = MiniGameChallengeDefinition(
                id: "challenge_\(enemyId)",
                challengeKind: .combat,
                difficulty: json.difficulty ?? 1,
                enemyId: enemyId,
                victoryConsequences: json.rewards?.toConsequences() ?? .none,
                defeatConsequences: json.penalties?.toConsequences() ?? .none
            )
        } else { challenge = nil }

        return EventDefinition(
            id: id,
            title: title,
            body: body,
            eventKind: kind,
            availability: avail,
            poolIds: poolIds ?? [],
            weight: weight ?? 10,
            isOneTime: isOneTime ?? false,
            choices: choiceDefs,
            miniGameChallenge: challenge
        )
    }
}

struct JSONAvailabilityForLoading: Codable {
    let regionStates: [String]?
    let regionIds: [String]?
    let minPressure: Int?
    let maxPressure: Int?
    let minBalance: Int?
    let maxBalance: Int?
    let requiredFlags: [String]?
    let forbiddenFlags: [String]?

    enum CodingKeys: String, CodingKey {
        case regionStates = "region_states"
        case regionIds = "region_ids"
        case minPressure = "min_pressure"
        case maxPressure = "max_pressure"
        case minBalance = "min_balance"
        case maxBalance = "max_balance"
        case requiredFlags = "required_flags"
        case forbiddenFlags = "forbidden_flags"
    }

    func toAvailability() -> Availability {
        Availability(
            requiredFlags: requiredFlags ?? [],
            forbiddenFlags: forbiddenFlags ?? [],
            minPressure: minPressure,
            maxPressure: maxPressure,
            minBalance: minBalance,
            maxBalance: maxBalance,
            regionStates: regionStates,
            regionIds: regionIds
        )
    }
}

struct JSONChoiceForLoading: Codable {
    let id: String
    let label: LocalizedString
    let tooltip: LocalizedString?
    let requirements: JSONChoiceRequirementsForLoading?
    let consequences: JSONChoiceConsequencesForLoading?

    func toDefinition() -> ChoiceDefinition {
        ChoiceDefinition(
            id: id,
            label: label,
            tooltip: tooltip,
            requirements: requirements?.toRequirements(),
            consequences: consequences?.toConsequences() ?? .none
        )
    }
}

struct JSONChoiceRequirementsForLoading: Codable {
    let minResources: [String: Int]?
    let minFaith: Int?
    let minHealth: Int?
    let minBalance: Int?
    let maxBalance: Int?
    let requiredFlags: [String]?
    let forbiddenFlags: [String]?

    enum CodingKeys: String, CodingKey {
        case minResources = "min_resources"
        case minFaith = "min_faith"
        case minHealth = "min_health"
        case minBalance = "min_balance"
        case maxBalance = "max_balance"
        case requiredFlags = "required_flags"
        case forbiddenFlags = "forbidden_flags"
    }

    func toRequirements() -> ChoiceRequirements {
        var resources = minResources ?? [:]
        if let faith = minFaith { resources["faith"] = faith }
        if let health = minHealth { resources["health"] = health }
        return ChoiceRequirements(
            minResources: resources,
            requiredFlags: requiredFlags ?? [],
            forbiddenFlags: forbiddenFlags ?? [],
            minBalance: minBalance,
            maxBalance: maxBalance
        )
    }
}

struct JSONChoiceConsequencesForLoading: Codable {
    let resourceChanges: [String: Int]?
    let setFlags: [String]?
    let clearFlags: [String]?
    let balanceDelta: Int?
    let regionStateChange: JSONRegionStateChangeForLoading?
    let questProgress: JSONQuestProgressForLoading?
    let triggerEventId: String?
    let resultKey: String?

    enum CodingKeys: String, CodingKey {
        case resourceChanges = "resource_changes"
        case setFlags = "set_flags"
        case clearFlags = "clear_flags"
        case balanceDelta = "balance_delta"
        case regionStateChange = "region_state_change"
        case questProgress = "quest_progress"
        case triggerEventId = "trigger_event_id"
        case resultKey = "result_key"
    }

    func toConsequences() -> ChoiceConsequences {
        let stateChange: RegionStateChange?
        if let rsc = regionStateChange {
            let transition: RegionStateChange.StateTransition?
            switch rsc.transition?.lowercased() {
            case "restore": transition = .restore
            case "degrade": transition = .degrade
            default: transition = nil
            }
            stateChange = RegionStateChange(
                regionId: rsc.regionId,
                newState: nil,
                transition: transition
            )
        } else { stateChange = nil }

        let questProg: QuestProgressTrigger?
        if let qp = questProgress {
            let action: QuestProgressTrigger.QuestAction
            switch qp.action?.lowercased() {
            case "complete": action = .complete
            case "unlock": action = .unlock
            case "fail": action = .fail
            case "advance": action = .advance
            default: action = .complete
            }
            questProg = QuestProgressTrigger(
                questId: qp.questId ?? "",
                objectiveId: qp.objectiveId,
                action: action
            )
        } else { questProg = nil }

        return ChoiceConsequences(
            resourceChanges: resourceChanges ?? [:],
            setFlags: setFlags ?? [],
            clearFlags: clearFlags ?? [],
            balanceDelta: balanceDelta ?? 0,
            regionStateChange: stateChange,
            questProgress: questProg,
            resultKey: resultKey
        )
    }
}

struct JSONRegionStateChangeForLoading: Codable {
    let regionId: String?
    let newState: String?
    let transition: String?

    enum CodingKeys: String, CodingKey {
        case regionId = "region_id"
        case newState = "new_state"
        case transition
    }
}

struct JSONQuestProgressForLoading: Codable {
    let questId: String?
    let objectiveId: String?
    let action: String?

    enum CodingKeys: String, CodingKey {
        case questId = "quest_id"
        case objectiveId = "objective_id"
        case action
    }
}

struct JSONMiniGameChallengeForLoading: Codable {
    let enemyId: String?
    let difficulty: Int?
    let rewards: JSONChallengeConsequencesForLoading?
    let penalties: JSONChallengeConsequencesForLoading?

    enum CodingKeys: String, CodingKey {
        case enemyId = "enemy_id"
        case difficulty, rewards, penalties
    }
}

struct JSONChallengeConsequencesForLoading: Codable {
    let resourceChanges: [String: Int]?
    let setFlags: [String]?
    let balanceShift: Int?

    enum CodingKeys: String, CodingKey {
        case resourceChanges = "resource_changes"
        case setFlags = "set_flags"
        case balanceShift = "balance_shift"
    }

    func toConsequences() -> ChoiceConsequences {
        ChoiceConsequences(
            resourceChanges: resourceChanges ?? [:],
            setFlags: setFlags ?? [],
            clearFlags: [],
            balanceDelta: balanceShift ?? 0
        )
    }
}


// ==========================================
// FILE: Engine/Data/Providers/ContentProvider.swift
// ==========================================

import Foundation

// MARK: - Content Provider Protocol
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.3
// Reference: Docs/MIGRATION_PLAN.md, Feature A3

/// Protocol for loading game content definitions.
/// Abstracts the source of content (code, JSON, database, etc.)
protocol ContentProvider {
    // MARK: - Regions

    /// Get all region definitions
    func getAllRegionDefinitions() -> [RegionDefinition]

    /// Get a specific region by ID
    func getRegionDefinition(id: String) -> RegionDefinition?

    // MARK: - Anchors

    /// Get all anchor definitions
    func getAllAnchorDefinitions() -> [AnchorDefinition]

    /// Get a specific anchor by ID
    func getAnchorDefinition(id: String) -> AnchorDefinition?

    /// Get anchor for a region
    func getAnchorDefinition(forRegion regionId: String) -> AnchorDefinition?

    // MARK: - Events

    /// Get all event definitions
    func getAllEventDefinitions() -> [EventDefinition]

    /// Get a specific event by ID
    func getEventDefinition(id: String) -> EventDefinition?

    /// Get events for a specific region
    func getEventDefinitions(forRegion regionId: String) -> [EventDefinition]

    /// Get events for a specific pool
    func getEventDefinitions(forPool poolId: String) -> [EventDefinition]

    // MARK: - Quests

    /// Get all quest definitions
    func getAllQuestDefinitions() -> [QuestDefinition]

    /// Get a specific quest by ID
    func getQuestDefinition(id: String) -> QuestDefinition?

    // MARK: - Mini-Game Challenges

    /// Get all mini-game challenge definitions
    func getAllMiniGameChallenges() -> [MiniGameChallengeDefinition]

    /// Get a specific challenge by ID
    func getMiniGameChallenge(id: String) -> MiniGameChallengeDefinition?

    // MARK: - Validation

    /// Validate all content for consistency
    func validate() -> [ContentValidationError]
}

// MARK: - Content Validation Error

/// Error found during content validation
struct ContentValidationError: Equatable, CustomStringConvertible {
    /// Type of validation error
    let type: ErrorType

    /// Affected definition ID
    let definitionId: String

    /// Detailed error message
    let message: String

    var description: String {
        return "[\(type.rawValue)] \(definitionId): \(message)"
    }

    enum ErrorType: String, Equatable {
        case duplicateId = "DUPLICATE_ID"
        case brokenReference = "BROKEN_REFERENCE"
        case invalidRange = "INVALID_RANGE"
        case missingRequired = "MISSING_REQUIRED"
        case emptyChoices = "EMPTY_CHOICES"
        case invalidLocalizationKey = "INVALID_KEY"
        case circularReference = "CIRCULAR_REF"
    }
}

// MARK: - Content Validator

/// Validates content from a provider
struct ContentValidator {
    let provider: ContentProvider

    init(provider: ContentProvider) {
        self.provider = provider
    }

    /// Run all validation checks
    func validate() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []

        errors.append(contentsOf: validateUniqueIds())
        errors.append(contentsOf: validateRegionReferences())
        errors.append(contentsOf: validateAnchorReferences())
        errors.append(contentsOf: validateEventReferences())
        errors.append(contentsOf: validateQuestReferences())
        errors.append(contentsOf: validateEventChoices())
        errors.append(contentsOf: validateRanges())

        return errors
    }

    // MARK: - Validation Checks

    /// Check for duplicate IDs within each type
    private func validateUniqueIds() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []

        // Regions
        let regionIds = provider.getAllRegionDefinitions().map { $0.id }
        for (id, count) in Dictionary(grouping: regionIds, by: { $0 }).filter({ $0.value.count > 1 }) {
            errors.append(ContentValidationError(
                type: .duplicateId,
                definitionId: id,
                message: "Region ID appears \(count.count) times"
            ))
        }

        // Events
        let eventIds = provider.getAllEventDefinitions().map { $0.id }
        for (id, count) in Dictionary(grouping: eventIds, by: { $0 }).filter({ $0.value.count > 1 }) {
            errors.append(ContentValidationError(
                type: .duplicateId,
                definitionId: id,
                message: "Event ID appears \(count.count) times"
            ))
        }

        // Quests
        let questIds = provider.getAllQuestDefinitions().map { $0.id }
        for (id, count) in Dictionary(grouping: questIds, by: { $0 }).filter({ $0.value.count > 1 }) {
            errors.append(ContentValidationError(
                type: .duplicateId,
                definitionId: id,
                message: "Quest ID appears \(count.count) times"
            ))
        }

        return errors
    }

    /// Check that region neighbor references exist
    private func validateRegionReferences() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []
        let allRegionIds = Set(provider.getAllRegionDefinitions().map { $0.id })

        for region in provider.getAllRegionDefinitions() {
            for neighborId in region.neighborIds {
                if !allRegionIds.contains(neighborId) {
                    errors.append(ContentValidationError(
                        type: .brokenReference,
                        definitionId: region.id,
                        message: "Neighbor '\(neighborId)' does not exist"
                    ))
                }
            }
        }

        return errors
    }

    /// Check that anchor region references exist
    private func validateAnchorReferences() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []
        let allRegionIds = Set(provider.getAllRegionDefinitions().map { $0.id })

        for anchor in provider.getAllAnchorDefinitions() {
            if !allRegionIds.contains(anchor.regionId) {
                errors.append(ContentValidationError(
                    type: .brokenReference,
                    definitionId: anchor.id,
                    message: "Region '\(anchor.regionId)' does not exist"
                ))
            }
        }

        return errors
    }

    /// Check event references
    private func validateEventReferences() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []
        let allEventIds = Set(provider.getAllEventDefinitions().map { $0.id })
        let allRegionIds = Set(provider.getAllRegionDefinitions().map { $0.id })

        for event in provider.getAllEventDefinitions() {
            // Check region references in availability
            if let regionIds = event.availability.regionIds {
                for regionId in regionIds {
                    if !allRegionIds.contains(regionId) {
                        errors.append(ContentValidationError(
                            type: .brokenReference,
                            definitionId: event.id,
                            message: "Region '\(regionId)' in availability does not exist"
                        ))
                    }
                }
            }

            // Check trigger event references
            for choice in event.choices {
                if let triggerId = choice.consequences.triggerEventId {
                    if !allEventIds.contains(triggerId) {
                        errors.append(ContentValidationError(
                            type: .brokenReference,
                            definitionId: event.id,
                            message: "Trigger event '\(triggerId)' in choice '\(choice.id)' does not exist"
                        ))
                    }
                }
            }
        }

        return errors
    }

    /// Check quest references
    private func validateQuestReferences() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []
        let allEventIds = Set(provider.getAllEventDefinitions().map { $0.id })
        let allRegionIds = Set(provider.getAllRegionDefinitions().map { $0.id })

        for quest in provider.getAllQuestDefinitions() {
            let objectiveIds = Set(quest.objectives.map { $0.id })

            for objective in quest.objectives {
                // Check next objective reference
                if let nextId = objective.nextObjectiveId, !objectiveIds.contains(nextId) {
                    errors.append(ContentValidationError(
                        type: .brokenReference,
                        definitionId: quest.id,
                        message: "Objective '\(objective.id)' references non-existent next '\(nextId)'"
                    ))
                }

                // Check completion condition references
                switch objective.completionCondition {
                case .eventCompleted(let eventId):
                    if !allEventIds.contains(eventId) {
                        errors.append(ContentValidationError(
                            type: .brokenReference,
                            definitionId: quest.id,
                            message: "Objective '\(objective.id)' references non-existent event '\(eventId)'"
                        ))
                    }
                case .visitRegion(let regionId):
                    if !allRegionIds.contains(regionId) {
                        errors.append(ContentValidationError(
                            type: .brokenReference,
                            definitionId: quest.id,
                            message: "Objective '\(objective.id)' references non-existent region '\(regionId)'"
                        ))
                    }
                case .choiceMade(let eventId, _):
                    if !allEventIds.contains(eventId) {
                        errors.append(ContentValidationError(
                            type: .brokenReference,
                            definitionId: quest.id,
                            message: "Objective '\(objective.id)' references non-existent event '\(eventId)'"
                        ))
                    }
                default:
                    break
                }
            }
        }

        return errors
    }

    /// Check that events have valid choices
    private func validateEventChoices() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []

        for event in provider.getAllEventDefinitions() {
            // Inline events should have at least 2 choices
            if case .inline = event.eventKind {
                if event.choices.isEmpty {
                    errors.append(ContentValidationError(
                        type: .emptyChoices,
                        definitionId: event.id,
                        message: "Inline event has no choices"
                    ))
                } else if event.choices.count < 2 {
                    errors.append(ContentValidationError(
                        type: .emptyChoices,
                        definitionId: event.id,
                        message: "Inline event should have at least 2 choices"
                    ))
                }
            }

            // Check for duplicate choice IDs within event
            let choiceIds = event.choices.map { $0.id }
            for (id, count) in Dictionary(grouping: choiceIds, by: { $0 }).filter({ $0.value.count > 1 }) {
                errors.append(ContentValidationError(
                    type: .duplicateId,
                    definitionId: event.id,
                    message: "Choice ID '\(id)' appears \(count.count) times"
                ))
            }
        }

        return errors
    }

    /// Check pressure/balance ranges are valid
    private func validateRanges() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []

        for event in provider.getAllEventDefinitions() {
            // Check pressure range
            if let min = event.availability.minPressure, let max = event.availability.maxPressure {
                if min > max {
                    errors.append(ContentValidationError(
                        type: .invalidRange,
                        definitionId: event.id,
                        message: "minPressure (\(min)) > maxPressure (\(max))"
                    ))
                }
            }

            // Check balance range
            if let min = event.availability.minBalance, let max = event.availability.maxBalance {
                if min > max {
                    errors.append(ContentValidationError(
                        type: .invalidRange,
                        definitionId: event.id,
                        message: "minBalance (\(min)) > maxBalance (\(max))"
                    ))
                }
            }

            // Check choice requirements
            for choice in event.choices {
                if let requirements = choice.requirements {
                    let minBal = requirements.minBalance ?? -100
                    let maxBal = requirements.maxBalance ?? 100
                    if minBal < -100 || maxBal > 100 {
                        errors.append(ContentValidationError(
                            type: .invalidRange,
                            definitionId: event.id,
                            message: "Choice '\(choice.id)' has balance range outside -100...100"
                        ))
                    }
                }
            }
        }

        return errors
    }
}


// ==========================================
// FILE: Engine/Data/Providers/JSONContentProvider.swift
// ==========================================

import Foundation

// MARK: - JSON Content Provider
// Reference: Docs/MIGRATION_PLAN.md, Feature A3 / EPIC D
// Phase 5 Implementation - Real cartridge-data-driven

/// Content provider that loads definitions from JSON files.
/// This is the "cartridge" approach - content as external data.
class JSONContentProvider: ContentProvider {
    // MARK: - Configuration

    /// Base path for content JSON files
    let contentPath: String

    /// Bundle containing content (nil = main bundle)
    let bundle: Bundle

    // MARK: - Cached Definitions (internal for @testable import)

    private(set) var regions: [String: RegionDefinition] = [:]
    private(set) var anchors: [String: AnchorDefinition] = [:]
    private(set) var events: [String: EventDefinition] = [:]
    private(set) var quests: [String: QuestDefinition] = [:]
    private(set) var miniGameChallenges: [String: MiniGameChallengeDefinition] = [:]

    // MARK: - Event Indices (internal for @testable import)

    private(set) var eventsByPool: [String: [EventDefinition]] = [:]
    private(set) var eventsByRegion: [String: [EventDefinition]] = [:]

    // MARK: - Loading State

    private(set) var isLoaded: Bool = false
    private(set) var loadErrors: [String] = []

    // MARK: - Initialization

    init(contentPath: String = "Content", bundle: Bundle? = nil) {
        self.contentPath = contentPath
        self.bundle = bundle ?? Bundle.main
    }

    /// Initialize and load content
    convenience init(loadImmediately: Bool, contentPath: String = "Content", bundle: Bundle? = nil) {
        self.init(contentPath: contentPath, bundle: bundle)
        if loadImmediately {
            do {
                try loadAllContent()
            } catch {
                loadErrors.append("Failed to load content: \(error.localizedDescription)")
            }
        }
    }

    // MARK: - Loading

    /// Load all content from JSON files
    func loadAllContent() throws {
        loadErrors.removeAll()

        // Load regions (files are at bundle root after Xcode copies them)
        if let regionsURL = bundle.url(forResource: "regions", withExtension: "json") {
            try loadRegions(from: regionsURL)
        } else {
            loadErrors.append("regions.json not found")
        }

        // Load anchors
        if let anchorsURL = bundle.url(forResource: "anchors", withExtension: "json") {
            try loadAnchors(from: anchorsURL)
        } else {
            loadErrors.append("anchors.json not found")
        }

        // Load quests
        if let questsURL = bundle.url(forResource: "quests", withExtension: "json") {
            try loadQuests(from: questsURL)
        } else {
            loadErrors.append("quests.json not found")
        }

        // Load challenges
        if let challengesURL = bundle.url(forResource: "challenges", withExtension: "json") {
            try loadChallenges(from: challengesURL)
        } else {
            loadErrors.append("challenges.json not found")
        }

        // Load event pools
        try loadEventPools()

        // Build indices
        buildEventIndices()

        isLoaded = true
    }

    /// Reload content (for development hot-reload)
    func reloadContent() throws {
        regions.removeAll()
        anchors.removeAll()
        events.removeAll()
        quests.removeAll()
        miniGameChallenges.removeAll()
        eventsByPool.removeAll()
        eventsByRegion.removeAll()
        isLoaded = false

        try loadAllContent()
    }

    // MARK: - Individual Loaders

    private func loadRegions(from url: URL) throws {
        let data = try Data(contentsOf: url)
        let container = try JSONDecoder().decode(RegionsContainer.self, from: data)
        for region in container.regions {
            regions[region.id] = region.toDefinition()
        }
    }

    private func loadAnchors(from url: URL) throws {
        let data = try Data(contentsOf: url)
        let container = try JSONDecoder().decode(AnchorsContainer.self, from: data)
        for anchor in container.anchors {
            anchors[anchor.id] = anchor.toDefinition()
        }
    }

    private func loadQuests(from url: URL) throws {
        let data = try Data(contentsOf: url)
        // quests.json can be either a container with "quests" array or a direct array
        do {
            let container = try JSONDecoder().decode(QuestsContainer.self, from: data)
            for quest in container.quests {
                quests[quest.id] = quest.toDefinition()
            }
        } catch {
            // Try direct array format (like events.json)
            let questArray = try JSONDecoder().decode([JSONQuest].self, from: data)
            for quest in questArray {
                quests[quest.id] = quest.toDefinition()
            }
        }
    }

    private func loadChallenges(from url: URL) throws {
        let data = try Data(contentsOf: url)
        let container = try JSONDecoder().decode(ChallengesContainer.self, from: data)
        for challenge in container.challenges {
            miniGameChallenges[challenge.id] = challenge.toDefinition()
        }
    }

    private func loadEventPools() throws {
        // Events are now in events.json with pool_ids field, not separate pool files
        // Load events.json which contains all events with their pool associations
        if let eventsURL = bundle.url(forResource: "events", withExtension: "json") {
            try loadEvents(from: eventsURL)
        } else {
            loadErrors.append("events.json not found")
        }
    }

    private func loadEvents(from url: URL) throws {
        let data = try Data(contentsOf: url)
        // events.json is a direct array, not wrapped in a container
        let eventArray = try JSONDecoder().decode([JSONEvent].self, from: data)
        for event in eventArray {
            let definition = event.toDefinition()
            events[definition.id] = definition
        }
    }

    private func loadEventPool(from url: URL) throws {
        let data = try Data(contentsOf: url)
        let container = try JSONDecoder().decode(EventPoolContainer.self, from: data)
        for event in container.events {
            let definition = event.toDefinition()
            events[definition.id] = definition
        }
    }

    private func buildEventIndices() {
        eventsByPool.removeAll()
        eventsByRegion.removeAll()

        for event in events.values {
            // Index by pool
            for poolId in event.poolIds {
                eventsByPool[poolId, default: []].append(event)
            }

            // Index by region (from availability)
            if let regionIds = event.availability.regionIds {
                for regionId in regionIds {
                    eventsByRegion[regionId, default: []].append(event)
                }
            }
        }
    }

    // MARK: - ContentProvider Implementation

    func getAllRegionDefinitions() -> [RegionDefinition] {
        return Array(regions.values)
    }

    func getRegionDefinition(id: String) -> RegionDefinition? {
        return regions[id]
    }

    func getAllAnchorDefinitions() -> [AnchorDefinition] {
        return Array(anchors.values)
    }

    func getAnchorDefinition(id: String) -> AnchorDefinition? {
        return anchors[id]
    }

    func getAnchorDefinition(forRegion regionId: String) -> AnchorDefinition? {
        return anchors.values.first { $0.regionId == regionId }
    }

    func getAllEventDefinitions() -> [EventDefinition] {
        return Array(events.values)
    }

    func getEventDefinition(id: String) -> EventDefinition? {
        return events[id]
    }

    func getEventDefinitions(forRegion regionId: String) -> [EventDefinition] {
        guard let region = regions[regionId] else { return [] }

        var result: [EventDefinition] = []
        for poolId in region.eventPoolIds {
            result.append(contentsOf: eventsByPool[poolId] ?? [])
        }
        result.append(contentsOf: eventsByRegion[regionId] ?? [])

        var seen = Set<String>()
        return result.filter { seen.insert($0.id).inserted }
    }

    func getEventDefinitions(forPool poolId: String) -> [EventDefinition] {
        return eventsByPool[poolId] ?? []
    }

    func getAllQuestDefinitions() -> [QuestDefinition] {
        return Array(quests.values)
    }

    func getQuestDefinition(id: String) -> QuestDefinition? {
        return quests[id]
    }

    func getAllMiniGameChallenges() -> [MiniGameChallengeDefinition] {
        return Array(miniGameChallenges.values)
    }

    func getMiniGameChallenge(id: String) -> MiniGameChallengeDefinition? {
        return miniGameChallenges[id]
    }

    func validate() -> [ContentValidationError] {
        let validator = ContentValidator(provider: self)
        return validator.validate()
    }
}

// MARK: - JSON Schema Containers

/// Container for regions.json
private struct RegionsContainer: Codable {
    let version: String?
    let description: String?
    let regions: [JSONRegion]
}

/// Container for anchors.json
private struct AnchorsContainer: Codable {
    let version: String?
    let description: String?
    let anchors: [JSONAnchor]
}

/// Container for quests.json
private struct QuestsContainer: Codable {
    let version: String?
    let description: String?
    let quests: [JSONQuest]
}

/// Container for challenges.json
private struct ChallengesContainer: Codable {
    let version: String?
    let description: String?
    let challenges: [JSONChallenge]
}

/// Container for event pool files
private struct EventPoolContainer: Codable {
    let version: String?
    let poolId: String?
    let description: String?
    let events: [JSONEvent]
}

// MARK: - JSON Schema Types

private struct JSONRegion: Codable {
    let id: String
    let title: LocalizedString
    let description: LocalizedString
    let regionType: String?
    let neighborIds: [String]
    let initiallyDiscovered: Bool?
    let anchorId: String?
    let eventPoolIds: [String]?
    let initialState: String?
    let degradationWeight: Int?

    enum CodingKeys: String, CodingKey {
        case id, title, description, neighborIds, initiallyDiscovered, anchorId
        case eventPoolIds, initialState, degradationWeight
        case regionType = "region_type"
    }

    func toDefinition() -> RegionDefinition {
        let state: RegionStateType
        switch initialState?.lowercased() {
        case "stable": state = .stable
        case "borderland": state = .borderland
        case "breach": state = .breach
        default: state = .stable
        }

        return RegionDefinition(
            id: id,
            title: title,
            description: description,
            regionType: regionType ?? "forest",
            neighborIds: neighborIds,
            initiallyDiscovered: initiallyDiscovered ?? false,
            anchorId: anchorId,
            eventPoolIds: eventPoolIds ?? [],
            initialState: state,
            degradationWeight: degradationWeight ?? 1
        )
    }
}

private struct JSONAnchor: Codable {
    let id: String
    let title: LocalizedString
    let description: LocalizedString
    let regionId: String
    let anchorType: String?
    let initialInfluence: String?
    let power: Int?
    let initialIntegrity: Int?

    func toDefinition() -> AnchorDefinition {
        let influence: AnchorInfluence
        switch initialInfluence?.lowercased() {
        case "light": influence = .light
        case "dark": influence = .dark
        default: influence = .neutral
        }

        return AnchorDefinition(
            id: id,
            title: title,
            description: description,
            regionId: regionId,
            anchorType: anchorType ?? "shrine",
            initialInfluence: influence,
            power: power ?? 5,
            initialIntegrity: initialIntegrity ?? 100
        )
    }
}

/// Represents event_kind which can be either a string "inline" or object {"mini_game": "combat"}
private enum JSONEventKind: Codable {
    case inline
    case miniGame(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()

        // Try string first (e.g., "inline")
        if let stringValue = try? container.decode(String.self) {
            if stringValue == "inline" {
                self = .inline
            } else {
                // Treat other strings as mini_game type
                self = .miniGame(stringValue)
            }
            return
        }

        // Try object (e.g., {"mini_game": "combat"})
        if let dictValue = try? container.decode([String: String].self),
           let miniGameType = dictValue["mini_game"] {
            self = .miniGame(miniGameType)
            return
        }

        // Default to inline
        self = .inline
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .inline:
            try container.encode("inline")
        case .miniGame(let type):
            try container.encode(["mini_game": type])
        }
    }

    func toEventKind() -> EventKind {
        switch self {
        case .inline:
            return .inline
        case .miniGame(let type):
            switch type.lowercased() {
            case "combat": return .miniGame(.combat)
            case "ritual": return .miniGame(.ritual)
            case "exploration": return .miniGame(.exploration)
            case "dialogue": return .miniGame(.dialogue)
            case "puzzle": return .miniGame(.puzzle)
            default: return .miniGame(.combat)
            }
        }
    }
}

private struct JSONEvent: Codable {
    let id: String
    let title: LocalizedString
    let body: LocalizedString
    let eventKind: JSONEventKind?
    let eventType: String?
    let poolIds: [String]?
    let availability: JSONAvailability?
    let weight: Int?
    let isOneTime: Bool?
    let isInstant: Bool?
    let cooldown: Int?
    let choices: [JSONChoice]?
    let combatData: JSONCombatData?
    let miniGameChallenge: JSONMiniGameChallenge?

    enum CodingKeys: String, CodingKey {
        case id, title, body, availability, weight, choices, combatData
        case eventKind = "event_kind"
        case eventType = "event_type"
        case poolIds = "pool_ids"
        case isOneTime = "is_one_time"
        case isInstant = "is_instant"
        case cooldown
        case miniGameChallenge = "mini_game_challenge"
    }

    func toDefinition() -> EventDefinition {
        let kind: EventKind
        // Prefer eventKind (can be string or object), fall back to eventType (legacy string)
        if let ek = eventKind {
            kind = ek.toEventKind()
        } else if let et = eventType {
            switch et.lowercased() {
            case "combat": kind = .miniGame(.combat)
            case "ritual": kind = .miniGame(.ritual)
            case "exploration": kind = .miniGame(.exploration)
            default: kind = .inline
            }
        } else {
            kind = .inline
        }

        let avail = availability?.toAvailability() ?? .always

        let choiceDefs = choices?.map { $0.toDefinition() } ?? []

        // Create MiniGameChallengeDefinition from JSON mini_game_challenge
        let challenge: MiniGameChallengeDefinition?
        if let json = miniGameChallenge, let enemyId = json.enemyId {
            challenge = MiniGameChallengeDefinition(
                id: "challenge_\(enemyId)",
                challengeKind: .combat,
                difficulty: json.difficulty ?? 1,
                enemyId: enemyId,
                victoryConsequences: json.rewards?.toConsequences() ?? .none,
                defeatConsequences: json.penalties?.toConsequences() ?? .none
            )
        } else {
            challenge = nil
        }

        return EventDefinition(
            id: id,
            title: title,
            body: body,
            eventKind: kind,
            availability: avail,
            poolIds: poolIds ?? [],
            weight: weight ?? 10,
            isOneTime: isOneTime ?? false,
            choices: choiceDefs,
            miniGameChallenge: challenge
        )
    }
}

private struct JSONAvailability: Codable {
    let regionStates: [String]?
    let regionIds: [String]?
    let minPressure: Int?
    let maxPressure: Int?
    let minBalance: Int?
    let maxBalance: Int?
    let requiredFlags: [String]?
    let forbiddenFlags: [String]?

    enum CodingKeys: String, CodingKey {
        case regionStates = "region_states"
        case regionIds = "region_ids"
        case minPressure = "min_pressure"
        case maxPressure = "max_pressure"
        case minBalance = "min_balance"
        case maxBalance = "max_balance"
        case requiredFlags = "required_flags"
        case forbiddenFlags = "forbidden_flags"
    }

    func toAvailability() -> Availability {
        return Availability(
            requiredFlags: requiredFlags ?? [],
            forbiddenFlags: forbiddenFlags ?? [],
            minPressure: minPressure,
            maxPressure: maxPressure,
            minBalance: minBalance,
            maxBalance: maxBalance,
            regionStates: regionStates,
            regionIds: regionIds
        )
    }
}

private struct JSONChoice: Codable {
    let id: String
    let label: LocalizedString
    let tooltip: LocalizedString?
    let requirements: JSONChoiceRequirements?
    let consequences: JSONChoiceConsequences?

    func toDefinition() -> ChoiceDefinition {
        let reqs = requirements?.toRequirements()
        let cons = consequences?.toConsequences() ?? .none

        return ChoiceDefinition(
            id: id,
            label: label,
            tooltip: tooltip,
            requirements: reqs,
            consequences: cons
        )
    }
}

private struct JSONChoiceRequirements: Codable {
    let minFaith: Int?
    let minHealth: Int?
    let minBalance: Int?
    let maxBalance: Int?
    let requiredFlags: [String]?
    let forbiddenFlags: [String]?

    func toRequirements() -> ChoiceRequirements {
        var minResources: [String: Int] = [:]
        if let faith = minFaith { minResources["faith"] = faith }
        if let health = minHealth { minResources["health"] = health }

        return ChoiceRequirements(
            minResources: minResources,
            requiredFlags: requiredFlags ?? [],
            forbiddenFlags: forbiddenFlags ?? [],
            minBalance: minBalance,
            maxBalance: maxBalance
        )
    }
}

private struct JSONChoiceConsequences: Codable {
    let resourceChanges: [String: Int]?
    let setFlags: [String: Bool]?
    let clearFlags: [String]?
    let balanceShift: Int?
    let tensionChange: Int?
    let reputationChange: Int?
    let anchorIntegrityChange: Int?
    let addCards: [String]?
    let addCurse: String?
    let giveArtifact: String?
    let startCombat: Bool?
    let startQuest: String?
    let messageKey: String?

    func toConsequences() -> ChoiceConsequences {
        let resources = resourceChanges ?? [:]

        // Convert flag dict to array
        let flags = setFlags?.filter { $0.value }.map { $0.key } ?? []
        let clear = clearFlags ?? []

        return ChoiceConsequences(
            resourceChanges: resources,
            setFlags: flags,
            clearFlags: clear,
            balanceDelta: balanceShift ?? 0,
            resultKey: messageKey
        )
    }
}

private struct JSONCombatData: Codable {
    let enemyId: String?
    let enemyName: String?
    let enemyPower: Int?
    let enemyDefense: Int?
    let enemyHealth: Int?
    let isBoss: Bool?
}

/// JSON representation of mini_game_challenge field in events
private struct JSONMiniGameChallenge: Codable {
    let enemyId: String?
    let difficulty: Int?
    let rewards: JSONChallengeConsequences?
    let penalties: JSONChallengeConsequences?

    enum CodingKeys: String, CodingKey {
        case enemyId = "enemy_id"
        case difficulty, rewards, penalties
    }
}

/// JSON representation of rewards/penalties in mini_game_challenge
private struct JSONChallengeConsequences: Codable {
    let resourceChanges: [String: Int]?
    let setFlags: [String]?
    let balanceShift: Int?

    enum CodingKeys: String, CodingKey {
        case resourceChanges = "resource_changes"
        case setFlags = "set_flags"
        case balanceShift = "balance_shift"
    }

    func toConsequences() -> ChoiceConsequences {
        return ChoiceConsequences(
            resourceChanges: resourceChanges ?? [:],
            setFlags: setFlags ?? [],
            clearFlags: [],
            balanceDelta: balanceShift ?? 0
        )
    }
}

private struct JSONQuest: Codable {
    let id: String
    let title: LocalizedString
    let description: LocalizedString
    let questKind: String?
    let availability: JSONQuestAvailability?
    let autoStart: Bool?
    let objectives: [JSONObjective]?
    let completionRewards: JSONQuestCompletionRewards?
    let failurePenalties: JSONQuestCompletionRewards?

    enum CodingKeys: String, CodingKey {
        case id, title, description, objectives, availability
        case questKind = "quest_kind"
        case autoStart = "auto_start"
        case completionRewards = "completion_rewards"
        case failurePenalties = "failure_penalties"
    }

    func toDefinition() -> QuestDefinition {
        let objDefs = objectives?.map { $0.toDefinition() } ?? []

        let kind: QuestKind
        switch questKind?.lowercased() {
        case "main": kind = .main
        case "side": kind = .side
        case "exploration": kind = .exploration
        case "challenge": kind = .challenge
        default: kind = .side
        }

        let avail = availability?.toAvailability() ?? .always
        let rewards = completionRewards?.toRewards() ?? .none
        let penalties = failurePenalties?.toRewards() ?? .none

        return QuestDefinition(
            id: id,
            title: title,
            description: description,
            objectives: objDefs,
            questKind: kind,
            availability: avail,
            autoStart: autoStart ?? false,
            completionRewards: rewards,
            failurePenalties: penalties
        )
    }
}

private struct JSONObjective: Codable {
    let id: String
    let description: LocalizedString
    let hint: LocalizedString?
    let completionCondition: JSONCompletionCondition?
    let targetValue: Int?
    let isOptional: Bool?
    let nextObjectiveId: String?
    let alternativeNextIds: [String]?

    enum CodingKeys: String, CodingKey {
        case id, description, hint
        case completionCondition = "completion_condition"
        case targetValue = "target_value"
        case isOptional = "is_optional"
        case nextObjectiveId = "next_objective_id"
        case alternativeNextIds = "alternative_next_ids"
    }

    func toDefinition() -> ObjectiveDefinition {
        let condition = completionCondition?.toCondition() ?? .manual

        return ObjectiveDefinition(
            id: id,
            description: description,
            hint: hint,
            completionCondition: condition,
            targetValue: targetValue ?? 1,
            isOptional: isOptional ?? false,
            nextObjectiveId: nextObjectiveId,
            alternativeNextIds: alternativeNextIds ?? []
        )
    }
}

/// Completion condition that can be either:
/// - Direct format: {"flag_set": "flag_name"} or {"visit_region": "region_id"}
/// - Object format: {"type": "flagset", "flag": "flag_name"}
private struct JSONCompletionCondition: Codable {
    // Direct format keys
    let flagSet: String?
    let visitRegion: String?
    let eventCompleted: String?
    let defeatEnemy: String?
    let collectItem: String?

    // Choice made format: {"choice_made": {"event_id": "...", "choice_id": "..."}}
    let choiceMade: JSONChoiceMadeCondition?

    // Resource threshold format: {"resource_threshold": {"resource_id": "...", "min_value": 10}}
    let resourceThreshold: JSONResourceThresholdCondition?

    // Legacy object format fields
    let type: String?
    let regionId: String?
    let eventId: String?
    let flag: String?
    let threshold: Int?

    enum CodingKeys: String, CodingKey {
        case flagSet = "flag_set"
        case visitRegion = "visit_region"
        case eventCompleted = "event_completed"
        case defeatEnemy = "defeat_enemy"
        case collectItem = "collect_item"
        case choiceMade = "choice_made"
        case resourceThreshold = "resource_threshold"
        case type, regionId, eventId, flag, threshold
    }

    func toCondition() -> CompletionCondition {
        // Check direct format keys first
        if let flag = flagSet {
            return .flagSet(flag)
        }
        if let region = visitRegion {
            return .visitRegion(region)
        }
        if let event = eventCompleted {
            return .eventCompleted(event)
        }
        if let enemy = defeatEnemy {
            return .defeatEnemy(enemy)
        }
        if let item = collectItem {
            return .collectItem(item)
        }
        if let choice = choiceMade {
            return .choiceMade(eventId: choice.eventId ?? "", choiceId: choice.choiceId ?? "")
        }
        if let resource = resourceThreshold {
            return .resourceThreshold(resourceId: resource.resourceId ?? "", minValue: resource.minValue ?? 0)
        }

        // Fall back to legacy object format
        switch type?.lowercased() {
        case "visitregion", "visit_region":
            return .visitRegion(regionId ?? "")
        case "eventcompleted", "event_completed":
            return .eventCompleted(eventId ?? "")
        case "flagset", "flag_set":
            return .flagSet(flag ?? "")
        case "defeatenemy", "defeat_enemy":
            return .defeatEnemy(eventId ?? "")
        default:
            return .manual
        }
    }
}

private struct JSONChoiceMadeCondition: Codable {
    let eventId: String?
    let choiceId: String?

    enum CodingKeys: String, CodingKey {
        case eventId = "event_id"
        case choiceId = "choice_id"
    }
}

private struct JSONResourceThresholdCondition: Codable {
    let resourceId: String?
    let minValue: Int?

    enum CodingKeys: String, CodingKey {
        case resourceId = "resource_id"
        case minValue = "min_value"
    }
}

private struct JSONQuestAvailability: Codable {
    let requiredFlags: [String]?
    let forbiddenFlags: [String]?
    let minPressure: Int?
    let maxPressure: Int?
    let minBalance: Int?
    let maxBalance: Int?
    let regionStates: [String]?
    let regionIds: [String]?

    enum CodingKeys: String, CodingKey {
        case requiredFlags = "required_flags"
        case forbiddenFlags = "forbidden_flags"
        case minPressure = "min_pressure"
        case maxPressure = "max_pressure"
        case minBalance = "min_balance"
        case maxBalance = "max_balance"
        case regionStates = "region_states"
        case regionIds = "region_ids"
    }

    func toAvailability() -> Availability {
        return Availability(
            requiredFlags: requiredFlags ?? [],
            forbiddenFlags: forbiddenFlags ?? [],
            minPressure: minPressure,
            maxPressure: maxPressure,
            minBalance: minBalance,
            maxBalance: maxBalance,
            regionStates: regionStates,
            regionIds: regionIds
        )
    }
}

private struct JSONQuestCompletionRewards: Codable {
    let resourceChanges: [String: Int]?
    let setFlags: [String]?
    let cardIds: [String]?
    let balanceDelta: Int?

    enum CodingKeys: String, CodingKey {
        case resourceChanges = "resource_changes"
        case setFlags = "set_flags"
        case cardIds = "card_ids"
        case balanceDelta = "balance_delta"
    }

    func toRewards() -> QuestCompletionRewards {
        return QuestCompletionRewards(
            resourceChanges: resourceChanges ?? [:],
            setFlags: setFlags ?? [],
            cardIds: cardIds ?? [],
            balanceDelta: balanceDelta ?? 0
        )
    }
}

private struct JSONQuestRewards: Codable {
    let resourceChanges: [String: Int]?
    let setFlags: [String: Bool]?
    let balanceShift: Int?
    let tensionChange: Int?
    let reputationChange: Int?
    let giveArtifact: String?
    let unlockRegions: [String]?
    let addCurse: String?
}

private struct JSONChallenge: Codable {
    let id: String
    let challengeKind: String?
    let difficulty: Int?
    let titleKey: String?
    let descriptionKey: String?
    let enemyData: JSONCombatData?
    let requirements: JSONChoiceRequirements?
    let rewards: JSONChallengeRewards?
    let penalties: JSONChallengePenalties?
    let isBoss: Bool?

    func toDefinition() -> MiniGameChallengeDefinition {
        let kind: MiniGameChallengeKind
        switch challengeKind?.lowercased() {
        case "combat": kind = .combat
        case "ritual": kind = .ritual
        case "exploration": kind = .exploration
        case "dialogue": kind = .dialogue
        case "puzzle": kind = .puzzle
        default: kind = .combat
        }

        return MiniGameChallengeDefinition(
            id: id,
            challengeKind: kind,
            difficulty: difficulty ?? 5,
            enemyId: enemyData?.enemyId
        )
    }
}

private struct JSONChallengeRewards: Codable {
    let victoryFaith: Int?
    let victoryBalance: Int?
    let setFlags: [String: Bool]?
    let discoverRegion: Bool?
    let findArtifact: Bool?
}

private struct JSONChallengePenalties: Codable {
    let defeatHealth: Int?
    let defeatTension: Int?
    let faithCost: Int?
    let healthCost: Int?
    let tensionGain: Int?
}


// ==========================================
// FILE: Engine/Data/Definitions/AnchorDefinition.swift
// ==========================================

import Foundation

// MARK: - Anchor Influence

/// Influence alignment of an anchor (maps to CardBalance in legacy models)
enum AnchorInfluence: String, Codable, Hashable {
    case light
    case neutral
    case dark
}

// MARK: - Anchor Definition
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.1
// Reference: Docs/EXPLORATION_CORE_DESIGN.md, Section 6

/// Immutable definition of an anchor point.
/// Anchors provide resistance to regional degradation.
/// Runtime state (current integrity, etc.) lives in AnchorRuntimeState.
struct AnchorDefinition: GameDefinition {
    // MARK: - Identity

    /// Unique anchor identifier (e.g., "anchor_forest_shrine")
    let id: String

    // MARK: - Localized Content

    /// Anchor name with all language variants
    let title: LocalizedString

    /// Anchor description with all language variants
    let description: LocalizedString

    // MARK: - Location

    /// ID of the region where this anchor is located
    let regionId: String

    // MARK: - Type & Influence (Twilight Marches specific)

    /// Anchor type (e.g., "chapel", "shrine", "sacred_tree")
    let anchorType: String

    /// Initial influence: "light", "neutral", or "dark"
    let initialInfluence: AnchorInfluence

    /// Power level (radius of influence, 1-10)
    let power: Int

    // MARK: - Mechanics

    /// Maximum integrity value (0-100)
    let maxIntegrity: Int

    /// Initial integrity value
    let initialIntegrity: Int

    /// Integrity gained per "strengthen" action
    let strengthenAmount: Int

    /// Resource cost to strengthen (e.g., ["faith": 5])
    let strengthenCost: ResourceTransaction

    // MARK: - Effects

    /// Resistance chance calculation: integrity / resistanceDivisor
    /// Default: 100 (so 50 integrity = 50% resistance)
    let resistanceDivisor: Int

    // MARK: - Initialization

    init(
        id: String,
        title: LocalizedString,
        description: LocalizedString,
        regionId: String,
        anchorType: String = "shrine",
        initialInfluence: AnchorInfluence = .neutral,
        power: Int = 5,
        maxIntegrity: Int = 100,
        initialIntegrity: Int = 50,
        strengthenAmount: Int = 15,
        strengthenCost: ResourceTransaction = .spend("faith", amount: 5),
        resistanceDivisor: Int = 100
    ) {
        self.id = id
        self.title = title
        self.description = description
        self.regionId = regionId
        self.anchorType = anchorType
        self.initialInfluence = initialInfluence
        self.power = power
        self.maxIntegrity = maxIntegrity
        self.initialIntegrity = initialIntegrity
        self.strengthenAmount = strengthenAmount
        self.strengthenCost = strengthenCost
        self.resistanceDivisor = resistanceDivisor
    }
}


// ==========================================
// FILE: Engine/Data/Definitions/EnemyDefinition.swift
// ==========================================

import Foundation

// MARK: - Enemy Definition
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.1
// Data-driven enemy definitions for combat events

/// Immutable definition of an enemy.
/// Used to create monster cards for combat events.
struct EnemyDefinition: GameDefinition {
    // MARK: - Identity

    /// Unique enemy identifier (e.g., "leshy", "wild_beast")
    let id: String

    // MARK: - Localized Content

    /// Enemy name with all language variants
    let name: LocalizedString

    /// Enemy description with all language variants
    let description: LocalizedString

    // MARK: - Stats

    /// Base health points
    let health: Int

    /// Base attack power
    let power: Int

    /// Base defense
    let defense: Int

    /// Difficulty rating (1-5, affects scaling)
    let difficulty: Int

    // MARK: - Classification

    /// Enemy type classification
    let enemyType: EnemyType

    /// Card rarity for loot/display
    let rarity: CardRarity

    // MARK: - Abilities

    /// Special abilities this enemy has
    let abilities: [EnemyAbility]

    // MARK: - Loot & Rewards

    /// Cards that can drop when defeated
    let lootCardIds: [String]

    /// Faith reward when defeated
    let faithReward: Int

    /// Balance change when defeated
    let balanceDelta: Int

    // Note: No explicit CodingKeys needed - PackLoader uses .convertFromSnakeCase
    // which automatically converts enemy_type → enemyType, faith_reward → faithReward, etc.

    // MARK: - Initialization

    init(
        id: String,
        name: LocalizedString,
        description: LocalizedString,
        health: Int,
        power: Int,
        defense: Int,
        difficulty: Int = 1,
        enemyType: EnemyType = .beast,
        rarity: CardRarity = .common,
        abilities: [EnemyAbility] = [],
        lootCardIds: [String] = [],
        faithReward: Int = 0,
        balanceDelta: Int = 0
    ) {
        self.id = id
        self.name = name
        self.description = description
        self.health = health
        self.power = power
        self.defense = defense
        self.difficulty = difficulty
        self.enemyType = enemyType
        self.rarity = rarity
        self.abilities = abilities
        self.lootCardIds = lootCardIds
        self.faithReward = faithReward
        self.balanceDelta = balanceDelta
    }

    /// Convert to legacy Card (monster type) for UI compatibility
    func toCard() -> Card {
        return Card(
            id: UUID(uuidString: id.md5UUID) ?? UUID(),
            definitionId: id,  // Content Pack ID for tracking
            name: name.localized,
            type: .monster,
            rarity: rarity,
            description: description.localized,
            power: power,
            defense: defense,
            health: health
        )
    }
}

// MARK: - Enemy Type

enum EnemyType: String, Codable, Hashable {
    case beast       // Wild animals
    case spirit      // Forest spirits, leshy
    case undead      // Risen dead, ghosts
    case demon       // Navi creatures
    case human       // Bandits, cultists
    case boss        // Major enemies
}

// MARK: - Enemy Ability

struct EnemyAbility: Codable, Hashable, Identifiable {
    let id: String
    let name: LocalizedString
    let description: LocalizedString
    let effect: EnemyAbilityEffect

    init(
        id: String,
        name: LocalizedString,
        description: LocalizedString,
        effect: EnemyAbilityEffect
    ) {
        self.id = id
        self.name = name
        self.description = description
        self.effect = effect
    }
}

enum EnemyAbilityEffect: Codable, Hashable {
    /// Deal extra damage
    case bonusDamage(Int)

    /// Heal each turn
    case regeneration(Int)

    /// Reduce incoming damage
    case armor(Int)

    /// First strike - attacks before player
    case firstStrike

    /// Cannot be targeted by spells
    case spellImmune

    /// Applies curse on hit
    case applyCurse(String)

    /// Custom effect by ID
    case custom(String)

    // MARK: - Custom Codable for JSON compatibility

    enum CodingKeys: String, CodingKey {
        case bonusDamage = "bonus_damage"
        case regeneration
        case armor
        case firstStrike = "first_strike"
        case spellImmune = "spell_immune"
        case applyCurse = "apply_curse"
        case custom
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        if let value = try container.decodeIfPresent(Int.self, forKey: .bonusDamage) {
            self = .bonusDamage(value)
        } else if let value = try container.decodeIfPresent(Int.self, forKey: .regeneration) {
            self = .regeneration(value)
        } else if let value = try container.decodeIfPresent(Int.self, forKey: .armor) {
            self = .armor(value)
        } else if (try? container.decodeIfPresent(Bool.self, forKey: .firstStrike)) == true {
            self = .firstStrike
        } else if (try? container.decodeIfPresent(Bool.self, forKey: .spellImmune)) == true {
            self = .spellImmune
        } else if let value = try container.decodeIfPresent(String.self, forKey: .applyCurse) {
            self = .applyCurse(value)
        } else if let value = try container.decodeIfPresent(String.self, forKey: .custom) {
            self = .custom(value)
        } else {
            // Default to custom with empty string if no recognized key
            self = .custom("unknown")
        }
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        switch self {
        case .bonusDamage(let value):
            try container.encode(value, forKey: .bonusDamage)
        case .regeneration(let value):
            try container.encode(value, forKey: .regeneration)
        case .armor(let value):
            try container.encode(value, forKey: .armor)
        case .firstStrike:
            try container.encode(true, forKey: .firstStrike)
        case .spellImmune:
            try container.encode(true, forKey: .spellImmune)
        case .applyCurse(let value):
            try container.encode(value, forKey: .applyCurse)
        case .custom(let value):
            try container.encode(value, forKey: .custom)
        }
    }
}

// MARK: - String UUID Extension (reuse pattern)

private extension String {
    var md5UUID: String {
        var hash: UInt64 = 5381
        for char in self.utf8 {
            hash = ((hash << 5) &+ hash) &+ UInt64(char)
        }
        let hex = String(format: "%016llX", hash)
        let padded = hex.padding(toLength: 32, withPad: "0", startingAt: 0)
        let chars = Array(padded)
        return "\(String(chars[0..<8]))-\(String(chars[8..<12]))-\(String(chars[12..<16]))-\(String(chars[16..<20]))-\(String(chars[20..<32]))"
    }
}


// ==========================================
// FILE: Engine/Data/Definitions/EventDefinition.swift
// ==========================================

import Foundation

// MARK: - Event Definition
// Reference: Docs/EVENT_MODULE_ARCHITECTURE.md
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.1

/// Immutable definition of a game event.
/// Events can be Inline (resolve in flow) or Mini-Game (external module).
/// Runtime state (completion, cooldowns) lives in EventRuntimeState.
struct EventDefinition: GameDefinition {
    // MARK: - Identity

    /// Unique event identifier (e.g., "event_forest_whispers")
    let id: String

    // MARK: - Localized Content

    /// Event title with all language variants
    let title: LocalizedString

    /// Event body/narrative text with all language variants
    let body: LocalizedString

    // MARK: - Type Classification

    /// Event kind: inline or mini-game
    let eventKind: EventKind

    // MARK: - Availability

    /// Conditions for this event to appear
    let availability: Availability

    /// Event pool IDs this event belongs to
    let poolIds: [String]

    /// Weight for random selection (higher = more likely)
    let weight: Int

    // MARK: - Behavior Flags

    /// If true, event can only occur once per playthrough
    let isOneTime: Bool

    /// If true, event resolves instantly (0 time cost)
    let isInstant: Bool

    /// Cooldown in turns before event can reoccur (0 = no cooldown)
    let cooldown: Int

    // MARK: - Content

    /// Choices available in this event (for inline events)
    let choices: [ChoiceDefinition]

    /// Mini-game challenge (for mini-game events)
    let miniGameChallenge: MiniGameChallengeDefinition?

    // MARK: - Initialization

    init(
        id: String,
        title: LocalizedString,
        body: LocalizedString,
        eventKind: EventKind = .inline,
        availability: Availability = .always,
        poolIds: [String] = [],
        weight: Int = 10,
        isOneTime: Bool = false,
        isInstant: Bool = false,
        cooldown: Int = 0,
        choices: [ChoiceDefinition] = [],
        miniGameChallenge: MiniGameChallengeDefinition? = nil
    ) {
        self.id = id
        self.title = title
        self.body = body
        self.eventKind = eventKind
        self.availability = availability
        self.poolIds = poolIds
        self.weight = weight
        self.isOneTime = isOneTime
        self.isInstant = isInstant
        self.cooldown = cooldown
        self.choices = choices
        self.miniGameChallenge = miniGameChallenge
    }
}

// MARK: - Event Kind

/// Classification of event kinds (Engine-specific, distinct from legacy EventType)
/// Reference: Docs/EVENT_MODULE_ARCHITECTURE.md, Section 2
enum EventKind: Codable, Hashable {
    /// Inline event - resolves within main game flow
    case inline

    /// Mini-game event - dispatches to external module
    case miniGame(MiniGameKind)

    /// All mini-game kinds
    enum MiniGameKind: String, Codable, Hashable {
        case combat
        case ritual
        case exploration
        case dialogue
        case puzzle
    }

    // MARK: - Custom Codable

    /// Coding keys for JSON object format
    /// Note: When decoder uses convertFromSnakeCase, the JSON key "mini_game"
    /// is already converted to "miniGame", so we use that directly
    private enum CodingKeys: String, CodingKey {
        case miniGame
        // Alternative key for when convertFromSnakeCase is NOT used
        case miniGameSnake = "mini_game"
    }

    init(from decoder: Decoder) throws {
        // Try decoding as a simple string first: "inline"
        if let container = try? decoder.singleValueContainer(),
           let stringValue = try? container.decode(String.self) {
            if stringValue == "inline" {
                self = .inline
            } else if let miniGameKind = MiniGameKind(rawValue: stringValue) {
                // Handle direct mini-game string: "combat", "ritual", etc.
                self = .miniGame(miniGameKind)
            } else {
                throw DecodingError.dataCorruptedError(
                    in: container,
                    debugDescription: "Unknown event kind: \(stringValue)"
                )
            }
            return
        }

        // Try decoding as object: {"mini_game": "combat"}
        // Try both key formats to support convertFromSnakeCase and regular decoding
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let miniGameString: String
        if let value = try container.decodeIfPresent(String.self, forKey: .miniGame) {
            miniGameString = value
        } else if let value = try container.decodeIfPresent(String.self, forKey: .miniGameSnake) {
            miniGameString = value
        } else {
            throw DecodingError.keyNotFound(
                CodingKeys.miniGame,
                DecodingError.Context(codingPath: container.codingPath, debugDescription: "Neither 'miniGame' nor 'mini_game' found")
            )
        }

        if let miniGameKind = MiniGameKind(rawValue: miniGameString) {
            self = .miniGame(miniGameKind)
        } else {
            throw DecodingError.dataCorruptedError(
                forKey: .miniGame,
                in: container,
                debugDescription: "Unknown mini-game kind: \(miniGameString)"
            )
        }
    }

    func encode(to encoder: Encoder) throws {
        switch self {
        case .inline:
            var container = encoder.singleValueContainer()
            try container.encode("inline")
        case .miniGame(let kind):
            // Always encode with snake_case for JSON compatibility
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(kind.rawValue, forKey: .miniGameSnake)
        }
    }
}

// MARK: - Choice Definition

/// Immutable definition of a choice within an event.
struct ChoiceDefinition: Codable, Hashable, Identifiable {
    // MARK: - Identity

    /// Unique choice identifier within the event
    let id: String

    // MARK: - Localized Content

    /// Choice button text with all language variants
    let label: LocalizedString

    /// Optional choice tooltip/description with all language variants
    let tooltip: LocalizedString?

    // MARK: - Requirements

    /// Conditions for this choice to be available
    let requirements: ChoiceRequirements?

    // MARK: - Consequences

    /// Outcomes when this choice is selected
    let consequences: ChoiceConsequences

    // MARK: - Initialization

    init(
        id: String,
        label: LocalizedString,
        tooltip: LocalizedString? = nil,
        requirements: ChoiceRequirements? = nil,
        consequences: ChoiceConsequences
    ) {
        self.id = id
        self.label = label
        self.tooltip = tooltip
        self.requirements = requirements
        self.consequences = consequences
    }
}

// MARK: - Choice Requirements

/// Requirements that must be met to select a choice
struct ChoiceRequirements: Codable, Hashable {
    /// Minimum resource values required
    let minResources: [String: Int]

    /// Flags that must be set
    let requiredFlags: [String]

    /// Flags that must NOT be set
    let forbiddenFlags: [String]

    /// Minimum balance required (nil = no minimum)
    let minBalance: Int?

    /// Maximum balance allowed (nil = no maximum)
    let maxBalance: Int?

    init(
        minResources: [String: Int] = [:],
        requiredFlags: [String] = [],
        forbiddenFlags: [String] = [],
        minBalance: Int? = nil,
        maxBalance: Int? = nil
    ) {
        self.minResources = minResources
        self.requiredFlags = requiredFlags
        self.forbiddenFlags = forbiddenFlags
        self.minBalance = minBalance
        self.maxBalance = maxBalance
    }

    /// Convenience initializer with balance range
    init(
        minResources: [String: Int] = [:],
        requiredFlags: [String] = [],
        forbiddenFlags: [String] = [],
        balanceRange: ClosedRange<Int>?
    ) {
        self.minResources = minResources
        self.requiredFlags = requiredFlags
        self.forbiddenFlags = forbiddenFlags
        self.minBalance = balanceRange?.lowerBound
        self.maxBalance = balanceRange?.upperBound
    }

    /// Check if requirements can be met with given context
    /// - Note: Prefer using `Requirements.evaluator.canMeet(requirements:...)` instead
    ///   for cleaner separation of data and logic (see ENGINE_ARCHITECTURE.md)
    @available(*, deprecated, message: "Use Requirements.evaluator.canMeet() instead")
    func canMeet(resources: [String: Int], flags: Set<String>, balance: Int) -> Bool {
        // Check resources
        for (resourceId, minValue) in minResources {
            if (resources[resourceId] ?? 0) < minValue {
                return false
            }
        }

        // Check required flags
        for flag in requiredFlags {
            if !flags.contains(flag) {
                return false
            }
        }

        // Check forbidden flags
        for flag in forbiddenFlags {
            if flags.contains(flag) {
                return false
            }
        }

        // Check balance range
        if let min = minBalance, balance < min {
            return false
        }
        if let max = maxBalance, balance > max {
            return false
        }

        return true
    }
}

// MARK: - Choice Consequences

/// Outcomes that occur when a choice is selected
struct ChoiceConsequences: Codable, Hashable {
    /// Resource changes (costs and gains)
    let resourceChanges: [String: Int]

    /// Flags to set
    let setFlags: [String]

    /// Flags to clear
    let clearFlags: [String]

    /// Balance change (-100 to +100)
    let balanceDelta: Int

    /// Region state change (if any)
    let regionStateChange: RegionStateChange?

    /// Quest progress trigger
    let questProgress: QuestProgressTrigger?

    /// Follow-up event to trigger (if any)
    let triggerEventId: String?

    /// Narrative result key (for UI display)
    let resultKey: String?

    init(
        resourceChanges: [String: Int] = [:],
        setFlags: [String] = [],
        clearFlags: [String] = [],
        balanceDelta: Int = 0,
        regionStateChange: RegionStateChange? = nil,
        questProgress: QuestProgressTrigger? = nil,
        triggerEventId: String? = nil,
        resultKey: String? = nil
    ) {
        self.resourceChanges = resourceChanges
        self.setFlags = setFlags
        self.clearFlags = clearFlags
        self.balanceDelta = balanceDelta
        self.regionStateChange = regionStateChange
        self.questProgress = questProgress
        self.triggerEventId = triggerEventId
        self.resultKey = resultKey
    }

    /// Empty consequences (no-op choice)
    static let none = ChoiceConsequences()
}

// MARK: - Supporting Types

/// Region state change triggered by choice
struct RegionStateChange: Codable, Hashable {
    /// Target region ID (nil = current region)
    let regionId: String?

    /// New state to set
    let newState: RegionStateType?

    /// State transition (degrade/restore)
    let transition: StateTransition?

    enum StateTransition: String, Codable, Hashable {
        case degrade
        case restore
    }
}

/// Quest progress trigger
struct QuestProgressTrigger: Codable, Hashable {
    let questId: String
    let objectiveId: String?
    let action: QuestAction

    enum QuestAction: String, Codable, Hashable {
        case advance      // Move to next objective
        case complete     // Complete specific objective
        case fail         // Fail the quest
        case unlock       // Unlock the quest
    }
}


// ==========================================
// FILE: Engine/Data/Definitions/GameDefinition.swift
// ==========================================

import Foundation

// MARK: - Base Definition Protocol
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.1
// Reference: Docs/MIGRATION_PLAN.md, Feature A1

/// Base protocol for all game content definitions.
/// Definitions are IMMUTABLE - they contain no runtime state.
/// All runtime data belongs in RuntimeState types.
///
/// **Invariants:**
/// - INV-D01: Definitions have no mutable properties
/// - INV-D02: All IDs are String (not UUID)
/// - INV-D03: All user-facing text uses localization keys (titleKey, bodyKey)
protocol GameDefinition: Codable, Identifiable, Hashable {
    /// Unique identifier for this definition.
    /// Must be unique within its type (regions, events, quests, etc.)
    var id: String { get }
}

// MARK: - Localization Key Validation

/// Helper to validate localization key format.
/// Keys should follow pattern: "type.id.field" (e.g., "region.forest.title")
enum LocalizationKeyValidator {
    static func isValidKey(_ key: String) -> Bool {
        // Key must contain at least one dot and no spaces
        return key.contains(".") && !key.contains(" ")
    }

    static func validateKeys(_ keys: [String]) -> [String] {
        return keys.filter { !isValidKey($0) }
    }
}

// MARK: - Common Types

/// Availability conditions for content (events, choices, etc.)
/// Reference: Docs/EVENT_MODULE_ARCHITECTURE.md, Section 2.3
struct Availability: Codable, Hashable {
    /// Required flags that must be set
    let requiredFlags: [String]

    /// Forbidden flags that must NOT be set
    let forbiddenFlags: [String]

    /// Minimum pressure/tension required
    let minPressure: Int?

    /// Maximum pressure/tension allowed
    let maxPressure: Int?

    /// Minimum balance value required
    let minBalance: Int?

    /// Maximum balance value allowed
    let maxBalance: Int?

    /// Specific region states where this is available
    let regionStates: [String]?

    /// Specific region IDs where this is available
    let regionIds: [String]?

    init(
        requiredFlags: [String] = [],
        forbiddenFlags: [String] = [],
        minPressure: Int? = nil,
        maxPressure: Int? = nil,
        minBalance: Int? = nil,
        maxBalance: Int? = nil,
        regionStates: [String]? = nil,
        regionIds: [String]? = nil
    ) {
        self.requiredFlags = requiredFlags
        self.forbiddenFlags = forbiddenFlags
        self.minPressure = minPressure
        self.maxPressure = maxPressure
        self.minBalance = minBalance
        self.maxBalance = maxBalance
        self.regionStates = regionStates
        self.regionIds = regionIds
    }

    /// Default availability (always available)
    static let always = Availability()
}

// MARK: - Resource Cost/Gain

/// Represents a resource change (cost or gain)
struct ResourceChange: Codable, Hashable {
    let resourceId: String
    let amount: Int

    /// Positive = gain, negative = cost
    var isGain: Bool { amount > 0 }
    var isCost: Bool { amount < 0 }
}

/// Collection of resource changes for a transaction
struct ResourceTransaction: Codable, Hashable {
    let changes: [ResourceChange]

    /// Convenience for single resource
    static func spend(_ resourceId: String, amount: Int) -> ResourceTransaction {
        ResourceTransaction(changes: [ResourceChange(resourceId: resourceId, amount: -abs(amount))])
    }

    static func gain(_ resourceId: String, amount: Int) -> ResourceTransaction {
        ResourceTransaction(changes: [ResourceChange(resourceId: resourceId, amount: abs(amount))])
    }

    static let none = ResourceTransaction(changes: [])
}


// ==========================================
// FILE: Engine/Data/Definitions/LocalizedString.swift
// ==========================================

import Foundation

// MARK: - Localized String
// Reference: Docs/ENGINE_ARCHITECTURE.md
// Supports runtime localization without app rebuild - "Cartridge" approach

/// A string with multiple language variants, loaded from JSON content.
/// This enables adding new content without rebuilding the app.
struct LocalizedString: Codable, Hashable {
    // MARK: - Supported Languages

    /// English text
    let en: String

    /// Russian text
    let ru: String

    // MARK: - Localized Access

    /// Returns the string for the current device locale.
    /// Falls back to English if the current locale is not supported.
    var localized: String {
        let languageCode = Locale.current.language.languageCode?.identifier ?? "en"
        switch languageCode {
        case "ru": return ru
        default: return en
        }
    }

    /// Returns the string for a specific language code.
    func localized(for languageCode: String) -> String {
        switch languageCode {
        case "ru": return ru
        default: return en
        }
    }

    // MARK: - Convenience Initializers

    /// Create with the same text for all languages (for testing/development)
    init(_ text: String) {
        self.en = text
        self.ru = text
    }

    /// Create with specific translations
    init(en: String, ru: String) {
        self.en = en
        self.ru = ru
    }
}

// MARK: - ExpressibleByStringLiteral

extension LocalizedString: ExpressibleByStringLiteral {
    init(stringLiteral value: String) {
        self.en = value
        self.ru = value
    }
}

// MARK: - CustomStringConvertible

extension LocalizedString: CustomStringConvertible {
    var description: String {
        localized
    }
}


// ==========================================
// FILE: Engine/Data/Definitions/MiniGameChallengeDefinition.swift
// ==========================================

import Foundation

// MARK: - Mini-Game Challenge Definition
// Reference: Docs/EVENT_MODULE_ARCHITECTURE.md, Section 4

/// Immutable definition of a mini-game challenge.
/// Describes what gets dispatched to external mini-game modules.
struct MiniGameChallengeDefinition: Codable, Hashable, Identifiable {
    // MARK: - Identity

    /// Unique challenge identifier
    let id: String

    // MARK: - Type

    /// Type of mini-game challenge
    let challengeKind: MiniGameChallengeKind

    // MARK: - Difficulty

    /// Base difficulty level (1-10)
    let difficulty: Int

    /// Difficulty scaling based on pressure
    let pressureScaling: Double

    // MARK: - Content Reference

    /// Enemy ID for combat challenges
    let enemyId: String?

    /// Puzzle ID for puzzle challenges
    let puzzleId: String?

    /// Dialogue tree ID for dialogue challenges
    let dialogueId: String?

    // MARK: - Outcomes

    /// Consequences on victory
    let victoryConsequences: ChoiceConsequences

    /// Consequences on defeat
    let defeatConsequences: ChoiceConsequences

    /// Consequences on retreat/escape (if allowed)
    let retreatConsequences: ChoiceConsequences?

    // MARK: - Options

    /// Whether retreat/escape is allowed
    let canRetreat: Bool

    /// Time limit in turns (0 = no limit)
    let turnLimit: Int

    // MARK: - Initialization

    init(
        id: String,
        challengeKind: MiniGameChallengeKind,
        difficulty: Int = 5,
        pressureScaling: Double = 0.1,
        enemyId: String? = nil,
        puzzleId: String? = nil,
        dialogueId: String? = nil,
        victoryConsequences: ChoiceConsequences = .none,
        defeatConsequences: ChoiceConsequences = .none,
        retreatConsequences: ChoiceConsequences? = nil,
        canRetreat: Bool = true,
        turnLimit: Int = 0
    ) {
        self.id = id
        self.challengeKind = challengeKind
        self.difficulty = difficulty
        self.pressureScaling = pressureScaling
        self.enemyId = enemyId
        self.puzzleId = puzzleId
        self.dialogueId = dialogueId
        self.victoryConsequences = victoryConsequences
        self.defeatConsequences = defeatConsequences
        self.retreatConsequences = retreatConsequences
        self.canRetreat = canRetreat
        self.turnLimit = turnLimit
    }

    /// Calculate effective difficulty based on current pressure
    func effectiveDifficulty(at pressure: Int) -> Int {
        let scaled = Double(difficulty) + (Double(pressure) * pressureScaling)
        return Int(scaled.rounded())
    }

    // MARK: - Custom Codable

    /// Coding keys for JSON format from events.json
    /// Supports both camelCase (when convertFromSnakeCase is used) and snake_case (explicit)
    private enum CodingKeys: String, CodingKey {
        case id
        // camelCase keys (for when convertFromSnakeCase converts them)
        case challengeKind
        case pressureScaling
        case enemyId
        case puzzleId
        case dialogueId
        case victoryConsequences
        case defeatConsequences
        case retreatConsequences
        case canRetreat
        case turnLimit
        case difficulty
        // Simplified format keys (always used as-is)
        case rewards
        case penalties
    }

    /// Helper to decode a value trying both camelCase and snake_case keys
    private static func decodeOptional<T: Decodable>(
        _ type: T.Type,
        from container: KeyedDecodingContainer<CodingKeys>,
        key: CodingKeys
    ) throws -> T? {
        // With convertFromSnakeCase, keys are already converted, so just use camelCase key
        return try container.decodeIfPresent(type, forKey: key)
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        // Try full format first, then simplified format
        if let id = try container.decodeIfPresent(String.self, forKey: .id) {
            self.id = id
        } else if let enemyIdValue = try container.decodeIfPresent(String.self, forKey: .enemyId) {
            // Generate ID from enemy ID for simplified format
            self.id = "challenge_\(enemyIdValue)"
        } else {
            self.id = "challenge_unknown"
        }

        // Challenge kind - default to combat for simplified format
        self.challengeKind = try container.decodeIfPresent(MiniGameChallengeKind.self, forKey: .challengeKind) ?? .combat

        // Difficulty
        self.difficulty = try container.decodeIfPresent(Int.self, forKey: .difficulty) ?? 5

        // Pressure scaling
        self.pressureScaling = try container.decodeIfPresent(Double.self, forKey: .pressureScaling) ?? 0.1

        // Content references
        self.enemyId = try container.decodeIfPresent(String.self, forKey: .enemyId)
        self.puzzleId = try container.decodeIfPresent(String.self, forKey: .puzzleId)
        self.dialogueId = try container.decodeIfPresent(String.self, forKey: .dialogueId)

        // Consequences - try full format first, then simplified
        if let victory = try container.decodeIfPresent(ChoiceConsequences.self, forKey: .victoryConsequences) {
            self.victoryConsequences = victory
        } else if let rewards = try container.decodeIfPresent(ChoiceConsequences.self, forKey: .rewards) {
            self.victoryConsequences = rewards
        } else {
            self.victoryConsequences = .none
        }

        if let defeat = try container.decodeIfPresent(ChoiceConsequences.self, forKey: .defeatConsequences) {
            self.defeatConsequences = defeat
        } else if let penalties = try container.decodeIfPresent(ChoiceConsequences.self, forKey: .penalties) {
            self.defeatConsequences = penalties
        } else {
            self.defeatConsequences = .none
        }

        self.retreatConsequences = try container.decodeIfPresent(ChoiceConsequences.self, forKey: .retreatConsequences)

        // Options
        self.canRetreat = try container.decodeIfPresent(Bool.self, forKey: .canRetreat) ?? true
        self.turnLimit = try container.decodeIfPresent(Int.self, forKey: .turnLimit) ?? 0
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(id, forKey: .id)
        try container.encode(challengeKind, forKey: .challengeKind)
        try container.encode(difficulty, forKey: .difficulty)
        try container.encode(pressureScaling, forKey: .pressureScaling)
        try container.encodeIfPresent(enemyId, forKey: .enemyId)
        try container.encodeIfPresent(puzzleId, forKey: .puzzleId)
        try container.encodeIfPresent(dialogueId, forKey: .dialogueId)
        try container.encode(victoryConsequences, forKey: .victoryConsequences)
        try container.encode(defeatConsequences, forKey: .defeatConsequences)
        try container.encodeIfPresent(retreatConsequences, forKey: .retreatConsequences)
        try container.encode(canRetreat, forKey: .canRetreat)
        try container.encode(turnLimit, forKey: .turnLimit)
    }
}

// MARK: - Mini-Game Challenge Kind

/// Types of mini-game challenges (Engine-specific, distinct from ChallengeType in EngineProtocols)
enum MiniGameChallengeKind: String, Codable, Hashable, CaseIterable {
    /// Combat encounter with deck-building mechanics
    case combat

    /// Ritual/prayer challenge (faith-based)
    case ritual

    /// Exploration challenge (resource management)
    case exploration

    /// Dialogue/negotiation challenge
    case dialogue

    /// Puzzle challenge
    case puzzle
}

// MARK: - Mini-Game Result

/// Result returned by a mini-game module
/// Reference: EVENT_MODULE_ARCHITECTURE.md, Section 4.2
struct MiniGameResult: Codable, Hashable {
    /// Outcome of the mini-game
    let outcome: MiniGameOutcome

    /// State diff to apply
    let diff: MiniGameDiff

    /// Additional data from the mini-game
    let metadata: [String: String]

    init(
        outcome: MiniGameOutcome,
        diff: MiniGameDiff,
        metadata: [String: String] = [:]
    ) {
        self.outcome = outcome
        self.diff = diff
        self.metadata = metadata
    }
}

/// Possible outcomes of a mini-game
enum MiniGameOutcome: String, Codable, Hashable {
    case victory
    case defeat
    case retreat
    case timeout
}

/// State changes from a mini-game (diff-only, no direct mutation)
/// Reference: EVENT_MODULE_ARCHITECTURE.md, Invariant #2
struct MiniGameDiff: Codable, Hashable {
    /// Resource changes
    let resourceChanges: [String: Int]

    /// Flags to set
    let flagsToSet: [String: Bool]

    /// Cards to add to deck
    let cardsToAdd: [String]

    /// Cards to remove from deck
    let cardsToRemove: [String]

    /// Balance change
    let balanceDelta: Int

    init(
        resourceChanges: [String: Int] = [:],
        flagsToSet: [String: Bool] = [:],
        cardsToAdd: [String] = [],
        cardsToRemove: [String] = [],
        balanceDelta: Int = 0
    ) {
        self.resourceChanges = resourceChanges
        self.flagsToSet = flagsToSet
        self.cardsToAdd = cardsToAdd
        self.cardsToRemove = cardsToRemove
        self.balanceDelta = balanceDelta
    }

    /// Empty diff (no changes)
    static let empty = MiniGameDiff()
}


// ==========================================
// FILE: Engine/Data/Definitions/QuestDefinition.swift
// ==========================================

import Foundation

// MARK: - Quest Definition
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.1
// Reference: Docs/EXPLORATION_CORE_DESIGN.md, Section 13

/// Immutable definition of a quest.
/// Runtime state (currentStage, completedObjectives) lives in QuestRuntimeState.
struct QuestDefinition: GameDefinition {
    // MARK: - Identity

    /// Unique quest identifier (e.g., "quest_main_act1")
    let id: String

    // MARK: - Localized Content

    /// Quest title with all language variants
    let title: LocalizedString

    /// Quest description with all language variants
    let description: LocalizedString

    // MARK: - Structure

    /// Ordered list of objectives (stages)
    let objectives: [ObjectiveDefinition]

    /// Quest kind classification
    let questKind: QuestKind

    // MARK: - Availability

    /// Conditions for this quest to become available
    let availability: Availability

    /// If true, quest starts automatically when available
    let autoStart: Bool

    // MARK: - Rewards

    /// Rewards given on quest completion
    let completionRewards: QuestCompletionRewards

    /// Penalties on quest failure
    let failurePenalties: QuestCompletionRewards

    // MARK: - Initialization

    init(
        id: String,
        title: LocalizedString,
        description: LocalizedString,
        objectives: [ObjectiveDefinition],
        questKind: QuestKind = .side,
        availability: Availability = .always,
        autoStart: Bool = false,
        completionRewards: QuestCompletionRewards = .none,
        failurePenalties: QuestCompletionRewards = .none
    ) {
        self.id = id
        self.title = title
        self.description = description
        self.objectives = objectives
        self.questKind = questKind
        self.availability = availability
        self.autoStart = autoStart
        self.completionRewards = completionRewards
        self.failurePenalties = failurePenalties
    }
}

// MARK: - Quest Kind

/// Quest kind classification (Engine-specific, distinct from legacy QuestType)
enum QuestKind: String, Codable, Hashable {
    case main           // Main storyline
    case side           // Optional side quest
    case exploration    // Discovery/exploration quest
    case challenge      // Optional challenge quest
}

// MARK: - Objective Definition

/// Immutable definition of a quest objective (stage).
struct ObjectiveDefinition: Codable, Hashable, Identifiable {
    // MARK: - Identity

    /// Unique objective identifier within the quest
    let id: String

    // MARK: - Localized Content

    /// Objective description with all language variants
    let description: LocalizedString

    /// Objective hint with all language variants (optional)
    let hint: LocalizedString?

    // MARK: - Completion Conditions

    /// Condition type for completion
    let completionCondition: CompletionCondition

    /// Target value for progress-based objectives
    let targetValue: Int

    // MARK: - Flow Control

    /// If true, this objective is optional
    let isOptional: Bool

    /// Next objective ID (nil = quest complete)
    let nextObjectiveId: String?

    /// Alternative objective IDs (for branching)
    let alternativeNextIds: [String]

    // MARK: - Initialization

    init(
        id: String,
        description: LocalizedString,
        hint: LocalizedString? = nil,
        completionCondition: CompletionCondition,
        targetValue: Int = 1,
        isOptional: Bool = false,
        nextObjectiveId: String? = nil,
        alternativeNextIds: [String] = []
    ) {
        self.id = id
        self.description = description
        self.hint = hint
        self.completionCondition = completionCondition
        self.targetValue = targetValue
        self.isOptional = isOptional
        self.nextObjectiveId = nextObjectiveId
        self.alternativeNextIds = alternativeNextIds
    }
}

// MARK: - Completion Condition

/// How an objective is completed
enum CompletionCondition: Codable, Hashable {
    /// Complete when specific flag is set
    case flagSet(String)

    /// Complete when visiting specific region
    case visitRegion(String)

    /// Complete when specific event is resolved
    case eventCompleted(String)

    /// Complete when specific choice is made
    case choiceMade(eventId: String, choiceId: String)

    /// Complete when resource threshold reached
    case resourceThreshold(resourceId: String, minValue: Int)

    /// Complete when defeating specific enemy
    case defeatEnemy(String)

    /// Complete when collecting specific item
    case collectItem(String)

    /// Complete manually (via quest progress trigger)
    case manual

    // MARK: - Custom Codable

    /// Coding keys for JSON format: {"flag_set": "value"} or {"visit_region": "value"}
    private enum CodingKeys: String, CodingKey {
        case flagSet
        case visitRegion
        case eventCompleted
        case choiceMade
        case resourceThreshold
        case defeatEnemy
        case collectItem
        case manual
        // For choiceMade sub-keys
        case eventId
        case choiceId
        // For resourceThreshold sub-keys
        case resourceId
        case minValue
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        // Try each case - JSON format is {"key": "value"} or {"key": {...}}
        if let value = try container.decodeIfPresent(String.self, forKey: .flagSet) {
            self = .flagSet(value)
            return
        }

        if let value = try container.decodeIfPresent(String.self, forKey: .visitRegion) {
            self = .visitRegion(value)
            return
        }

        if let value = try container.decodeIfPresent(String.self, forKey: .eventCompleted) {
            self = .eventCompleted(value)
            return
        }

        if let value = try container.decodeIfPresent(String.self, forKey: .defeatEnemy) {
            self = .defeatEnemy(value)
            return
        }

        if let value = try container.decodeIfPresent(String.self, forKey: .collectItem) {
            self = .collectItem(value)
            return
        }

        if container.contains(.manual) {
            self = .manual
            return
        }

        // Try nested container for choiceMade: {"choice_made": {"event_id": "...", "choice_id": "..."}}
        if container.contains(.choiceMade) {
            let nested = try container.nestedContainer(keyedBy: CodingKeys.self, forKey: .choiceMade)
            let eventId = try nested.decode(String.self, forKey: .eventId)
            let choiceId = try nested.decode(String.self, forKey: .choiceId)
            self = .choiceMade(eventId: eventId, choiceId: choiceId)
            return
        }

        // Try nested container for resourceThreshold: {"resource_threshold": {"resource_id": "...", "min_value": 10}}
        if container.contains(.resourceThreshold) {
            let nested = try container.nestedContainer(keyedBy: CodingKeys.self, forKey: .resourceThreshold)
            let resourceId = try nested.decode(String.self, forKey: .resourceId)
            let minValue = try nested.decode(Int.self, forKey: .minValue)
            self = .resourceThreshold(resourceId: resourceId, minValue: minValue)
            return
        }

        throw DecodingError.dataCorrupted(
            DecodingError.Context(
                codingPath: container.codingPath,
                debugDescription: "Unknown completion condition type"
            )
        )
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        switch self {
        case .flagSet(let value):
            try container.encode(value, forKey: .flagSet)
        case .visitRegion(let value):
            try container.encode(value, forKey: .visitRegion)
        case .eventCompleted(let value):
            try container.encode(value, forKey: .eventCompleted)
        case .choiceMade(let eventId, let choiceId):
            var nested = container.nestedContainer(keyedBy: CodingKeys.self, forKey: .choiceMade)
            try nested.encode(eventId, forKey: .eventId)
            try nested.encode(choiceId, forKey: .choiceId)
        case .resourceThreshold(let resourceId, let minValue):
            var nested = container.nestedContainer(keyedBy: CodingKeys.self, forKey: .resourceThreshold)
            try nested.encode(resourceId, forKey: .resourceId)
            try nested.encode(minValue, forKey: .minValue)
        case .defeatEnemy(let value):
            try container.encode(value, forKey: .defeatEnemy)
        case .collectItem(let value):
            try container.encode(value, forKey: .collectItem)
        case .manual:
            try container.encode(true, forKey: .manual)
        }
    }
}

// MARK: - Quest Completion Rewards

/// Rewards/penalties for quest completion (Engine-specific, distinct from legacy QuestRewards)
struct QuestCompletionRewards: Codable, Hashable {
    /// Resource changes
    let resourceChanges: [String: Int]

    /// Flags to set
    let setFlags: [String]

    /// Cards to add to deck
    let cardIds: [String]

    /// Balance change
    let balanceDelta: Int

    init(
        resourceChanges: [String: Int] = [:],
        setFlags: [String] = [],
        cardIds: [String] = [],
        balanceDelta: Int = 0
    ) {
        self.resourceChanges = resourceChanges
        self.setFlags = setFlags
        self.cardIds = cardIds
        self.balanceDelta = balanceDelta
    }

    /// No rewards
    static let none = QuestCompletionRewards()
}


// ==========================================
// FILE: Engine/Data/Definitions/RegionDefinition.swift
// ==========================================

import Foundation

// MARK: - Region Definition
// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4.1
// Reference: Docs/EXPLORATION_CORE_DESIGN.md, Section 5

/// Immutable definition of a region in the game world.
/// Runtime state (visitCount, currentState, etc.) lives in RegionRuntimeState.
struct RegionDefinition: GameDefinition {
    // MARK: - Identity

    /// Unique region identifier (e.g., "forest", "village_square")
    let id: String

    // MARK: - Localized Content

    /// Region name with all language variants
    let title: LocalizedString

    /// Region description with all language variants
    let description: LocalizedString

    // MARK: - Type

    /// Region type string (e.g., "forest", "settlement", "swamp")
    /// This determines visual representation and gameplay effects
    let regionType: String

    // MARK: - Connections

    /// IDs of neighboring regions (for travel)
    let neighborIds: [String]

    /// Whether this region is initially discovered
    let initiallyDiscovered: Bool

    // MARK: - Content

    /// ID of the anchor in this region (nil if no anchor)
    let anchorId: String?

    /// Event pool IDs for this region
    let eventPoolIds: [String]

    // MARK: - Initial State

    /// Initial region state: "stable", "borderland", or "breach"
    let initialState: RegionStateType

    /// Weight for random degradation selection (higher = more likely to degrade)
    let degradationWeight: Int

    // MARK: - Initialization

    init(
        id: String,
        title: LocalizedString,
        description: LocalizedString,
        regionType: String = "forest",
        neighborIds: [String],
        initiallyDiscovered: Bool = false,
        anchorId: String? = nil,
        eventPoolIds: [String] = [],
        initialState: RegionStateType = .stable,
        degradationWeight: Int = 1
    ) {
        self.id = id
        self.title = title
        self.description = description
        self.regionType = regionType
        self.neighborIds = neighborIds
        self.initiallyDiscovered = initiallyDiscovered
        self.anchorId = anchorId
        self.eventPoolIds = eventPoolIds
        self.initialState = initialState
        self.degradationWeight = degradationWeight
    }
}

// MARK: - Region State Types

/// Possible states for a region
enum RegionStateType: String, Codable, Hashable, CaseIterable {
    case stable = "stable"
    case borderland = "borderland"
    case breach = "breach"

    /// Degradation order: stable → borderland → breach
    var degraded: RegionStateType? {
        switch self {
        case .stable: return .borderland
        case .borderland: return .breach
        case .breach: return nil // Cannot degrade further
        }
    }

    /// Restoration order: breach → borderland → stable
    var restored: RegionStateType? {
        switch self {
        case .stable: return nil // Cannot restore further
        case .borderland: return .stable
        case .breach: return .borderland
        }
    }

    /// Weight for random selection during degradation
    var degradationSelectionWeight: Int {
        switch self {
        case .stable: return 0     // Stable regions not selected
        case .borderland: return 1
        case .breach: return 2     // Breach regions more likely
        }
    }
}

// MARK: - Region Type (Twilight Marches specific)

/// Specific region types for Twilight Marches setting
/// Note: This is game-specific, not engine-level
enum TwilightMarchesRegionType: String, Codable, Hashable {
    case settlement = "settlement"
    case wilderness = "wilderness"
    case sacred = "sacred"
    case corrupted = "corrupted"
    case threshold = "threshold"
}


// ==========================================
// FILE: Engine/Migration/EngineAdapters.swift
// ==========================================

import Foundation
import Combine

// MARK: - Engine Adapters
// Bridge between new Engine and legacy Models during migration
// NOTE: These adapters are still required for save/load compatibility
// They can be removed once EngineSave replaces GameSave completely

// MARK: - WorldState Engine Adapter

/// Bridges TwilightGameEngine with legacy WorldState
/// Provides bidirectional sync during migration period
final class WorldStateEngineAdapter {
    // MARK: - Properties

    let worldState: WorldState
    private weak var engine: TwilightGameEngine?
    private var cancellables = Set<AnyCancellable>()

    // MARK: - Initialization

    init(worldState: WorldState, engine: TwilightGameEngine) {
        self.worldState = worldState
        self.engine = engine

        // Note: We don't set up automatic sync here because
        // during Phase 3, all changes should go through Engine
        // Legacy sync is one-way: Engine -> WorldState
    }

    // MARK: - Apply Engine Changes to Legacy

    /// Apply state changes from engine to legacy WorldState
    func applyChanges(_ changes: [StateChange]) {
        for change in changes {
            applyChange(change)
        }
    }

    private func applyChange(_ change: StateChange) {
        switch change {
        case .dayAdvanced(let newDay):
            worldState.daysPassed = newDay

        case .tensionChanged(_, let newValue):
            worldState.worldTension = newValue

        case .regionChanged(let regionId):
            worldState.currentRegionId = regionId

        case .regionStateChanged(let regionId, let newState):
            if let index = worldState.regions.firstIndex(where: { $0.id == regionId }),
               let state = RegionState(rawValue: newState) {
                worldState.regions[index].state = state
            }

        case .anchorIntegrityChanged(let anchorId, _, let newValue):
            // Find region with this anchor and update
            for (index, region) in worldState.regions.enumerated() {
                if region.anchor?.id == anchorId {
                    worldState.regions[index].anchor?.integrity = newValue
                    break
                }
            }

        case .flagSet(let key, let value):
            worldState.worldFlags[key] = value

        case .eventCompleted(let eventId):
            // Mark event as completed in allEvents
            if let index = worldState.allEvents.firstIndex(where: { $0.id == eventId }) {
                worldState.allEvents[index].completed = true
            }

        case .questProgressed(let questId, let newStage):
            // Update quest stage in WorldState's activeQuests
            // questId is String, Quest.id is UUID - convert for comparison
            if let index = worldState.activeQuests.firstIndex(where: { $0.id.uuidString == questId }) {
                worldState.activeQuests[index].stage = newStage
            }

        default:
            // Other changes handled elsewhere or not applicable to WorldState
            break
        }
    }

    // MARK: - Query WorldState for Engine

    /// Get event consequences for a choice
    func getEventConsequences(eventId: UUID, choiceIndex: Int) -> EventConsequences? {
        // Find the event in current available events
        guard let region = worldState.getCurrentRegion() else { return nil }

        let events = worldState.getAvailableEvents(for: region)
        guard let event = events.first(where: { $0.id == eventId }),
              choiceIndex < event.choices.count else {
            return nil
        }

        return event.choices[choiceIndex].consequences
    }

    /// Generate event for region
    func generateEvent(for regionId: UUID, trigger: EventTrigger) -> UUID? {
        guard let region = worldState.getRegion(byId: regionId) else { return nil }

        let events = worldState.getAvailableEvents(for: region)

        // Weight-based selection using WorldRNG
        guard !events.isEmpty else { return nil }

        // Select event using weights
        let totalWeight = events.reduce(0) { $0 + $1.weight }
        guard totalWeight > 0 else { return events.first?.id }

        let roll = WorldRNG.shared.nextInt(in: 0..<totalWeight)
        var cumulative = 0
        for event in events {
            cumulative += event.weight
            if roll < cumulative {
                return event.id
            }
        }

        return events.first?.id
    }

    /// Check quest progress and return changes
    func checkQuestProgress() -> [StateChange] {
        var changes: [StateChange] = []

        // Delegate to WorldState's quest checking
        // This is a simplified version - full implementation would check all triggers
        for quest in worldState.activeQuests where !quest.completed {
            let previousStage = quest.stage
            worldState.checkQuestProgress(quest)

            if let updatedQuest = worldState.activeQuests.first(where: { $0.id == quest.id }),
               updatedQuest.stage != previousStage {
                changes.append(.questProgressed(questId: quest.id.uuidString, newStage: updatedQuest.stage))
            }
        }

        return changes
    }
}

// MARK: - Player Engine Adapter

/// Bridges TwilightGameEngine with legacy Player model
final class PlayerEngineAdapter {
    // MARK: - Properties

    let player: Player
    private weak var engine: TwilightGameEngine?

    // MARK: - Initialization

    init(player: Player, engine: TwilightGameEngine) {
        self.player = player
        self.engine = engine
    }

    // MARK: - Update Methods

    func updateHealth(_ newValue: Int) {
        player.health = newValue
    }

    func updateFaith(_ newValue: Int) {
        player.faith = newValue
    }

    func updateBalance(_ newValue: Int) {
        player.balance = newValue
    }

    func updateStrength(_ newValue: Int) {
        player.strength = newValue
    }

    // MARK: - Sync Methods

    /// Sync player state from engine resources
    func syncFromEngine() {
        // During migration, engine state is authoritative
        // Player model is updated to match
    }

    /// Sync engine resources from player
    func syncToEngine() {
        // This would push player state to engine
        // Used during initial setup
    }
}

// MARK: - Unused Adapters Removed
// GameStateEngineAdapter and EngineMigrationHelper were removed as part of Phase 4 cleanup.
// ContentView now uses Engine-First architecture directly.


// ==========================================
// FILE: Engine/Migration/EventDefinitionAdapter.swift
// ==========================================

import Foundation

// MARK: - Event Definition Adapter
// Converts EventDefinition (new data-driven) to GameEvent (legacy UI-compatible)
// This enables using content packs while maintaining compatibility with existing UI

extension EventDefinition {

    /// Convert EventDefinition to legacy GameEvent for UI compatibility
    /// - Parameter regionId: Optional region ID for context-specific conversion
    /// - Returns: GameEvent compatible with existing UI
    func toGameEvent(forRegion regionId: String? = nil) -> GameEvent {
        // Generate deterministic UUID from string ID for consistency
        let eventUUID = UUID(uuidString: id.md5UUID) ?? UUID()

        // Map event kind to legacy event type
        let eventType = mapEventKind(eventKind)

        // Map region states from availability
        let regionStates = mapRegionStates(availability.regionStates)

        // Map region types (infer from region IDs if needed)
        let regionTypes = mapRegionTypes(availability.regionIds)

        // Convert choices
        let eventChoices = choices.map { $0.toEventChoice() }

        // Create monster card for combat events
        let monsterCard = createMonsterCard(for: miniGameChallenge)

        return GameEvent(
            id: eventUUID,
            definitionId: id,  // Content Pack ID (e.g., "village_elder_request")
            eventType: eventType,
            title: title.localized,
            description: body.localized,
            regionTypes: regionTypes,
            regionStates: regionStates,
            choices: eventChoices,
            questLinks: extractQuestLinks(),
            oneTime: isOneTime,
            completed: false,
            monsterCard: monsterCard,
            instant: isInstant,
            weight: weight,
            minTension: availability.minPressure,
            maxTension: availability.maxPressure,
            requiredFlags: availability.requiredFlags.isEmpty ? nil : availability.requiredFlags,
            forbiddenFlags: availability.forbiddenFlags.isEmpty ? nil : availability.forbiddenFlags
        )
    }

    // MARK: - Private Mapping Helpers

    private func mapEventKind(_ kind: EventKind) -> EventType {
        switch kind {
        case .inline:
            return .narrative
        case .miniGame(let miniGameKind):
            switch miniGameKind {
            case .combat:
                return .combat
            case .ritual:
                return .ritual
            case .exploration:
                return .exploration
            case .dialogue:
                return .narrative
            case .puzzle:
                return .ritual
            }
        }
    }

    private func mapRegionStates(_ stateStrings: [String]?) -> [RegionState] {
        guard let states = stateStrings else {
            return [.stable, .borderland, .breach] // Default: all states
        }

        return states.compactMap { stateString in
            switch stateString.lowercased() {
            case "stable": return .stable
            case "borderland": return .borderland
            case "breach": return .breach
            default: return nil
            }
        }
    }

    private func mapRegionTypes(_ regionIds: [String]?) -> [RegionType] {
        guard let ids = regionIds else {
            return [] // Empty = any region type
        }

        // Look up region types from ContentRegistry (no hardcoded ID mapping)
        var types = Set<RegionType>()
        for regionId in ids {
            if let regionDef = ContentRegistry.shared.getRegion(id: regionId) {
                // Map regionType string from definition to RegionType enum
                let regionType = mapRegionTypeString(regionDef.regionType)
                types.insert(regionType)
            }
        }
        return Array(types)
    }

    private func mapRegionTypeString(_ typeString: String) -> RegionType {
        switch typeString.lowercased() {
        case "settlement": return .settlement
        case "forest": return .forest
        case "swamp": return .swamp
        case "wasteland": return .wasteland
        case "sacred": return .sacred
        case "mountain": return .mountain
        case "water": return .water
        default: return .forest
        }
    }

    private func extractQuestLinks() -> [String] {
        // Extract quest links from choice consequences
        var links: [String] = []
        for choice in choices {
            if let questProgress = choice.consequences.questProgress {
                links.append(questProgress.questId)
            }
        }
        return links
    }

    private func createMonsterCard(for challenge: MiniGameChallengeDefinition?) -> Card? {
        guard let challenge = challenge,
              let enemyId = challenge.enemyId else { return nil }

        // First, try to get enemy from ContentRegistry
        if let enemy = ContentRegistry.shared.getEnemy(id: enemyId) {
            return enemy.toCard()
        }

        // Fallback: Create from hardcoded stats
        let enemyStats = getEnemyStats(for: enemyId, difficulty: challenge.difficulty)

        return Card(
            id: UUID(),
            definitionId: enemyId,  // Content Pack ID for tracking
            name: enemyId.replacingOccurrences(of: "_", with: " ").capitalized,
            type: .monster,
            rarity: difficultyToRarity(challenge.difficulty),
            description: "Enemy: \(enemyId)",
            power: enemyStats.power,
            defense: enemyStats.defense,
            health: enemyStats.health
        )
    }

    private func getEnemyStats(for enemyId: String, difficulty: Int) -> (health: Int, power: Int, defense: Int) {
        // Base stats scaled by difficulty
        let baseHealth = 5 + (difficulty * 3)
        let basePower = 2 + difficulty
        let baseDefense = 1 + (difficulty / 2)

        // Enemy-specific adjustments
        switch enemyId {
        case "wild_beast":
            return (health: baseHealth, power: basePower + 1, defense: baseDefense)
        case "leshy":
            return (health: baseHealth + 2, power: basePower, defense: baseDefense + 1)
        case "mountain_spirit":
            return (health: baseHealth + 3, power: basePower + 1, defense: baseDefense + 2)
        case "leshy_guardian_boss":
            return (health: baseHealth + 10, power: basePower + 3, defense: baseDefense + 3)
        default:
            return (health: baseHealth, power: basePower, defense: baseDefense)
        }
    }

    private func difficultyToRarity(_ difficulty: Int) -> CardRarity {
        switch difficulty {
        case 1: return .common
        case 2: return .uncommon
        case 3: return .rare
        case 4...5: return .epic
        default: return .legendary
        }
    }
}

// MARK: - Choice Definition to Event Choice

extension ChoiceDefinition {

    /// Convert ChoiceDefinition to legacy EventChoice
    func toEventChoice() -> EventChoice {
        return EventChoice(
            id: id,
            text: label.localized,
            requirements: requirements?.toEventRequirements(),
            consequences: consequences.toEventConsequences()
        )
    }
}

// MARK: - Choice Requirements Conversion

extension ChoiceRequirements {

    /// Convert to legacy EventRequirements
    func toEventRequirements() -> EventRequirements {
        var requirements = EventRequirements()

        // Map resource requirements
        if let faith = minResources["faith"] {
            requirements.minimumFaith = faith
        }
        if let health = minResources["health"] {
            requirements.minimumHealth = health
        }

        // Map balance requirements
        if let minBal = minBalance {
            if minBal >= 70 {
                requirements.requiredBalance = .light
            } else if let maxBal = maxBalance, maxBal <= 30 {
                requirements.requiredBalance = .dark
            }
        }

        // Map flag requirements
        if !requiredFlags.isEmpty {
            requirements.requiredFlags = requiredFlags
        }

        return requirements
    }
}

// MARK: - Choice Consequences Conversion

extension ChoiceConsequences {

    /// Convert to legacy EventConsequences
    func toEventConsequences() -> EventConsequences {
        var consequences = EventConsequences()

        // Map resource changes
        if let faith = resourceChanges["faith"] {
            consequences.faithChange = faith
        }
        if let health = resourceChanges["health"] {
            consequences.healthChange = health
        }

        // Map balance change
        if balanceDelta != 0 {
            consequences.balanceChange = balanceDelta
        }

        // Map flags
        if !setFlags.isEmpty {
            var flagDict: [String: Bool] = [:]
            for flag in setFlags {
                flagDict[flag] = true
            }
            for flag in clearFlags {
                flagDict[flag] = false
            }
            consequences.setFlags = flagDict
        }

        // Map region state change to anchor integrity
        if let stateChange = regionStateChange,
           let transition = stateChange.transition {
            switch transition {
            case .restore:
                consequences.anchorIntegrityChange = 20
            case .degrade:
                consequences.anchorIntegrityChange = -20
            }
        }

        // Result message from result key
        if let resultKey = resultKey {
            consequences.message = resultKey.replacingOccurrences(of: "_", with: " ").capitalized
        }

        return consequences
    }
}

// MARK: - String UUID Extension

private extension String {
    /// Generate a deterministic UUID-like string from this string
    var md5UUID: String {
        // Simple hash-based UUID generation for determinism
        var hash: UInt64 = 5381
        for char in self.utf8 {
            hash = ((hash << 5) &+ hash) &+ UInt64(char)
        }

        // Format as UUID string (simplified)
        let hex = String(format: "%016llX", hash)
        let padded = hex.padding(toLength: 32, withPad: "0", startingAt: 0)

        // Insert dashes: 8-4-4-4-12
        let chars = Array(padded)
        return "\(String(chars[0..<8]))-\(String(chars[8..<12]))-\(String(chars[12..<16]))-\(String(chars[16..<20]))-\(String(chars[20..<32]))"
    }
}


// ==========================================
// FILE: Engine/Migration/QuestDefinitionAdapter.swift
// ==========================================

import Foundation

// MARK: - Quest Definition Adapter
// Converts QuestDefinition (new data-driven) to Quest (legacy UI-compatible)
// This enables using content packs while maintaining compatibility with existing UI

extension QuestDefinition {

    /// Convert QuestDefinition to legacy Quest for UI compatibility
    /// - Returns: Quest compatible with existing UI
    func toQuest() -> Quest {
        // Generate deterministic UUID from string ID for consistency
        let questUUID = UUID(uuidString: id.md5UUID) ?? UUID()

        // Map quest kind to legacy quest type
        let questType = mapQuestKind(questKind)

        // Convert objectives
        let legacyObjectives = objectives.map { $0.toQuestObjective() }

        // Convert rewards
        let rewards = completionRewards.toQuestRewards()

        return Quest(
            id: questUUID,
            definitionId: id,  // Content Pack ID for QuestTriggerEngine
            title: title.localized,
            description: description.localized,
            questType: questType,
            stage: 0,
            objectives: legacyObjectives,
            rewards: rewards,
            completed: false
        )
    }

    // MARK: - Private Mapping Helpers

    private func mapQuestKind(_ kind: QuestKind) -> QuestType {
        switch kind {
        case .main:
            return .main
        case .side, .exploration, .challenge:
            return .side
        }
    }
}

// MARK: - Objective Definition to Quest Objective

extension ObjectiveDefinition {

    /// Convert ObjectiveDefinition to legacy QuestObjective
    func toQuestObjective() -> QuestObjective {
        // Generate deterministic UUID from string ID
        let objectiveUUID = UUID(uuidString: id.md5UUID) ?? UUID()

        // Extract required flags from completion condition
        let requiredFlags = extractRequiredFlags(from: completionCondition)

        return QuestObjective(
            id: objectiveUUID,
            description: description.localized,
            completed: false,
            requiredFlags: requiredFlags
        )
    }

    private func extractRequiredFlags(from condition: CompletionCondition) -> [String]? {
        switch condition {
        case .flagSet(let flag):
            return [flag]
        case .eventCompleted(let eventId):
            return ["\(eventId)_completed"]
        case .choiceMade(let eventId, let choiceId):
            return ["\(eventId)_\(choiceId)_chosen"]
        case .visitRegion(let regionId):
            return ["visited_\(regionId)"]
        case .defeatEnemy(let enemyId):
            return ["defeated_\(enemyId)"]
        case .collectItem(let itemId):
            return ["collected_\(itemId)"]
        case .resourceThreshold, .manual:
            return nil
        }
    }
}

// MARK: - Quest Completion Rewards to Quest Rewards

extension QuestCompletionRewards {

    /// Convert to legacy QuestRewards
    func toQuestRewards() -> QuestRewards {
        let faith = resourceChanges["faith"]
        let cards = cardIds.isEmpty ? nil : cardIds

        return QuestRewards(
            faith: faith,
            cards: cards,
            artifact: nil,  // Artifacts not supported in new format yet
            experience: nil  // Experience not supported in new format yet
        )
    }
}

// MARK: - String UUID Extension (reuse from EventDefinitionAdapter)

private extension String {
    /// Generate a deterministic UUID-like string from this string
    var md5UUID: String {
        // Simple hash-based UUID generation for determinism
        var hash: UInt64 = 5381
        for char in self.utf8 {
            hash = ((hash << 5) &+ hash) &+ UInt64(char)
        }

        // Format as UUID string (simplified)
        let hex = String(format: "%016llX", hash)
        let padded = hex.padding(toLength: 32, withPad: "0", startingAt: 0)

        // Insert dashes: 8-4-4-4-12
        let chars = Array(padded)
        return "\(String(chars[0..<8]))-\(String(chars[8..<12]))-\(String(chars[12..<16]))-\(String(chars[16..<20]))-\(String(chars[20..<32]))"
    }
}


// ==========================================
// FILE: Engine/Story/StoryDirector.swift
// ==========================================

import Foundation

// MARK: - Story Director Protocol
// Dynamic event composition and quest management system
// Makes each game session unique and the world feel alive

/// Protocol for story management - selects events, manages quest flow
/// Different campaigns can have different Director implementations
protocol StoryDirector {

    // MARK: - Event Selection

    /// Select the next event for a region based on current context
    /// Returns nil if no suitable events are available
    func selectEvent(
        forRegion regionId: String,
        context: StoryContext,
        using rng: inout WorldRNG
    ) -> EventDefinition?

    /// Get all events available in current context (for debugging/testing)
    func getAvailableEvents(context: StoryContext) -> [EventDefinition]

    // MARK: - Action Processing

    /// Process a completed action and return story updates
    /// This is called after every game action to update quests, unlock events, etc.
    func processAction(
        _ action: StoryAction,
        context: StoryContext
    ) -> StoryUpdate

    // MARK: - Quest Management

    /// Get currently active quests
    func getActiveQuests(context: StoryContext) -> [QuestDefinition]

    /// Check if victory conditions are met
    func checkVictoryConditions(context: StoryContext) -> VictoryCheck

    /// Check if defeat conditions are met
    func checkDefeatConditions(context: StoryContext) -> DefeatCheck
}

// MARK: - Story Context

/// All context needed for story decisions
struct StoryContext {
    // World State
    let currentRegionId: String
    let regionStates: [String: RegionStateType]
    let worldTension: Int
    let currentDay: Int

    // Player State
    let playerHealth: Int
    let playerFaith: Int
    let playerBalance: Int

    // Quest State
    let activeQuestIds: Set<String>
    let completedQuestIds: Set<String>
    let questObjectiveStates: [String: Set<String>]  // questId -> completed objective IDs

    // Flags & History
    let worldFlags: [String: Bool]
    let completedEventIds: Set<String>
    let visitedRegionIds: Set<String>

    // Campaign Info
    let campaignId: String
    let actNumber: Int
}

// MARK: - Story Action

/// Actions that affect story progression
enum StoryAction {
    case visitedRegion(regionId: String)
    case completedEvent(eventId: String, choiceId: String)
    case defeatedEnemy(enemyId: String)
    case dayPassed(newDay: Int)
    case tensionChanged(newTension: Int)
    case flagSet(flagName: String, value: Bool)
    case anchorChanged(regionId: String, newIntegrity: Int)
}

// MARK: - Story Update

/// Result of story processing - what changed
struct StoryUpdate {
    /// Quest progress updates
    let questUpdates: [QuestProgressUpdate]

    /// Newly unlocked events
    let unlockedEvents: [String]

    /// Events that became unavailable
    let lockedEvents: [String]

    /// World flags to set
    let flagsToSet: [String: Bool]

    /// Narrative messages to display
    let narrativeMessages: [LocalizedString]

    /// If set, game has ended
    let gameEnding: GameEnding?

    static let none = StoryUpdate(
        questUpdates: [],
        unlockedEvents: [],
        lockedEvents: [],
        flagsToSet: [:],
        narrativeMessages: [],
        gameEnding: nil
    )
}

// MARK: - Game Ending

/// How the game ended
enum GameEnding {
    case victory(endingId: String, description: LocalizedString)
    case defeat(reason: DefeatReason, description: LocalizedString)
}

enum DefeatReason {
    case healthZero
    case tensionMax
    case questFailed
    case anchorDestroyed
}

// MARK: - Victory/Defeat Checks

struct VictoryCheck {
    let isVictory: Bool
    let endingId: String?
    let description: LocalizedString?
}

struct DefeatCheck {
    let isDefeat: Bool
    let reason: DefeatReason?
    let description: LocalizedString?
}

// MARK: - Event Pool

/// Pool of events for a specific context
struct EventPool {
    let id: String
    let events: [EventDefinition]
    let selectionStrategy: EventSelectionStrategy
}

enum EventSelectionStrategy {
    case weighted      // Use event weights
    case sequential    // In order (for story events)
    case random        // Pure random
    case priority      // Highest priority first
}

// MARK: - Default Implementation

/// Base implementation with common logic
class BaseStoryDirector: StoryDirector {

    let contentRegistry: ContentRegistry
    let questTriggerEngine: QuestTriggerEngine

    init(contentRegistry: ContentRegistry = .shared) {
        self.contentRegistry = contentRegistry
        self.questTriggerEngine = QuestTriggerEngine(contentRegistry: contentRegistry)
    }

    // MARK: - Event Selection

    func selectEvent(
        forRegion regionId: String,
        context: StoryContext,
        using rng: inout WorldRNG
    ) -> EventDefinition? {
        let available = getAvailableEvents(context: context)
            .filter { event in
                // Filter by region
                if let regionIds = event.availability.regionIds, !regionIds.isEmpty {
                    return regionIds.contains(regionId)
                }
                return true
            }

        guard !available.isEmpty else { return nil }

        // Weighted random selection
        let totalWeight = available.reduce(0) { $0 + $1.weight }
        var roll = rng.nextInt(in: 1...totalWeight)

        for event in available {
            roll -= event.weight
            if roll <= 0 {
                return event
            }
        }

        return available.last
    }

    func getAvailableEvents(context: StoryContext) -> [EventDefinition] {
        return contentRegistry.getAllEvents().filter { event in
            isEventAvailable(event, context: context)
        }
    }

    /// Check if an event is available in current context
    func isEventAvailable(_ event: EventDefinition, context: StoryContext) -> Bool {
        // Check one-time events
        if event.isOneTime && context.completedEventIds.contains(event.id) {
            return false
        }

        // Check required flags
        for flag in event.availability.requiredFlags {
            if context.worldFlags[flag] != true {
                return false
            }
        }

        // Check forbidden flags
        for flag in event.availability.forbiddenFlags {
            if context.worldFlags[flag] == true {
                return false
            }
        }

        // Check tension range
        if let minPressure = event.availability.minPressure {
            if context.worldTension < minPressure {
                return false
            }
        }
        if let maxPressure = event.availability.maxPressure {
            if context.worldTension > maxPressure {
                return false
            }
        }

        // Check region states
        if let regionStates = event.availability.regionStates, !regionStates.isEmpty {
            let currentState = context.regionStates[context.currentRegionId]?.rawValue ?? "stable"
            if !regionStates.contains(currentState) {
                return false
            }
        }

        return true
    }

    // MARK: - Action Processing

    func processAction(_ action: StoryAction, context: StoryContext) -> StoryUpdate {
        // Convert to QuestTriggerAction
        let triggerAction = convertToTriggerAction(action)

        // Build trigger context
        let triggerContext = buildTriggerContext(from: context)

        // Process through quest trigger engine
        let questUpdates = questTriggerEngine.processAction(triggerAction, context: triggerContext)

        // Collect flags to set
        var flagsToSet: [String: Bool] = [:]
        for update in questUpdates {
            for flag in update.flagsToSet {
                flagsToSet[flag] = true
            }
        }

        // Check for game ending
        let victoryCheck = checkVictoryConditions(context: context)
        let defeatCheck = checkDefeatConditions(context: context)

        var gameEnding: GameEnding? = nil
        if victoryCheck.isVictory {
            gameEnding = .victory(
                endingId: victoryCheck.endingId ?? "default",
                description: victoryCheck.description ?? LocalizedString(en: "Victory!", ru: "Победа!")
            )
        } else if defeatCheck.isDefeat {
            gameEnding = .defeat(
                reason: defeatCheck.reason ?? .healthZero,
                description: defeatCheck.description ?? LocalizedString(en: "Defeat", ru: "Поражение")
            )
        }

        return StoryUpdate(
            questUpdates: questUpdates,
            unlockedEvents: [],
            lockedEvents: [],
            flagsToSet: flagsToSet,
            narrativeMessages: [],
            gameEnding: gameEnding
        )
    }

    // MARK: - Quest Management

    func getActiveQuests(context: StoryContext) -> [QuestDefinition] {
        return context.activeQuestIds.compactMap { contentRegistry.getQuest(id: $0) }
    }

    func checkVictoryConditions(context: StoryContext) -> VictoryCheck {
        // Default: check for act completion flag
        let actCompletedFlag = "act\(context.actNumber)_completed"
        if context.worldFlags[actCompletedFlag] == true {
            return VictoryCheck(
                isVictory: true,
                endingId: "act\(context.actNumber)_standard",
                description: LocalizedString(
                    en: "Act \(context.actNumber) completed!",
                    ru: "Акт \(context.actNumber) завершён!"
                )
            )
        }
        return VictoryCheck(isVictory: false, endingId: nil, description: nil)
    }

    func checkDefeatConditions(context: StoryContext) -> DefeatCheck {
        // Check health
        if context.playerHealth <= 0 {
            return DefeatCheck(
                isDefeat: true,
                reason: .healthZero,
                description: LocalizedString(en: "You have fallen...", ru: "Вы пали...")
            )
        }

        // Check tension
        if context.worldTension >= 100 {
            return DefeatCheck(
                isDefeat: true,
                reason: .tensionMax,
                description: LocalizedString(
                    en: "The darkness has consumed the world...",
                    ru: "Тьма поглотила мир..."
                )
            )
        }

        return DefeatCheck(isDefeat: false, reason: nil, description: nil)
    }

    // MARK: - Helpers

    private func convertToTriggerAction(_ action: StoryAction) -> QuestTriggerAction {
        switch action {
        case .visitedRegion(let regionId):
            return .visitedRegion(regionId: regionId)
        case .completedEvent(let eventId, let choiceId):
            return .completedEvent(eventId: eventId, choiceId: choiceId)
        case .defeatedEnemy(let enemyId):
            return .defeatedEnemy(enemyId: enemyId)
        case .flagSet(let flagName, _):
            return .flagSet(flagName: flagName)
        case .dayPassed, .tensionChanged, .anchorChanged:
            // These don't directly trigger quest objectives
            return .resourceChanged(resourceId: "day", newValue: 0)
        }
    }

    private func buildTriggerContext(from context: StoryContext) -> QuestTriggerContext {
        let activeQuests = context.activeQuestIds.compactMap { questId -> QuestState? in
            guard let quest = contentRegistry.getQuest(id: questId) else { return nil }
            let completedIds = context.questObjectiveStates[questId] ?? []
            let currentObjectiveId = quest.objectives.first { !completedIds.contains($0.id) }?.id
            return QuestState(
                definitionId: questId,
                currentObjectiveId: currentObjectiveId,
                completedObjectiveIds: completedIds
            )
        }

        return QuestTriggerContext(
            activeQuests: activeQuests,
            completedQuestIds: context.completedQuestIds,
            worldFlags: context.worldFlags,
            resources: [
                "health": context.playerHealth,
                "faith": context.playerFaith,
                "balance": context.playerBalance,
                "tension": context.worldTension
            ],
            currentDay: context.currentDay,
            currentRegionId: context.currentRegionId
        )
    }
}

