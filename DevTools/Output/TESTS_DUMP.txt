=== DUMP GENERATED ===
Source: /Users/abondarenko/Library/Mobile Documents/com~apple~CloudDocs/XCode/CardSampleGame

=== FILE STRUCTURE (Relevant Files) ===
CardSampleGameTests/
    Unit/
        HeroRegistryTests.swift
        SaveLoadTests.swift
        ContentPackTests/
            ContentManagerTests.swift
            ContentRegistryTests.swift
            PackLoaderTests.swift
    Integration/
    TestHelpers/
        SourcePathResolver.swift
        TestContentLoader.swift
    Views/
        HeroPanelTests.swift
    GateTests/
        AuditGateTests.swift
        CodeHygieneTests.swift
        ConditionValidatorTests.swift
        ContentValidationTests.swift
        DesignSystemComplianceTests.swift
        ExpressionParserTests.swift
        LocalizationValidatorTests.swift

=== FILE CONTENTS ===

// ==========================================
// FILE: CardSampleGameTests/Unit/HeroRegistryTests.swift
// ==========================================

import XCTest
import TwilightEngine
import CoreHeroesContent
import TwilightMarchesActIContent

@testable import CardSampleGame

/// Тесты для загрузки героев из Content Pack через ContentRegistry
final class HeroRegistryTests: XCTestCase {

    override func setUp() {
        super.setUp()
        TestContentLoader.loadContentPacksIfNeeded()
    }

    // MARK: - Базовые тесты

    func testRegistryHasHeroes() {
        let heroes = ContentRegistry.shared.getAllHeroes()
        XCTAssertGreaterThan(heroes.count, 0, "Реестр должен содержать героев из контент пака")
    }

    func testHeroHasValidStats() {
        let heroes = ContentRegistry.shared.getAllHeroes()

        for hero in heroes {
            XCTAssertGreaterThan(hero.baseStats.maxHealth, 0, "Герой \(hero.id) должен иметь maxHealth > 0")
            XCTAssertGreaterThan(hero.baseStats.maxFaith, 0, "Герой \(hero.id) должен иметь maxFaith > 0")
        }
    }

    func testHeroHasSpecialAbility() {
        let heroes = ContentRegistry.shared.getAllHeroes()

        for hero in heroes {
            XCTAssertFalse(hero.specialAbility.id.isEmpty, "Герой \(hero.id) должен иметь способность")
        }
    }

    // MARK: - Тесты поиска по ID

    func testHeroLookupById() {
        let heroes = ContentRegistry.shared.getAllHeroes()

        guard let firstHero = heroes.first else {
            XCTFail("Нет героев в реестре")
            return
        }

        let foundHero = ContentRegistry.shared.getHero(id: firstHero.id)
        XCTAssertNotNil(foundHero)
        XCTAssertEqual(foundHero?.id, firstHero.id)
    }

    func testNonExistentHeroReturnsNil() {
        let hero = ContentRegistry.shared.getHero(id: "nonexistent_hero_12345")
        XCTAssertNil(hero)
    }

    // MARK: - Тесты доступности

    func testAvailableHeroes() {
        let heroes = ContentRegistry.shared.getAllHeroes()
        let available = heroes.filter { hero in
            if case .alwaysAvailable = hero.availability {
                return true
            }
            return false
        }

        XCTAssertGreaterThan(available.count, 0, "Должны быть доступные герои")
    }

    // MARK: - Тесты стартовых колод

    func testHeroesHaveStartingDecks() {
        let heroes = ContentRegistry.shared.getAllHeroes()

        for hero in heroes {
            XCTAssertFalse(hero.startingDeckCardIDs.isEmpty,
                          "Герой \(hero.id) должен иметь стартовую колоду")
        }
    }

    // MARK: - Тесты первого героя

    func testFirstHeroExists() {
        let heroes = ContentRegistry.shared.getAllHeroes()
        XCTAssertFalse(heroes.isEmpty, "Должен быть хотя бы один герой")
    }
}


// ==========================================
// FILE: CardSampleGameTests/Unit/SaveLoadTests.swift
// ==========================================

import XCTest
import TwilightEngine

@testable import CardSampleGame

/// Engine-First Save/Load Tests
/// Tests the EngineSave-based save system (no legacy GameSave)
final class SaveLoadTests: XCTestCase {

    var engine: TwilightGameEngine!
    var saveManager: SaveManager!

    override func setUp() {
        super.setUp()
        TestContentLoader.loadContentPacksIfNeeded()
        engine = TwilightGameEngine()
        engine.initializeNewGame(playerName: "Test Hero", heroId: nil)
        saveManager = SaveManager()

        // Clear test slots
        for slot in 100...105 {
            saveManager.deleteSave(from: slot)
        }
    }

    override func tearDown() {
        // Clear after tests
        for slot in 100...105 {
            saveManager.deleteSave(from: slot)
        }
        engine = nil
        saveManager = nil
        WorldRNG.shared.setSeed(0)
        super.tearDown()
    }

    // MARK: - Basic Save/Load

    func testSaveGameCreatesSlot() {
        saveManager.saveGame(to: 100, engine: engine)
        XCTAssertTrue(saveManager.hasSave(in: 100), "Slot should have a save")
    }

    func testSaveGamePreservesPlayerName() {
        saveManager.saveGame(to: 100, engine: engine)
        let save = saveManager.getSave(from: 100)

        XCTAssertEqual(save?.playerName, "Test Hero")
    }

    func testSaveGamePreservesHealth() {
        let initialHealth = engine.playerHealth
        let initialMaxHealth = engine.playerMaxHealth

        saveManager.saveGame(to: 100, engine: engine)
        let save = saveManager.getSave(from: 100)

        XCTAssertEqual(save?.playerHealth, initialHealth)
        XCTAssertEqual(save?.playerMaxHealth, initialMaxHealth)
    }

    func testSaveGamePreservesFaith() {
        let initialFaith = engine.playerFaith
        let initialMaxFaith = engine.playerMaxFaith

        saveManager.saveGame(to: 100, engine: engine)
        let save = saveManager.getSave(from: 100)

        XCTAssertEqual(save?.playerFaith, initialFaith)
        XCTAssertEqual(save?.playerMaxFaith, initialMaxFaith)
    }

    func testSaveGamePreservesBalance() {
        let initialBalance = engine.playerBalance

        saveManager.saveGame(to: 100, engine: engine)
        let save = saveManager.getSave(from: 100)

        XCTAssertEqual(save?.playerBalance, initialBalance)
    }

    func testSaveGamePreservesCurrentDay() {
        // Advance some days
        _ = engine.performAction(.skipTurn)
        _ = engine.performAction(.skipTurn)
        let currentDay = engine.currentDay

        saveManager.saveGame(to: 100, engine: engine)
        let save = saveManager.getSave(from: 100)

        XCTAssertEqual(save?.currentDay, currentDay)
    }

    // MARK: - Deck Preservation (CRITICAL)

    func testSaveGamePreservesDeck() {
        let deckCount = engine.playerDeck.count

        saveManager.saveGame(to: 100, engine: engine)
        let save = saveManager.getSave(from: 100)

        XCTAssertEqual(save?.deckCardIds.count, deckCount, "Deck preserved")
    }

    func testSaveGamePreservesHand() {
        let handCount = engine.playerHand.count

        saveManager.saveGame(to: 100, engine: engine)
        let save = saveManager.getSave(from: 100)

        XCTAssertEqual(save?.handCardIds.count, handCount, "Hand preserved")
    }

    // MARK: - World State Preservation (CRITICAL)

    func testSaveGamePreservesWorldTension() {
        // Advance time to increase tension
        for _ in 0..<6 {
            _ = engine.performAction(.skipTurn)
        }
        let tension = engine.worldTension

        saveManager.saveGame(to: 100, engine: engine)
        let save = saveManager.getSave(from: 100)

        XCTAssertEqual(save?.worldTension, tension)
    }

    func testSaveGamePreservesMainQuestStage() {
        let stage = engine.mainQuestStage

        saveManager.saveGame(to: 100, engine: engine)
        let save = saveManager.getSave(from: 100)

        XCTAssertEqual(save?.mainQuestStage, stage)
    }

    func testSaveGamePreservesWorldFlags() {
        engine.setWorldFlags(["test_flag": true, "another_flag": false])

        saveManager.saveGame(to: 100, engine: engine)
        let save = saveManager.getSave(from: 100)

        XCTAssertEqual(save?.worldFlags["test_flag"], true)
        XCTAssertEqual(save?.worldFlags["another_flag"], false)
    }

    // MARK: - Load Game

    func testLoadGameRestoresHealth() {
        saveManager.saveGame(to: 100, engine: engine)
        let savedHealth = engine.playerHealth

        let newEngine = TwilightGameEngine()
        TestContentLoader.loadContentPacksIfNeeded()
        XCTAssertTrue(saveManager.loadGame(from: 100, engine: newEngine))

        XCTAssertEqual(newEngine.playerHealth, savedHealth)
    }

    func testLoadGameRestoresFaith() {
        saveManager.saveGame(to: 100, engine: engine)
        let savedFaith = engine.playerFaith

        let newEngine = TwilightGameEngine()
        TestContentLoader.loadContentPacksIfNeeded()
        XCTAssertTrue(saveManager.loadGame(from: 100, engine: newEngine))

        XCTAssertEqual(newEngine.playerFaith, savedFaith)
    }

    func testLoadGameRestoresBalance() {
        saveManager.saveGame(to: 100, engine: engine)
        let savedBalance = engine.playerBalance

        let newEngine = TwilightGameEngine()
        TestContentLoader.loadContentPacksIfNeeded()
        XCTAssertTrue(saveManager.loadGame(from: 100, engine: newEngine))

        XCTAssertEqual(newEngine.playerBalance, savedBalance)
    }

    func testLoadGameRestoresCurrentDay() {
        _ = engine.performAction(.skipTurn)
        _ = engine.performAction(.skipTurn)
        saveManager.saveGame(to: 100, engine: engine)
        let savedDay = engine.currentDay

        let newEngine = TwilightGameEngine()
        TestContentLoader.loadContentPacksIfNeeded()
        XCTAssertTrue(saveManager.loadGame(from: 100, engine: newEngine))

        XCTAssertEqual(newEngine.currentDay, savedDay)
    }

    func testLoadGameRestoresWorldTension() {
        for _ in 0..<6 {
            _ = engine.performAction(.skipTurn)
        }
        saveManager.saveGame(to: 100, engine: engine)
        let savedTension = engine.worldTension

        let newEngine = TwilightGameEngine()
        TestContentLoader.loadContentPacksIfNeeded()
        XCTAssertTrue(saveManager.loadGame(from: 100, engine: newEngine))

        XCTAssertEqual(newEngine.worldTension, savedTension)
    }

    // MARK: - Delete Save

    func testDeleteSave() {
        saveManager.saveGame(to: 100, engine: engine)
        XCTAssertTrue(saveManager.hasSave(in: 100))

        saveManager.deleteSave(from: 100)

        XCTAssertFalse(saveManager.hasSave(in: 100))
    }

    // MARK: - Multiple Slots

    func testMultipleSaveSlots() {
        engine.initializeNewGame(playerName: "Hero 1", heroId: nil)
        saveManager.saveGame(to: 101, engine: engine)

        engine.initializeNewGame(playerName: "Hero 2", heroId: nil)
        saveManager.saveGame(to: 102, engine: engine)

        let save1 = saveManager.getSave(from: 101)
        let save2 = saveManager.getSave(from: 102)

        XCTAssertEqual(save1?.playerName, "Hero 1")
        XCTAssertEqual(save2?.playerName, "Hero 2")
    }

    func testOverwriteSave() {
        // Ensure slot is clean
        saveManager.deleteSave(from: 100)

        let firstDay = engine.currentDay
        saveManager.saveGame(to: 100, engine: engine)

        // Advance time (use skipTurn - doesn't require region validation)
        _ = engine.performAction(.skipTurn)
        _ = engine.performAction(.skipTurn)

        let secondDay = engine.currentDay
        XCTAssertGreaterThan(secondDay, firstDay, "Day should advance after skipTurn")

        // Overwrite save
        saveManager.saveGame(to: 100, engine: engine)

        let save = saveManager.getSave(from: 100)
        XCTAssertEqual(save?.currentDay, secondDay, "Save should have updated day")
    }

    // MARK: - Data Integrity

    func testSaveDataIntegrity() {
        // Advance the game a bit
        for _ in 0..<5 {
            _ = engine.performAction(.skipTurn)
        }

        saveManager.saveGame(to: 100, engine: engine)

        let newEngine = TwilightGameEngine()
        TestContentLoader.loadContentPacksIfNeeded()
        XCTAssertTrue(saveManager.loadGame(from: 100, engine: newEngine))

        // Verify all fields match
        XCTAssertEqual(newEngine.playerName, engine.playerName)
        XCTAssertEqual(newEngine.playerHealth, engine.playerHealth)
        XCTAssertEqual(newEngine.playerMaxHealth, engine.playerMaxHealth)
        XCTAssertEqual(newEngine.playerFaith, engine.playerFaith)
        XCTAssertEqual(newEngine.playerMaxFaith, engine.playerMaxFaith)
        XCTAssertEqual(newEngine.playerBalance, engine.playerBalance)
        XCTAssertEqual(newEngine.currentDay, engine.currentDay)
        XCTAssertEqual(newEngine.worldTension, engine.worldTension)
        XCTAssertEqual(newEngine.mainQuestStage, engine.mainQuestStage)
    }

    // MARK: - EngineSave Encoding/Decoding

    func testEngineSaveEncodeDecode() {
        saveManager.saveGame(to: 100, engine: engine)

        guard let save = saveManager.getSave(from: 100) else {
            XCTFail("Failed to get save")
            return
        }

        do {
            let encoded = try JSONEncoder().encode(save)
            let decoded = try JSONDecoder().decode(EngineSave.self, from: encoded)

            XCTAssertEqual(decoded.playerName, save.playerName)
            XCTAssertEqual(decoded.playerHealth, save.playerHealth)
            XCTAssertEqual(decoded.currentDay, save.currentDay)
        } catch {
            XCTFail("Encoding error: \(error)")
        }
    }

    // MARK: - Pack Compatibility (Epic 7)

    func testSaveStoresPackSetAndRefusesIncompatibleLoad() {
        // 1. Save the game - should capture current pack set
        saveManager.saveGame(to: 100, engine: engine)

        guard let save = saveManager.getSave(from: 100) else {
            XCTFail("Failed to get save")
            return
        }

        // 2. Verify save stores pack compatibility info
        XCTAssertFalse(save.coreVersion.isEmpty, "Save should store coreVersion")
        XCTAssertGreaterThan(save.formatVersion, 0, "Save should store formatVersion")
        // activePackSet may be empty if no packs loaded - that's OK for test

        // 3. Verify compatibility check works for current save
        let compatibility = save.validateCompatibility(with: ContentRegistry.shared)
        XCTAssertTrue(compatibility.isLoadable, "Save with current packs should be loadable")

        // 4. Test incompatible save (format version too new)
        let incompatibleSave = EngineSave(
            version: save.version,
            savedAt: save.savedAt,
            gameDuration: save.gameDuration,
            coreVersion: save.coreVersion,
            activePackSet: save.activePackSet,
            formatVersion: EngineSave.currentFormatVersion + 10, // Future format
            primaryCampaignPackId: "nonexistent_campaign_pack", // Missing pack
            playerName: save.playerName,
            heroId: save.heroId,
            playerHealth: save.playerHealth,
            playerMaxHealth: save.playerMaxHealth,
            playerFaith: save.playerFaith,
            playerMaxFaith: save.playerMaxFaith,
            playerBalance: save.playerBalance,
            deckCardIds: save.deckCardIds,
            handCardIds: save.handCardIds,
            discardCardIds: save.discardCardIds,
            currentDay: save.currentDay,
            worldTension: save.worldTension,
            lightDarkBalance: save.lightDarkBalance,
            currentRegionId: save.currentRegionId,
            regions: save.regions,
            mainQuestStage: save.mainQuestStage,
            activeQuestIds: save.activeQuestIds,
            completedQuestIds: save.completedQuestIds,
            questStages: save.questStages,
            completedEventIds: save.completedEventIds,
            eventLog: save.eventLog,
            worldFlags: save.worldFlags,
            rngSeed: save.rngSeed,
            rngState: save.rngState
        )

        // 5. Verify incompatible save is rejected
        let incompatibleResult = incompatibleSave.validateCompatibility(with: ContentRegistry.shared)
        XCTAssertFalse(incompatibleResult.isLoadable, "Save with future format should not be loadable")
        XCTAssertFalse(incompatibleResult.errorMessages.isEmpty, "Should have error messages")

        // 6. Test SaveManager returns detailed result
        let loadResult = saveManager.loadGameWithResult(from: 100, engine: engine)
        XCTAssertTrue(loadResult.success, "Loading current save should succeed")
        XCTAssertNil(loadResult.error, "No error for successful load")
    }

    func testSaveStoresPrimaryCampaignPackId() {
        // Save should capture the primary campaign pack
        saveManager.saveGame(to: 100, engine: engine)

        guard let save = saveManager.getSave(from: 100) else {
            XCTFail("Failed to get save")
            return
        }

        // If packs are loaded, primaryCampaignPackId should be set
        // If no packs loaded (test environment), it can be nil - that's OK
        if !ContentRegistry.shared.loadedPacks.isEmpty {
            // At least one pack loaded - check if it's a campaign/full pack
            let hasCampaignPack = ContentRegistry.shared.loadedPacks.values
                .contains { $0.manifest.packType == .campaign || $0.manifest.packType == .full }

            if hasCampaignPack {
                XCTAssertNotNil(save.primaryCampaignPackId, "Should store primary campaign pack ID")
            }
        }

        // Either way, the save should be valid
        let compatibility = save.validateCompatibility(with: ContentRegistry.shared)
        XCTAssertTrue(compatibility.isLoadable, "Save should be loadable")
    }

    func testLoadGameWithResultReturnsSaveNotFoundError() {
        // Try to load from empty slot
        let result = saveManager.loadGameWithResult(from: 999, engine: engine)

        XCTAssertFalse(result.success, "Loading from empty slot should fail")
        XCTAssertNotNil(result.error, "Should have error")

        if case .saveNotFound(let slot) = result.error {
            XCTAssertEqual(slot, 999, "Error should contain correct slot")
        } else {
            XCTFail("Expected saveNotFound error")
        }
    }
}


// ==========================================
// FILE: CardSampleGameTests/Unit/ContentPackTests/ContentManagerTests.swift
// ==========================================

import XCTest
import TwilightEngine
import CoreHeroesContent
import TwilightMarchesActIContent

@testable import CardSampleGame

/// Tests for ContentManager functionality
final class ContentManagerTests: XCTestCase {

    // MARK: - Properties

    private var characterPackURL: URL?
    private var storyPackURL: URL?

    // MARK: - Setup

    override func setUp() {
        super.setUp()
        // Reset managers before each test
        ContentRegistry.shared.resetForTesting()
        ContentManager.shared.reset()

        // Use TestContentLoader for robust URL discovery
        characterPackURL = TestContentLoader.characterPackURL
        storyPackURL = TestContentLoader.storyPackURL
    }

    override func tearDown() {
        ContentRegistry.shared.resetForTesting()
        ContentManager.shared.reset()
        characterPackURL = nil
        storyPackURL = nil
        super.tearDown()
    }

    // MARK: - Pack Discovery Tests

    func testDiscoverPacksFindsProvidedURLs() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // When - Discover packs with bundled URLs
        let discovered = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!, storyPackURL!])

        // Then - Both packs should be discovered
        XCTAssertEqual(discovered.count, 2)

        let packIds = discovered.map { $0.id }
        XCTAssertTrue(packIds.contains("core-heroes"))
        XCTAssertTrue(packIds.contains("twilight-marches-act1"))
    }

    func testDiscoveredPacksHaveCorrectSource() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // When
        let discovered = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // Then - Should be marked as bundled source
        XCTAssertEqual(discovered.count, 1)
        if case .bundled = discovered[0].source {
            // OK - correct source type
        } else {
            XCTFail("Pack should have bundled source")
        }
    }

    func testDiscoveredPacksHaveManifest() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // When
        let discovered = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // Then - Should have manifest loaded
        XCTAssertEqual(discovered.count, 1)
        XCTAssertNotNil(discovered[0].manifest)
        XCTAssertEqual(discovered[0].manifest?.packId, "core-heroes")
    }

    func testDiscoveredPacksStartInDiscoveredState() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // When
        let discovered = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // Then - Should start in discovered state (not loaded yet)
        XCTAssertEqual(discovered.count, 1)
        XCTAssertEqual(discovered[0].state, .discovered)
    }

    // MARK: - Pack Validation Tests

    func testValidatePackReturnsValidSummary() async throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given - Discover pack first
        _ = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // When - Validate pack
        let summary = await ContentManager.shared.validatePack("core-heroes")

        // Then - Should be valid
        XCTAssertEqual(summary.packId, "core-heroes")
        XCTAssertEqual(summary.errorCount, 0, "Pack should have no errors")
        XCTAssertTrue(summary.isValid)
    }

    func testValidatePackFileDirectly() async throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // When - Validate pack file directly
        let summary = await ContentManager.shared.validatePackFile(at: characterPackURL!)

        // Then
        XCTAssertEqual(summary.errorCount, 0)
        XCTAssertTrue(summary.isValid)
        XCTAssertGreaterThan(summary.duration, 0)
    }

    func testValidateNonExistentPackReturnsError() async {
        // When - Validate non-existent pack
        let summary = await ContentManager.shared.validatePack("non-existent-pack")

        // Then - Should return error
        XCTAssertEqual(summary.errorCount, 1)
        XCTAssertFalse(summary.isValid)
        XCTAssertTrue(summary.errors.contains { $0.contains("not found") })
    }

    // MARK: - Pack Loading Tests

    func testLoadPackSucceeds() async throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given - Discover pack
        _ = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // When - Load pack
        let loadedPack = try await ContentManager.shared.loadPack("core-heroes")

        // Then
        XCTAssertEqual(loadedPack.manifest.packId, "core-heroes")
        XCTAssertTrue(ContentRegistry.shared.loadedPackIds.contains("core-heroes"))
    }

    func testLoadPackUpdatesState() async throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given
        _ = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // When
        _ = try await ContentManager.shared.loadPack("core-heroes")

        // Then - Get pack state
        let pack = ContentManager.shared.getPack("core-heroes")
        XCTAssertEqual(pack?.state, .loaded)
        XCTAssertNotNil(pack?.loadedAt)
    }

    func testLoadNonExistentPackThrows() async {
        // When/Then - Loading non-existent pack should throw
        do {
            _ = try await ContentManager.shared.loadPack("non-existent")
            XCTFail("Should have thrown error")
        } catch {
            // Expected
            XCTAssertTrue(error is ContentReloadError)
        }
    }

    // MARK: - State Query Tests

    func testGetAllPacksReturnsDiscoveredPacks() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given
        _ = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // When
        let allPacks = ContentManager.shared.getAllPacks()

        // Then
        XCTAssertEqual(allPacks.count, 1)
        XCTAssertEqual(allPacks[0].id, "core-heroes")
    }

    func testGetPackReturnsSpecificPack() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given
        _ = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // When
        let pack = ContentManager.shared.getPack("core-heroes")

        // Then
        XCTAssertNotNil(pack)
        XCTAssertEqual(pack?.id, "core-heroes")
    }

    func testGetPackReturnsNilForUnknownPack() {
        // When
        let pack = ContentManager.shared.getPack("unknown-pack")

        // Then
        XCTAssertNil(pack)
    }

    func testGetBundledPacksFiltersCorrectly() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given - Discover bundled pack
        _ = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // When
        let bundled = ContentManager.shared.getBundledPacks()

        // Then
        XCTAssertEqual(bundled.count, 1)
        if case .bundled = bundled[0].source {
            // OK
        } else {
            XCTFail("Should be bundled source")
        }
    }

    // MARK: - Reload Capability Tests

    func testBundledPacksCannotReload() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given
        _ = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // When
        let canReload = ContentManager.shared.canReload("core-heroes")

        // Then - Bundled packs cannot be hot-reloaded
        XCTAssertFalse(canReload)
    }

    func testSafeReloadFailsForBundledPacks() async throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given - Discover and load pack
        _ = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])
        _ = try await ContentManager.shared.loadPack("core-heroes")

        // When - Try to reload bundled pack
        let result = await ContentManager.shared.safeReloadPack("core-heroes")

        // Then - Should fail with notReloadable error
        switch result {
        case .success:
            XCTFail("Should not succeed for bundled pack")
        case .failure(let error):
            if case .notReloadable = error {
                // Expected
            } else {
                XCTFail("Should be notReloadable error, got: \(error)")
            }
        }
    }

    // MARK: - ManagedPack Property Tests

    func testManagedPackCanValidateWhenDiscovered() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given
        let discovered = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // Then
        XCTAssertTrue(discovered[0].canValidate)
    }

    func testManagedPackHasFileSize() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given
        let discovered = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // Then
        XCTAssertGreaterThan(discovered[0].fileSize, 0)
    }

    func testManagedPackHasModificationDate() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given
        let discovered = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // Then - Should have recent modification date (within last year)
        let oneYearAgo = Date().addingTimeInterval(-365 * 24 * 60 * 60)
        XCTAssertGreaterThan(discovered[0].modifiedAt, oneYearAgo)
    }

    // MARK: - ValidationSummary Tests

    func testValidationSummaryEquality() {
        let summary1 = ValidationSummary(
            packId: "test",
            errorCount: 0,
            warningCount: 1,
            infoCount: 2,
            duration: 0.5
        )
        let summary2 = ValidationSummary(
            packId: "test",
            errorCount: 0,
            warningCount: 1,
            infoCount: 2,
            duration: 0.5
        )

        // ValidationSummary equality is based on packId
        XCTAssertEqual(summary1.packId, summary2.packId)
    }

    func testValidationSummaryIsValidWhenNoErrors() {
        let summary = ValidationSummary(
            packId: "test",
            errorCount: 0,
            warningCount: 5,
            infoCount: 10,
            duration: 1.0
        )

        XCTAssertTrue(summary.isValid)
    }

    func testValidationSummaryIsInvalidWhenHasErrors() {
        let summary = ValidationSummary(
            packId: "test",
            errorCount: 1,
            warningCount: 0,
            infoCount: 0,
            duration: 1.0
        )

        XCTAssertFalse(summary.isValid)
    }

    // MARK: - PackLoadState Tests

    func testPackLoadStateEquality() {
        XCTAssertEqual(PackLoadState.discovered, PackLoadState.discovered)
        XCTAssertEqual(PackLoadState.validating, PackLoadState.validating)
        XCTAssertEqual(PackLoadState.loading, PackLoadState.loading)
        XCTAssertEqual(PackLoadState.loaded, PackLoadState.loaded)
        XCTAssertEqual(PackLoadState.failed("error"), PackLoadState.failed("error"))
        XCTAssertNotEqual(PackLoadState.failed("error1"), PackLoadState.failed("error2"))
    }

    func testPackLoadStateStatusIcon() {
        XCTAssertEqual(PackLoadState.discovered.statusIcon, "circle")
        XCTAssertEqual(PackLoadState.loaded.statusIcon, "checkmark.circle.fill")
        XCTAssertEqual(PackLoadState.failed("").statusIcon, "xmark.circle.fill")
    }

    // MARK: - PackSource Tests

    func testPackSourceIsReloadable() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        let bundled = PackSource.bundled(url: characterPackURL!)
        let external = PackSource.external(url: characterPackURL!)

        XCTAssertFalse(bundled.isReloadable)
        XCTAssertTrue(external.isReloadable)
    }

    func testPackSourceDisplayName() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        let bundled = PackSource.bundled(url: characterPackURL!)
        let external = PackSource.external(url: characterPackURL!)

        XCTAssertEqual(bundled.displayName, "Bundled")
        XCTAssertEqual(external.displayName, "External")
    }

    func testPackSourceURL() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        let bundled = PackSource.bundled(url: characterPackURL!)

        XCTAssertEqual(bundled.url, characterPackURL!)
    }
}


// ==========================================
// FILE: CardSampleGameTests/Unit/ContentPackTests/ContentRegistryTests.swift
// ==========================================

import XCTest
import TwilightEngine
import CoreHeroesContent
import TwilightMarchesActIContent

@testable import CardSampleGame

/// Tests for ContentRegistry functionality
final class ContentRegistryTests: XCTestCase {

    // MARK: - Properties

    private var characterPackURL: URL?
    private var storyPackURL: URL?

    // MARK: - Setup

    override func setUp() {
        super.setUp()
        // Reset registry before each test
        ContentRegistry.shared.resetForTesting()

        // Use TestContentLoader for robust URL discovery (with file path fallback)
        characterPackURL = TestContentLoader.characterPackURL
        storyPackURL = TestContentLoader.storyPackURL
    }

    override func tearDown() {
        ContentRegistry.shared.resetForTesting()
        characterPackURL = nil
        storyPackURL = nil
        super.tearDown()
    }

    // MARK: - Pack Loading Tests

    func testLoadMultiplePacks() throws {
        // Skip if packs not available (Bundle.module resolution issue in tests)
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // When - Load both packs using multi-pack loader
        let packs = try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // Then
        XCTAssertEqual(packs.count, 2)
        XCTAssertTrue(ContentRegistry.shared.loadedPackIds.contains("core-heroes"))
        XCTAssertTrue(ContentRegistry.shared.loadedPackIds.contains("twilight-marches-act1"))
    }

    func testLoadPackRegistersContent() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // When
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // Then
        XCTAssertGreaterThan(ContentRegistry.shared.getAllCards().count, 0)
        XCTAssertGreaterThan(ContentRegistry.shared.getAllHeroes().count, 0)
        XCTAssertGreaterThan(ContentRegistry.shared.getAllRegions().count, 0)
    }

    func testLoadPackUpdatesBalanceConfig() throws {
        // Given - No balance config before loading
        XCTAssertNil(ContentRegistry.shared.getBalanceConfig())

        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // When
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // Then
        XCTAssertNotNil(ContentRegistry.shared.getBalanceConfig())
    }

    func testCannotLoadSamePackTwice() throws {
        // Skip if character pack not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }

        // Given
        try ContentRegistry.shared.loadPack(from: characterPackURL!)

        // Then - Should throw when trying to load again
        XCTAssertThrowsError(try ContentRegistry.shared.loadPack(from: characterPackURL!)) { error in
            if case PackLoadError.packAlreadyLoaded(let packId) = error {
                XCTAssertEqual(packId, "core-heroes")
            } else {
                XCTFail("Expected packAlreadyLoaded error")
            }
        }
    }

    // MARK: - Content Access Tests

    func testGetCardById() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When - Try to get a known card
        let allCards = ContentRegistry.shared.getAllCards()
        guard let firstCard = allCards.first else {
            XCTFail("No cards loaded")
            return
        }

        // Then
        let fetchedCard = ContentRegistry.shared.getCard(id: firstCard.id)
        XCTAssertNotNil(fetchedCard)
        XCTAssertEqual(fetchedCard?.id, firstCard.id)
    }

    func testGetHeroById() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When
        let allHeroes = ContentRegistry.shared.getAllHeroes()
        guard let firstHero = allHeroes.first else {
            XCTFail("No heroes loaded")
            return
        }

        // Then
        let fetchedHero = ContentRegistry.shared.getHero(id: firstHero.id)
        XCTAssertNotNil(fetchedHero)
        XCTAssertEqual(fetchedHero?.id, firstHero.id)
    }

    func testGetNonExistentContent() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // Then
        XCTAssertNil(ContentRegistry.shared.getCard(id: "nonexistent_card"))
        XCTAssertNil(ContentRegistry.shared.getHero(id: "nonexistent_hero"))
        XCTAssertNil(ContentRegistry.shared.getRegion(id: "nonexistent_region"))
    }

    // MARK: - Starting Deck Tests

    func testGetStartingDeckForHero() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])
        let allHeroes = ContentRegistry.shared.getAllHeroes()
        guard let hero = allHeroes.first else {
            XCTFail("No heroes loaded")
            return
        }

        // When
        let startingDeck = ContentRegistry.shared.getStartingDeck(forHero: hero.id)

        // Then
        XCTAssertFalse(startingDeck.isEmpty, "Hero should have starting deck")
        XCTAssertEqual(startingDeck.count, hero.startingDeckCardIDs.count)
    }

    // MARK: - Unload Tests

    func testUnloadPack() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When - Unload character pack
        ContentRegistry.shared.unloadPack("core-heroes")

        // Then - Only character pack content should be gone
        XCTAssertFalse(ContentRegistry.shared.loadedPackIds.contains("core-heroes"))
        XCTAssertTrue(ContentRegistry.shared.loadedPackIds.contains("twilight-marches-act1"))
    }

    func testUnloadAllPacks() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])
        XCTAssertGreaterThan(ContentRegistry.shared.getAllCards().count, 0)

        // When
        ContentRegistry.shared.unloadAllPacks()

        // Then
        XCTAssertEqual(ContentRegistry.shared.getAllCards().count, 0)
        XCTAssertEqual(ContentRegistry.shared.getAllHeroes().count, 0)
        XCTAssertTrue(ContentRegistry.shared.loadedPackIds.isEmpty)
    }

    // MARK: - Validation Tests

    func testValidateLoadedContent() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When
        let errors = ContentRegistry.shared.validateAllContent()

        // Then - Should have no critical errors (warnings are OK)
        let criticalErrors = errors.filter { $0.type == .brokenReference }
        XCTAssertTrue(criticalErrors.isEmpty, "Should have no broken references: \(criticalErrors)")
    }

    // MARK: - Inventory Tests

    func testTotalInventory() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When
        let inventory = ContentRegistry.shared.totalInventory

        // Then
        XCTAssertGreaterThan(inventory.cardCount, 0)
        XCTAssertGreaterThan(inventory.heroCount, 0)
        XCTAssertTrue(inventory.hasBalanceConfig)
    }

    // MARK: - ContentProvider Protocol Tests

    func testContentProviderProtocolConformance() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])
        let provider: ContentProvider = ContentRegistry.shared

        // When/Then - Should work as ContentProvider
        XCTAssertFalse(provider.getAllRegionDefinitions().isEmpty, "Should have regions")
        XCTAssertFalse(provider.getAllEventDefinitions().isEmpty, "Should have events")
        XCTAssertFalse(provider.getAllQuestDefinitions().isEmpty, "Should have quests")
    }

    // MARK: - Pack Type Query Tests

    func testGetCharacterPacks() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When
        let characterPacks = ContentRegistry.shared.getCharacterPacks()

        // Then
        XCTAssertEqual(characterPacks.count, 1)
        XCTAssertEqual(characterPacks.first?.manifest.packId, "core-heroes")
    }

    func testGetStoryPacks() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When
        let storyPacks = ContentRegistry.shared.getStoryPacks()

        // Then
        XCTAssertEqual(storyPacks.count, 1)
        XCTAssertEqual(storyPacks.first?.manifest.packId, "twilight-marches-act1")
    }

    func testIsReadyForGameplay() throws {
        // Given - No packs loaded
        XCTAssertFalse(ContentRegistry.shared.isReadyForGameplay)

        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // When - Load only character pack
        try ContentRegistry.shared.loadPack(from: characterPackURL!)
        XCTAssertFalse(ContentRegistry.shared.isReadyForGameplay)

        // When - Load story pack
        try ContentRegistry.shared.loadPack(from: storyPackURL!)
        XCTAssertTrue(ContentRegistry.shared.isReadyForGameplay)
    }

    // MARK: - Season/Campaign Query Tests

    func testGetPacksBySeason() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When
        let season1Packs = ContentRegistry.shared.getPacksBySeason("season1")

        // Then - TwilightMarchesActI should be in season1
        XCTAssertEqual(season1Packs.count, 1)
        XCTAssertEqual(season1Packs.first?.manifest.packId, "twilight-marches-act1")
    }

    func testGetPacksByCampaign() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When
        let campaignPacks = ContentRegistry.shared.getPacksByCampaign("twilight-marches")

        // Then
        XCTAssertEqual(campaignPacks.count, 1)
        XCTAssertEqual(campaignPacks.first?.manifest.packId, "twilight-marches-act1")
        XCTAssertEqual(campaignPacks.first?.manifest.campaignOrder, 1)
    }

    func testGetAvailableSeasons() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When
        let seasons = ContentRegistry.shared.getAvailableSeasons()

        // Then - Should include season1 from TwilightMarchesActI
        XCTAssertTrue(seasons.contains("season1"))
    }

    func testGetCampaignsInSeason() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When
        let campaigns = ContentRegistry.shared.getCampaignsInSeason("season1")

        // Then
        XCTAssertTrue(campaigns.contains("twilight-marches"))
    }

    func testIsCampaignCompleteWithSingleAct() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When - With only Act I loaded, campaign is "complete" (sequential from 1)
        let isComplete = ContentRegistry.shared.isCampaignComplete("twilight-marches")

        // Then - Act I starts at order 1, so it's complete for what's loaded
        XCTAssertTrue(isComplete)
    }

    func testGetNextPackInCampaignReturnsNilForLastAct() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When - Try to get next pack after Act I (Act II not loaded)
        let nextPack = ContentRegistry.shared.getNextPackInCampaign(after: "twilight-marches-act1")

        // Then - Should be nil since Act II isn't loaded
        XCTAssertNil(nextPack)
    }

    func testHasAllRequiredPacksForFirstAct() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When - Check if Act I has all required packs (it shouldn't require any)
        let hasRequired = ContentRegistry.shared.hasAllRequiredPacks(for: "twilight-marches-act1")

        // Then - Act I is the first act, so no required packs
        XCTAssertTrue(hasRequired)
    }

    func testCharacterPackHasNoSeason() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When - Get packs for non-existent season
        let noSeasonPacks = ContentRegistry.shared.getPacksBySeason("nonexistent")

        // Then - Should be empty
        XCTAssertTrue(noSeasonPacks.isEmpty)

        // And - CoreHeroes should not appear in season1 (it has no season)
        let characterPacks = ContentRegistry.shared.getCharacterPacks()
        XCTAssertNil(characterPacks.first?.manifest.season)
    }

    // MARK: - Mock Content Tests

    func testRegisterMockContent() {
        // Given
        let mockRegion = RegionDefinition(
            id: "test_region",
            title: .inline(LocalizedString(en: "Test", ru: "Тест")),
            description: .inline(LocalizedString(en: "Test region", ru: "Тестовый регион")),
            regionType: "test",
            neighborIds: []
        )

        // When
        ContentRegistry.shared.registerMockContent(
            regions: ["test_region": mockRegion]
        )

        // Then
        XCTAssertNotNil(ContentRegistry.shared.getRegion(id: "test_region"))
        XCTAssertEqual(ContentRegistry.shared.getAllRegions().count, 1)
    }
}


// ==========================================
// FILE: CardSampleGameTests/Unit/ContentPackTests/PackLoaderTests.swift
// ==========================================

import XCTest
import TwilightEngine
import CoreHeroesContent
import TwilightMarchesActIContent

@testable import CardSampleGame

/// Tests for PackLoader functionality
/// Note: PackLoader is used at compile-time to load JSON content packs.
/// These tests use the JSON source directories, not the binary .pack files.
final class PackLoaderTests: XCTestCase {

    // MARK: - Properties

    /// URL to JSON source directory (not .pack file)
    private var characterPackURL: URL?
    private var storyPackURL: URL?

    // MARK: - Setup

    override func setUp() {
        super.setUp()
        // Use TestContentLoader JSON URLs for PackLoader tests
        characterPackURL = TestContentLoader.characterPackJSONURL
        storyPackURL = TestContentLoader.storyPackJSONURL
    }

    override func tearDown() {
        characterPackURL = nil
        storyPackURL = nil
        super.tearDown()
    }

    // MARK: - Character Pack Manifest Tests

    func testLoadCharacterPackManifest() throws {
        // Fail if character pack not available (Bundle.module resolution issue in tests)
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }

        // Given
        let url = characterPackURL!

        // When
        let manifest = try PackManifest.load(from: url)

        // Then
        XCTAssertEqual(manifest.packId, "core-heroes")
        XCTAssertEqual(manifest.packType, .character)
        XCTAssertFalse(manifest.displayName.en.isEmpty)
        XCTAssertFalse(manifest.displayName.ru.isEmpty)
    }

    // MARK: - Story Pack Manifest Tests

    func testLoadStoryPackManifest() throws {
        // Given
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI pack not available")

        // When
        let manifest = try PackManifest.load(from: url)

        // Then
        XCTAssertEqual(manifest.packId, "twilight-marches-act1")
        XCTAssertEqual(manifest.packType, .campaign)
        XCTAssertFalse(manifest.displayName.en.isEmpty)
        XCTAssertFalse(manifest.displayName.ru.isEmpty)
    }

    func testManifestVersionParsing() throws {
        // Given
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI pack not available")

        // When
        let manifest = try PackManifest.load(from: url)

        // Then
        XCTAssertGreaterThanOrEqual(manifest.version.major, 1)
    }

    func testManifestCoreCompatibility() throws {
        // Given
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI pack not available")

        // When
        let manifest = try PackManifest.load(from: url)

        // Then
        XCTAssertTrue(manifest.isCompatibleWithCore(), "Pack should be compatible with current Core version")
    }

    func testManifestPackType() throws {
        // Given
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI pack not available")

        // When
        let manifest = try PackManifest.load(from: url)

        // Then - TwilightMarchesActI is a campaign pack
        XCTAssertEqual(manifest.packType, .campaign)
    }

    func testManifestEntryRegion() throws {
        // Given
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI pack not available")

        // When
        let manifest = try PackManifest.load(from: url)

        // Then - Campaign packs should have an entry region
        XCTAssertNotNil(manifest.entryRegionId)
    }

    func testManifestLocales() throws {
        // Given
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI pack not available")

        // When
        let manifest = try PackManifest.load(from: url)

        // Then
        XCTAssertTrue(manifest.supportedLocales.contains("en"))
        XCTAssertTrue(manifest.supportedLocales.contains("ru"))
    }

    // MARK: - Content Loading Tests

    func testLoadCharacterPackContent() throws {
        // Fail if character pack not available (Bundle.module resolution issue in tests)
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }

        // Given
        let url = characterPackURL!
        let manifest = try PackManifest.load(from: url)

        // When
        let pack = try PackLoader.load(manifest: manifest, from: url)

        // Then - Should load heroes and cards
        XCTAssertGreaterThan(pack.cards.count, 0, "Should load cards")
        XCTAssertGreaterThan(pack.heroes.count, 0, "Should load heroes")
    }

    func testLoadStoryPackContent() throws {
        // Given
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI pack not available")
        let manifest = try PackManifest.load(from: url)

        // When
        let pack = try PackLoader.load(manifest: manifest, from: url)

        // Then - Should load story content
        XCTAssertGreaterThan(pack.regions.count, 0, "Should load regions")
        XCTAssertGreaterThan(pack.events.count, 0, "Should load events")
    }

    func testLoadBalanceConfiguration() throws {
        // Given
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI pack not available")
        let manifest = try PackManifest.load(from: url)

        // When
        let pack = try PackLoader.load(manifest: manifest, from: url)

        // Then
        XCTAssertNotNil(pack.balanceConfig, "Should load balance configuration")
    }

    func testBalanceConfigurationValues() throws {
        // Given
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI pack not available")
        let manifest = try PackManifest.load(from: url)
        let pack = try PackLoader.load(manifest: manifest, from: url)

        // When
        let balance = try XCTUnwrap(pack.balanceConfig)

        // Then - Validate sensible values
        XCTAssertGreaterThan(balance.resources.maxHealth, 0)
        XCTAssertGreaterThan(balance.resources.maxFaith, 0)
        XCTAssertGreaterThanOrEqual(balance.resources.startingHealth, 1)
        XCTAssertGreaterThanOrEqual(balance.pressure.maxPressure, 1)
        XCTAssertGreaterThan(balance.anchor.maxIntegrity, 0)
    }

    // MARK: - Cards Loading Tests

    func testLoadCards() throws {
        // Fail if character pack not available (Bundle.module resolution issue in tests)
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }

        // Given
        let url = characterPackURL!
        let manifest = try PackManifest.load(from: url)

        // When
        let pack = try PackLoader.load(manifest: manifest, from: url)

        // Then
        XCTAssertFalse(pack.cards.isEmpty, "Should load cards")

        // Verify card structure
        if let firstCard = pack.cards.values.first {
            XCTAssertFalse(firstCard.id.isEmpty)
            XCTAssertFalse(firstCard.name.isEmpty)
        }
    }

    func testCardsHaveValidFaithCost() throws {
        // Fail if character pack not available (Bundle.module resolution issue in tests)
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }

        // Given
        let url = characterPackURL!
        let manifest = try PackManifest.load(from: url)
        let pack = try PackLoader.load(manifest: manifest, from: url)

        // Then - All cards should have non-negative faith cost
        for (id, card) in pack.cards {
            XCTAssertGreaterThanOrEqual(card.faithCost, 0, "Card '\(id)' has negative faith cost")
        }
    }

    // MARK: - Heroes Loading Tests

    func testLoadHeroes() throws {
        // Fail if character pack not available (Bundle.module resolution issue in tests)
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }

        // Given
        let url = characterPackURL!
        let manifest = try PackManifest.load(from: url)

        // When
        let pack = try PackLoader.load(manifest: manifest, from: url)

        // Then
        XCTAssertFalse(pack.heroes.isEmpty, "Should load heroes")

        // Verify hero structure
        if let firstHero = pack.heroes.values.first {
            XCTAssertFalse(firstHero.id.isEmpty)
            XCTAssertFalse(firstHero.name.isEmpty)
        }
    }

    func testHeroesHaveStartingDecks() throws {
        // Fail if character pack not available (Bundle.module resolution issue in tests)
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }

        // Given
        let url = characterPackURL!
        let manifest = try PackManifest.load(from: url)
        let pack = try PackLoader.load(manifest: manifest, from: url)

        // Then - Heroes should have starting decks
        for (id, hero) in pack.heroes {
            XCTAssertFalse(hero.startingDeckCardIDs.isEmpty, "Hero '\(id)' has no starting deck")
        }
    }

    func testHeroesHaveValidBaseStats() throws {
        // Fail if character pack not available (Bundle.module resolution issue in tests)
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }

        // Given
        let url = characterPackURL!
        let manifest = try PackManifest.load(from: url)
        let pack = try PackLoader.load(manifest: manifest, from: url)

        // Then - Heroes should have valid base stats
        for (id, hero) in pack.heroes {
            XCTAssertGreaterThan(hero.baseStats.maxHealth, 0, "Hero '\(id)' has invalid maxHealth")
            XCTAssertGreaterThan(hero.baseStats.maxFaith, 0, "Hero '\(id)' has invalid maxFaith")
        }
    }

    func testHeroesHaveSpecialAbility() throws {
        // Fail if character pack not available (Bundle.module resolution issue in tests)
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }

        // Given
        let url = characterPackURL!
        let manifest = try PackManifest.load(from: url)
        let pack = try PackLoader.load(manifest: manifest, from: url)

        // Then - Heroes should have special ability from their class
        for (id, hero) in pack.heroes {
            XCTAssertFalse(hero.specialAbility.id.isEmpty, "Hero '\(id)' has no special ability")
        }
    }

    // MARK: - Error Handling Tests

    func testLoadManifestFromInvalidPath() {
        // Given
        let invalidURL = URL(fileURLWithPath: "/nonexistent/path")

        // Then
        XCTAssertThrowsError(try PackManifest.load(from: invalidURL)) { error in
            // Should throw a file not found or similar error
            XCTAssertTrue(error is PackLoadError || error is DecodingError)
        }
    }

    // MARK: - Semantic Version Tests

    func testSemanticVersionComparison() {
        // Given
        let v100 = SemanticVersion(major: 1, minor: 0, patch: 0)
        let v110 = SemanticVersion(major: 1, minor: 1, patch: 0)
        let v111 = SemanticVersion(major: 1, minor: 1, patch: 1)
        let v200 = SemanticVersion(major: 2, minor: 0, patch: 0)

        // Then
        XCTAssertLessThan(v100, v110)
        XCTAssertLessThan(v110, v111)
        XCTAssertLessThan(v111, v200)
        XCTAssertEqual(v100, SemanticVersion(major: 1, minor: 0, patch: 0))
    }

    func testSemanticVersionFromString() {
        // Given
        let version = SemanticVersion(string: "1.2.3")

        // Then
        XCTAssertEqual(version?.major, 1)
        XCTAssertEqual(version?.minor, 2)
        XCTAssertEqual(version?.patch, 3)
    }

    func testSemanticVersionDescription() {
        // Given
        let version = SemanticVersion(major: 1, minor: 2, patch: 3)

        // Then
        XCTAssertEqual(version.description, "1.2.3")
    }
}


// ==========================================
// FILE: CardSampleGameTests/TestHelpers/SourcePathResolver.swift
// ==========================================

import Foundation

/// Centralizes source file path resolution for gate tests.
/// Requirement: AUDIT_FIXLIST C1 - no hardcoded paths scattered in tests.
///
/// All engine source paths should use this resolver to ensure:
/// 1. Paths are consistent across all gate tests
/// 2. Path changes only need to be made in one place
/// 3. Tests fail clearly if paths are wrong
struct SourcePathResolver {

    // MARK: - Base Paths

    /// Project root directory (where CardSampleGame.xcodeproj is located)
    static var projectRoot: URL {
        // Navigate from test file to project root
        var url = URL(fileURLWithPath: #file)
        // Go up: SourcePathResolver.swift -> TestHelpers -> CardSampleGameTests -> Project Root
        for _ in 0..<3 {
            url = url.deletingLastPathComponent()
        }
        return url
    }

    /// TwilightEngine package base path
    static var engineBase: String {
        "Packages/TwilightEngine/Sources/TwilightEngine"
    }

    /// Full URL to TwilightEngine sources
    static var engineBaseURL: URL {
        projectRoot.appendingPathComponent(engineBase)
    }

    // MARK: - Engine Core Paths

    /// Path to TwilightGameEngine.swift
    static var twilightGameEngine: URL {
        engineBaseURL.appendingPathComponent("Core/TwilightGameEngine.swift")
    }

    /// Path to EngineSave.swift
    static var engineSave: URL {
        engineBaseURL.appendingPathComponent("Core/EngineSave.swift")
    }

    /// Path to EngineProtocols.swift
    static var engineProtocols: URL {
        engineBaseURL.appendingPathComponent("Core/EngineProtocols.swift")
    }

    // MARK: - Engine Module Paths

    /// Path to ExplorationModels.swift
    static var explorationModels: URL {
        engineBaseURL.appendingPathComponent("Models/ExplorationModels.swift")
    }

    /// Path to BalanceConfiguration.swift
    static var balanceConfiguration: URL {
        engineBaseURL.appendingPathComponent("ContentPacks/BalanceConfiguration.swift")
    }

    /// Path to ContentRegistry.swift
    static var contentRegistry: URL {
        engineBaseURL.appendingPathComponent("ContentPacks/ContentRegistry.swift")
    }

    // MARK: - Core Directories

    /// All core engine directories to scan for architectural compliance
    static var coreDirectories: [String] {
        [
            "\(engineBase)/Core",
            "\(engineBase)/ContentPacks",
            "\(engineBase)/Events",
            "\(engineBase)/Combat",
            "\(engineBase)/Quest",
            "\(engineBase)/Cards",
            "\(engineBase)/Heroes",
            "\(engineBase)/Modules",
            "\(engineBase)/Config",
            "\(engineBase)/Runtime",
            "\(engineBase)/Story",
            "\(engineBase)/Localization"
        ]
    }

    /// All production code directories (Engine + App)
    static var productionDirectories: [String] {
        [engineBase, "App", "Views", "Models", "Utilities"]
    }

    // MARK: - Validation

    /// Check if a critical path exists, fail the test if not
    static func requireExists(_ url: URL, file: StaticString = #file, line: UInt = #line) -> Bool {
        if FileManager.default.fileExists(atPath: url.path) {
            return true
        }
        return false
    }

    /// Get full path for a relative path within the project
    static func resolve(_ relativePath: String) -> URL {
        projectRoot.appendingPathComponent(relativePath)
    }

    /// Check if the project root is correctly resolved
    static func validateProjectRoot() -> Bool {
        // Check that Views folder exists at project root
        let viewsPath = projectRoot.appendingPathComponent("Views")
        return FileManager.default.fileExists(atPath: viewsPath.path)
    }
}


// ==========================================
// FILE: CardSampleGameTests/TestHelpers/TestContentLoader.swift
// ==========================================

import Foundation
import TwilightEngine
import CoreHeroesContent
import TwilightMarchesActIContent

@testable import CardSampleGame

/// Helper для загрузки ContentPacks в тестовом окружении
/// Использует CoreHeroes и TwilightMarchesActI пакеты для получения контента
enum TestContentLoader {

    /// Флаг, показывающий загружены ли паки
    private(set) static var isLoaded = false

    // MARK: - JSON Directory URLs (for PackLoader tests)

    /// URL to CoreHeroes JSON source directory (for testing PackLoader)
    /// Returns the directory containing manifest.json and content files
    static var characterPackJSONURL: URL? {
        // Get .pack URL and derive JSON directory (sibling directory with same name)
        if let packURL = characterPackURL {
            let jsonDirURL = packURL.deletingPathExtension()
            if FileManager.default.fileExists(atPath: jsonDirURL.appendingPathComponent("manifest.json").path) {
                return jsonDirURL
            }
        }
        // Fallback: search directly
        return findJSONDirectory(bundleName: "CoreHeroes_CoreHeroesContent", resourceName: "CoreHeroes")
    }

    /// URL to TwilightMarchesActI JSON source directory (for testing PackLoader)
    /// Returns the directory containing manifest.json and content files
    static var storyPackJSONURL: URL? {
        // Get .pack URL and derive JSON directory (sibling directory with same name)
        if let packURL = storyPackURL {
            let jsonDirURL = packURL.deletingPathExtension()
            if FileManager.default.fileExists(atPath: jsonDirURL.appendingPathComponent("manifest.json").path) {
                return jsonDirURL
            }
        }
        // Fallback: search directly
        return findJSONDirectory(bundleName: "TwilightMarchesActI_TwilightMarchesActIContent", resourceName: "TwilightMarchesActI")
    }

    // MARK: - Binary Pack URLs

    /// URL to CoreHeroes pack (via Bundle.module or bundle search fallback)
    /// Returns nil if the pack cannot be verified to exist with a valid manifest
    static var characterPackURL: URL? {
        #if DEBUG
        print("🔍 TestContentLoader: Looking for CoreHeroes pack")
        print("🔍 CoreHeroesContent.packURL = \(String(describing: CoreHeroesContent.packURL))")
        #endif

        // Try Bundle.module first - expects .pack file
        if let url = CoreHeroesContent.packURL {
            if verifyPackFile(at: url) {
                return url
            }
            #if DEBUG
            print("⚠️ CoreHeroesContent.packURL exists but not a valid .pack file")
            #endif
        }

        // Fallback: search for the .pack file in the test bundle
        let fallback = findPackFile(bundleName: "CoreHeroes_CoreHeroesContent", resourceName: "CoreHeroes")
        #if DEBUG
        print("🔍 Fallback result = \(String(describing: fallback))")
        #endif

        // Verify fallback is valid .pack file
        if let url = fallback, verifyPackFile(at: url) {
            return url
        }

        #if DEBUG
        print("❌ TestContentLoader: No valid CoreHeroes pack found")
        #endif
        return nil
    }

    /// URL to TwilightMarchesActI pack (via Bundle.module or bundle search fallback)
    /// Returns nil if the pack cannot be verified to exist with a valid manifest
    static var storyPackURL: URL? {
        #if DEBUG
        print("🔍 TestContentLoader: Looking for TwilightMarchesActI pack")
        print("🔍 TwilightMarchesActIContent.packURL = \(String(describing: TwilightMarchesActIContent.packURL))")
        #endif

        // Try Bundle.module first - expects .pack file
        if let url = TwilightMarchesActIContent.packURL {
            if verifyPackFile(at: url) {
                return url
            }
            #if DEBUG
            print("⚠️ TwilightMarchesActIContent.packURL exists but not a valid .pack file")
            #endif
        }

        // Fallback: search for the .pack file in the test bundle
        let fallback = findPackFile(bundleName: "TwilightMarchesActI_TwilightMarchesActIContent", resourceName: "TwilightMarchesActI")
        #if DEBUG
        print("🔍 Fallback result = \(String(describing: fallback))")
        #endif

        // Verify fallback is valid .pack file
        if let url = fallback, verifyPackFile(at: url) {
            return url
        }

        #if DEBUG
        print("❌ TestContentLoader: No valid TwilightMarchesActI pack found")
        #endif
        return nil
    }

    /// Загрузить ContentPacks из пакетов
    /// Безопасно вызывать многократно - загрузка произойдёт только один раз
    static func loadContentPacksIfNeeded() {
        // Also reload if registry was reset externally
        guard !isLoaded || ContentRegistry.shared.loadedPackIds.isEmpty else { return }

        do {
            // Загружаем паки через ContentRegistry
            let registry = ContentRegistry.shared

            // Проверяем, не загружен ли уже
            if registry.loadedPackIds.isEmpty {
                var urls: [URL] = []

                // Load character pack first (priority order)
                if let heroesURL = characterPackURL {
                    urls.append(heroesURL)
                }

                // Load story pack
                if let storyURL = storyPackURL {
                    urls.append(storyURL)
                }

                guard !urls.isEmpty else {
                    print("⚠️ TestContentLoader: ContentPacks not found in packages")
                    return
                }

                try registry.loadPacks(from: urls)
                print("✅ TestContentLoader: Loaded \(urls.count) packs")
            }

            isLoaded = true
        } catch {
            print("❌ TestContentLoader: Failed to load packs: \(error)")
        }
    }

    /// Find .pack file by searching in test bundle and all related locations
    private static func findPackFile(bundleName: String, resourceName: String) -> URL? {
        let testBundle = Bundle(for: BundleToken.self)
        let packFileName = "\(resourceName).pack"

        #if DEBUG
        print("🔍 findPackFile: Looking for \(bundleName).bundle/\(packFileName)")
        print("🔍 Test bundle path: \(testBundle.bundlePath)")
        #endif

        // Method 1: Direct URL lookup in test bundle
        if let url = testBundle.url(forResource: bundleName, withExtension: "bundle") {
            let packPath = url.appendingPathComponent(packFileName)
            #if DEBUG
            print("🔍 Method 1: Found bundle at \(url)")
            print("🔍 Method 1: Checking \(packPath.path)")
            #endif
            if FileManager.default.fileExists(atPath: packPath.path) {
                #if DEBUG
                print("✅ Method 1: Found .pack file!")
                #endif
                return packPath
            }
        }

        // Method 2: Direct path construction in test bundle
        if let testBundlePath = testBundle.bundlePath as NSString? {
            let bundlePath = testBundlePath.appendingPathComponent("\(bundleName).bundle")
            let packPath = (bundlePath as NSString).appendingPathComponent(packFileName)
            #if DEBUG
            print("🔍 Method 2: Checking \(packPath)")
            #endif
            if FileManager.default.fileExists(atPath: packPath) {
                #if DEBUG
                print("✅ Method 2: Found .pack file!")
                #endif
                return URL(fileURLWithPath: packPath)
            }
        }

        // Method 3: Search in Frameworks folder
        if let testBundlePath = testBundle.bundlePath as NSString? {
            let frameworksPath = testBundlePath.appendingPathComponent("Frameworks")
            #if DEBUG
            print("🔍 Method 3: Checking frameworks at \(frameworksPath)")
            #endif
            if let contents = try? FileManager.default.contentsOfDirectory(atPath: frameworksPath) {
                #if DEBUG
                print("🔍 Method 3: Found frameworks: \(contents)")
                #endif
                for item in contents where item.hasSuffix(".framework") {
                    let frameworkPath = (frameworksPath as NSString).appendingPathComponent(item)
                    let innerBundlePath = (frameworkPath as NSString).appendingPathComponent("\(bundleName).bundle")
                    let packPath = (innerBundlePath as NSString).appendingPathComponent(packFileName)
                    if FileManager.default.fileExists(atPath: packPath) {
                        #if DEBUG
                        print("✅ Method 3: Found .pack file at \(packPath)!")
                        #endif
                        return URL(fileURLWithPath: packPath)
                    }
                }
            }
        }

        // Method 4: Check main app bundle
        if let mainBundlePath = Bundle.main.bundlePath as NSString? {
            let bundlePath = mainBundlePath.appendingPathComponent("\(bundleName).bundle")
            let packPath = (bundlePath as NSString).appendingPathComponent(packFileName)
            #if DEBUG
            print("🔍 Method 4: Checking main bundle \(packPath)")
            #endif
            if FileManager.default.fileExists(atPath: packPath) {
                #if DEBUG
                print("✅ Method 4: Found .pack file!")
                #endif
                return URL(fileURLWithPath: packPath)
            }
        }

        #if DEBUG
        print("❌ findPackFile: Pack file not found for \(bundleName).bundle/\(packFileName)")
        #endif
        return nil
    }

    /// Verify that a URL points to a valid .pack file
    private static func verifyPackFile(at url: URL) -> Bool {
        #if DEBUG
        print("🔍 verifyPackFile: checking \(url.path)")
        #endif

        // Check file exists
        guard FileManager.default.fileExists(atPath: url.path) else {
            #if DEBUG
            print("❌ verifyPackFile: file does not exist")
            #endif
            return false
        }

        // Verify it's a valid .pack file using BinaryPackReader
        let isValid = BinaryPackReader.isValidPackFile(url)
        #if DEBUG
        print(isValid ? "✅ verifyPackFile: valid .pack file" : "❌ verifyPackFile: not a valid .pack file")
        #endif
        return isValid
    }

    /// Find JSON source directory (for PackLoader tests)
    private static func findJSONDirectory(bundleName: String, resourceName: String) -> URL? {
        let testBundle = Bundle(for: BundleToken.self)

        // Method 1: Direct URL lookup in test bundle
        if let url = testBundle.url(forResource: bundleName, withExtension: "bundle") {
            let jsonDirPath = url.appendingPathComponent(resourceName)
            let manifestPath = jsonDirPath.appendingPathComponent("manifest.json")
            if FileManager.default.fileExists(atPath: manifestPath.path) {
                return jsonDirPath
            }
        }

        // Method 2: Direct path construction
        if let testBundlePath = testBundle.bundlePath as NSString? {
            let bundlePath = testBundlePath.appendingPathComponent("\(bundleName).bundle")
            let jsonDirPath = (bundlePath as NSString).appendingPathComponent(resourceName)
            let manifestPath = (jsonDirPath as NSString).appendingPathComponent("manifest.json")
            if FileManager.default.fileExists(atPath: manifestPath) {
                return URL(fileURLWithPath: jsonDirPath)
            }
        }

        // Method 3: Search in Frameworks folder
        if let testBundlePath = testBundle.bundlePath as NSString? {
            let frameworksPath = testBundlePath.appendingPathComponent("Frameworks")
            if let contents = try? FileManager.default.contentsOfDirectory(atPath: frameworksPath) {
                for item in contents where item.hasSuffix(".framework") {
                    let frameworkPath = (frameworksPath as NSString).appendingPathComponent(item)
                    let innerBundlePath = (frameworkPath as NSString).appendingPathComponent("\(bundleName).bundle")
                    let jsonDirPath = (innerBundlePath as NSString).appendingPathComponent(resourceName)
                    let manifestPath = (jsonDirPath as NSString).appendingPathComponent("manifest.json")
                    if FileManager.default.fileExists(atPath: manifestPath) {
                        return URL(fileURLWithPath: jsonDirPath)
                    }
                }
            }
        }

        return nil
    }

    /// Сбросить состояние (для изолированных тестов)
    static func reset() {
        ContentRegistry.shared.unloadAllPacks()
        CardRegistry.shared.clear()
        AbilityRegistry.shared.clear()
        isLoaded = false
    }
}

// Helper class to get the test bundle
private class BundleToken {}


// ==========================================
// FILE: CardSampleGameTests/Views/HeroPanelTests.swift
// ==========================================

import XCTest
import TwilightEngine

@testable import CardSampleGame

/// Tests for the HeroPanel component
/// Verifies that the unified hero panel displays correctly across all screens
final class HeroPanelTests: XCTestCase {

    // MARK: - Test Engine Setup

    var engine: TwilightGameEngine!

    override func setUp() {
        super.setUp()
        engine = TwilightGameEngine()
    }

    override func tearDown() {
        engine = nil
        super.tearDown()
    }

    // MARK: - Hero Display Tests

    func testHeroDisplaysCorrectly() {
        // Given: Get first available hero from registry
        let registry = HeroRegistry.shared
        guard let hero = registry.firstHero else {
            XCTFail("No heroes in registry"); return
        }

        // Set hero via Engine-First
        engine.setHeroId(hero.id)

        // Then: Hero ID should be set
        XCTAssertEqual(engine.heroId, hero.id)
    }

    func testAllHeroesHaveValidData() {
        // Verify all heroes have valid data for display
        let registry = HeroRegistry.shared

        for hero in registry.allHeroes {
            XCTAssertFalse(hero.id.isEmpty, "Hero should have ID")
            XCTAssertFalse(hero.name.isEmpty, "Hero \(hero.id) should have a name")
            XCTAssertFalse(hero.icon.isEmpty, "Hero \(hero.id) should have an icon")
            XCTAssertFalse(hero.description.isEmpty, "Hero \(hero.id) should have a description")
        }
    }

    // MARK: - Player Stats Tests

    func testPlayerStatsAvailableFromEngine() {
        // Given: Engine with specific stats
        // Note: setMaxHealth before setHealth, as health is capped to maxHealth
        engine.setPlayerMaxHealth(20)
        engine.setPlayerHealth(15)
        engine.setPlayerFaith(8)
        engine.setPlayerBalance(65)
        engine.setPlayerName("Тестовый Герой")

        // Then: Stats should be readable from engine
        XCTAssertEqual(engine.playerName, "Тестовый Герой")
        XCTAssertEqual(engine.playerHealth, 15)
        XCTAssertEqual(engine.playerMaxHealth, 20)
        XCTAssertEqual(engine.playerFaith, 8)
        XCTAssertEqual(engine.playerBalance, 65)
    }

    // MARK: - Balance Display Tests

    func testBalanceDescriptionForLightPath() {
        // Given: Player with high balance (Light path)
        engine.setPlayerBalance(80)

        // Then: Balance should indicate Light path
        XCTAssertGreaterThanOrEqual(engine.playerBalance, 70)
    }

    func testBalanceDescriptionForDarkPath() {
        // Given: Player with low balance (Dark path)
        engine.setPlayerBalance(20)

        // Then: Balance should indicate Dark path
        XCTAssertLessThanOrEqual(engine.playerBalance, 30)
    }

    func testBalanceDescriptionForNeutral() {
        // Given: Player with neutral balance
        engine.setPlayerBalance(50)

        // Then: Balance should be in neutral range
        let balance = engine.playerBalance
        XCTAssertGreaterThan(balance, 30)
        XCTAssertLessThan(balance, 70)
    }

    // MARK: - Health Color Tests

    func testHealthColorLogic() {
        // Test health percentage thresholds
        // > 60% = green, 30-60% = orange, < 30% = red

        // High health (> 60%)
        let highPercentage = Double(18) / Double(20) // 90%
        XCTAssertGreaterThan(highPercentage, 0.6)

        // Medium health (30-60%)
        let medPercentage = Double(10) / Double(20) // 50%
        XCTAssertGreaterThan(medPercentage, 0.3)
        XCTAssertLessThan(medPercentage, 0.6)

        // Low health (< 30%)
        let lowPercentage = Double(4) / Double(20) // 20%
        XCTAssertLessThan(lowPercentage, 0.3)
    }
}


// ==========================================
// FILE: CardSampleGameTests/GateTests/AuditGateTests.swift
// ==========================================

import XCTest
import TwilightEngine

@testable import CardSampleGame

/// Audit Gate Tests - Required for "фундамент для будущих игр" approval
/// These tests verify architectural requirements from Audit 2.0
///
/// Reference: Результат аудита 2.0.rtf
final class AuditGateTests: XCTestCase {

    override func setUp() {
        super.setUp()
        WorldRNG.shared.setSeed(0)
        // Загружаем ContentPacks для тестов
        TestContentLoader.loadContentPacksIfNeeded()
    }

    override func tearDown() {
        WorldRNG.shared.setSeed(0)
        super.tearDown()
    }

    // MARK: - EPIC 0: Release Safety & Build Hygiene

    /// Gate test: Missing asset returns placeholder, never nil/crash
    /// Requirement: "UI никогда не показывает пустую иконку из-за отсутствующего ассета"
    func testMissingAssetHandling_returnsPlaceholder() {
        // Test with definitely non-existent asset names
        let missingAssets = [
            "nonexistent_icon_12345",
            "missing_region_xyz",
            "invalid_asset_name",
            "",
            "   "
        ]

        let defaultFallback = "questionmark.circle"

        for assetName in missingAssets {
            let result = AssetValidator.safeIconName(assetName, fallback: defaultFallback)

            // Must return fallback, not the missing asset name
            XCTAssertEqual(
                result,
                defaultFallback,
                "Missing asset '\(assetName)' should return fallback '\(defaultFallback)'"
            )
        }

        // Test nil input
        let nilResult = AssetValidator.safeIconName(nil, fallback: defaultFallback)
        XCTAssertEqual(
            nilResult,
            defaultFallback,
            "Nil asset name should return fallback"
        )

        // Test custom fallback
        let customFallback = "exclamationmark.triangle"
        let customResult = AssetValidator.safeIconName("missing_icon", fallback: customFallback)
        XCTAssertEqual(
            customResult,
            customFallback,
            "Should use custom fallback when provided"
        )
    }

    /// Gate test: AssetValidator.assetExists returns false for missing assets
    func testAssetValidator_detectsMissingAssets() {
        // Non-existent asset should return false
        XCTAssertFalse(
            AssetValidator.assetExists("definitely_not_a_real_asset_xyz"),
            "assetExists should return false for missing assets"
        )

        // Validate pack icons returns list of missing
        let testIcons = ["missing1", "missing2", "missing3"]
        let missing = AssetValidator.validatePackIcons(icons: testIcons)
        XCTAssertEqual(
            missing.count,
            testIcons.count,
            "All test icons should be reported as missing"
        )
    }

    /// Gate test: AssetRegistry returns SF Symbol fallback for missing assets
    /// Requirement: Epic 0.1 - "UI никогда не показывает пустую иконку"
    func testAssetRegistry_returnsFallbackForMissingAssets() {
        // AssetRegistry should always return a valid Image, never crash
        // For missing assets, it falls back to SF Symbols

        // Test region fallback
        _ = AssetRegistry.regionIcon("nonexistent_region_12345")

        // Test hero fallback
        _ = AssetRegistry.heroPortrait("nonexistent_hero_xyz")

        // Test card fallback
        _ = AssetRegistry.cardArt("nonexistent_card_abc")

        // Test hasAsset returns false for missing
        XCTAssertFalse(
            AssetRegistry.hasAsset(named: "definitely_missing_asset_99999"),
            "hasAsset should return false for missing assets"
        )

        // Test placeholder validation
        let missingPlaceholders = AssetRegistry.validatePlaceholders()
        // Note: In a real app with Assets.xcassets, this would be empty
        // For now we verify the API works
        XCTAssertNotNil(missingPlaceholders, "validatePlaceholders should return array")
    }

    // MARK: - EPIC 1: Engine Core Scrubbing

    /// Gate test: Engine/Core should not contain game-specific IDs
    /// Requirement: "Engine не содержит ни одного ID, специфичного для игры"
    func testEngineContainsNoGameSpecificIds() {
        // Verify that regions come from ContentRegistry, not hardcoded in Engine
        let registry = ContentRegistry.shared
        let regionsFromRegistry = registry.getAllRegions()

        // If packs are loaded, verify engine uses ContentRegistry data
        if !regionsFromRegistry.isEmpty {
            // All region IDs should come from loaded packs
            let regionIds = regionsFromRegistry.map { $0.id }
            XCTAssertFalse(regionIds.isEmpty, "Регионы должны загружаться из ContentRegistry")

            // Verify each region has data-driven properties
            for region in regionsFromRegistry {
                XCTAssertFalse(region.id.isEmpty, "Region ID не должен быть пустым")
                XCTAssertFalse(region.title.localized.isEmpty, "Region должен иметь локализованное имя")
                XCTAssertFalse(region.regionType.isEmpty, "Region должен иметь тип из данных")
            }
        }

        // Verify Engine initializes and works with data-driven content
        let engine = TwilightGameEngine()
        XCTAssertNotNil(engine, "Engine должен инициализироваться без хардкода контента")

        // Engine should expose regions from ContentRegistry, not internal hardcoded list
        let engineRegions = engine.regionsArray
        XCTAssertNotNil(engineRegions, "Engine должен предоставлять регионы из ContentRegistry")
    }

    /// Gate test: Manifest is single source of entry region
    /// Requirement: "no fallback 'village'"
    func testManifestIsSingleSourceOfEntryRegion() {
        // Verify that ContentRegistry uses manifest.entryRegionId
        let registry = ContentRegistry.shared

        // Campaign packs should have entryRegionId, character packs don't need it
        let campaignPacks = registry.loadedPacks.values.filter {
            $0.manifest.packType == .campaign
        }

        for pack in campaignPacks {
            // Campaign packs must specify entryRegionId
            XCTAssertNotNil(
                pack.manifest.entryRegionId,
                "Campaign pack '\(pack.manifest.packId)' must specify entryRegionId"
            )
        }

        // The code change removed `?? "village"` fallback
        // This test documents the requirement
    }

    // MARK: - EPIC 1.1: One Truth Runtime (Engine-First Architecture)

    /// Gate test: Views should primarily use TwilightGameEngine, not legacy WorldState
    /// Requirement: "UI читает Engine, а не legacy WorldState напрямую"
    func testViewsUseEngineFirstArchitecture() {
        // This test documents the Engine-First architecture requirement
        // Views should observe TwilightGameEngine for state, not WorldState directly
        //
        // Allowed patterns:
        // - @ObservedObject var engine: TwilightGameEngine (primary source)
        // - WorldState usage only for legacy compatibility adapters (marked as such)
        //
        // Disallowed patterns:
        // - Direct WorldState mutation from Views
        // - Views creating new WorldState instances for game logic

        // Verify Engine provides all necessary data for Views
        let engine = TwilightGameEngine()

        // Engine should expose player state
        XCTAssertGreaterThan(engine.playerHealth, 0, "Engine должен предоставлять здоровье игрока")
        XCTAssertGreaterThan(engine.playerFaith, 0, "Engine должен предоставлять веру игрока")

        // Engine should expose world state
        XCTAssertFalse(engine.playerName.isEmpty, "Engine должен предоставлять имя игрока")

        // Engine should handle actions
        let result = engine.performAction(.rest)
        XCTAssertNotNil(result, "Engine должен обрабатывать действия")

        // Note: Full verification requires static code analysis
        // This test documents the requirement and verifies API availability
    }

    /// Gate test: Contract tests run against production engine
    /// Requirement: "контрактные тесты идут против production engine, не test stub"
    func testContractsRunAgainstProductionEngine() {
        // Verify that TwilightGameEngine (production) is testable
        let engine = TwilightGameEngine()

        // Basic contracts: state changes are observable
        let initialHealth = engine.playerHealth
        XCTAssertGreaterThan(initialHealth, 0, "Initial health должен быть положительным")

        // Perform action that should change state
        _ = engine.performAction(.rest)

        // State should be accessible (may or may not change depending on game rules)
        XCTAssertGreaterThanOrEqual(engine.playerHealth, 0, "Health должен быть доступен после действия")

        // The test verifies we're using production engine, not a mock
        // Production engine has full game logic
    }

    // MARK: - EPIC 2.1: Code Registry Isolation

    /// Gate test: CardFactory is the primary interface, not direct registry access
    /// Requirement: "runtime не обращается напрямую к CodeRegistry"
    func testCardFactoryIsThePrimaryInterface() throws {
        // CardFactory should be the single entry point for card creation at runtime
        // It abstracts over both ContentRegistry (JSON packs) and CardRegistry (built-in)

        let factory = CardFactory.shared

        // Factory should provide starting decks
        let deck = factory.createStartingDeck(forHero: "veleslava")
        // Deck may be empty if no packs loaded, but method should work
        XCTAssertNotNil(deck, "CardFactory должен предоставлять стартовые колоды")

        // Factory should provide guardians
        let guardians = factory.createGuardians()
        // Skip if ContentPacks not loaded in test environment
        // GATE TEST: Must not skip - if packs not loaded, this is a test environment issue
        if guardians.isEmpty {
            XCTFail("GATE TEST FAILURE: ContentPacks not loaded - test environment configuration issue")
            return
        }

        // Factory should provide encounter deck
        let encounters = factory.createEncounterDeck()
        XCTAssertNotNil(encounters, "CardFactory должен предоставлять колоду столкновений")

        // This test documents that CardFactory is the correct abstraction layer
        // Direct CardRegistry/HeroRegistry access should only be in CardFactory implementation
    }

    /// Gate test: ContentRegistry is the source of truth for pack content
    /// Requirement: "ContentRegistry как единственный источник данных из pack'ов"
    func testContentRegistryIsSingleSourceOfPackData() {
        // ContentRegistry should be used for all pack content access
        let registry = ContentRegistry.shared

        // Registry should expose loaded packs
        XCTAssertNotNil(registry.loadedPacks, "ContentRegistry должен хранить загруженные pack'и")

        // Registry should provide access to pack content via factory methods
        // Direct access to registry methods is appropriate for reading definitions
        let regions = registry.getAllRegions()
        XCTAssertNotNil(regions, "ContentRegistry должен предоставлять регионы")

        let events = registry.getAllEvents()
        XCTAssertNotNil(events, "ContentRegistry должен предоставлять события")

        // This documents that ContentRegistry is the correct source for pack data
    }

    // MARK: - EPIC 2: Determinism

    /// Gate test: Full playthrough is identical with same seed
    /// Requirement: "полный playthrough одинаков при seed (на production engine)"
    func testWorldDeterminismWithSeed() {
        let testSeed: UInt64 = 12345

        // First playthrough
        WorldRNG.shared.setSeed(testSeed)
        let results1 = simulateDeterministicActions()

        // Second playthrough with same seed
        WorldRNG.shared.setSeed(testSeed)
        let results2 = simulateDeterministicActions()

        // Results must be identical
        XCTAssertEqual(
            results1.randomValues,
            results2.randomValues,
            "Random values must be identical with same seed"
        )
        XCTAssertEqual(
            results1.selectedIndices,
            results2.selectedIndices,
            "Selection results must be identical with same seed"
        )
    }

    /// Gate test: No system random in Engine/Core and core paths
    /// Requirement: "статический scan по randomElement/shuffled/Double.random"
    func testNoSystemRandomInEngineCore() throws {
        // Get project root directory from compile-time path
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // Engine
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        // Scan entire engine source tree recursively (no hardcoded subdirectory list)
        let engineBase = SourcePathResolver.engineBase

        // Forbidden patterns (system random APIs)
        let forbiddenPatterns = [
            ".randomElement()",      // Array.randomElement()
            ".shuffled()",           // Array.shuffled()
            "Int.random(",           // Int.random(in:)
            "Double.random(",        // Double.random(in:)
            "UInt64.random(",        // UInt64.random(in:)
            "Bool.random(",          // Bool.random()
            "arc4random",            // C random
            "drand48"                // C random
        ]

        // Allowed contexts (where system random is OK)
        let allowedContexts = [
            "WorldRNG",              // Our deterministic RNG
            "// ",                   // Single-line comments
            "/// ",                  // Doc comments
            "/* ",                   // Block comments
            "* "                     // Block comment continuation
        ]

        // No exceptions: all system RNG removed from engine
        let allowedExceptions: [String: [String]] = [:]

        var violations: [String] = []

        let engineDir = projectRoot.appendingPathComponent(engineBase)
        let swiftFiles = findSwiftFiles(in: engineDir)

        for fileURL in swiftFiles {
            let fileName = fileURL.lastPathComponent
            let content = try String(contentsOf: fileURL, encoding: .utf8)
            let lines = content.components(separatedBy: .newlines)

            for (index, line) in lines.enumerated() {
                let trimmedLine = line.trimmingCharacters(in: .whitespaces)
                let lineNumber = index + 1

                // Check each forbidden pattern
                for pattern in forbiddenPatterns {
                    if line.contains(pattern) {
                        // Check if it's in an allowed context
                        let isAllowedContext = allowedContexts.contains { context in
                            trimmedLine.hasPrefix(context) || line.contains(context)
                        }

                        // Check if it's an allowed exception for this file
                        let isAllowedException = allowedExceptions[fileName]?.contains { exception in
                            pattern.contains(exception) || exception.contains(pattern)
                        } ?? false

                        if !isAllowedContext && !isAllowedException {
                            violations.append("  \(fileName):\(lineNumber): \(trimmedLine) [pattern: \(pattern)]")
                        }
                    }
                }
            }
        }

        if !violations.isEmpty {
            let message = """
            Found \(violations.count) system random API usages in core engine paths:
            \(violations.joined(separator: "\n"))

            All randomness in Engine/Core must use WorldRNG for determinism.
            Replace:
            - .randomElement() → WorldRNG.shared.randomElement(from:)
            - .shuffled() → WorldRNG.shared.shuffle(&array)
            - Int.random(in:) → WorldRNG.shared.nextInt(in:)
            - Double.random(in:) → WorldRNG.shared.nextDouble()
            """
            XCTFail(message)
        }

        // Also verify WorldRNG determinism
        WorldRNG.shared.setSeed(42)
        let val1 = WorldRNG.shared.nextDouble()
        WorldRNG.shared.setSeed(42)
        let val2 = WorldRNG.shared.nextDouble()
        XCTAssertEqual(val1, val2, "WorldRNG must be deterministic with same seed")
    }

    // MARK: - EPIC 3: Pack Compatibility

    /// Gate test: Can load multiple packs (campaign + character)
    /// Note: "Character Pack" replaces "Investigator Pack" for Twilight Marches theme
    func testLoadTwoPacks_CampaignPlusCharacter() throws {
        // This test would require having multiple pack files
        // For now, verify the API supports this
        let registry = ContentRegistry.shared

        // Verify registry can hold multiple packs
        XCTAssertNotNil(registry.loadedPacks, "Registry should support multiple packs")

        // Note: Full test requires campaign + character pack files
    }

    /// Gate test: Save stores pack versions and validates on load
    func testSaveLoadValidatesPackVersions() {
        // Get currently loaded packs to create a valid activePackSet
        let registry = ContentRegistry.shared
        var activePackSet: [String: String] = [:]
        for (packId, pack) in registry.loadedPacks {
            activePackSet[packId] = pack.manifest.version.description
        }

        // Create a test save with pack version info
        let testSave = EngineSave(
            version: EngineSave.currentVersion,
            savedAt: Date(),
            gameDuration: 100,
            coreVersion: EngineSave.currentCoreVersion,
            activePackSet: activePackSet,
            formatVersion: EngineSave.currentFormatVersion,
            primaryCampaignPackId: nil,
            playerName: "Test",
            heroId: nil,
            playerHealth: 10,
            playerMaxHealth: 10,
            playerFaith: 5,
            playerMaxFaith: 5,
            playerBalance: 50,
            deckCardIds: [],
            handCardIds: [],
            discardCardIds: [],
            currentDay: 1,
            worldTension: 0,
            lightDarkBalance: 50,
            currentRegionId: nil,
            regions: [],
            mainQuestStage: 0,
            activeQuestIds: [],
            completedQuestIds: [],
            questStages: [:],
            completedEventIds: [],
            eventLog: [],
            worldFlags: [:],
            rngSeed: 0,
            rngState: 0
        )

        // Verify save contains required version fields
        XCTAssertFalse(testSave.coreVersion.isEmpty, "Save must store coreVersion")
        XCTAssertNotNil(testSave.activePackSet, "Save must store activePackSet")
        XCTAssertGreaterThan(testSave.formatVersion, 0, "Save must have formatVersion > 0")

        // Verify validation works - save with matching pack versions should be loadable
        let compatibility = testSave.validateCompatibility(with: registry)
        XCTAssertTrue(compatibility.isLoadable, "Save with matching pack versions should be loadable")

        // Test that mismatched pack triggers warning/error
        let mismatchedSave = EngineSave(
            version: EngineSave.currentVersion,
            savedAt: Date(),
            gameDuration: 100,
            coreVersion: EngineSave.currentCoreVersion,
            activePackSet: ["nonexistent_pack": "1.0.0"],
            formatVersion: EngineSave.currentFormatVersion,
            primaryCampaignPackId: nil,
            playerName: "Test",
            heroId: nil,
            playerHealth: 10,
            playerMaxHealth: 10,
            playerFaith: 5,
            playerMaxFaith: 5,
            playerBalance: 50,
            deckCardIds: [],
            handCardIds: [],
            discardCardIds: [],
            currentDay: 1,
            worldTension: 0,
            lightDarkBalance: 50,
            currentRegionId: nil,
            regions: [],
            mainQuestStage: 0,
            activeQuestIds: [],
            completedQuestIds: [],
            questStages: [:],
            completedEventIds: [],
            eventLog: [],
            worldFlags: [:],
            rngSeed: 0,
            rngState: 0
        )

        let mismatchedCompatibility = mismatchedSave.validateCompatibility(with: registry)
        // Missing packs result in warnings, not errors - save is still loadable
        // This allows users to continue playing even if some content is unavailable
        XCTAssertTrue(mismatchedCompatibility.isLoadable, "Save with missing pack should still be loadable (with warnings)")

        // But it should have warnings
        if case .compatible(let warnings) = mismatchedCompatibility {
            XCTAssertFalse(warnings.isEmpty, "Missing pack should generate warnings")
        } else if case .fullyCompatible = mismatchedCompatibility {
            XCTFail("Missing pack should generate at least a warning")
        }
    }

    // MARK: - EPIC 5: Localization Support

    /// Gate test: Pack content supports localization
    /// Requirement: "Packs используют stringKey/nameRu/descriptionRu для локализации"
    func testPackContentSupportsLocalization() {
        // Verify that content definitions have localization support
        // Current implementation uses nameRu/descriptionRu fields (PoC approach)
        // Future: stringKey approach for app-side localization

        // Verify HeroRegistry uses localized names
        let heroes = HeroRegistry.shared.allHeroes
        for hero in heroes {
            // Hero should have a name (either localized or default)
            XCTAssertFalse(hero.name.isEmpty, "Hero должен иметь имя")
            XCTAssertFalse(hero.description.isEmpty, "Hero должен иметь описание")
        }

        // Verify ContentRegistry provides localized content
        let registry = ContentRegistry.shared
        let regions = registry.getAllRegions()
        for region in regions {
            XCTAssertFalse(region.title.localized.isEmpty, "Region должен иметь имя")
        }

        // This documents that localization is supported via nameRu/descriptionRu pattern
        // The pack loader handles locale detection and returns appropriate strings
    }

    // MARK: - EPIC 6: Pack Composition

    /// Gate test: Multiple packs can be loaded together
    /// Requirement: "Campaign Pack + Character Pack работают вместе"
    func testCampaignPlusCharacterPackComposition() {
        // Verify ContentRegistry supports multiple pack loading
        let registry = ContentRegistry.shared

        // Registry should be able to hold multiple packs
        XCTAssertNotNil(registry.loadedPacks, "Registry должен поддерживать множественные pack'и")

        // Verify pack loading API exists
        // Note: Full test requires actual pack files

        // Document the composition requirement:
        // - Campaign pack provides: regions, events, quests, enemies
        // - Character pack provides: heroes, hero-specific cards, hero abilities
        // - Packs can have dependencies (character pack depends on campaign pack)
    }

    // MARK: - EPIC 7: Save Pack Set Tracking

    /// Gate test: Save stores pack set for compatibility
    /// Requirement: "Save хранит activePackSet и проверяет при загрузке"
    func testSaveStoresPackSetAndValidates() {
        // Verify EngineSave has pack compatibility fields
        let engine = TwilightGameEngine()

        // EngineSave should include:
        // - coreVersion: String
        // - activePackSet: [String: String] (packId -> version)
        // - formatVersion: Int

        // Verify engine is valid and can be used for save
        XCTAssertNotNil(engine, "Engine должен быть создан для сохранения")

        // Create a minimal save to verify structure
        // Note: This is documented in EngineSave.swift
        XCTAssertEqual(EngineSave.currentVersion, 1, "EngineSave должен иметь версию")
        XCTAssertEqual(EngineSave.currentFormatVersion, 1, "EngineSave должен иметь версию формата")
        XCTAssertFalse(EngineSave.currentCoreVersion.isEmpty, "EngineSave должен иметь версию core")
    }

    // MARK: - Determinism Helpers

    private struct DeterministicResults {
        var randomValues: [Double] = []
        var selectedIndices: [Int] = []
    }

    private func simulateDeterministicActions() -> DeterministicResults {
        var results = DeterministicResults()

        // Generate random values
        for _ in 0..<10 {
            results.randomValues.append(WorldRNG.shared.nextDouble())
        }

        // Simulate selection from arrays
        let testArray = ["a", "b", "c", "d", "e"]
        for _ in 0..<5 {
            if let selected = WorldRNG.shared.randomElement(from: testArray),
               let index = testArray.firstIndex(of: selected) {
                results.selectedIndices.append(index)
            }
        }

        return results
    }

    // MARK: - EPIC 1.2: One Engine = One Truth

    /// Gate test: Contract tests run against production engine, not test stub
    /// Also verifies that TwilightGameEngine is the ONLY runtime engine
    func testContractsAgainstProductionEngine() {
        // Verify that TwilightGameEngine (production) can be tested
        let engine = TwilightGameEngine()

        // Basic contract: performAction returns result
        let result = engine.performAction(.rest)
        XCTAssertNotNil(result, "Production engine should return action result")

        // Contract: state changes are observable
        // (This is verified by the Engine-First architecture)
    }

    /// Gate test: No alternative runtime engines exist in TwilightEngine package
    /// Requirement: "Production runtime engine должен быть единственным исполняемым движком"
    func testNoAlternativeEnginesExist() throws {
        // Get project root directory from compile-time path
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // Engine
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        let coreDir = projectRoot.appendingPathComponent(SourcePathResolver.engineBase + "/Core")

        // Scan for files with "Engine" in the name
        let engineFiles = try FileManager.default.contentsOfDirectory(at: coreDir, includingPropertiesForKeys: nil)
            .filter { $0.pathExtension == "swift" }
            .filter { $0.lastPathComponent.contains("Engine") }
            .map { $0.lastPathComponent }

        // Only TwilightGameEngine should exist as the runtime engine
        // Other "Engine" files (TimeEngine, PressureEngine) are subsystems, not full runtime engines
        let alternativeEngines = engineFiles.filter { file in
            // TwilightGameEngine is the production engine
            if file == "TwilightGameEngine.swift" { return false }
            // TimeEngine and PressureEngine are subsystems, not runtime engines
            if file == "TimeEngine.swift" || file == "PressureEngine.swift" { return false }
            // EngineProtocols.swift contains protocols, not a runtime engine
            if file == "EngineProtocols.swift" { return false }
            // EngineSave.swift is a data model, not a runtime engine
            if file == "EngineSave.swift" { return false }
            // Any other "Engine" file is a potential violation
            return true
        }

        XCTAssertTrue(
            alternativeEngines.isEmpty,
            "Found alternative runtime engines that should be removed: \(alternativeEngines). " +
            "TwilightGameEngine должен быть единственным runtime движком."
        )
    }

    // MARK: - EPIC 2.1: Single Source of Content (Packs only)

    /// Gate test: Runtime does not access code registries directly
    /// Requirement: "Вся загрузка карт/героев/квестов/ивентов осуществляется через ContentRegistry"
    func testRuntimeDoesNotAccessCodeRegistries() throws {
        // Get project root directory from compile-time path
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // Engine
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        // Directories to check (production code only, excluding tests)
        // Engine code is now in TwilightEngine package
        let productionDirs = [SourcePathResolver.engineBase, "App", "Views", "Models", "Utilities"]

        // Patterns that indicate direct code registry access (should use ContentRegistry/CardFactory)
        let forbiddenPatterns = [
            "CardRegistry.shared",           // Direct CardRegistry access
            "TwilightMarchesCards",          // Hardcoded card definitions
            "registerBuiltInCards",          // Built-in card registration
            "HeroRegistry.shared.register"   // Direct hero registration (reading is OK)
        ]

        // Allowed patterns (these files ARE the registries, they can access themselves)
        let allowedFiles = [
            "CardRegistry.swift",
            "CardFactory.swift",  // CardFactory internally manages registries
            "ContentRegistry.swift",
            "HeroRegistry.swift"
        ]

        var violations: [String] = []

        for dir in productionDirs {
            let dirURL = projectRoot.appendingPathComponent(dir)
            guard FileManager.default.fileExists(atPath: dirURL.path) else { continue }

            let swiftFiles = findSwiftFiles(in: dirURL)
            for fileURL in swiftFiles {
                let fileName = fileURL.lastPathComponent

                // Skip allowed files (registries themselves)
                if allowedFiles.contains(fileName) { continue }

                let fileViolations = try checkForbiddenPatternsInFile(fileURL, patterns: forbiddenPatterns)
                violations.append(contentsOf: fileViolations)
            }
        }

        if !violations.isEmpty {
            let message = """
            Found \(violations.count) direct code registry accesses in production code:
            \(violations.joined(separator: "\n"))

            Runtime должен использовать ContentRegistry/CardFactory для загрузки контента.
            Прямой доступ к CardRegistry.shared или TwilightMarchesCards запрещён.
            """
            XCTFail(message)
        }
    }

    /// Gate test: Runtime rejects raw JSON files, only accepts binary .pack
    /// Requirement: "Runtime загружает только .pack файлы, JSON только для compile-time"
    func testRuntimeRejectsRawJSON() throws {
        // Create a temporary JSON directory (simulating raw JSON pack)
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        defer { try? FileManager.default.removeItem(at: tempDir) }

        // Create a minimal manifest.json file
        let manifestJSON = """
        {
            "packId": "test-json-pack",
            "displayName": { "en": "Test JSON Pack", "ru": "Тестовый JSON пак" },
            "version": "1.0.0",
            "packType": "character",
            "coreVersionMin": "1.0.0"
        }
        """
        let manifestURL = tempDir.appendingPathComponent("manifest.json")
        try manifestJSON.write(to: manifestURL, atomically: true, encoding: .utf8)

        // Attempt to load raw JSON directory should fail
        let registry = ContentRegistry.shared
        registry.resetForTesting()

        // Try to load the JSON directory (not a .pack file)
        do {
            _ = try registry.loadPack(from: tempDir)
            XCTFail("GATE TEST FAILURE: Runtime должен отвергать raw JSON директории")
        } catch let error as PackLoadError {
            // Expected: should fail with invalidManifest error
            if case .invalidManifest(let reason) = error {
                XCTAssertTrue(
                    reason.contains(".pack") || reason.contains("pack"),
                    "Error message should mention .pack files: \(reason)"
                )
            } else {
                // Any PackLoadError is acceptable - runtime rejected the JSON
            }
        } catch {
            // Any error is fine - runtime rejected the raw JSON
        }

        // Also verify that a file with wrong extension is rejected
        let wrongExtFile = tempDir.appendingPathComponent("test.json")
        try "{}".write(to: wrongExtFile, atomically: true, encoding: .utf8)

        do {
            _ = try registry.loadPack(from: wrongExtFile)
            XCTFail("GATE TEST FAILURE: Runtime должен отвергать файлы без расширения .pack")
        } catch {
            // Expected: any error means runtime correctly rejected the file
        }
    }

    /// Check a Swift file for forbidden patterns not in comments
    private func checkForbiddenPatternsInFile(_ fileURL: URL, patterns: [String]) throws -> [String] {
        let content = try String(contentsOf: fileURL, encoding: .utf8)
        let lines = content.components(separatedBy: .newlines)
        var violations: [String] = []

        for (index, line) in lines.enumerated() {
            let trimmedLine = line.trimmingCharacters(in: .whitespaces)
            let lineNumber = index + 1

            // Skip comments
            if trimmedLine.hasPrefix("//") || trimmedLine.hasPrefix("/*") || trimmedLine.hasPrefix("*") {
                continue
            }

            // Remove inline comments for pattern matching
            var lineToCheck = trimmedLine
            if let commentRange = lineToCheck.range(of: "//") {
                lineToCheck = String(lineToCheck[..<commentRange.lowerBound])
            }

            // Check for forbidden patterns
            for pattern in patterns {
                if lineToCheck.contains(pattern) {
                    let fileName = fileURL.lastPathComponent
                    violations.append("  \(fileName):\(lineNumber): \(trimmedLine) [pattern: \(pattern)]")
                }
            }
        }

        return violations
    }
}

// MARK: - Static Analysis Test (Supplementary)

extension AuditGateTests {

    /// Supplementary: Verify no hardcoded region IDs in key files
    /// See ArchitectureComplianceTests for full static analysis
    func testDocumentHardcodedIdRemoval() throws {
        // Document the changes made to remove hardcoded IDs:
        //
        // 1. TwilightGameEngine.swift:
        //    - mapRegionType(fromString:) now takes regionType string, not ID
        //    - entryRegionId comes from manifest, no "village" fallback
        //    - tensionTickInterval and restHealAmount now from BalanceConfiguration
        //
        // 2. JSONContentProvider.swift:
        //    - Events loaded from events.json, not hardcoded pool_* files
        //    - RegionDefinition includes regionType field
        //
        // 3. ContentView.swift, WorldMapView.swift, WorldState.swift:
        //    - All TwilightMarchesCards usage replaced with CardFactory
        //
        // 4. PlayerRuntimeState.swift:
        //    - shuffle() replaced with WorldRNG.shared.shuffle()
        //
        // 5. BalanceConfiguration:
        //    - Added restHealAmount and tensionTickInterval

        // Verify architectural principles are enforced
        // Full static analysis in ArchitectureComplianceTests
        let factory = CardFactory.shared
        XCTAssertNotNil(factory, "CardFactory must be the single source of cards")

        let guardians = factory.createGuardians()
        // Skip if ContentPacks not loaded in test environment
        // GATE TEST: Must not skip - if packs not loaded, this is a test environment issue
        if guardians.isEmpty {
            XCTFail("GATE TEST FAILURE: ContentPacks not loaded - test environment configuration issue")
            return
        }
    }

    // MARK: - EPIC 0.3: Content Hash Verification

    /// Gate test: Checksum mismatch throws error during pack loading
    /// Requirement: "hash verification при загрузке pack'ов"
    func testContentHashMismatchThrowsError() throws {
        // Create a temporary pack with incorrect checksum
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }

        // Create a simple test file
        let testContent = "test content"
        let testFileURL = tempDir.appendingPathComponent("test.json")
        try testContent.data(using: .utf8)!.write(to: testFileURL)

        // Compute correct hash
        let correctHash = try PackLoader.computeSHA256(of: testFileURL)
        XCTAssertFalse(correctHash.isEmpty, "Hash should not be empty")

        // Verify that an intentionally wrong hash would be detected
        let wrongHash = "0000000000000000000000000000000000000000000000000000000000000000"
        XCTAssertNotEqual(correctHash, wrongHash, "Correct hash should differ from test wrong hash")

        // Create manifest with wrong checksum
        let manifest = PackManifest(
            packId: "test-pack",
            displayName: LocalizedString("Test Pack"),
            description: LocalizedString("Test pack for checksum verification"),
            version: SemanticVersion(major: 1, minor: 0, patch: 0),
            packType: .campaign,
            coreVersionMin: SemanticVersion(major: 1, minor: 0, patch: 0),
            author: "Test",
            checksums: ["test.json": wrongHash]
        )

        // Attempt to load should fail with checksum mismatch
        do {
            _ = try PackLoader.load(manifest: manifest, from: tempDir)
            XCTFail("Loading pack with wrong checksum should throw error")
        } catch let error as PackLoadError {
            if case .checksumMismatch(let file, let expected, let actual) = error {
                XCTAssertEqual(file, "test.json")
                XCTAssertEqual(expected, wrongHash)
                XCTAssertEqual(actual, correctHash)
            } else {
                // File not found is acceptable since we only have test.json
                // and no real content files
                if case .fileNotFound = error {
                    // This is OK - the checksum check happens first
                } else {
                    throw error
                }
            }
        }
    }

    /// Gate test: Correct checksum passes verification
    func testCorrectChecksumPassesVerification() throws {
        // Create a temporary pack with correct checksum
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }

        // Create a simple test file
        let testContent = "test content"
        let testFileURL = tempDir.appendingPathComponent("test.json")
        try testContent.data(using: .utf8)!.write(to: testFileURL)

        // Compute correct hash
        let correctHash = try PackLoader.computeSHA256(of: testFileURL)

        // Create manifest with correct checksum
        let manifest = PackManifest(
            packId: "test-pack",
            displayName: LocalizedString("Test Pack"),
            description: LocalizedString("Test pack for checksum verification"),
            version: SemanticVersion(major: 1, minor: 0, patch: 0),
            packType: .campaign,
            coreVersionMin: SemanticVersion(major: 1, minor: 0, patch: 0),
            author: "Test",
            checksums: ["test.json": correctHash]
        )

        // Attempt to load should pass checksum verification
        // (may fail later due to missing content files, but that's OK)
        do {
            _ = try PackLoader.load(manifest: manifest, from: tempDir)
        } catch let error as PackLoadError {
            // Checksum should pass, other errors are acceptable
            if case .checksumMismatch = error {
                XCTFail("Pack with correct checksum should not fail checksum verification")
            }
            // Other errors (contentLoadFailed, etc.) are acceptable since we have minimal test files
        }
    }

    // MARK: - EPIC 11.2: Negative Tests for ContentLoader

    /// Negative test: Broken JSON fails to load
    func testBrokenJSONFailsToLoad() throws {
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }

        // Create invalid JSON
        let brokenJSON = "{ invalid json content"
        let jsonFileURL = tempDir.appendingPathComponent("regions.json")
        try brokenJSON.data(using: .utf8)!.write(to: jsonFileURL)

        // Create manifest pointing to broken JSON
        let manifest = PackManifest(
            packId: "broken-pack",
            displayName: LocalizedString("Broken Pack"),
            description: LocalizedString("Test pack with broken JSON"),
            version: SemanticVersion(major: 1, minor: 0, patch: 0),
            packType: .campaign,
            coreVersionMin: SemanticVersion(major: 1, minor: 0, patch: 0),
            author: "Test",
            regionsPath: "regions.json"
        )

        // Attempt to load should fail
        do {
            _ = try PackLoader.load(manifest: manifest, from: tempDir)
            XCTFail("Loading broken JSON should throw error")
        } catch let error as PackLoadError {
            // Should fail with contentLoadFailed
            if case .contentLoadFailed(let file, _) = error {
                XCTAssertEqual(file, "regions.json", "Ошибка должна указывать на сломанный файл")
            } else {
                // Any PackLoadError is acceptable for broken JSON
            }
        }
    }

    /// Negative test: Missing required fields fails validation
    func testMissingRequiredFieldsFailsValidation() throws {
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }

        // Create JSON with missing required fields (id is required for regions)
        let incompleteJSON = """
        [
            {
                "name": "Test Region"
            }
        ]
        """
        let jsonFileURL = tempDir.appendingPathComponent("regions.json")
        try incompleteJSON.data(using: .utf8)!.write(to: jsonFileURL)

        // Create manifest
        let manifest = PackManifest(
            packId: "incomplete-pack",
            displayName: LocalizedString("Incomplete Pack"),
            description: LocalizedString("Test pack with incomplete JSON"),
            version: SemanticVersion(major: 1, minor: 0, patch: 0),
            packType: .campaign,
            coreVersionMin: SemanticVersion(major: 1, minor: 0, patch: 0),
            author: "Test",
            regionsPath: "regions.json"
        )

        // Attempt to load - should fail due to missing fields
        do {
            _ = try PackLoader.load(manifest: manifest, from: tempDir)
            // If it loads, the JSON decoder should have failed
            XCTFail("Loading JSON with missing required fields should fail")
        } catch {
            // Expected to fail - any error is acceptable
        }
    }

    // MARK: - EPIC 11.3: State Round-Trip Serialization

    /// Gate test: EngineSave round-trip preserves all data
    func testStateRoundTripSerialization() throws {
        // Create EngineSave with test data
        let originalSave = EngineSave(
            version: EngineSave.currentVersion,
            savedAt: Date(),
            gameDuration: 3600.0,
            coreVersion: EngineSave.currentCoreVersion,
            activePackSet: ["test_campaign": "1.0.0"],
            formatVersion: EngineSave.currentFormatVersion,
            primaryCampaignPackId: nil,
            playerName: "Test Hero",
            heroId: "test_hero",
            playerHealth: 10,
            playerMaxHealth: 12,
            playerFaith: 5,
            playerMaxFaith: 8,
            playerBalance: 50,
            deckCardIds: ["card_1", "card_2", "card_3"],
            handCardIds: ["card_4"],
            discardCardIds: ["card_5"],
            currentDay: 3,
            worldTension: 25,
            lightDarkBalance: 50,
            currentRegionId: "test_region",
            regions: [],
            mainQuestStage: 2,
            activeQuestIds: ["quest_1"],
            completedQuestIds: ["quest_0"],
            questStages: ["quest_1": 1],
            completedEventIds: ["event_1", "event_2"],
            eventLog: [],
            worldFlags: ["flag_1": true, "flag_2": false],
            rngSeed: 12345,
            rngState: 12345
        )

        // Encode to JSON
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        let jsonData = try encoder.encode(originalSave)

        // Decode back
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        let loadedSave = try decoder.decode(EngineSave.self, from: jsonData)

        // Verify all fields match
        XCTAssertEqual(loadedSave.version, originalSave.version)
        XCTAssertEqual(loadedSave.coreVersion, originalSave.coreVersion)
        XCTAssertEqual(loadedSave.formatVersion, originalSave.formatVersion)
        XCTAssertEqual(loadedSave.playerName, originalSave.playerName)
        XCTAssertEqual(loadedSave.playerHealth, originalSave.playerHealth)
        XCTAssertEqual(loadedSave.playerMaxHealth, originalSave.playerMaxHealth)
        XCTAssertEqual(loadedSave.playerFaith, originalSave.playerFaith)
        XCTAssertEqual(loadedSave.playerMaxFaith, originalSave.playerMaxFaith)
        XCTAssertEqual(loadedSave.playerBalance, originalSave.playerBalance)
        XCTAssertEqual(loadedSave.deckCardIds, originalSave.deckCardIds)
        XCTAssertEqual(loadedSave.handCardIds, originalSave.handCardIds)
        XCTAssertEqual(loadedSave.discardCardIds, originalSave.discardCardIds)
        XCTAssertEqual(loadedSave.currentDay, originalSave.currentDay)
        XCTAssertEqual(loadedSave.worldTension, originalSave.worldTension)
        XCTAssertEqual(loadedSave.lightDarkBalance, originalSave.lightDarkBalance)
        XCTAssertEqual(loadedSave.currentRegionId, originalSave.currentRegionId)
        XCTAssertEqual(loadedSave.mainQuestStage, originalSave.mainQuestStage)
        XCTAssertEqual(loadedSave.activeQuestIds, originalSave.activeQuestIds)
        XCTAssertEqual(loadedSave.completedQuestIds, originalSave.completedQuestIds)
        XCTAssertEqual(loadedSave.questStages, originalSave.questStages)
        XCTAssertEqual(loadedSave.completedEventIds, originalSave.completedEventIds)
        XCTAssertEqual(loadedSave.worldFlags, originalSave.worldFlags)
        XCTAssertEqual(loadedSave.rngSeed, originalSave.rngSeed)
        XCTAssertEqual(loadedSave.activePackSet, originalSave.activePackSet)
    }

    // MARK: - EPIC 12: Critical Game Conditions

    /// Gate test: Player health reaching 0 triggers defeat
    /// Requirement: "здоровье игрока = 0 вызывает поражение"
    func testPlayerDeathTriggersDefeat() {
        let engine = TwilightGameEngine()
        engine.initializeNewGame(playerName: "Test", heroId: nil, startingDeck: [])

        // Verify player starts alive
        XCTAssertGreaterThan(engine.playerHealth, 0, "Player should start with health > 0")

        // Deal fatal damage
        let fatalDamage = engine.playerHealth + 10
        engine.performAction(.combatApplyEffect(effect: .takeDamage(amount: fatalDamage)))

        // Verify player health is 0 (not negative)
        XCTAssertEqual(engine.playerHealth, 0, "Player health should be exactly 0, not negative")
    }

    /// Gate test: Player health cannot go below 0
    /// Requirement: "здоровье не может быть отрицательным"
    func testPlayerHealthCannotBeNegative() {
        let engine = TwilightGameEngine()
        engine.initializeNewGame(playerName: "Test", heroId: nil, startingDeck: [])

        // Deal massive damage
        engine.performAction(.combatApplyEffect(effect: .takeDamage(amount: 9999)))

        // Health should be 0, not negative
        XCTAssertGreaterThanOrEqual(engine.playerHealth, 0, "Health cannot be negative")
    }

    /// Gate test: Healing cannot exceed max health
    /// Requirement: "лечение не превышает максимальное здоровье"
    func testHealingCannotExceedMaxHealth() {
        let engine = TwilightGameEngine()
        engine.initializeNewGame(playerName: "Test", heroId: nil, startingDeck: [])

        let maxHealth = engine.playerMaxHealth

        // Heal beyond max
        engine.performAction(.combatApplyEffect(effect: .heal(amount: 9999)))

        // Health should not exceed max
        XCTAssertLessThanOrEqual(engine.playerHealth, maxHealth, "Health cannot exceed max")
        XCTAssertEqual(engine.playerHealth, maxHealth, "Healing should cap at max health")
    }

    /// Gate test: Faith cannot go below 0 or exceed max
    /// Requirement: "вера в пределах 0..max"
    func testFaithBoundsAreRespected() {
        let engine = TwilightGameEngine()
        engine.initializeNewGame(playerName: "Test", heroId: nil, startingDeck: [])

        let maxFaith = engine.playerMaxFaith

        // Try to spend more faith than available
        engine.performAction(.combatApplyEffect(effect: .spendFaith(amount: 9999)))
        XCTAssertGreaterThanOrEqual(engine.playerFaith, 0, "Faith cannot be negative")

        // Try to gain more faith than max
        engine.performAction(.combatApplyEffect(effect: .gainFaith(amount: 9999)))
        XCTAssertLessThanOrEqual(engine.playerFaith, maxFaith, "Faith cannot exceed max")
    }

    /// Gate test: Enemy health cannot go below 0
    /// Requirement: "здоровье врага не отрицательное"
    func testEnemyHealthCannotBeNegative() {
        let engine = TwilightGameEngine()
        engine.initializeNewGame(playerName: "Test", heroId: nil, startingDeck: [])

        let enemy = Card(name: "Test Enemy", type: .monster, description: "Test", health: 10)
        engine.setupCombatEnemy(enemy)

        // Deal massive damage
        engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: 9999)))

        // Enemy health should be 0, not negative
        XCTAssertEqual(engine.combatEnemyHealth, 0, "Enemy health should be 0, not negative")
    }

    // MARK: - EPIC 0.2: Release Configuration (Debug Prints)

    /// Gate test: All print() statements must be wrapped in #if DEBUG
    /// Requirement: "В Release сборке нет debug print'ов"
    func testAllPrintStatementsAreDebugOnly() throws {
        // Get project root directory from compile-time path
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // Engine
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        // Skip if project source not accessible (e.g., running on CI without source)
        guard FileManager.default.fileExists(atPath: projectRoot.path) else {
            XCTFail("GATE TEST FAILURE: Project source not accessible at \(projectRoot.path)")
            return
        }

        // Directories to check (production code only)
        let productionDirs = [
            "Engine",
            "App",
            "Views",
            "Models",
            "Utilities"
        ]

        var violations: [String] = []

        for dir in productionDirs {
            let dirURL = projectRoot.appendingPathComponent(dir)

            // Skip if directory doesn't exist
            guard FileManager.default.fileExists(atPath: dirURL.path) else {
                continue
            }

            let swiftFiles = findSwiftFiles(in: dirURL)

            for fileURL in swiftFiles {
                let fileViolations = try checkPrintStatementsInFile(fileURL)
                violations.append(contentsOf: fileViolations)
            }
        }

        // Report all violations
        if !violations.isEmpty {
            let message = "Found \(violations.count) print() statements not wrapped in #if DEBUG:\n" +
                violations.joined(separator: "\n")
            XCTFail(message)
        }
    }

    /// Find all Swift files recursively in a directory
    private func findSwiftFiles(in directory: URL) -> [URL] {
        var result: [URL] = []
        let fileManager = FileManager.default

        guard let enumerator = fileManager.enumerator(
            at: directory,
            includingPropertiesForKeys: [.isRegularFileKey],
            options: [.skipsHiddenFiles]
        ) else {
            return result
        }

        for case let fileURL as URL in enumerator {
            if fileURL.pathExtension == "swift" {
                result.append(fileURL)
            }
        }

        return result
    }

    /// Check a Swift file for print() statements not in #if DEBUG blocks
    /// Returns array of violation descriptions
    private func checkPrintStatementsInFile(_ fileURL: URL) throws -> [String] {
        let content = try String(contentsOf: fileURL, encoding: .utf8)
        let lines = content.components(separatedBy: .newlines)
        var violations: [String] = []

        // Track preprocessor directive stack
        // Each entry is true if we're in a DEBUG-related block
        var conditionalStack: [Bool] = []
        var inPreviewBlock = false
        var previewBraceDepth = 0

        for (index, line) in lines.enumerated() {
            let trimmedLine = line.trimmingCharacters(in: .whitespaces)
            let lineNumber = index + 1

            // Track #if / #elseif / #else / #endif blocks
            if trimmedLine.hasPrefix("#if DEBUG") || trimmedLine.hasPrefix("#if compiler") {
                // Start of DEBUG or compiler-specific block (compiler is also debug-only)
                conditionalStack.append(true)
            } else if trimmedLine.hasPrefix("#if ") || trimmedLine.hasPrefix("#if(") {
                // Start of non-DEBUG conditional
                conditionalStack.append(false)
            } else if trimmedLine.hasPrefix("#elseif DEBUG") {
                // Switching to DEBUG branch
                if !conditionalStack.isEmpty {
                    conditionalStack[conditionalStack.count - 1] = true
                }
            } else if trimmedLine.hasPrefix("#elseif") || trimmedLine.hasPrefix("#else") {
                // Switching to non-DEBUG branch (inverse of previous)
                if !conditionalStack.isEmpty {
                    conditionalStack[conditionalStack.count - 1] = false
                }
            } else if trimmedLine.hasPrefix("#endif") {
                // End of conditional block
                if !conditionalStack.isEmpty {
                    conditionalStack.removeLast()
                }
            }

            // Track #Preview blocks (SwiftUI previews are debug-only)
            if trimmedLine.hasPrefix("#Preview") {
                inPreviewBlock = true
                previewBraceDepth = 0
            }

            // Track braces in preview block
            if inPreviewBlock {
                previewBraceDepth += trimmedLine.filter { $0 == "{" }.count
                previewBraceDepth -= trimmedLine.filter { $0 == "}" }.count
                if previewBraceDepth <= 0 && trimmedLine.contains("}") {
                    inPreviewBlock = false
                }
            }

            // Check if we're inside any DEBUG block
            let isInsideDebugBlock = conditionalStack.contains(true)

            // Skip if inside DEBUG or Preview block
            if isInsideDebugBlock || inPreviewBlock {
                continue
            }

            // Skip comments
            if trimmedLine.hasPrefix("//") || trimmedLine.hasPrefix("/*") || trimmedLine.hasPrefix("*") {
                continue
            }

            // Skip markdown files embedded in code (documentation)
            if fileURL.lastPathComponent.hasSuffix(".md") {
                continue
            }

            // Check for print() call
            if trimmedLine.contains("print(") {
                // Skip if it's in a comment on the same line
                if let printIndex = trimmedLine.range(of: "print("),
                   let commentIndex = trimmedLine.range(of: "//"),
                   commentIndex.lowerBound < printIndex.lowerBound {
                    continue
                }

                let fileName = fileURL.lastPathComponent
                violations.append("  \(fileName):\(lineNumber): \(trimmedLine)")
            }
        }

        return violations
    }

    // MARK: - EPIC 1.1: One Truth Runtime (No Legacy Models in Views)

    /// Gate test: Views should not use legacy WorldState, GameState, or direct state mutations
    /// Requirement: "Views/ не импортируют и не используют legacy модели"
    func testNoLegacyWorldStateUsageInViews() throws {
        // Get project root directory from compile-time path
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // Engine
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        let viewsDir = projectRoot.appendingPathComponent("Views")

        // Skip if Views directory doesn't exist
        guard FileManager.default.fileExists(atPath: viewsDir.path) else {
            XCTFail("GATE TEST FAILURE: Views directory not found at \(viewsDir.path)")
            return
        }

        // Legacy patterns that should NOT appear in Views (outside of comments/previews)
        let legacyPatterns = [
            "WorldState",           // Legacy world state model
            "GameState",            // Legacy game state model
            "legacyPlayer",         // Legacy player reference
            "legacyWorldState",     // Legacy world state reference
            "connectToLegacy"       // Legacy connection method
        ]

        var violations: [String] = []
        let swiftFiles = findSwiftFiles(in: viewsDir)

        for fileURL in swiftFiles {
            let fileViolations = try checkLegacyPatternsInFile(fileURL, patterns: legacyPatterns)
            violations.append(contentsOf: fileViolations)
        }

        // Report all violations
        if !violations.isEmpty {
            let message = """
            Found \(violations.count) legacy model usages in Views/:
            \(violations.joined(separator: "\n"))

            Views should only use TwilightGameEngine as the single source of truth.
            Remove legacy WorldState/GameState references and use engine properties instead.
            """
            XCTFail(message)
        }
    }

    /// Check a Swift file for legacy patterns not in comments or preview blocks
    private func checkLegacyPatternsInFile(_ fileURL: URL, patterns: [String]) throws -> [String] {
        let content = try String(contentsOf: fileURL, encoding: .utf8)
        let lines = content.components(separatedBy: .newlines)
        var violations: [String] = []

        // Track if we're inside a preview block or multiline comment
        var inPreviewBlock = false
        var previewBraceDepth = 0
        var inMultilineComment = false

        for (index, line) in lines.enumerated() {
            let trimmedLine = line.trimmingCharacters(in: .whitespaces)
            let lineNumber = index + 1

            // Track multiline comments
            if trimmedLine.contains("/*") {
                inMultilineComment = true
            }
            if trimmedLine.contains("*/") {
                inMultilineComment = false
                continue
            }
            if inMultilineComment {
                continue
            }

            // Track #Preview blocks
            if trimmedLine.hasPrefix("#Preview") || trimmedLine.contains("PreviewProvider") {
                inPreviewBlock = true
                previewBraceDepth = 0
            }

            // Track braces in preview block
            if inPreviewBlock {
                previewBraceDepth += trimmedLine.filter { $0 == "{" }.count
                previewBraceDepth -= trimmedLine.filter { $0 == "}" }.count
                if previewBraceDepth <= 0 && trimmedLine.contains("}") {
                    inPreviewBlock = false
                }
                continue  // Skip preview content
            }

            // Skip single-line comments
            if trimmedLine.hasPrefix("//") {
                continue
            }

            // Remove inline comments for pattern matching
            var lineToCheck = trimmedLine
            if let commentRange = lineToCheck.range(of: "//") {
                lineToCheck = String(lineToCheck[..<commentRange.lowerBound])
            }

            // Check for legacy patterns
            for pattern in patterns {
                if lineToCheck.contains(pattern) {
                    let fileName = fileURL.lastPathComponent
                    violations.append("  \(fileName):\(lineNumber): \(trimmedLine) [pattern: \(pattern)]")
                }
            }
        }

        return violations
    }

    // MARK: - EPIC 3.1: Stable IDs Everywhere

    /// Gate test: Save/Load uses stable definition IDs, not UUIDs
    /// Requirement: "Запрет UUID для контентных сущностей в Save/Load"
    func testSaveLoadUsesStableDefinitionIdsOnly() throws {
        // Get project root directory from compile-time path
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // Engine
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        let engineFile = projectRoot
            .appendingPathComponent(SourcePathResolver.engineBase + "/Core/TwilightGameEngine.swift")

        guard FileManager.default.fileExists(atPath: engineFile.path) else {
            XCTFail("GATE TEST FAILURE: TwilightGameEngine.swift not found at \(engineFile.path)")
            return
        }

        let content = try String(contentsOf: engineFile, encoding: .utf8)

        // Patterns that indicate UUID usage for content entity IDs (should use String definition IDs)
        let forbiddenPatterns = [
            "completedEventIds: Set<UUID>",      // Should be Set<String>
            "completedEventIds.map { $0.uuidString }",  // Should not need conversion
            "compactMap { UUID(uuidString:",    // Should not convert strings to UUIDs
            "eventDefinitionIdToUUID"           // Helper should be removed
        ]

        var violations: [String] = []
        let lines = content.components(separatedBy: .newlines)

        for (index, line) in lines.enumerated() {
            let trimmedLine = line.trimmingCharacters(in: .whitespaces)
            let lineNumber = index + 1

            // Skip comments
            if trimmedLine.hasPrefix("//") || trimmedLine.hasPrefix("/*") || trimmedLine.hasPrefix("*") {
                continue
            }

            for pattern in forbiddenPatterns {
                if line.contains(pattern) {
                    violations.append("  TwilightGameEngine.swift:\(lineNumber): \(trimmedLine) [pattern: \(pattern)]")
                }
            }
        }

        if !violations.isEmpty {
            let message = """
            Found \(violations.count) UUID usages for content entity IDs:
            \(violations.joined(separator: "\n"))

            Content entity IDs (events, quests, cards, heroes) should use stable String definition IDs,
            not generated UUIDs. This ensures save compatibility across sessions.
            """
            XCTFail(message)
        }

        // Additional verification: completedEventIds should be declared as Set<String>
        XCTAssertTrue(
            content.contains("completedEventIds: Set<String>"),
            "completedEventIds should be declared as Set<String>, not Set<UUID>"
        )

        // Verify EngineSave uses String IDs
        let saveFile = projectRoot.appendingPathComponent(SourcePathResolver.engineBase + "/Core/EngineSave.swift")
        if FileManager.default.fileExists(atPath: saveFile.path) {
            let saveContent = try String(contentsOf: saveFile, encoding: .utf8)
            XCTAssertTrue(
                saveContent.contains("completedEventIds: [String]"),
                "EngineSave.completedEventIds should be [String], not [UUID]"
            )
        }
    }

    // MARK: - A1: definitionId Non-Optional Gate Tests

    /// Gate test: definitionId must be non-optional in pack-driven entities (Audit A1)
    /// Requirement: "definitionId должен быть обязательным для всех pack-driven сущностей"
    func testDefinitionIdIsNonOptional() throws {
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // Engine
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        // Check EngineRegionState
        let engineFile = projectRoot.appendingPathComponent(SourcePathResolver.engineBase + "/Core/TwilightGameEngine.swift")
        guard FileManager.default.fileExists(atPath: engineFile.path) else {
            XCTFail("GATE TEST FAILURE: TwilightGameEngine.swift not found")
            return
        }

        let engineContent = try String(contentsOf: engineFile, encoding: .utf8)

        // EngineRegionState.definitionId must be String (not String?)
        XCTAssertTrue(
            engineContent.contains("public let definitionId: String"),
            "EngineRegionState.definitionId must be non-optional String"
        )
        XCTAssertFalse(
            engineContent.contains("public let definitionId: String?"),
            "EngineAnchorState.definitionId must be non-optional String"
        )

        // Check Quest
        let modelsFile = projectRoot.appendingPathComponent(SourcePathResolver.engineBase + "/Models/ExplorationModels.swift")
        guard FileManager.default.fileExists(atPath: modelsFile.path) else {
            XCTFail("GATE TEST FAILURE: ExplorationModels.swift not found")
            return
        }

        let modelsContent = try String(contentsOf: modelsFile, encoding: .utf8)

        // Quest.definitionId must be String (not String?)
        XCTAssertTrue(
            modelsContent.contains("public let definitionId: String            // Content Pack ID (REQUIRED"),
            "Quest.definitionId must be non-optional String"
        )
    }

    /// Gate test: All pack-driven entities have non-empty definitionId at runtime (Audit 1.4)
    func testDefinitionIdNeverNilForPackEntities() throws {
        let registry = ContentRegistry.shared
        XCTAssertFalse(registry.loadedPacks.isEmpty, "Content packs must be loaded")

        // Regions
        for (id, region) in registry.loadedPacks.values.flatMap({ $0.regions }) {
            XCTAssertFalse(id.isEmpty, "Region definitionId must not be empty")
            XCTAssertEqual(id, region.id, "Region key must match id")
        }

        // Events
        for (id, event) in registry.loadedPacks.values.flatMap({ $0.events }) {
            XCTAssertFalse(id.isEmpty, "Event definitionId must not be empty")
            XCTAssertEqual(id, event.id, "Event key must match id")
            for choice in event.choices {
                XCTAssertFalse(choice.id.isEmpty, "EventChoice.id must not be empty (event: \(id))")
            }
        }

        // Quests
        for (id, quest) in registry.loadedPacks.values.flatMap({ $0.quests }) {
            XCTAssertFalse(id.isEmpty, "Quest definitionId must not be empty")
            XCTAssertEqual(id, quest.id, "Quest key must match id")
        }

        // Heroes
        for (id, hero) in registry.loadedPacks.values.flatMap({ $0.heroes }) {
            XCTAssertFalse(id.isEmpty, "Hero definitionId must not be empty")
            XCTAssertEqual(id, hero.id, "Hero key must match id")
        }

        // Enemies
        for (id, enemy) in registry.loadedPacks.values.flatMap({ $0.enemies }) {
            XCTAssertFalse(id.isEmpty, "Enemy definitionId must not be empty")
            XCTAssertEqual(id, enemy.id, "Enemy key must match id")
        }

        // Cards
        for card in registry.getAllCards() {
            XCTAssertFalse(card.id.isEmpty, "Card definitionId must not be empty")
        }
    }

    /// Gate test: No UUID fallback in save serialization (Audit A1)
    /// Requirement: "Полностью удалить fallback uuidString из сейвов"
    func testNoUuidFallbackInSave() throws {
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()
            .deletingLastPathComponent()
            .deletingLastPathComponent()

        let saveFile = projectRoot.appendingPathComponent(SourcePathResolver.engineBase + "/Core/EngineSave.swift")
        guard FileManager.default.fileExists(atPath: saveFile.path) else {
            XCTFail("GATE TEST FAILURE: EngineSave.swift not found")
            return
        }

        let content = try String(contentsOf: saveFile, encoding: .utf8)

        // No UUID fallback patterns allowed
        let forbiddenPatterns = [
            "?? region.id.uuidString",
            "?? anchor.id.uuidString",
            "?? quest.id.uuidString",
            ".uuidString // fallback"
        ]

        var violations: [String] = []
        let lines = content.components(separatedBy: .newlines)

        for (index, line) in lines.enumerated() {
            for pattern in forbiddenPatterns {
                if line.contains(pattern) {
                    violations.append("Line \(index + 1): \(line.trimmingCharacters(in: .whitespaces))")
                }
            }
        }

        if !violations.isEmpty {
            XCTFail("""
                Found UUID fallback patterns in EngineSave.swift (Audit A1 violation):
                \(violations.joined(separator: "\n"))

                definitionId must be required, no UUID fallback allowed.
                """)
        }
    }

    // MARK: - A2: RNG State Persistence Gate Tests

    /// Gate test: RNG state is saved and restored (Audit A2)
    /// Requirement: "Сейв обязан хранить RNG state для детерминизма после загрузки"
    func testSaveLoadRestoresRngState() throws {
        // Set a known RNG state
        let testSeed: UInt64 = 12345
        WorldRNG.shared.setSeed(testSeed)

        // Advance RNG a few times
        _ = WorldRNG.shared.next()
        _ = WorldRNG.shared.next()
        _ = WorldRNG.shared.next()

        let stateBeforeSave = WorldRNG.shared.currentState()

        // Generate some random values to verify
        let value1 = WorldRNG.shared.next()
        let value2 = WorldRNG.shared.next()

        // Restore state to before we generated values
        WorldRNG.shared.restoreState(stateBeforeSave)

        // Verify same values are generated
        let restored1 = WorldRNG.shared.next()
        let restored2 = WorldRNG.shared.next()

        XCTAssertEqual(value1, restored1, "RNG should produce same value after state restore")
        XCTAssertEqual(value2, restored2, "RNG should produce same sequence after state restore")
    }

    /// Gate test: EngineSave includes rngState field (Audit A2)
    func testEngineSaveHasRngStateField() throws {
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()
            .deletingLastPathComponent()
            .deletingLastPathComponent()

        let saveFile = projectRoot.appendingPathComponent(SourcePathResolver.engineBase + "/Core/EngineSave.swift")
        guard FileManager.default.fileExists(atPath: saveFile.path) else {
            XCTFail("GATE TEST FAILURE: EngineSave.swift not found")
            return
        }

        let content = try String(contentsOf: saveFile, encoding: .utf8)

        // EngineSave must have rngState field
        XCTAssertTrue(
            content.contains("public let rngState: UInt64"),
            "EngineSave must have rngState field for deterministic save/load (Audit 1.5)"
        )
    }

    /// Gate test: createSave saves RNG state (Audit A2)
    func testCreateSaveSavesRngState() throws {
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()
            .deletingLastPathComponent()
            .deletingLastPathComponent()

        let engineFile = projectRoot.appendingPathComponent(SourcePathResolver.engineBase + "/Core/TwilightGameEngine.swift")
        guard FileManager.default.fileExists(atPath: engineFile.path) else {
            XCTFail("GATE TEST FAILURE: TwilightGameEngine.swift not found")
            return
        }

        let content = try String(contentsOf: engineFile, encoding: .utf8)

        // createSave must include RNG state
        XCTAssertTrue(
            content.contains("rngState: WorldRNG.shared.currentState()"),
            "createSave must save WorldRNG.shared.currentState() (Audit A2)"
        )

        // Must not have "rngSeed: nil" pattern anymore
        XCTAssertFalse(
            content.contains("rngSeed: nil"),
            "createSave must not set rngSeed to nil (Audit A2)"
        )
    }

    // MARK: - Audit 4.2: Pack Compiler Round-Trip

    /// Gate test: .pack load → re-write → re-load round-trip (Audit 4.2)
    func testPackCompilerRoundTrip() throws {
        // Load the compiled .pack via registry (already loaded)
        let registry = ContentRegistry.shared
        XCTAssertFalse(registry.loadedPacks.isEmpty, "Packs must be loaded")

        guard let pack = registry.loadedPacks.values.first else {
            XCTFail("GATE TEST FAILURE: No loaded packs available")
            return
        }

        let originalRegionCount = pack.regions.count
        let originalEventCount = pack.events.count
        let packId = pack.manifest.packId

        // Write to temp .pack file
        let tempDir = FileManager.default.temporaryDirectory
            .appendingPathComponent("pack_roundtrip_\(ProcessInfo.processInfo.globallyUniqueString)")
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        defer { try? FileManager.default.removeItem(at: tempDir) }

        let packFile = tempDir.appendingPathComponent("roundtrip.pack")
        try BinaryPackWriter.compile(pack, to: packFile)

        // Verify .pack file exists and is non-empty
        let attrs = try FileManager.default.attributesOfItem(atPath: packFile.path)
        let fileSize = attrs[.size] as? Int64 ?? 0
        XCTAssertGreaterThan(fileSize, 0, ".pack file must not be empty")

        // Re-load .pack
        let reloaded = try BinaryPackReader.loadContent(from: packFile)

        // Validate round-trip: content is intact
        XCTAssertEqual(reloaded.manifest.packId, packId, "Pack ID must survive round-trip")
        XCTAssertEqual(reloaded.regions.count, originalRegionCount, "Region count must survive round-trip")
        XCTAssertEqual(reloaded.events.count, originalEventCount, "Event count must survive round-trip")
    }

    // MARK: - F1: No Legacy Initialization in Views

    /// Gate test: Views must not contain legacy initialization patterns (Audit F1)
    /// Requirement: "В WorldMapView отсутствуют legacy init/ветки/комментарии"
    ///
    /// Legacy patterns to detect:
    /// - "legacy init" / "legacy initialization" comments
    /// - "shared between legacy" comments
    /// - Legacy adapter references
    ///
    /// Positive patterns to allow:
    /// - "no legacy sync needed" (indicates legacy was removed)
    func testNoLegacyInitializationInViews() throws {
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // Engine
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        let viewsDir = projectRoot.appendingPathComponent("Views")

        guard FileManager.default.fileExists(atPath: viewsDir.path) else {
            XCTFail("GATE TEST FAILURE: Views directory not found")
            return
        }

        // Legacy patterns that indicate old architecture (should be removed)
        let forbiddenPatterns = [
            "legacy init",
            "legacy initialization",
            "shared between legacy",
            "LegacyAdapter",
            "legacyInit",
            "connectToLegacy"
        ]

        // Positive patterns that are allowed (indicate legacy was removed)
        let allowedPatterns = [
            "no legacy sync needed",
            "no legacy needed",
            "legacy removed"
        ]

        var violations: [(file: String, line: Int, content: String, pattern: String)] = []
        let swiftFiles = findSwiftFiles(in: viewsDir)

        for fileURL in swiftFiles {
            let content = try String(contentsOf: fileURL, encoding: .utf8)
            let lines = content.components(separatedBy: .newlines)
            let fileName = fileURL.lastPathComponent

            for (index, line) in lines.enumerated() {
                let lowerLine = line.lowercased()
                let lineNumber = index + 1

                // Check each forbidden pattern
                for pattern in forbiddenPatterns {
                    if lowerLine.contains(pattern.lowercased()) {
                        // Check if this line also contains an allowed pattern
                        let hasAllowedPattern = allowedPatterns.contains { allowed in
                            lowerLine.contains(allowed.lowercased())
                        }

                        if !hasAllowedPattern {
                            violations.append((
                                file: fileName,
                                line: lineNumber,
                                content: line.trimmingCharacters(in: .whitespaces),
                                pattern: pattern
                            ))
                        }
                    }
                }
            }
        }

        if !violations.isEmpty {
            let message = violations.map { "\($0.file):\($0.line): \($0.content) [pattern: \($0.pattern)]" }
                .joined(separator: "\n")
            XCTFail("""
                GATE TEST FAILURE: Legacy initialization patterns found in Views/ (Audit F1)

                Views should use Engine-First architecture only.
                Remove legacy initialization, adapters, and related comments.

                Violations:
                \(message)
                """)
        }
    }

    /// Audit 2.1 alias: exact name from acceptance criteria
    func testNoLegacyInitializationCommentsInWorldMapView() throws {
        try testNoLegacyInitializationInViews()
    }

    // MARK: - F2: AssetRegistry Safety (No Direct UIImage)

    /// Gate test: Views and ViewModels must not use UIImage(named:) directly (Audit F2)
    /// Requirement: "Запрещены прямые UIImage(named:) в UI и VM — только через AssetRegistry"
    ///
    /// Direct UIImage(named:) bypasses the fallback system and can show:
    /// - Pink squares (missing image)
    /// - Empty images
    /// - Nil crashes
    ///
    /// All image loading must go through AssetRegistry which provides SF Symbol fallback.
    /// Audit 2.2 alias: exact name from acceptance criteria
    func testNoDirectImageNamedInViews() throws {
        try testNoDirectUIImageNamedInViewsAndViewModels()
    }

    func testNoDirectUIImageNamedInViewsAndViewModels() throws {
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // Engine
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        // Directories to scan
        let dirsToScan = ["Views", "ViewModels"]

        // Forbidden patterns (direct UIImage/NSImage/SwiftUI Image loading)
        let forbiddenPatterns = [
            "UIImage(named:",
            "NSImage(named:",
            "Image(uiImage: UIImage(named:",
            "Image(nsImage: NSImage(named:"
        ]

        // Forbidden SwiftUI pattern: Image("...") but NOT Image(systemName:
        let swiftUIImagePattern = "Image(\""

        // Allowed files (AssetRegistry itself needs to use UIImage)
        let allowedFiles = [
            "AssetRegistry.swift",
            "AssetValidator.swift"
        ]

        var violations: [(file: String, line: Int, content: String)] = []

        for dirName in dirsToScan {
            let dirURL = projectRoot.appendingPathComponent(dirName)

            guard FileManager.default.fileExists(atPath: dirURL.path) else {
                continue
            }

            let swiftFiles = findSwiftFiles(in: dirURL)

            for fileURL in swiftFiles {
                let fileName = fileURL.lastPathComponent

                // Skip allowed files
                if allowedFiles.contains(fileName) {
                    continue
                }

                let content = try String(contentsOf: fileURL, encoding: .utf8)
                let lines = content.components(separatedBy: .newlines)

                for (index, line) in lines.enumerated() {
                    let trimmedLine = line.trimmingCharacters(in: .whitespaces)
                    let lineNumber = index + 1

                    // Skip comments
                    if trimmedLine.hasPrefix("//") || trimmedLine.hasPrefix("/*") || trimmedLine.hasPrefix("*") {
                        continue
                    }

                    // Check for forbidden patterns
                    for pattern in forbiddenPatterns {
                        if line.contains(pattern) {
                            violations.append((
                                file: fileName,
                                line: lineNumber,
                                content: trimmedLine
                            ))
                        }
                    }

                    // Check for SwiftUI Image("...") — but not Image(systemName:
                    if line.contains(swiftUIImagePattern) && !line.contains("Image(systemName:") {
                        violations.append((
                            file: fileName,
                            line: lineNumber,
                            content: trimmedLine
                        ))
                    }
                }
            }
        }

        if !violations.isEmpty {
            let message = violations.map { "\($0.file):\($0.line): \($0.content)" }
                .joined(separator: "\n")
            XCTFail("""
                GATE TEST FAILURE: Direct Image(named:)/UIImage(named:) found in Views/ViewModels (Audit 2.2)

                Use AssetRegistry instead for automatic fallback support:
                - AssetRegistry.image(for: .region("forest"))
                - AssetRegistry.heroPortrait("warrior")
                - AssetRegistry.cardArt("fireball")

                Violations:
                \(message)
                """)
        }
    }

    // MARK: - B1.2: Static Scan — No Game-Specific IDs in Engine Source

    /// Gate test: Engine source must not contain hardcoded game-specific region/entity IDs (Audit 1.2)
    /// Requirement: "Engine не должен содержать game-specific IDs/словари конкретной игры"
    func testEngineSourceContainsNoGameSpecificIds() throws {
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // GateTests
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        let engineBase = projectRoot.appendingPathComponent(SourcePathResolver.engineBase)

        // Build forbidden literals dynamically from loaded content packs.
        // Any content-defined ID (region, event, quest, hero, enemy) should NOT
        // appear as a string literal in Engine source code.
        TestContentLoader.loadContentPacksIfNeeded()
        var contentIds: Set<String> = []
        for pack in ContentRegistry.shared.loadedPacks.values {
            contentIds.formUnion(pack.regions.keys)
            contentIds.formUnion(pack.events.keys)
            contentIds.formUnion(pack.quests.keys)
            contentIds.formUnion(pack.heroes.keys)
            contentIds.formUnion(pack.enemies.keys)
        }

        // Exclude engine-level enum rawValues that coincide with content IDs
        // (e.g., "breach" is both a region ID and a RegionState enum value)
        var engineTerms: Set<String> = []
        // RegionState rawValues
        for state in RegionState.allCases { engineTerms.insert(state.rawValue) }
        // RegionStateType rawValues
        for state in RegionStateType.allCases { engineTerms.insert(state.rawValue) }
        // Generic terms used by engine code (defaults, error messages)
        engineTerms.insert("unknown")
        engineTerms.insert("test")
        engineTerms.insert("rest")
        contentIds.subtract(engineTerms)

        // Format as quoted string literals for source scanning
        let forbiddenLiterals = contentIds.map { "\"\($0)\"" }

        // Allowed contexts: files that define type enums with rawValue strings
        let allowedFiles = [
            "ExplorationModels.swift"  // RegionType enum rawValues
        ]

        var violations: [String] = []

        // Scan all Swift files recursively under engine source (no hardcoded subdirectory list)
        let swiftFiles = findSwiftFiles(in: engineBase)

        for fileURL in swiftFiles {
            let fileName = fileURL.lastPathComponent
            if allowedFiles.contains(fileName) { continue }

            let content = try String(contentsOf: fileURL, encoding: .utf8)
            let lines = content.components(separatedBy: .newlines)

            for (index, line) in lines.enumerated() {
                let trimmed = line.trimmingCharacters(in: .whitespaces)

                // Skip comments
                if trimmed.hasPrefix("//") || trimmed.hasPrefix("/*") || trimmed.hasPrefix("*") {
                    continue
                }

                for literal in forbiddenLiterals {
                    if line.contains(literal) {
                        violations.append("  \(fileName):\(index + 1): \(trimmed) [literal: \(literal)]")
                    }
                }
            }
        }

        if !violations.isEmpty {
            XCTFail("""
                GATE TEST FAILURE: Game-specific IDs found in Engine source (Audit 1.2)

                Engine must not contain hardcoded game-specific strings.
                All IDs must come from pack manifests/definitions.

                Violations:
                \(violations.joined(separator: "\n"))
                """)
        }
    }

    // MARK: - C1: No XCTSkip in ANY Tests

    /// Gate test: ALL tests must not use XCTSkip (Audit C1 / v2.1)
    /// Requirement: "Gate tests должны падать, а не скипаться"
    /// Scope expanded to ALL test directories (v2.1 audit requirement)
    ///
    /// If a test can't verify something, it must XCTFail, not XCTSkip.
    /// XCTSkip creates "false green" - CI passes but nothing was verified.
    func testNoXCTSkipInAnyTests() throws {
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // GateTests
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        // Scan ALL test directories (v2.1: expanded from GateTests only)
        let testDirs = [
            projectRoot.appendingPathComponent("CardSampleGameTests"),
            projectRoot.appendingPathComponent("Packages/TwilightEngine/Tests/TwilightEngineTests") // Test dir, not engine source
        ]

        var violations: [(file: String, line: Int, content: String)] = []

        for testDir in testDirs {
            guard FileManager.default.fileExists(atPath: testDir.path) else { continue }

            let fileManager = FileManager.default
            guard let enumerator = fileManager.enumerator(
                at: testDir,
                includingPropertiesForKeys: [.isRegularFileKey],
                options: [.skipsHiddenFiles]
            ) else { continue }

            for case let fileURL as URL in enumerator {
                guard fileURL.pathExtension == "swift" else { continue }

                let content = try String(contentsOf: fileURL, encoding: .utf8)
                let lines = content.components(separatedBy: .newlines)

                for (index, line) in lines.enumerated() {
                    let trimmed = line.trimmingCharacters(in: .whitespaces)

                    // Skip comments
                    if trimmed.hasPrefix("//") || trimmed.hasPrefix("/*") || trimmed.hasPrefix("*") {
                        continue
                    }

                    // Skip string literals containing "XCTSkip" (e.g. in this very test's detection logic)
                    if trimmed.contains("\"XCTSkip") || trimmed.contains("XCTSkip\"") {
                        continue
                    }

                    // Match actual XCTSkip/XCTSkipIf calls
                    if line.contains("XCTSkip(") || line.contains("XCTSkipIf(") || line.contains("XCTSkipUnless(") {
                        let fileName = fileURL.lastPathComponent
                        violations.append((file: fileName, line: index + 1, content: trimmed))
                    }
                }
            }
        }

        if !violations.isEmpty {
            let message = violations.map { "\($0.file):\($0.line): \($0.content)" }.joined(separator: "\n")
            XCTFail("""
                GATE TEST FAILURE: XCTSkip found in tests (Audit C1 v2.1)

                ALL tests must use XCTFail, not XCTSkip. XCTSkip creates "false green" CI results.

                Violations:
                \(message)

                Fix: Replace XCTSkip/XCTSkipIf with XCTFail and return.
                """)
        }
    }
}


// ==========================================
// FILE: CardSampleGameTests/GateTests/CodeHygieneTests.swift
// ==========================================

import XCTest
@testable import CardSampleGame

/// Audit tests to ensure Code Hygiene compliance (Epic 10)
/// These tests fail if:
/// - Public API methods lack `///` doc comments (10.1)
/// - Files contain too many types or exceed line limits (10.2)
final class CodeHygieneTests: XCTestCase {

    // MARK: - Configuration

    /// Maximum lines per file before warning (for NEW files)
    /// Legacy files are grandfathered at their current size
    private let maxLinesPerFile = 600

    /// Maximum public types per file (for NEW files)
    /// Related small types (enums, helper structs) can stay together
    private let maxTypesPerFile = 5

    /// Files that are exempt from limits (legacy, grandfathered)
    /// These files existed before Epic 10 enforcement
    /// New files MUST follow the limits
    private let legacyFiles: Set<String> = [
        // Large files (>600 lines)
        "ExplorationModels.swift",      // 872 lines - exploration domain models
        "TwilightGameEngine.swift",     // 2247 lines - main engine
        "ContentRegistry.swift",        // 844 lines - registry
        "JSONContentProvider.swift",    // 969 lines - JSON loading
        "PackValidator.swift",          // 699 lines - validation
        // Files with many related types (>5 types)
        "EngineProtocols.swift",        // 30+ protocols - all engine contracts
        "CodeContentProvider.swift",    // JSON loading types
        "EventDefinition.swift",        // Event system types
        "HeroAbility.swift",            // Ability system types
        "PackTypes.swift",              // Pack-related types
        "BalanceConfiguration.swift",   // Balance config types (intentionally grouped)
        "CardDefinition.swift",         // Card system types
        "CardType.swift",               // Card enums
        "ContentManager.swift",         // Content management types (cohesive hot-reload API)
        "GameDefinition.swift",         // Game definition types
        "QuestDefinition.swift",        // Quest system types
        "AbilityRegistry.swift",        // Ability loading types
        "HeroRegistry.swift",           // Hero loading types
        "HeroDefinition.swift",         // Hero system types
        "CardRegistry.swift",           // Card loading types
        "EngineSave.swift",             // Save system types
        "TimeEngine.swift",             // Time system types
        "TwilightGameAction.swift",     // Action types
        "PressureEngine.swift",         // Pressure system types
        "ContentProvider.swift",        // Provider types
        "MiniGameChallengeDefinition.swift", // MiniGame types
        "EnemyDefinition.swift",        // Enemy types
        "EngineTypes.swift",            // Runtime types
    ]

    /// Directories to audit in TwilightEngine
    private let engineDirectories = [
        "Cards",
        "ContentPacks",
        "Heroes",
        "Core",
        "Data",
        "Models",
        "Runtime"
    ]

    /// Critical public API files that MUST have doc comments on public methods
    /// These are the main entry points for engine consumers
    private let criticalAPIFiles = [
        "CardRegistry.swift",
        "HeroRegistry.swift",
        "ContentRegistry.swift",
        "PackLoader.swift",
        "PackManifest.swift"
    ]

    /// Methods in critical API files that are allowed without docs (internal helpers)
    private let exemptMethods: Set<String> = [
        "loadHeroes()",     // Protocol implementation in data sources
        "loadCards()",      // Protocol implementation in data sources
        "toStandard()",     // Conversion helper
        "toHeroStats()",    // Conversion helper
    ]

    // MARK: - Path Resolution

    private var engineRoot: URL? {
        guard let root = projectRoot else { return nil }
        return root
            .appendingPathComponent("Packages")
            .appendingPathComponent("TwilightEngine")
            .appendingPathComponent("Sources")
            .appendingPathComponent("TwilightEngine")
    }

    private var projectRoot: URL? {
        // Try SRCROOT from scheme environment
        if let srcRoot = ProcessInfo.processInfo.environment["SRCROOT"] {
            return URL(fileURLWithPath: srcRoot)
        }

        // Fallback: Navigate up from test file location
        let thisFile = #file
        var url = URL(fileURLWithPath: thisFile)
        // Go up: Engine -> CardSampleGameTests -> Project Root
        for _ in 0..<3 {
            url = url.deletingLastPathComponent()
        }

        // Verify we found the right directory
        let packagesPath = url.appendingPathComponent("Packages")
        if FileManager.default.fileExists(atPath: packagesPath.path) {
            return url
        }

        return nil
    }

    // MARK: - 10.1 Documentation Tests

    func testPublicMethodsHaveDocComments() throws {
        guard let engine = engineRoot else {
            XCTFail("GATE TEST FAILURE: Could not determine engine root path"); return
        }

        var violations: [(file: String, method: String)] = []

        for apiFile in criticalAPIFiles {
            let filePath = findFile(named: apiFile, in: engine)
            guard let path = filePath else {
                XCTFail("Critical API file not found: \(apiFile)")
                continue
            }

            let content = try String(contentsOfFile: path, encoding: .utf8)
            let undocumentedMethods = findUndocumentedPublicMethods(in: content)

            for method in undocumentedMethods {
                // Skip exempt methods (internal helpers, protocol implementations)
                if exemptMethods.contains(method) {
                    continue
                }
                violations.append((apiFile, method))
            }
        }

        if !violations.isEmpty {
            let message = violations.map { "  \($0.file): \($0.method)" }.joined(separator: "\n")
            XCTFail("""
                Found \(violations.count) public methods without /// doc comments:
                \(message)

                Add documentation like:
                /// Brief description of what method does.
                /// - Parameter name: Description of parameter.
                /// - Returns: Description of return value.
                """)
        }
    }

    func testPublicPropertiesHaveDocComments() throws {
        guard let engine = engineRoot else {
            XCTFail("GATE TEST FAILURE: Could not determine engine root path"); return
        }

        var violations: [(file: String, property: String)] = []

        // Only check CardRegistry and HeroRegistry for now
        // ContentRegistry/PackLoader/PackManifest have many internal properties
        let strictPropertyFiles = ["CardRegistry.swift", "HeroRegistry.swift"]

        for apiFile in strictPropertyFiles {
            let filePath = findFile(named: apiFile, in: engine)
            guard let path = filePath else { continue }

            let content = try String(contentsOfFile: path, encoding: .utf8)
            let undocumentedProps = findUndocumentedPublicProperties(in: content)

            for prop in undocumentedProps {
                // Skip common property names that are self-documenting
                if ["id", "name", "shared", "fileURL"].contains(prop) {
                    continue
                }
                violations.append((apiFile, prop))
            }
        }

        if !violations.isEmpty {
            let message = violations.map { "  \($0.file): \($0.property)" }.joined(separator: "\n")
            XCTFail("""
                Found \(violations.count) public properties without /// doc comments:
                \(message)

                Add documentation like:
                /// Brief description of property.
                public let/var propertyName: Type
                """)
        }
    }

    // MARK: - 10.2 File Organization Tests

    func testFilesDoNotExceedLineLimit() throws {
        guard let engine = engineRoot else {
            XCTFail("GATE TEST FAILURE: Could not determine engine root path"); return
        }

        var violations: [(file: String, lines: Int)] = []

        for dir in engineDirectories {
            let dirPath = engine.appendingPathComponent(dir)
            let files = findSwiftFiles(in: dirPath)

            for filePath in files {
                let fileName = URL(fileURLWithPath: filePath).lastPathComponent

                // Skip legacy files (grandfathered)
                if legacyFiles.contains(fileName) {
                    continue
                }

                let content = try String(contentsOfFile: filePath, encoding: .utf8)
                let lineCount = content.components(separatedBy: .newlines).count

                if lineCount > maxLinesPerFile {
                    violations.append((fileName, lineCount))
                }
            }
        }

        if !violations.isEmpty {
            let message = violations.map { "  \($0.file): \($0.lines) lines (max \(maxLinesPerFile))" }.joined(separator: "\n")
            XCTFail("""
                Found \(violations.count) NEW files exceeding line limit:
                \(message)

                Consider splitting into smaller files:
                - Extract related types into separate files
                - Move extensions to Type+Extension.swift files
                - Group by functionality, not just proximity

                If this is intentional, add the file to legacyFiles in CodeHygieneTests.swift
                """)
        }
    }

    func testFilesDoNotHaveTooManyTypes() throws {
        guard let engine = engineRoot else {
            XCTFail("GATE TEST FAILURE: Could not determine engine root path"); return
        }

        var violations: [(file: String, types: [String])] = []

        for dir in engineDirectories {
            let dirPath = engine.appendingPathComponent(dir)
            let files = findSwiftFiles(in: dirPath)

            for filePath in files {
                let fileName = URL(fileURLWithPath: filePath).lastPathComponent

                // Skip legacy files (grandfathered)
                if legacyFiles.contains(fileName) {
                    continue
                }

                let content = try String(contentsOfFile: filePath, encoding: .utf8)
                let publicTypes = findPublicTypeDeclarations(in: content)

                if publicTypes.count > maxTypesPerFile {
                    violations.append((fileName, publicTypes))
                }
            }
        }

        if !violations.isEmpty {
            let message = violations.map { file, types in
                "  \(file): \(types.count) types [\(types.prefix(5).joined(separator: ", "))\(types.count > 5 ? "..." : "")]"
            }.joined(separator: "\n")
            XCTFail("""
                Found \(violations.count) NEW files with too many public types (max \(maxTypesPerFile)):
                \(message)

                Follow "1 file = 1 main type" principle:
                - Primary type: MyType.swift
                - Extensions: MyType+Feature.swift
                - Related small types can stay together if cohesive

                If this is intentional, add the file to legacyFiles in CodeHygieneTests.swift
                """)
        }
    }

    // MARK: - Helpers

    private func findFile(named name: String, in directory: URL) -> String? {
        guard let enumerator = FileManager.default.enumerator(
            at: directory,
            includingPropertiesForKeys: [.isRegularFileKey],
            options: [.skipsHiddenFiles]
        ) else { return nil }

        for case let fileURL as URL in enumerator {
            if fileURL.lastPathComponent == name {
                return fileURL.path
            }
        }
        return nil
    }

    private func findSwiftFiles(in directory: URL) -> [String] {
        var files: [String] = []

        guard let enumerator = FileManager.default.enumerator(
            at: directory,
            includingPropertiesForKeys: [.isRegularFileKey],
            options: [.skipsHiddenFiles]
        ) else { return files }

        for case let fileURL as URL in enumerator {
            if fileURL.pathExtension == "swift" {
                files.append(fileURL.path)
            }
        }

        return files
    }

    /// Find public methods without preceding /// doc comment
    private func findUndocumentedPublicMethods(in content: String) -> [String] {
        var undocumented: [String] = []
        let lines = content.components(separatedBy: .newlines)

        // Pattern for public func/method declarations
        let methodPattern = #"^\s*public\s+(static\s+)?func\s+(\w+)"#
        let methodRegex = try? NSRegularExpression(pattern: methodPattern)

        // Attributes that can appear between doc comment and declaration
        let attributePattern = #"^\s*@\w+"#

        for (index, line) in lines.enumerated() {
            guard let regex = methodRegex,
                  let match = regex.firstMatch(in: line, range: NSRange(line.startIndex..., in: line)) else {
                continue
            }

            // Extract method name
            if let nameRange = Range(match.range(at: 2), in: line) {
                let methodName = String(line[nameRange])

                // Check if previous non-empty, non-attribute line is a doc comment
                var prevIndex = index - 1
                var foundDocComment = false

                while prevIndex >= 0 {
                    let prevLine = lines[prevIndex].trimmingCharacters(in: .whitespaces)
                    if prevLine.isEmpty {
                        prevIndex -= 1
                        continue
                    }
                    // Skip Swift attributes (@discardableResult, @MainActor, etc.)
                    if prevLine.range(of: attributePattern, options: .regularExpression) != nil {
                        prevIndex -= 1
                        continue
                    }
                    // Check for doc comment
                    if prevLine.hasPrefix("///") || prevLine.hasPrefix("*/") {
                        foundDocComment = true
                    }
                    break
                }

                if !foundDocComment {
                    undocumented.append(methodName + "()")
                }
            }
        }

        return undocumented
    }

    /// Find public properties without preceding /// doc comment
    private func findUndocumentedPublicProperties(in content: String) -> [String] {
        var undocumented: [String] = []
        let lines = content.components(separatedBy: .newlines)

        // Pattern for public let/var declarations (not in function bodies)
        let propPattern = #"^\s*public\s+(static\s+)?(let|var)\s+(\w+)"#
        let propRegex = try? NSRegularExpression(pattern: propPattern)

        // Attributes that can appear between doc comment and declaration
        let attributePattern = #"^\s*@\w+"#

        for (index, line) in lines.enumerated() {
            guard let regex = propRegex,
                  let match = regex.firstMatch(in: line, range: NSRange(line.startIndex..., in: line)) else {
                continue
            }

            // Skip computed properties (they have doc comments on the var line usually)
            if line.contains("{") && line.contains("return") {
                continue
            }

            // Extract property name
            if let nameRange = Range(match.range(at: 3), in: line) {
                let propName = String(line[nameRange])

                // Check if previous non-empty, non-attribute line is a doc comment
                var prevIndex = index - 1
                var foundDocComment = false

                while prevIndex >= 0 {
                    let prevLine = lines[prevIndex].trimmingCharacters(in: .whitespaces)
                    if prevLine.isEmpty {
                        prevIndex -= 1
                        continue
                    }
                    // Skip Swift attributes
                    if prevLine.range(of: attributePattern, options: .regularExpression) != nil {
                        prevIndex -= 1
                        continue
                    }
                    // Check for doc comment
                    if prevLine.hasPrefix("///") || prevLine.hasPrefix("*/") {
                        foundDocComment = true
                    }
                    break
                }

                if !foundDocComment {
                    undocumented.append(propName)
                }
            }
        }

        return undocumented
    }

    /// Find public type declarations (class, struct, enum, protocol)
    private func findPublicTypeDeclarations(in content: String) -> [String] {
        var types: [String] = []
        let lines = content.components(separatedBy: .newlines)

        // Pattern for public type declarations
        let typePattern = #"^\s*public\s+(final\s+)?(class|struct|enum|protocol|actor)\s+(\w+)"#
        let typeRegex = try? NSRegularExpression(pattern: typePattern)

        for line in lines {
            guard let regex = typeRegex,
                  let match = regex.firstMatch(in: line, range: NSRange(line.startIndex..., in: line)) else {
                continue
            }

            if let nameRange = Range(match.range(at: 3), in: line) {
                types.append(String(line[nameRange]))
            }
        }

        return types
    }
}


// ==========================================
// FILE: CardSampleGameTests/GateTests/ConditionValidatorTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Tests for condition validation (Audit G1 requirement).
/// Ensures all conditions in packs use known, valid types.
///
/// Architecture note: This engine uses typed enums for conditions,
/// not string expressions. This provides compile-time safety against typos
/// like "WorldResonanse" - they simply won't compile or parse.
final class ConditionValidatorTests: XCTestCase {

    // MARK: - Whitelist Tests

    func testValidAbilityConditionTypesExist() throws {
        // Verify the whitelist is not empty
        let types = ConditionValidator.allValidConditionTypes()
        XCTAssertFalse(types.isEmpty, "Should have valid condition types")

        // Verify known conditions are in the list
        XCTAssertTrue(types.contains("hpBelowPercent"), "hpBelowPercent should be valid")
        XCTAssertTrue(types.contains("targetFullHP"), "targetFullHP should be valid")
        XCTAssertTrue(types.contains("firstAttack"), "firstAttack should be valid")
    }

    func testValidAbilityTriggersExist() throws {
        let triggers = ConditionValidator.allValidTriggers()
        XCTAssertFalse(triggers.isEmpty, "Should have valid triggers")

        // Verify known triggers
        XCTAssertTrue(triggers.contains("onAttack"), "onAttack should be valid")
        XCTAssertTrue(triggers.contains("turnStart"), "turnStart should be valid")
        XCTAssertTrue(triggers.contains("manual"), "manual should be valid")
    }

    func testValidAbilityEffectTypesExist() throws {
        let effects = ConditionValidator.allValidEffectTypes()
        XCTAssertFalse(effects.isEmpty, "Should have valid effect types")

        // Verify known effects
        XCTAssertTrue(effects.contains("bonusDamage"), "bonusDamage should be valid")
        XCTAssertTrue(effects.contains("heal"), "heal should be valid")
        XCTAssertTrue(effects.contains("drawCard"), "drawCard should be valid")
    }

    // MARK: - Rejection Tests

    func testRejectsUnknownConditionType() throws {
        // Typos like "WorldResonanse" should be rejected
        XCTAssertFalse(
            ConditionValidator.validateAbilityCondition("WorldResonanse"),
            "Unknown condition 'WorldResonanse' should be rejected"
        )
        XCTAssertFalse(
            ConditionValidator.validateAbilityCondition("hp_below_percent"),
            "Snake_case version should be rejected (we use camelCase)"
        )
        XCTAssertFalse(
            ConditionValidator.validateAbilityCondition(""),
            "Empty string should be rejected"
        )
    }

    func testRejectsUnknownTrigger() throws {
        XCTAssertFalse(
            ConditionValidator.validateAbilityTrigger("onDamageRecieved"), // typo
            "Typo 'onDamageRecieved' should be rejected"
        )
        XCTAssertFalse(
            ConditionValidator.validateAbilityTrigger("on_attack"),
            "Snake_case should be rejected"
        )
    }

    func testRejectsUnknownEffectType() throws {
        XCTAssertFalse(
            ConditionValidator.validateAbilityEffectType("bonusDammage"), // typo
            "Typo 'bonusDammage' should be rejected"
        )
        XCTAssertFalse(
            ConditionValidator.validateAbilityEffectType("bonus_damage"),
            "Snake_case should be rejected"
        )
    }

    // MARK: - Integration Test: All Pack Conditions Valid

    func testAllPackConditionsAreValid() throws {
        // Use shared registry (packs are loaded globally in tests)
        let registry = ContentRegistry.shared

        // Ensure packs are loaded
        guard !registry.loadedPackIds.isEmpty else {
            // Load packs if not already loaded
            guard let storyPackURL = TestContentLoader.storyPackURL,
                  let charPackURL = TestContentLoader.characterPackURL else {
                XCTFail("GATE TEST FAILURE: Could not locate content packs for validation")
                return
            }

            do {
                try registry.loadPack(from: storyPackURL)
                try registry.loadPack(from: charPackURL)
            } catch {
                XCTFail("GATE TEST FAILURE: Failed to load packs: \(error)")
                return
            }
            return try testAllPackConditionsAreValid()
        }

        // Validate all loaded packs
        for (packId, pack) in registry.loadedPacks {
            let result = ConditionValidator.validate(pack: pack)
            if !result.isValid {
                XCTFail("Pack '\(packId)' has invalid conditions:\n\(result.errors.joined(separator: "\n"))")
            }
        }
    }

    // MARK: - Type Safety Tests

    func testConditionsUseTypedEnumsNotStrings() throws {
        // This test documents that our architecture prevents string-based typos
        // by using typed enums that are validated at parse time

        // AbilityConditionType is an enum with CaseIterable
        let allConditionTypes = AbilityConditionType.allCases
        XCTAssertFalse(allConditionTypes.isEmpty, "AbilityConditionType should have cases")

        // Attempting to decode an unknown type would fail JSON parsing
        let invalidJSON = """
        {"type": "WorldResonanse", "value": 50}
        """.data(using: .utf8)!

        // This should fail to decode because "WorldResonanse" is not a valid enum case
        XCTAssertThrowsError(try JSONDecoder().decode(AbilityCondition.self, from: invalidJSON)) { error in
            // Verify it's a decoding error for unknown enum value
            XCTAssertTrue(error is DecodingError, "Should throw DecodingError for unknown enum value")
        }
    }

    func testValidConditionDecodesSuccessfully() throws {
        // Valid condition should decode
        let validJSON = """
        {"type": "hpBelowPercent", "value": 50}
        """.data(using: .utf8)!

        let condition = try JSONDecoder().decode(AbilityCondition.self, from: validJSON)
        XCTAssertEqual(condition.type, .hpBelowPercent)
        XCTAssertEqual(condition.value, 50)
    }

    func testSnakeCaseEnumValueIsRejected() throws {
        // Enum values must use camelCase, not snake_case
        // keyDecodingStrategy only converts dictionary keys, not enum string values
        let snakeCaseJSON = """
        {"type": "hp_below_percent", "value": 50}
        """.data(using: .utf8)!

        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase

        // This should FAIL because "hp_below_percent" is not a valid enum value
        // Our enums use camelCase: "hpBelowPercent"
        XCTAssertThrowsError(try decoder.decode(AbilityCondition.self, from: snakeCaseJSON)) { error in
            XCTAssertTrue(error is DecodingError, "Snake_case enum values should be rejected")
        }
    }
}


// ==========================================
// FILE: CardSampleGameTests/GateTests/ContentValidationTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Content Validation Tests - validates cross-references in JSON content
/// Prevents "silent failures" where typos cause conditions to never match
///
/// **Risk Mitigation:**
/// - Typo in flag name → condition never triggers
/// - Typo in region ID → event never appears in that region
/// - Typo in quest ID → quest progress never registers
/// - Typo in resource ID → requirement check fails silently
final class ContentValidationTests: XCTestCase {

    // MARK: - Test Data

    private var loadedPack: LoadedPack?
    private var allRegionIds: Set<String> = []
    private var allEventIds: Set<String> = []
    private var allQuestIds: Set<String> = []
    private var allCardIds: Set<String> = []
    private var allHeroIds: Set<String> = []
    private var allEnemyIds: Set<String> = []
    private var allAnchorIds: Set<String> = []

    // System flags and known resources are collected dynamically from loaded packs
    // to avoid hardcoding game-specific content in engine-level tests.
    private var systemFlags: Set<String> = []
    private var knownResources: Set<String> = []

    // Known valid region states (engine-level enum values, not game-specific)
    private let knownRegionStates: Set<String> = [
        "stable",
        "borderland",
        "breach",
        "corrupted",
        "lost"
    ]

    // MARK: - Setup

    override func setUpWithError() throws {
        try super.setUpWithError()

        // Load content pack using TestContentLoader
        TestContentLoader.loadContentPacksIfNeeded()

        // Get loaded pack from registry
        guard let packId = ContentRegistry.shared.loadedPackIds.first(where: { $0.contains("twilight") || $0.contains("act") }),
              let pack = ContentRegistry.shared.loadedPacks[packId] else {
            XCTFail("CONTENT VALIDATION FAILURE: TwilightMarchesActI pack not loaded - check TestContentLoader"); return
        }

        self.loadedPack = pack
        collectKnownIds()
    }

    private func collectKnownIds() {
        guard let pack = loadedPack else { return }

        // Regions (dictionary keys are IDs)
        allRegionIds = Set(pack.regions.keys)

        // Events
        allEventIds = Set(pack.events.keys)

        // Quests
        allQuestIds = Set(pack.quests.keys)

        // Cards
        allCardIds = Set(pack.cards.keys)

        // Heroes
        allHeroIds = Set(pack.heroes.keys)

        // Enemies
        allEnemyIds = Set(pack.enemies.keys)

        // Anchors
        allAnchorIds = Set(pack.anchors.keys)

        // Collect all flags that are SET by consequences (these are valid to reference)
        collectKnownFlags(from: pack)

        // Collect known resources from balance config
        collectKnownResources()
    }

    /// Collect all flags that are set/cleared by event choices and quest outcomes.
    /// These flags are valid to reference in conditions — no hardcoded list needed.
    private func collectKnownFlags(from pack: LoadedPack) {
        var flags: Set<String> = []

        for (_, event) in pack.events {
            for choice in event.choices {
                flags.formUnion(choice.consequences.setFlags)
                flags.formUnion(choice.consequences.clearFlags)
            }
        }

        for (_, quest) in pack.quests {
            flags.formUnion(quest.completionRewards.setFlags)
            flags.formUnion(quest.failurePenalties.setFlags)
        }

        systemFlags = flags
    }

    /// Collect known resource keys from balance config and engine conventions.
    private func collectKnownResources() {
        // Engine-level resource keys (used by ResourceBalanceConfig and consequences)
        knownResources = ["health", "faith", "supplies", "gold", "balance"]
        // Extend from balance config if available
        if let config = ContentRegistry.shared.getBalanceConfig() {
            // Balance config confirms these resources exist; no game-specific names needed
            _ = config
        }
    }

    // MARK: - Flag Validation

    func testAllReferencedFlagsAreKnown() throws {
        guard let pack = loadedPack else {
            XCTFail("CONTENT VALIDATION FAILURE: Pack not loaded"); return
        }

        var referencedFlags: Set<String> = []
        var setFlags: Set<String> = []

        // Collect flags from events
        for (_, event) in pack.events {
            // Availability flags
            referencedFlags.formUnion(event.availability.requiredFlags)
            referencedFlags.formUnion(event.availability.forbiddenFlags)

            // Choice flags
            for choice in event.choices {
                if let req = choice.requirements {
                    referencedFlags.formUnion(req.requiredFlags)
                    referencedFlags.formUnion(req.forbiddenFlags)
                }
                setFlags.formUnion(choice.consequences.setFlags)
                setFlags.formUnion(choice.consequences.clearFlags)
            }
        }

        // Collect flags from quests
        for (_, quest) in pack.quests {
            referencedFlags.formUnion(quest.availability.requiredFlags)
            referencedFlags.formUnion(quest.availability.forbiddenFlags)

            setFlags.formUnion(quest.completionRewards.setFlags)
            setFlags.formUnion(quest.failurePenalties.setFlags)

            // Flags in objective completion conditions are set by engine logic
            for objective in quest.objectives {
                if case .flagSet(let flag) = objective.completionCondition {
                    setFlags.insert(flag)
                }
            }
        }

        // All set flags become valid referenced flags
        let allKnownFlags = systemFlags.union(setFlags)

        // Find unknown flags
        let unknownFlags = referencedFlags.subtracting(allKnownFlags)

        if !unknownFlags.isEmpty {
            XCTFail("""
                Found \(unknownFlags.count) unknown flags referenced in conditions:
                \(unknownFlags.sorted().map { "  - \($0)" }.joined(separator: "\n"))

                These flags are checked but never set. Possible causes:
                1. Typo in flag name
                2. Flag is set elsewhere (add to systemFlags in test)
                3. Missing set_flags in consequences
                """)
        }
    }

    // MARK: - Region ID Validation

    func testAllReferencedRegionIdsExist() throws {
        guard let pack = loadedPack else {
            XCTFail("CONTENT VALIDATION FAILURE: Pack not loaded"); return
        }

        var referencedRegionIds: Set<String> = []

        // From event availability
        for (_, event) in pack.events {
            if let regionIds = event.availability.regionIds {
                referencedRegionIds.formUnion(regionIds)
            }
        }

        // From quest availability
        for (_, quest) in pack.quests {
            if let regionIds = quest.availability.regionIds {
                referencedRegionIds.formUnion(regionIds)
            }
        }

        // From region connections (neighborIds)
        for (_, region) in pack.regions {
            referencedRegionIds.formUnion(region.neighborIds)
        }

        // Find unknown regions
        let unknownRegions = referencedRegionIds.subtracting(allRegionIds)

        if !unknownRegions.isEmpty {
            XCTFail("""
                Found \(unknownRegions.count) unknown region IDs:
                \(unknownRegions.sorted().map { "  - \($0)" }.joined(separator: "\n"))

                Known regions: \(allRegionIds.sorted().joined(separator: ", "))
                """)
        }
    }

    // MARK: - Quest ID Validation

    func testAllReferencedQuestIdsExist() throws {
        guard let pack = loadedPack else {
            XCTFail("CONTENT VALIDATION FAILURE: Pack not loaded"); return
        }

        var referencedQuestIds: Set<String> = []

        // From event consequences
        for (_, event) in pack.events {
            for choice in event.choices {
                if let questProgress = choice.consequences.questProgress {
                    referencedQuestIds.insert(questProgress.questId)
                }
            }
        }

        // Find unknown quests
        let unknownQuests = referencedQuestIds.subtracting(allQuestIds)

        if !unknownQuests.isEmpty {
            XCTFail("""
                Found \(unknownQuests.count) unknown quest IDs in event consequences:
                \(unknownQuests.sorted().map { "  - \($0)" }.joined(separator: "\n"))

                Known quests: \(allQuestIds.sorted().joined(separator: ", "))
                """)
        }
    }

    // MARK: - Event ID Validation

    func testAllReferencedEventIdsExist() throws {
        guard let pack = loadedPack else {
            XCTFail("CONTENT VALIDATION FAILURE: Pack not loaded"); return
        }

        var referencedEventIds: Set<String> = []

        // From choice consequences (trigger_event_id)
        for (_, event) in pack.events {
            for choice in event.choices {
                if let triggerId = choice.consequences.triggerEventId {
                    referencedEventIds.insert(triggerId)
                }
            }
        }

        // Find unknown events
        let unknownEvents = referencedEventIds.subtracting(allEventIds)

        if !unknownEvents.isEmpty {
            XCTFail("""
                Found \(unknownEvents.count) unknown event IDs in trigger_event_id:
                \(unknownEvents.sorted().map { "  - \($0)" }.joined(separator: "\n"))

                Known events: \(allEventIds.sorted().joined(separator: ", "))
                """)
        }
    }

    // MARK: - Resource ID Validation

    func testAllReferencedResourceIdsAreKnown() throws {
        guard let pack = loadedPack else {
            XCTFail("CONTENT VALIDATION FAILURE: Pack not loaded"); return
        }

        var referencedResources: Set<String> = []

        // From event choice requirements and consequences
        for (_, event) in pack.events {
            for choice in event.choices {
                if let req = choice.requirements {
                    referencedResources.formUnion(req.minResources.keys)
                }
                referencedResources.formUnion(choice.consequences.resourceChanges.keys)
            }
        }

        // From quest rewards/penalties
        for (_, quest) in pack.quests {
            referencedResources.formUnion(quest.completionRewards.resourceChanges.keys)
            referencedResources.formUnion(quest.failurePenalties.resourceChanges.keys)
        }

        // Find unknown resources
        let unknownResources = referencedResources.subtracting(knownResources)

        if !unknownResources.isEmpty {
            XCTFail("""
                Found \(unknownResources.count) unknown resource IDs:
                \(unknownResources.sorted().map { "  - \($0)" }.joined(separator: "\n"))

                Known resources: \(knownResources.sorted().joined(separator: ", "))
                """)
        }
    }

    // MARK: - Region State Validation

    func testAllReferencedRegionStatesAreKnown() throws {
        guard let pack = loadedPack else {
            XCTFail("CONTENT VALIDATION FAILURE: Pack not loaded"); return
        }

        var referencedStates: Set<String> = []

        // From event availability
        for (_, event) in pack.events {
            if let states = event.availability.regionStates {
                referencedStates.formUnion(states)
            }
        }

        // From quest availability
        for (_, quest) in pack.quests {
            if let states = quest.availability.regionStates {
                referencedStates.formUnion(states)
            }
        }

        // Find unknown states
        let unknownStates = referencedStates.subtracting(knownRegionStates)

        if !unknownStates.isEmpty {
            XCTFail("""
                Found \(unknownStates.count) unknown region states:
                \(unknownStates.sorted().map { "  - \($0)" }.joined(separator: "\n"))

                Known states: \(knownRegionStates.sorted().joined(separator: ", "))
                """)
        }
    }

    // MARK: - Card ID Validation

    func testAllReferencedCardIdsExist() throws {
        guard let pack = loadedPack else {
            XCTFail("CONTENT VALIDATION FAILURE: Pack not loaded"); return
        }

        var referencedCardIds: Set<String> = []

        // From quest rewards
        for (_, quest) in pack.quests {
            referencedCardIds.formUnion(quest.completionRewards.cardIds)
        }

        // From hero starting decks (if heroes are loaded)
        for (_, hero) in pack.heroes {
            referencedCardIds.formUnion(hero.startingDeckCardIDs)
        }

        // Find unknown cards - need to check global CardRegistry too
        let allKnownCards = allCardIds.union(Set(CardRegistry.shared.allCards.map { $0.id }))
        let unknownCards = referencedCardIds.subtracting(allKnownCards)

        if !unknownCards.isEmpty {
            XCTFail("""
                Found \(unknownCards.count) unknown card IDs:
                \(unknownCards.sorted().map { "  - \($0)" }.joined(separator: "\n"))

                Known cards in pack: \(allCardIds.sorted().joined(separator: ", "))
                """)
        }
    }

    // MARK: - Comprehensive Summary

    func testContentIntegrityReport() throws {
        guard let pack = loadedPack else {
            XCTFail("CONTENT VALIDATION FAILURE: Pack not loaded"); return
        }

        print("""

            === Content Integrity Report ===

            Pack: \(pack.manifest.packId) v\(pack.manifest.version)

            Content Counts:
            - Regions: \(pack.regions.count)
            - Events: \(pack.events.count)
            - Quests: \(pack.quests.count)
            - Cards: \(pack.cards.count)
            - Heroes: \(pack.heroes.count)
            - Enemies: \(pack.enemies.count)
            - Anchors: \(pack.anchors.count)

            Region IDs: \(allRegionIds.sorted().joined(separator: ", "))
            Quest IDs: \(allQuestIds.sorted().joined(separator: ", "))

            ================================

            """)

        // This test always passes - it's for diagnostics
        XCTAssertTrue(true)
    }
}


// ==========================================
// FILE: CardSampleGameTests/GateTests/DesignSystemComplianceTests.swift
// ==========================================

import XCTest
@testable import CardSampleGame

/// Audit tests to ensure Design System compliance
/// These tests fail if magic numbers or hardcoded colors are found in View files
/// Reference: AUDIT_ENGINE_FIRST_v1_1.md, Epic 9.1
///
/// All View files are now fully compliant. These tests enforce:
/// - No magic numbers (use Spacing.*, Sizes.*, CornerRadius.*)
/// - No hardcoded colors (use AppColors.*)
/// - No hardcoded opacity (use Opacity.*)
final class DesignSystemComplianceTests: XCTestCase {

    /// Strict compliance mode - fails on any violation
    private let allowLegacyViolations = false

    /// No legacy files - all Views are now compliant
    private let legacyFiles: [String] = []

    // MARK: - View Files to Audit

    /// All View files that must use DesignSystem constants
    private var viewFiles: [String] {
        guard let root = projectRoot else { return [] }
        let viewsDir = root.appendingPathComponent("Views")
        return findSwiftFiles(in: viewsDir)
    }

    private var projectRoot: URL? {
        // Try to find project root via SRCROOT (set in scheme environment)
        if let srcRoot = ProcessInfo.processInfo.environment["SRCROOT"] {
            return URL(fileURLWithPath: srcRoot)
        }

        // Fallback: Navigate up from test file location
        // This file is at CardSampleGameTests/GateTests/DesignSystemComplianceTests.swift
        let thisFile = #file
        var url = URL(fileURLWithPath: thisFile)
        // Go up 3 levels: GateTests -> CardSampleGameTests -> Project Root
        for _ in 0..<3 {
            url = url.deletingLastPathComponent()
        }

        // Verify we found the right directory by checking for Views folder
        let viewsPath = url.appendingPathComponent("Views")
        if FileManager.default.fileExists(atPath: viewsPath.path) {
            return url
        }

        return nil
    }

    // MARK: - Magic Number Patterns

    /// Patterns that indicate hardcoded spacing/padding values
    private let magicNumberPatterns: [(pattern: String, description: String)] = [
        // Padding with raw numbers (but allow Spacing.* references)
        (#"\.padding\(\s*\d+\s*\)"#, "padding with magic number"),
        (#"\.padding\(\.\w+,\s*\d+\s*\)"#, "directional padding with magic number"),
        (#"\.padding\(\.horizontal,\s*\d+\s*\)"#, "horizontal padding with magic number"),
        (#"\.padding\(\.vertical,\s*\d+\s*\)"#, "vertical padding with magic number"),

        // Spacing with raw numbers in stacks (0 is allowed - means no spacing)
        (#"VStack\(spacing:\s*[1-9]\d*\s*\)"#, "VStack spacing with magic number"),
        (#"HStack\(spacing:\s*[1-9]\d*\s*\)"#, "HStack spacing with magic number"),
        (#"LazyVStack\(spacing:\s*[1-9]\d*\s*\)"#, "LazyVStack spacing with magic number"),
        (#"LazyHStack\(spacing:\s*[1-9]\d*\s*\)"#, "LazyHStack spacing with magic number"),

        // Corner radius with raw numbers
        (#"\.cornerRadius\(\s*\d+\s*\)"#, "cornerRadius with magic number"),

        // Frame with raw numbers (except 0 and .infinity)
        (#"\.frame\(width:\s*[1-9]\d*\s*\)"#, "frame width with magic number"),
        (#"\.frame\(height:\s*[1-9]\d*\s*\)"#, "frame height with magic number"),
    ]

    /// Patterns that are allowed (exceptions)
    private let allowedPatterns: [String] = [
        "Spacing\\.", // Spacing.sm, Spacing.md, etc.
        "Sizes\\.",   // Sizes.iconSmall, etc.
        "CornerRadius\\.", // CornerRadius.md, etc.
        "lineWidth:", // lineWidth is ok for strokes
        "size:\\s*\\d+", // font size modifiers (allowed for now)
        "#Preview", // Preview code is exempt
        "PreviewProvider", // Preview code is exempt
    ]

    // MARK: - Hardcoded Color Patterns

    /// Patterns that indicate hardcoded colors instead of AppColors
    private let hardcodedColorPatterns: [(pattern: String, description: String)] = [
        (#"Color\.red(?!\w)"#, "hardcoded Color.red"),
        (#"Color\.blue(?!\w)"#, "hardcoded Color.blue"),
        (#"Color\.green(?!\w)"#, "hardcoded Color.green"),
        (#"Color\.orange(?!\w)"#, "hardcoded Color.orange"),
        (#"Color\.yellow(?!\w)"#, "hardcoded Color.yellow"),
        (#"Color\.purple(?!\w)"#, "hardcoded Color.purple"),
        (#"Color\.gray(?!\w)"#, "hardcoded Color.gray"),
        (#"Color\.pink(?!\w)"#, "hardcoded Color.pink"),
        (#"\.foregroundColor\(\.red\)"#, "foregroundColor(.red)"),
        (#"\.foregroundColor\(\.blue\)"#, "foregroundColor(.blue)"),
        (#"\.foregroundColor\(\.green\)"#, "foregroundColor(.green)"),
        (#"\.foregroundColor\(\.orange\)"#, "foregroundColor(.orange)"),
        (#"\.foregroundColor\(\.yellow\)"#, "foregroundColor(.yellow)"),
        (#"\.foregroundColor\(\.purple\)"#, "foregroundColor(.purple)"),
        (#"\.foregroundColor\(\.gray\)"#, "foregroundColor(.gray)"),
        (#"\.foregroundColor\(\.secondary\)"#, "foregroundColor(.secondary) - use AppColors.muted"),
    ]

    /// Color patterns that are allowed
    private let allowedColorPatterns: [String] = [
        "AppColors\\.",   // AppColors.primary, etc.
        "Color\\.white",  // white is ok (neutral)
        "Color\\.black",  // black is ok (neutral)
        "Color\\.clear",  // clear is ok
        "Color\\.primary", // system primary is ok
        "Color\\.accentColor", // accent is ok
        "Color\\(UIColor\\.", // UIColor wrappers are ok
        "Color\\.indigo", // indigo is ok (no AppColors equivalent yet)
        "Color\\.brown",  // brown is ok (no AppColors equivalent yet)
        "Color\\.teal",   // teal is ok (no AppColors equivalent yet)
        "Color\\.cyan",   // cyan is ok (no AppColors equivalent yet)
        "Color\\.pink",   // pink is ok (no AppColors equivalent yet)
        "#Preview",       // Preview code is exempt
        "PreviewProvider", // Preview code is exempt
        "// DesignSystem-exempt", // Explicit exemption comment
    ]

    // MARK: - Hardcoded Opacity Patterns

    /// Patterns that indicate hardcoded opacity values
    private let hardcodedOpacityPatterns: [(pattern: String, description: String)] = [
        (#"\.opacity\(0\.\d+\)"#, "hardcoded opacity value"),
    ]

    /// Opacity patterns that are allowed
    private let allowedOpacityPatterns: [String] = [
        "Opacity\\.",     // Opacity.medium, etc.
        "#Preview",       // Preview code is exempt
        "PreviewProvider", // Preview code is exempt
        "\\.opacity\\(0\\.15\\)", // 0.15 is acceptable for card backgrounds (close to Opacity.faint)
        "\\.opacity\\(0\\.1\\)",  // 0.1 is acceptable for subtle backgrounds
    ]

    // MARK: - Tests

    func testNoMagicNumbersInViews() throws {
        guard projectRoot != nil else {
            XCTFail("GATE TEST FAILURE: Could not determine project root path"); return
        }
        var violations: [(file: String, line: Int, issue: String)] = []

        for filePath in viewFiles {
            let content = try String(contentsOfFile: filePath, encoding: .utf8)
            let lines = content.components(separatedBy: .newlines)

            for (lineIndex, line) in lines.enumerated() {
                // Skip if line contains allowed pattern
                if allowedPatterns.contains(where: { line.range(of: $0, options: .regularExpression) != nil }) {
                    continue
                }

                // Check for magic number violations
                for (pattern, description) in magicNumberPatterns {
                    if line.range(of: pattern, options: .regularExpression) != nil {
                        let fileName = URL(fileURLWithPath: filePath).lastPathComponent
                        violations.append((fileName, lineIndex + 1, description))
                    }
                }
            }
        }

        // Separate legacy vs new violations
        let newViolations = violations.filter { !legacyFiles.contains($0.file) }
        let legacyViolations = violations.filter { legacyFiles.contains($0.file) }

        // Always fail on new violations
        if !newViolations.isEmpty {
            let message = newViolations.map { "  \($0.file):\($0.line) - \($0.issue)" }.joined(separator: "\n")
            XCTFail("Found \(newViolations.count) magic number violations in migrated files:\n\(message)\n\nUse Spacing.*, Sizes.*, or CornerRadius.* instead.")
        }

        // Warn about legacy violations (or fail if strict mode)
        if !legacyViolations.isEmpty && !allowLegacyViolations {
            let message = legacyViolations.map { "  \($0.file):\($0.line) - \($0.issue)" }.joined(separator: "\n")
            XCTFail("Found \(legacyViolations.count) magic number violations in legacy files:\n\(message)")
        }
    }

    func testNoHardcodedColorsInViews() throws {
        guard projectRoot != nil else {
            XCTFail("GATE TEST FAILURE: Could not determine project root path"); return
        }
        var violations: [(file: String, line: Int, issue: String)] = []

        for filePath in viewFiles {
            let content = try String(contentsOfFile: filePath, encoding: .utf8)
            let lines = content.components(separatedBy: .newlines)

            for (lineIndex, line) in lines.enumerated() {
                // Skip if line contains allowed pattern
                if allowedColorPatterns.contains(where: { line.range(of: $0, options: .regularExpression) != nil }) {
                    continue
                }

                // Check for hardcoded color violations
                for (pattern, description) in hardcodedColorPatterns {
                    if line.range(of: pattern, options: .regularExpression) != nil {
                        let fileName = URL(fileURLWithPath: filePath).lastPathComponent
                        violations.append((fileName, lineIndex + 1, description))
                    }
                }
            }
        }

        // Separate legacy vs new violations
        let newViolations = violations.filter { !legacyFiles.contains($0.file) }
        let legacyViolations = violations.filter { legacyFiles.contains($0.file) }

        // Always fail on new violations
        if !newViolations.isEmpty {
            let message = newViolations.map { "  \($0.file):\($0.line) - \($0.issue)" }.joined(separator: "\n")
            XCTFail("Found \(newViolations.count) hardcoded color violations in migrated files:\n\(message)\n\nUse AppColors.* instead.")
        }

        // Warn about legacy violations (or fail if strict mode)
        if !legacyViolations.isEmpty && !allowLegacyViolations {
            let message = legacyViolations.map { "  \($0.file):\($0.line) - \($0.issue)" }.joined(separator: "\n")
            XCTFail("Found \(legacyViolations.count) hardcoded color violations in legacy files:\n\(message)")
        }
    }

    func testNoHardcodedOpacityInViews() throws {
        guard projectRoot != nil else {
            XCTFail("GATE TEST FAILURE: Could not determine project root path"); return
        }
        var violations: [(file: String, line: Int, issue: String)] = []

        for filePath in viewFiles {
            let content = try String(contentsOfFile: filePath, encoding: .utf8)
            let lines = content.components(separatedBy: .newlines)

            for (lineIndex, line) in lines.enumerated() {
                // Skip if line contains allowed pattern
                if allowedOpacityPatterns.contains(where: { line.range(of: $0, options: .regularExpression) != nil }) {
                    continue
                }

                // Check for hardcoded opacity violations
                for (pattern, description) in hardcodedOpacityPatterns {
                    if line.range(of: pattern, options: .regularExpression) != nil {
                        let fileName = URL(fileURLWithPath: filePath).lastPathComponent
                        violations.append((fileName, lineIndex + 1, description))
                    }
                }
            }
        }

        // Separate legacy vs new violations
        let newViolations = violations.filter { !legacyFiles.contains($0.file) }
        let legacyViolations = violations.filter { legacyFiles.contains($0.file) }

        // Always fail on new violations
        if !newViolations.isEmpty {
            let message = newViolations.map { "  \($0.file):\($0.line) - \($0.issue)" }.joined(separator: "\n")
            XCTFail("Found \(newViolations.count) hardcoded opacity violations in migrated files:\n\(message)\n\nUse Opacity.* instead.")
        }

        // Warn about legacy violations (or fail if strict mode)
        if !legacyViolations.isEmpty && !allowLegacyViolations {
            let message = legacyViolations.map { "  \($0.file):\($0.line) - \($0.issue)" }.joined(separator: "\n")
            XCTFail("Found \(legacyViolations.count) hardcoded opacity violations in legacy files:\n\(message)")
        }
    }

    func testDesignSystemFilesExist() throws {
        guard let root = projectRoot else {
            XCTFail("GATE TEST FAILURE: Could not determine project root path"); return
        }
        let designSystemPath = root.appendingPathComponent("Utilities/DesignSystem.swift")
        XCTAssertTrue(
            FileManager.default.fileExists(atPath: designSystemPath.path),
            "DesignSystem.swift must exist at Utilities/DesignSystem.swift"
        )
    }

    func testDesignSystemHasRequiredTokens() throws {
        guard let root = projectRoot else {
            XCTFail("GATE TEST FAILURE: Could not determine project root path"); return
        }
        let designSystemPath = root.appendingPathComponent("Utilities/DesignSystem.swift")
        let content = try String(contentsOf: designSystemPath, encoding: .utf8)

        // Check for required enums
        XCTAssertTrue(content.contains("enum Spacing"), "DesignSystem must define Spacing enum")
        XCTAssertTrue(content.contains("enum Sizes"), "DesignSystem must define Sizes enum")
        XCTAssertTrue(content.contains("enum CornerRadius"), "DesignSystem must define CornerRadius enum")
        XCTAssertTrue(content.contains("enum AppColors"), "DesignSystem must define AppColors enum")
        XCTAssertTrue(content.contains("enum Opacity"), "DesignSystem must define Opacity enum")

        // Check for key tokens
        XCTAssertTrue(content.contains("static let sm"), "Spacing must have sm token")
        XCTAssertTrue(content.contains("static let md"), "Spacing must have md token")
        XCTAssertTrue(content.contains("static let lg"), "Spacing must have lg token")
        XCTAssertTrue(content.contains("static let primary"), "AppColors must have primary token")
        XCTAssertTrue(content.contains("static let danger"), "AppColors must have danger token")
        XCTAssertTrue(content.contains("static let success"), "AppColors must have success token")
    }

    // MARK: - Helpers

    private func findSwiftFiles(in directory: URL) -> [String] {
        var files: [String] = []

        guard let enumerator = FileManager.default.enumerator(
            at: directory,
            includingPropertiesForKeys: [.isRegularFileKey],
            options: [.skipsHiddenFiles]
        ) else {
            return files
        }

        for case let fileURL as URL in enumerator {
            if fileURL.pathExtension == "swift" {
                files.append(fileURL.path)
            }
        }

        return files
    }
}


// ==========================================
// FILE: CardSampleGameTests/GateTests/ExpressionParserTests.swift
// ==========================================

import XCTest
import TwilightEngine

/// Expression Parser Tests — Audit v2.1, Section 3.1
/// Validates that the ExpressionParser correctly rejects unknown variables,
/// unknown functions, and invalid syntax in pack condition strings.
final class ExpressionParserTests: XCTestCase {

    // MARK: - Rejects Unknown Variables

    func testRejectsUnknownVariables() {
        // "WorldResonanse" is a typo for "WorldResonance"
        let result = ExpressionParser.validate("WorldResonanse < -50")
        XCTAssertNotNil(result, "Should reject unknown variable")

        if case .unknownVariable(let name) = result {
            XCTAssertEqual(name, "WorldResonanse", "Should identify the typo variable")
        } else {
            XCTFail("Expected unknownVariable error, got: \(String(describing: result))")
        }

        // Another typo
        let result2 = ExpressionParser.validate("playerHelth > 5")
        XCTAssertNotNil(result2, "Should reject 'playerHelth' typo")
    }

    func testAcceptsKnownVariables() {
        // These should all pass validation
        let validExpressions = [
            "WorldTension > 50",
            "playerHealth < 10",
            "lightDarkBalance >= 30",
            "currentDay == 5",
            "PlayerFaith <= 3"
        ]

        for expr in validExpressions {
            let result = ExpressionParser.validate(expr)
            XCTAssertNil(result, "Should accept valid expression: '\(expr)', got: \(String(describing: result))")
        }
    }

    // MARK: - Rejects Unknown Functions

    func testRejectsUnknownFunctions() {
        let result = ExpressionParser.validate("unknownFunc(\"test\")")
        XCTAssertNotNil(result, "Should reject unknown function")

        if case .unknownFunction(let name) = result {
            XCTAssertEqual(name, "unknownFunc", "Should identify the unknown function")
        } else {
            XCTFail("Expected unknownFunction error, got: \(String(describing: result))")
        }
    }

    func testAcceptsKnownFunctions() {
        let validExpressions = [
            "hasFlag(\"quest_started\")",
            "notFlag(\"boss_defeated\")",
            "visitedRegion(\"market\")",
            "hasQuest(\"main_quest\")"
        ]

        for expr in validExpressions {
            let result = ExpressionParser.validate(expr)
            XCTAssertNil(result, "Should accept valid expression: '\(expr)', got: \(String(describing: result))")
        }
    }

    // MARK: - Rejects Invalid Syntax

    func testRejectsInvalidSyntax() {
        // Empty expression
        let emptyResult = ExpressionParser.validate("")
        XCTAssertNotNil(emptyResult, "Should reject empty expression")
        if case .emptyExpression = emptyResult {
            // Expected
        } else {
            XCTFail("Expected emptyExpression error")
        }

        // Whitespace only
        let whitespaceResult = ExpressionParser.validate("   ")
        XCTAssertNotNil(whitespaceResult, "Should reject whitespace-only expression")
    }

    func testRejectsUnterminatedString() {
        let result = ExpressionParser.validate("hasFlag(\"unterminated)")
        // Should detect either invalid syntax or reach end of expression improperly
        // The tokenizer handles unterminated strings as invalid
        XCTAssertNotNil(result, "Should reject unterminated string literal")
    }

    // MARK: - Batch Validation

    func testValidateAllReturnsAllErrors() {
        let expressions = [
            "WorldTension > 50",       // Valid
            "WorldResonanse < -50",    // Invalid: typo
            "playerHealth >= 0",       // Valid
            "unknownFunc(\"x\")",      // Invalid: unknown function
        ]

        let errors = ExpressionParser.validateAll(expressions)
        XCTAssertEqual(errors.count, 2, "Should find exactly 2 invalid expressions")
        XCTAssertEqual(errors[0].0, "WorldResonanse < -50")
        XCTAssertEqual(errors[1].0, "unknownFunc(\"x\")")
    }

    // MARK: - Complex Expressions

    func testComplexValidExpression() {
        let result = ExpressionParser.validate("WorldTension > 50 && playerHealth < 10")
        XCTAssertNil(result, "Should accept complex valid expression with &&")
    }

    func testComparisonOperators() {
        let ops = ["<", ">", "<=", ">=", "==", "!="]
        for op in ops {
            let result = ExpressionParser.validate("WorldTension \(op) 50")
            XCTAssertNil(result, "Should accept operator: \(op)")
        }
    }

    // MARK: - Boolean Literals

    func testAcceptsBooleanLiterals() {
        let result = ExpressionParser.validate("hasFlag(\"test\") == true")
        XCTAssertNil(result, "Should accept boolean literal 'true'")
    }

    // MARK: - All Pack Conditions Are Valid (Integration)

    func testAllPackConditionsAreValid() {
        // Load all packs and validate that any string-based conditions parse correctly
        // Currently the engine uses typed Availability structs, not string expressions.
        // This test ensures the ExpressionParser infrastructure is ready for string conditions.

        let registry = ContentRegistry.shared

        // Verify the parser accepts all known variable names
        for variable in ExpressionParser.knownVariables {
            let result = ExpressionParser.validate("\(variable) > 0")
            XCTAssertNil(result, "Known variable '\(variable)' should be accepted")
        }

        // Verify the parser accepts all known function names
        for function in ExpressionParser.knownFunctions {
            let result = ExpressionParser.validate("\(function)(\"test\")")
            XCTAssertNil(result, "Known function '\(function)' should be accepted")
        }

        // Verify registry is accessible
        XCTAssertNotNil(registry, "ContentRegistry should be accessible")
    }
}


// ==========================================
// FILE: CardSampleGameTests/GateTests/LocalizationValidatorTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Gate tests for localization schema consistency (Audit B1 requirement).
/// Ensures all packs use the canonical localization approach without mixing schemes.
///
/// Canonical approach: Inline LocalizedString { "en": "...", "ru": "..." }
/// Forbidden: Mixing inline strings with StringKey references within the same pack.
final class LocalizationValidatorTests: XCTestCase {

    // MARK: - Canon Tests

    func testCanonicalSchemeIsInlineOnly() throws {
        // Document the canonical scheme
        XCTAssertEqual(
            LocalizationValidator.canonicalScheme,
            .inlineOnly,
            "Canonical localization scheme should be inline-only"
        )
    }

    func testInlineTextIsCanonical() throws {
        let text = LocalizableText.localized(en: "Strike", ru: "Удар")
        XCTAssertTrue(
            LocalizationValidator.isCanonical(text),
            "Inline LocalizedString should be canonical"
        )
    }

    func testStringKeyIsNotCanonical() throws {
        let text = LocalizableText.key("card.strike.name")
        XCTAssertFalse(
            LocalizationValidator.isCanonical(text),
            "StringKey should NOT be canonical (we use inline scheme)"
        )
    }

    // MARK: - Gate Test: No Mixed Localization Schema

    func testNoMixedLocalizationSchema() throws {
        // Load real packs
        let registry = ContentRegistry.shared

        // Ensure packs are loaded
        if registry.loadedPackIds.isEmpty {
            guard let storyPackURL = TestContentLoader.storyPackURL,
                  let charPackURL = TestContentLoader.characterPackURL else {
                XCTFail("GATE TEST FAILURE: Could not locate content packs")
                return
            }
            do {
                try registry.loadPack(from: storyPackURL)
                try registry.loadPack(from: charPackURL)
            } catch {
                XCTFail("GATE TEST FAILURE: Failed to load packs: \(error)")
                return
            }
        }

        // Validate all loaded packs
        for (packId, pack) in registry.loadedPacks {
            let result = LocalizationValidator.validate(pack: pack)

            // Check scheme is canonical
            if result.scheme != LocalizationValidator.canonicalScheme {
                let reason = LocalizationValidator.failureReason(result: result)
                XCTFail("Pack '\(packId)' uses non-canonical localization scheme:\n\(reason)")
            }

            // Check no mixed entities
            if !result.mixedEntities.isEmpty {
                let entities = result.mixedEntities.prefix(5).joined(separator: ", ")
                XCTFail("Pack '\(packId)' has entities mixing localization schemes: \(entities)")
            }
        }
    }

    // MARK: - Fallback Determinism Test

    func testLocalizationFallbackIsDeterministic() throws {
        // Test that fallback to English is deterministic when Russian is missing

        // Create inline text with both translations
        let fullText = LocalizableText.localized(en: "Attack", ru: "Атака")

        // Resolve for English (should return English)
        let enResult = fullText.resolved(for: "en")
        XCTAssertEqual(enResult, "Attack", "English resolution should return English text")

        // Resolve for Russian (should return Russian)
        let ruResult = fullText.resolved(for: "ru")
        XCTAssertEqual(ruResult, "Атака", "Russian resolution should return Russian text")

        // Resolve for unknown locale (should fallback to English)
        let unknownResult = fullText.resolved(for: "de")
        XCTAssertEqual(unknownResult, "Attack", "Unknown locale should fallback to English")

        // Multiple resolutions should be deterministic
        XCTAssertEqual(fullText.resolved(for: "de"), unknownResult, "Fallback should be deterministic")
        XCTAssertEqual(fullText.resolved(for: "de"), unknownResult, "Fallback should be deterministic")
    }

    func testEmptyRussianReturnsEnglishWhenEmpty() throws {
        // Create text with empty Russian
        let text = LocalizableText.inline(LocalizedString(en: "Test", ru: ""))

        // Current behavior: returns empty string (no automatic fallback)
        // This is documented behavior - content authors must provide all translations
        let ruResult = text.resolved(for: "ru")

        // Document the current behavior
        // Note: This could be changed to fallback to English if desired
        XCTAssertTrue(ruResult.isEmpty || ruResult == "Test",
            "Russian should either return empty or fallback to English")
    }

    // MARK: - Validation Result Tests

    func testValidationResultForInlineOnlyPack() throws {
        // Create a mock validation result for inline-only pack
        let result = LocalizationValidator.ValidationResult(
            isValid: true,
            scheme: .inlineOnly,
            inlineCount: 100,
            keyCount: 0,
            mixedEntities: []
        )

        XCTAssertTrue(result.isValid)
        XCTAssertEqual(result.scheme, .inlineOnly)
        XCTAssertTrue(result.mixedEntities.isEmpty)
    }

    func testValidationResultForMixedPack() throws {
        // Create a mock validation result for mixed pack
        let result = LocalizationValidator.ValidationResult(
            isValid: false,
            scheme: .mixed,
            inlineCount: 50,
            keyCount: 50,
            mixedEntities: ["event:test_event", "hero:test_hero"]
        )

        XCTAssertFalse(result.isValid)
        XCTAssertEqual(result.scheme, .mixed)
        XCTAssertFalse(result.mixedEntities.isEmpty)
    }
}

