=== DUMP GENERATED ===
Source: /Users/abondarenko/Library/Mobile Documents/com~apple~CloudDocs/XCode/CardSampleGame

=== FILE STRUCTURE ===
Packages/
    TwilightEngine/
        Package.swift
        Tests/
            PackAuthoringTests/
                PackAuthoringTestHelper.swift
                PackCompilerTests.swift
                PackValidatorTests.swift
            TwilightEngineTests/
                CombatEngineFirstTests.swift
                CombatSpiritTests.swift
                DataSeparationTests.swift
                EncounterFateFlowTests.swift
                EnemyDefinitionTests.swift
                FateAttackTests.swift
                FateDeckManagerTests.swift
                FateSkillCheckTests.swift
                GameplayFlowTests.swift
                Phase3ContractTests.swift
                RegressionPlaythroughTests.swift
                ResonanceEngineTests.swift
                TimeSystemTests.swift
                IntegrationTests/
                    EncounterIntegrationTests.swift
                LayerTests/
                    BehaviorRuntimeTests.swift
                    EncounterEngineTests.swift
                    FateDeckEngineTests.swift
                    KeywordInterpreterTests.swift
                    ModifierSystemTests.swift
                GateTests/
                    INV_BHV_GateTests.swift
                    INV_CNT_GateTests.swift
                    INV_ENC_GateTests.swift
                    INV_FATE_GateTests.swift
                Helpers/
                    EncounterContextFixtures.swift
                    TestContentLoader.swift
CardSampleGameTests/
    Unit/
        HeroRegistryTests.swift
        SaveLoadTests.swift
        ContentPackTests/
            ContentManagerTests.swift
            ContentRegistryTests.swift
            PackLoaderTests.swift
    Integration/
    TestHelpers/
        SourcePathResolver.swift
        TestContentLoader.swift
    Views/
        HeroPanelTests.swift
    GateTests/
        AuditGateTests.swift
        CodeHygieneTests.swift
        ConditionValidatorTests.swift
        ContentValidationTests.swift
        DesignSystemComplianceTests.swift
        ExpressionParserTests.swift
        LocalizationValidatorTests.swift

=== FILE CONTENTS ===

// ==========================================
// FILE: Packages/TwilightEngine/Tests/PackAuthoringTests/PackAuthoringTestHelper.swift
// ==========================================

import Foundation

/// Helper to locate pack JSON directories from SPM test context
enum PackAuthoringTestHelper {

    /// Project root, derived from this file's path
    static let projectRoot: URL = {
        // PackAuthoringTests/PackAuthoringTestHelper.swift
        //   → PackAuthoringTests → Tests → TwilightEngine → Packages → ProjectRoot
        URL(fileURLWithPath: #filePath)
            .deletingLastPathComponent()  // PackAuthoringTests
            .deletingLastPathComponent()  // Tests
            .deletingLastPathComponent()  // TwilightEngine
            .deletingLastPathComponent()  // Packages
            .deletingLastPathComponent()  // Project root
    }()

    /// URL to TwilightMarchesActI JSON source directory
    static var storyPackJSONURL: URL? {
        let url = projectRoot
            .appendingPathComponent("Packages/StoryPacks/Season1/TwilightMarchesActI/Sources/TwilightMarchesActIContent/Resources/TwilightMarchesActI")
        guard FileManager.default.fileExists(atPath: url.appendingPathComponent("manifest.json").path) else {
            return nil
        }
        return url
    }

    /// URL to CoreHeroes JSON source directory
    static var characterPackJSONURL: URL? {
        let url = projectRoot
            .appendingPathComponent("Packages/CharacterPacks/CoreHeroes/Sources/CoreHeroesContent/Resources/CoreHeroes")
        guard FileManager.default.fileExists(atPath: url.appendingPathComponent("manifest.json").path) else {
            return nil
        }
        return url
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/PackAuthoringTests/PackCompilerTests.swift
// ==========================================

import XCTest
import TwilightEngine
import PackAuthoring

/// Tests for PackCompiler functionality
/// PackCompiler converts JSON source directories to binary .pack files
final class PackCompilerTests: XCTestCase {

    // MARK: - Properties

    private var storyPackURL: URL?
    private var characterPackURL: URL?
    private var outputURL: URL!

    // MARK: - Setup

    override func setUp() {
        super.setUp()
        storyPackURL = PackAuthoringTestHelper.storyPackJSONURL
        characterPackURL = PackAuthoringTestHelper.characterPackJSONURL
        outputURL = FileManager.default.temporaryDirectory
            .appendingPathComponent("PackCompilerTests_\(UUID().uuidString)")
            .appendingPathExtension("pack")
    }

    override func tearDown() {
        try? FileManager.default.removeItem(at: outputURL)
        storyPackURL = nil
        characterPackURL = nil
        super.tearDown()
    }

    // MARK: - Compile Tests

    func testCompileStoryPack() throws {
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI JSON not available")

        let result = try PackCompiler.compile(from: url, to: outputURL)

        XCTAssertEqual(result.packId, "twilight-marches-act1")
        XCTAssertTrue(FileManager.default.fileExists(atPath: outputURL.path))
        XCTAssertGreaterThan(result.outputSize, 0)
        XCTAssertGreaterThan(result.contentStats.regions, 0)
        XCTAssertGreaterThan(result.contentStats.events, 0)
    }

    func testCompileCharacterPack() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes JSON not available"); return }
        let url = characterPackURL!

        let result = try PackCompiler.compile(from: url, to: outputURL)

        XCTAssertEqual(result.packId, "core-heroes")
        XCTAssertTrue(FileManager.default.fileExists(atPath: outputURL.path))
        XCTAssertGreaterThan(result.contentStats.heroes, 0)
        XCTAssertGreaterThan(result.contentStats.cards, 0)
    }

    func testCompileProducesValidPackFile() throws {
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI JSON not available")

        try PackCompiler.compile(from: url, to: outputURL)

        XCTAssertTrue(BinaryPackReader.isValidPackFile(outputURL))
        let content = try BinaryPackReader.loadContent(from: outputURL)
        XCTAssertGreaterThan(content.regions.count, 0)
    }

    func testCompilationResultHasStats() throws {
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI JSON not available")

        let result = try PackCompiler.compile(from: url, to: outputURL)

        XCTAssertGreaterThan(result.inputSize, 0, "Should report input size")
        XCTAssertGreaterThan(result.outputSize, 0, "Should report output size")
        XCTAssertGreaterThan(result.compilationTime, 0, "Should report compilation time")
        XCTAssertFalse(result.summary.isEmpty, "Should produce summary")
    }

    func testCompressionRatio() throws {
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI JSON not available")

        let result = try PackCompiler.compile(from: url, to: outputURL)

        XCTAssertGreaterThan(result.compressionRatio, 0, "Compression ratio should be positive")
    }

    // MARK: - Validate Tests

    func testValidateValidPack() throws {
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI JSON not available")

        let result = try PackCompiler.validate(at: url)

        XCTAssertTrue(result.isValid)
        XCTAssertTrue(result.coreCompatible)
        XCTAssertTrue(result.contentValid)
        XCTAssertNil(result.error)
    }

    func testValidateReportsSummary() throws {
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI JSON not available")

        let result = try PackCompiler.validate(at: url)

        XCTAssertFalse(result.summary.isEmpty)
        XCTAssertFalse(result.packId.isEmpty)
    }

    // MARK: - Error Tests

    func testCompileFromInvalidPathThrows() {
        let invalidURL = URL(fileURLWithPath: "/nonexistent/pack")
        XCTAssertThrowsError(try PackCompiler.compile(from: invalidURL, to: outputURL))
    }

    func testValidateFromInvalidPathThrows() {
        let invalidURL = URL(fileURLWithPath: "/nonexistent/pack")
        XCTAssertThrowsError(try PackCompiler.validate(at: invalidURL))
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/PackAuthoringTests/PackValidatorTests.swift
// ==========================================

import XCTest
import TwilightEngine
import PackAuthoring

/// Tests for PackValidator functionality
/// PackValidator performs multi-phase validation of content packs
final class PackValidatorTests: XCTestCase {

    // MARK: - Properties

    private var storyPackURL: URL?
    private var characterPackURL: URL?

    // MARK: - Setup

    override func setUp() {
        super.setUp()
        storyPackURL = PackAuthoringTestHelper.storyPackJSONURL
        characterPackURL = PackAuthoringTestHelper.characterPackJSONURL
    }

    override func tearDown() {
        storyPackURL = nil
        characterPackURL = nil
        super.tearDown()
    }

    // MARK: - Valid Pack Tests

    func testValidateStoryPackPasses() throws {
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI JSON not available")

        let validator = PackValidator(packURL: url)
        let summary = validator.validate()

        XCTAssertTrue(summary.isValid, "Story pack should pass validation. Errors: \(summary.results.filter { $0.severity == .error }.map { $0.description })")
        XCTAssertEqual(summary.errorCount, 0)
        XCTAssertEqual(summary.packId, "twilight-marches-act1")
    }

    func testValidateCharacterPackPasses() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes JSON not available"); return }
        let url = characterPackURL!

        let validator = PackValidator(packURL: url)
        let summary = validator.validate()

        XCTAssertTrue(summary.isValid, "Character pack should pass validation. Errors: \(summary.results.filter { $0.severity == .error }.map { $0.description })")
        XCTAssertEqual(summary.errorCount, 0)
        XCTAssertEqual(summary.packId, "core-heroes")
    }

    // MARK: - Summary Structure Tests

    func testValidationSummaryHasDuration() throws {
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI JSON not available")

        let validator = PackValidator(packURL: url)
        let summary = validator.validate()

        XCTAssertGreaterThan(summary.duration, 0, "Validation should report duration")
    }

    func testValidationSummaryHasInfoMessages() throws {
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI JSON not available")

        let validator = PackValidator(packURL: url)
        let summary = validator.validate()

        XCTAssertGreaterThan(summary.infoCount, 0, "Should produce info messages about loaded content")
    }

    // MARK: - Quick Validate Tests

    func testQuickValidateReturnsZeroErrorsForValidPack() throws {
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI JSON not available")

        let (errors, _) = PackValidator.quickValidate(packURL: url)

        XCTAssertEqual(errors, 0)
    }

    // MARK: - Invalid Pack Tests

    func testValidateNonExistentPathReportsError() {
        let invalidURL = URL(fileURLWithPath: "/nonexistent/pack")

        let validator = PackValidator(packURL: invalidURL)
        let summary = validator.validate()

        XCTAssertFalse(summary.isValid)
        XCTAssertGreaterThan(summary.errorCount, 0)
    }

    func testValidateDirectoryWithoutManifestReportsError() throws {
        let tempDir = FileManager.default.temporaryDirectory
            .appendingPathComponent("PackValidatorTests_\(UUID().uuidString)")
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        defer { try? FileManager.default.removeItem(at: tempDir) }

        let validator = PackValidator(packURL: tempDir)
        let summary = validator.validate()

        XCTAssertFalse(summary.isValid)
        XCTAssertGreaterThan(summary.errorCount, 0)
    }

    func testValidateDirectoryWithInvalidManifestReportsError() throws {
        let tempDir = FileManager.default.temporaryDirectory
            .appendingPathComponent("PackValidatorTests_\(UUID().uuidString)")
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        defer { try? FileManager.default.removeItem(at: tempDir) }

        let manifestURL = tempDir.appendingPathComponent("manifest.json")
        try "{ invalid json".data(using: .utf8)!.write(to: manifestURL)

        let validator = PackValidator(packURL: tempDir)
        let summary = validator.validate()

        XCTAssertFalse(summary.isValid)
        XCTAssertGreaterThan(summary.errorCount, 0)
    }

    // MARK: - Cross-Reference Validation

    func testStoryPackNeighborReferencesAreValid() throws {
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI JSON not available")

        let validator = PackValidator(packURL: url)
        let summary = validator.validate()

        let neighborErrors = summary.results.filter {
            $0.severity == .error && $0.message.contains("non-existent neighbor")
        }
        XCTAssertTrue(neighborErrors.isEmpty, "Should have no broken neighbor references: \(neighborErrors.map { $0.description })")
    }

    func testCharacterPackCardReferencesAreValid() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes JSON not available"); return }
        let url = characterPackURL!

        let validator = PackValidator(packURL: url)
        let summary = validator.validate()

        let cardRefErrors = summary.results.filter {
            $0.severity == .error && $0.message.contains("non-existent card")
        }
        XCTAssertTrue(cardRefErrors.isEmpty, "Should have no broken card references: \(cardRefErrors.map { $0.description })")
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/CombatEngineFirstTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Tests for Engine-First combat system
/// Verifies that combat works without legacy Player/WorldState adapters
final class CombatEngineFirstTests: XCTestCase {

    var engine: TwilightGameEngine!

    // Load content once for all tests in this class
    override class func setUp() {
        super.setUp()
        TestContentLoader.loadContentPacksIfNeeded()
    }

    override func setUp() {
        super.setUp()
        engine = TwilightGameEngine()

        // Initialize game with starting deck
        let startingDeck = [
            Card(id: "strike_1", name: "Strike", type: .attack, description: "Basic attack", power: 3),
            Card(id: "strike_2", name: "Strike", type: .attack, description: "Basic attack", power: 3),
            Card(id: "defend_1", name: "Defend", type: .defense, description: "Basic defense", defense: 2),
            Card(id: "defend_2", name: "Defend", type: .defense, description: "Basic defense", defense: 2),
            Card(id: "heal_1", name: "Heal", type: .spell, description: "Heal 2 HP")
        ]
        engine.initializeNewGame(playerName: "Test Hero", heroId: nil, startingDeck: startingDeck)
    }

    override func tearDown() {
        engine = nil
        super.tearDown()
    }

    // MARK: - Combat Setup Tests

    func testSetupCombatEnemy() {
        // Given
        let enemy = Card(id: "enemy_wild_beast", name: "Wild Beast", type: .monster, description: "A wild beast", power: 3, defense: 2, health: 10)

        // When
        engine.setupCombatEnemy(enemy)

        // Then
        XCTAssertTrue(engine.isInCombat, "Should be in combat after setup")
        XCTAssertEqual(engine.combatEnemyHealth, 10, "Enemy health should be set")
        XCTAssertNotNil(engine.combatState, "Combat state should be available")
        XCTAssertEqual(engine.combatState?.enemy.name, "Wild Beast")
    }

    func testCombatInitializeDrawsCards() {
        // Given
        let enemy = Card(id: "test_enemy", name: "Enemy", type: .monster, description: "Test", health: 10)
        engine.setupCombatEnemy(enemy)

        // When
        engine.performAction(.combatInitialize)

        // Then
        XCTAssertEqual(engine.playerHand.count, 5, "Should draw 5 cards")
    }

    // MARK: - Damage Tests

    func testDamageEnemyReducesHealth() {
        // Given
        let enemy = Card(id: "test_enemy", name: "Enemy", type: .monster, description: "Test", health: 10)
        engine.setupCombatEnemy(enemy)
        let initialHealth = engine.combatEnemyHealth

        // When
        engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: 3)))

        // Then
        XCTAssertEqual(engine.combatEnemyHealth, initialHealth - 3, "Enemy health should decrease by damage amount")
    }

    func testDamageEnemyCannotGoBelowZero() {
        // Given
        let enemy = Card(id: "test_enemy_5hp", name: "Enemy", type: .monster, description: "Test", health: 5)
        engine.setupCombatEnemy(enemy)

        // When
        engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: 100)))

        // Then
        XCTAssertEqual(engine.combatEnemyHealth, 0, "Enemy health should not go below 0")
    }

    func testDamageEnemyRequiresCombatEnemy() {
        // Given - no enemy set up
        XCTAssertFalse(engine.isInCombat)

        // When
        engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: 5)))

        // Then - should not crash, just no effect
        XCTAssertEqual(engine.combatEnemyHealth, 0)
    }

    // MARK: - Card Effects Tests

    func testHealEffectRestoresHealth() {
        // Given
        engine.performAction(.combatApplyEffect(effect: .takeDamage(amount: 5)))
        let healthAfterDamage = engine.playerHealth

        // When
        engine.performAction(.combatApplyEffect(effect: .heal(amount: 3)))

        // Then
        XCTAssertEqual(engine.playerHealth, healthAfterDamage + 3, "Health should increase by heal amount")
    }

    func testHealEffectCannotExceedMax() {
        // Given - at full health
        let maxHealth = engine.playerMaxHealth

        // When
        engine.performAction(.combatApplyEffect(effect: .heal(amount: 100)))

        // Then
        XCTAssertEqual(engine.playerHealth, maxHealth, "Health should not exceed max")
    }

    func testDrawCardsEffect() {
        // Given
        let enemy = Card(id: "test_enemy", name: "Enemy", type: .monster, description: "Test", health: 10)
        engine.setupCombatEnemy(enemy)
        engine.performAction(.combatInitialize)
        XCTAssertEqual(engine.playerHand.count, 5, "Should start with 5 cards")

        // When - play a card first to make room
        if !engine.playerHand.isEmpty {
            engine.performAction(.playCard(cardId: engine.playerHand[0].id, targetId: nil))
        }
        let handSizeAfterPlay = engine.playerHand.count
        engine.performAction(.combatApplyEffect(effect: .drawCards(count: 1)))

        // Then - hand size should increase by 1 (if deck has cards)
        XCTAssertGreaterThanOrEqual(engine.playerHand.count, handSizeAfterPlay)
    }

    func testGainFaithEffect() {
        // Given
        let initialFaith = engine.playerFaith

        // When
        engine.performAction(.combatApplyEffect(effect: .gainFaith(amount: 2)))

        // Then
        XCTAssertEqual(engine.playerFaith, min(initialFaith + 2, engine.playerMaxFaith))
    }

    func testSpendFaithEffect() {
        // Given
        let initialFaith = engine.playerFaith

        // When
        engine.performAction(.combatApplyEffect(effect: .spendFaith(amount: 1)))

        // Then
        XCTAssertEqual(engine.playerFaith, max(0, initialFaith - 1))
    }

    func testTakeDamageEffect() {
        // Given
        let initialHealth = engine.playerHealth

        // When
        engine.performAction(.combatApplyEffect(effect: .takeDamage(amount: 3)))

        // Then
        XCTAssertEqual(engine.playerHealth, initialHealth - 3)
    }

    func testAddBonusDiceEffect() {
        // Given
        let enemy = Card(id: "test_enemy", name: "Enemy", type: .monster, description: "Test", health: 10)
        engine.setupCombatEnemy(enemy)

        // When
        engine.performAction(.combatApplyEffect(effect: .addBonusDice(count: 2)))

        // Then
        XCTAssertEqual(engine.combatState?.bonusDice, 2)
    }

    func testAddBonusDamageEffect() {
        // Given
        let enemy = Card(id: "test_enemy", name: "Enemy", type: .monster, description: "Test", health: 10)
        engine.setupCombatEnemy(enemy)

        // When
        engine.performAction(.combatApplyEffect(effect: .addBonusDamage(amount: 5)))

        // Then
        XCTAssertEqual(engine.combatState?.bonusDamage, 5)
    }

    // MARK: - Combat Lifecycle Tests

    func testCombatFinishClearsEnemy() {
        // Given
        let enemy = Card(id: "test_enemy", name: "Enemy", type: .monster, description: "Test", health: 10)
        engine.setupCombatEnemy(enemy)
        XCTAssertTrue(engine.isInCombat)

        // When
        engine.performAction(.combatFinish(victory: true))

        // Then
        XCTAssertFalse(engine.isInCombat, "Should not be in combat after finish")
        XCTAssertNil(engine.combatState, "Combat state should be nil")
    }

    func testCombatFleeClearsEnemy() {
        // Given
        let enemy = Card(id: "test_enemy", name: "Enemy", type: .monster, description: "Test", health: 10)
        engine.setupCombatEnemy(enemy)

        // When
        engine.performAction(.combatFlee)

        // Then
        XCTAssertFalse(engine.isInCombat)
    }

    // MARK: - Multiple Combats Tests

    func testSecondCombatRestoresDeck() {
        // Given - first combat
        let enemy1 = Card(id: "test_enemy_1", name: "Enemy 1", type: .monster, description: "Test", health: 5)
        engine.setupCombatEnemy(enemy1)
        engine.performAction(.combatInitialize)

        let initialHandCount = engine.playerHand.count
        XCTAssertEqual(initialHandCount, 5, "Should start with 5 cards in hand")

        // Play some attack cards (they reliably go to discard)
        let attackCards = engine.playerHand.filter { $0.type == .attack }
        for card in attackCards {
            engine.performAction(.playCard(cardId: card.id, targetId: nil))
        }
        XCTAssertLessThan(engine.playerHand.count, initialHandCount, "Some cards should be played")

        // End first combat
        engine.performAction(.combatFinish(victory: true))

        // When - start second combat
        let enemy2 = Card(id: "test_enemy_2", name: "Enemy 2", type: .monster, description: "Test", health: 5)
        engine.setupCombatEnemy(enemy2)
        engine.performAction(.combatInitialize)

        // Then - should have full hand again (deck restored from discard)
        XCTAssertEqual(engine.playerHand.count, 5, "Should draw full hand in second combat")
    }

    func testCardsReturnFromDiscardOnNewCombat() {
        // Given - setup and use cards in first combat
        let enemy = Card(id: "test_enemy_100hp", name: "Enemy", type: .monster, description: "Test", health: 100)
        engine.setupCombatEnemy(enemy)
        engine.performAction(.combatInitialize)

        let totalCards = engine.playerHand.count + engine.playerDeck.count

        // Play some cards (with safety limit to prevent infinite loop)
        var cardsPlayed = 0
        let maxCardsToPlay = 10
        while !engine.playerHand.isEmpty && cardsPlayed < maxCardsToPlay {
            engine.performAction(.playCard(cardId: engine.playerHand[0].id, targetId: nil))
            cardsPlayed += 1
        }

        // End combat
        engine.performAction(.combatFinish(victory: false))

        // When - new combat
        engine.setupCombatEnemy(enemy)
        engine.performAction(.combatInitialize)

        // Then - all cards should be available again
        let newTotalCards = engine.playerHand.count + engine.playerDeck.count + engine.playerDiscard.count
        XCTAssertEqual(newTotalCards, totalCards, "All cards should be restored")
    }

    // MARK: - Balance Shift Tests

    func testShiftBalanceTowardsLight() {
        // Given
        let initialBalance = engine.playerBalance

        // When
        engine.performAction(.combatApplyEffect(effect: .shiftBalance(towards: "light", amount: 10)))

        // Then
        XCTAssertEqual(engine.playerBalance, min(100, initialBalance + 10))
    }

    func testShiftBalanceTowardsDark() {
        // Given
        let initialBalance = engine.playerBalance

        // When
        engine.performAction(.combatApplyEffect(effect: .shiftBalance(towards: "dark", amount: 10)))

        // Then
        XCTAssertEqual(engine.playerBalance, max(0, initialBalance - 10))
    }

    // MARK: - Gate Test: Combat Determinism

    /// Gate test: Combat with same seed produces identical results
    /// Requirement: "бой с одинаковым seed даёт одинаковый результат"
    func testCombatDeterminismWithSeed() {
        let testSeed: UInt64 = 54321

        // First combat simulation
        WorldRNG.shared.setSeed(testSeed)
        let results1 = simulateCombatSequence()

        // Second combat simulation with same seed
        WorldRNG.shared.setSeed(testSeed)
        let results2 = simulateCombatSequence()

        // Results must be identical
        XCTAssertEqual(results1.finalEnemyHealth, results2.finalEnemyHealth,
                       "Enemy health must be identical with same seed")
        XCTAssertEqual(results1.finalPlayerHealth, results2.finalPlayerHealth,
                       "Player health must be identical with same seed")
        XCTAssertEqual(results1.cardsDrawn, results2.cardsDrawn,
                       "Cards drawn must be identical with same seed")
        XCTAssertEqual(results1.damageDealt, results2.damageDealt,
                       "Damage dealt must be identical with same seed")
    }

    /// Helper: Simulate a combat sequence and return results
    private func simulateCombatSequence() -> CombatSimulationResult {
        let engine = TwilightGameEngine()

        // Initialize with known deck
        let startingDeck = [
            Card(id: "sim_strike_1", name: "Strike", type: .attack, description: "Basic attack", power: 3),
            Card(id: "sim_strike_2", name: "Strike", type: .attack, description: "Basic attack", power: 3),
            Card(id: "sim_defend_1", name: "Defend", type: .defense, description: "Basic defense", defense: 2),
            Card(id: "sim_heal_1", name: "Heal", type: .spell, description: "Heal 2 HP"),
            Card(id: "sim_power_1", name: "Power", type: .attack, description: "Strong attack", power: 5)
        ]
        engine.initializeNewGame(playerName: "Test", heroId: nil, startingDeck: startingDeck)

        // Setup combat
        let enemy = Card(id: "sim_test_enemy", name: "Test Enemy", type: .monster, description: "Test", power: 4, health: 20)
        engine.setupCombatEnemy(enemy)
        engine.performAction(.combatInitialize)

        // Record initial state
        let cardsDrawn = engine.playerHand.map { $0.name }
        var totalDamage = 0

        // Simulate combat turns
        for _ in 0..<3 {
            // Play attack cards
            for card in engine.playerHand where card.type == .attack {
                engine.performAction(.playCard(cardId: card.id, targetId: nil))
                totalDamage += card.power ?? 0
            }

            // Apply damage to enemy
            engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: 5)))

            // End turn
            engine.performAction(.combatEndTurnPhase)
        }

        return CombatSimulationResult(
            finalEnemyHealth: engine.combatEnemyHealth,
            finalPlayerHealth: engine.playerHealth,
            cardsDrawn: cardsDrawn,
            damageDealt: totalDamage
        )
    }
}

/// Result of combat simulation for determinism testing
private struct CombatSimulationResult {
    let finalEnemyHealth: Int
    let finalPlayerHealth: Int
    let cardsDrawn: [String]
    let damageDealt: Int
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/CombatSpiritTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Tests for Dual Track combat: Spirit/Will damage and Pacification (Task 4.2)
final class CombatSpiritTests: XCTestCase {

    // MARK: - Spirit Attack Action

    func testSpiritAttackReducesWill() {
        let engine = TwilightGameEngine()
        engine.initializeNewGame()

        // Setup fate deck with known modifier so damage is deterministic
        let cards = [FateCard(id: "f1", modifier: 1, name: "Fortune")]
        engine.setupFateDeck(cards: cards)

        let enemy = Card(
            id: "spirit_enemy", name: "Spirit", type: .monster, description: "Test",
            health: 20, will: 10
        )
        engine.setupCombatEnemy(enemy)
        XCTAssertEqual(engine.combatEnemyWill, 10)

        engine.performAction(.combatSpiritAttack)

        // baseStat = max(wisdom=0, intelligence=0, 1) = 1; fateModifier = 1; damage = max(1, 1+1) = 2
        XCTAssertEqual(engine.combatEnemyWill, 8, "Will should be reduced by calculated damage")
    }

    func testSpiritAttackPacifiesEnemy() {
        let engine = TwilightGameEngine()
        engine.initializeNewGame()

        // High modifier to guarantee pacification
        let cards = [FateCard(id: "f1", modifier: 3, isCritical: true, name: "Crit")]
        engine.setupFateDeck(cards: cards)

        let enemy = Card(
            id: "spirit_enemy", name: "Spirit", type: .monster, description: "Test",
            health: 20, will: 3
        )
        engine.setupCombatEnemy(enemy)

        // baseStat = 1; fateModifier = 3; damage = 4 > will(3)
        let result = engine.performAction(.combatSpiritAttack)

        XCTAssertEqual(engine.combatEnemyWill, 0, "Will should not go below 0")
        XCTAssertTrue(result.stateChanges.contains(.enemyPacified(enemyId: "spirit_enemy")),
                      "Should emit enemyPacified when will reaches 0")
    }

    func testSpiritAttackIgnoredIfNoWill() {
        let engine = TwilightGameEngine()
        engine.initializeNewGame()

        // Enemy without will
        let enemy = Card(
            id: "basic_enemy", name: "Beast", type: .monster, description: "Test",
            health: 10
        )
        engine.setupCombatEnemy(enemy)
        XCTAssertEqual(engine.combatEnemyMaxWill, 0)

        let result = engine.performAction(.combatSpiritAttack)

        XCTAssertTrue(result.stateChanges.isEmpty, "Spirit attack should be ignored for enemies without will")
    }

    func testSpiritAttackConsumesAction() {
        let engine = TwilightGameEngine()
        engine.initializeNewGame()

        let cards = [FateCard(id: "f1", modifier: 0, name: "Neutral")]
        engine.setupFateDeck(cards: cards)

        let enemy = Card(
            id: "spirit_enemy", name: "Spirit", type: .monster, description: "Test",
            health: 20, will: 10
        )
        engine.setupCombatEnemy(enemy)
        let actionsBefore = engine.combatActionsRemaining

        engine.performAction(.combatSpiritAttack)

        XCTAssertEqual(engine.combatActionsRemaining, actionsBefore - 1,
                       "Spirit attack should consume one action")
    }

    // MARK: - CombatState Dual Track

    func testCombatStateHasSpiritTrack() {
        let engine = TwilightGameEngine()
        engine.initializeNewGame()

        let enemy = Card(
            id: "spirit_enemy", name: "Spirit", type: .monster, description: "Test",
            health: 20, will: 15
        )
        engine.setupCombatEnemy(enemy)

        let state = engine.combatState
        XCTAssertNotNil(state)
        XCTAssertTrue(state!.hasSpiritTrack, "Enemy with will should have spirit track")
        XCTAssertEqual(state!.enemyWill, 15)
        XCTAssertEqual(state!.enemyMaxWill, 15)
    }

    func testCombatStateNoSpiritTrack() {
        let engine = TwilightGameEngine()
        engine.initializeNewGame()

        let enemy = Card(
            id: "basic_enemy", name: "Beast", type: .monster, description: "Test",
            health: 10
        )
        engine.setupCombatEnemy(enemy)

        let state = engine.combatState
        XCTAssertFalse(state!.hasSpiritTrack, "Enemy without will should not have spirit track")
    }

    // MARK: - CombatCalculator Spirit Attack

    func testCalculatorSpiritAttackWithFateDeck() {
        let cards = [FateCard(id: "f1", modifier: 2, name: "Fortune")]
        let deck = FateDeckManager(cards: cards)
        let context = CombatPlayerContext(health: 10, maxHealth: 10, faith: 5, balance: 50, strength: 1, activeCurses: [], heroBonusDice: 0, heroDamageBonus: 0)

        let result = CombatCalculator.calculateSpiritAttack(
            context: context,
            enemyCurrentWill: 10,
            fateDeck: deck
        )

        // baseStat = max(wisdom=0, intelligence=0, 1) = 1; fateModifier = 2; damage = max(1, 1+2) = 3
        XCTAssertEqual(result.damage, 3)
        XCTAssertEqual(result.fateModifier, 2)
        XCTAssertEqual(result.newWill, 7)
        XCTAssertFalse(result.isPacified)
    }

    func testCalculatorSpiritAttackPacifies() {
        let cards = [FateCard(id: "f1", modifier: 3, isCritical: true, name: "Crit")]
        let deck = FateDeckManager(cards: cards)
        let context = CombatPlayerContext(health: 10, maxHealth: 10, faith: 5, balance: 50, strength: 1, activeCurses: [], heroBonusDice: 0, heroDamageBonus: 0)

        let result = CombatCalculator.calculateSpiritAttack(
            context: context,
            enemyCurrentWill: 2,
            fateDeck: deck
        )

        // baseStat = 1; fateModifier = 3; damage = 4; newWill = max(0, 2-4) = 0
        XCTAssertEqual(result.newWill, 0)
        XCTAssertTrue(result.isPacified)
    }

    // MARK: - StateChange

    func testEnemyWillDamagedStateChange() {
        let change = StateChange.enemyWillDamaged(enemyId: "test", damage: 5, newWill: 3)
        let change2 = StateChange.enemyWillDamaged(enemyId: "test", damage: 5, newWill: 3)
        XCTAssertEqual(change, change2, "StateChange.enemyWillDamaged should be Equatable")
    }

    func testEnemyPacifiedStateChange() {
        let change = StateChange.enemyPacified(enemyId: "test")
        let change2 = StateChange.enemyPacified(enemyId: "test")
        XCTAssertEqual(change, change2, "StateChange.enemyPacified should be Equatable")
    }

    // MARK: - Integration: Fate Draw Effects Through Engine

    func testSpiritAttackAppliesResonanceShift() {
        let engine = TwilightGameEngine()
        engine.initializeNewGame()

        let cards = [FateCard(
            id: "nav_card", modifier: 1, name: "Nav Wind",
            suit: .nav,
            onDrawEffects: [FateDrawEffect(type: .shiftResonance, value: -5)]
        )]
        engine.setupFateDeck(cards: cards)

        let enemy = Card(
            id: "spirit_enemy", name: "Spirit", type: .monster, description: "Test",
            health: 20, will: 10
        )
        engine.setupCombatEnemy(enemy)

        let resonanceBefore = engine.resonanceValue
        let result = engine.performAction(.combatSpiritAttack)

        let hasResonanceChange = result.stateChanges.contains { change in
            if case .resonanceChanged(let delta, _) = change { return delta == -5.0 }
            return false
        }
        XCTAssertTrue(hasResonanceChange, "Spirit attack should emit resonanceChanged from fate draw effect")
        XCTAssertEqual(engine.resonanceValue, resonanceBefore - 5.0, "Resonance should shift by draw effect")
    }

    func testSpiritAttackAppliesTensionShift() {
        let engine = TwilightGameEngine()
        engine.initializeNewGame()

        let cards = [FateCard(
            id: "curse_card", modifier: -1, name: "Curse",
            onDrawEffects: [FateDrawEffect(type: .shiftTension, value: 3)]
        )]
        engine.setupFateDeck(cards: cards)

        let enemy = Card(
            id: "spirit_enemy", name: "Spirit", type: .monster, description: "Test",
            health: 20, will: 10
        )
        engine.setupCombatEnemy(enemy)

        let tensionBefore = engine.worldTension
        let result = engine.performAction(.combatSpiritAttack)

        let hasTensionChange = result.stateChanges.contains { change in
            if case .tensionChanged(let delta, _) = change { return delta == 3 }
            return false
        }
        XCTAssertTrue(hasTensionChange, "Spirit attack should emit tensionChanged from fate draw effect")
        XCTAssertEqual(engine.worldTension, tensionBefore + 3, "Tension should shift by draw effect")
    }

    func testSpiritAttackResonanceRuleModifiesDamage() {
        let engine = TwilightGameEngine()
        engine.initializeNewGame()

        // Card with +3 bonus in deepNav zone
        let cards = [FateCard(
            id: "nav_card", modifier: 1, name: "Nav Power",
            resonanceRules: [FateResonanceRule(zone: .deepNav, modifyValue: 3)]
        )]
        engine.setupFateDeck(cards: cards)

        // Set resonance to deepNav territory
        engine.setResonance(-80)

        let enemy = Card(
            id: "spirit_enemy", name: "Spirit", type: .monster, description: "Test",
            health: 20, will: 20
        )
        engine.setupCombatEnemy(enemy)

        engine.performAction(.combatSpiritAttack)

        // baseStat=1, baseValue=1, resonanceBonus=3, effectiveValue=4, damage=max(1, 1+4)=5
        XCTAssertEqual(engine.combatEnemyWill, 15,
            "Resonance rule should boost fate modifier and increase damage")
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/DataSeparationTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Data Separation Contract Tests
/// Verify Definition/Runtime separation is maintained.
/// Reference: Docs/ENGINE_ARCHITECTURE.md, Section 4
final class DataSeparationTests: XCTestCase {

    // MARK: - INV-D01: Definitions Are Immutable

    /// Definition structs should have no runtime/mutable state
    /// Reference: ENGINE_ARCHITECTURE.md, Section 4.1
    func testDefinitionsAreImmutable() {
        // Given: A region definition
        let regionDef = MockRegionDefinition(
            id: "test_region",
            title: LocalizedString(en: "Test Region", ru: "Тестовый регион"),
            neighborIds: ["north", "south"],
            anchorId: "anchor_001",
            eventPoolIds: ["pool_common", "pool_special"],
            initialState: "stable"
        )

        // Then: All properties should be let (immutable)
        // This test verifies by construction - Definition uses let for all fields
        XCTAssertEqual(regionDef.id, "test_region")
        XCTAssertEqual(regionDef.neighborIds.count, 2)

        // Note: In Swift, the compiler enforces immutability via let.
        // This test documents the contract.
    }

    func testDefinitionHasNoRuntimeFields() {
        // Given: Event definition
        let eventDef = MockEventDefinition(
            id: "event_001",
            title: LocalizedString(en: "Test Event", ru: "Тестовое событие"),
            body: LocalizedString(en: "Test body", ru: "Тестовое тело"),
            choiceIds: ["choice_a", "choice_b"],
            isOneTime: true,
            pressureRange: 0...100,
            regionIds: ["forest", "village"]
        )

        // Then: No runtime fields (visitCount, isCompleted, etc.)
        // Definition only has static data
        XCTAssertEqual(eventDef.id, "event_001")
        XCTAssertTrue(eventDef.isOneTime)

        // Runtime state like "isCompleted" lives in EventRuntimeState, not here
    }

    // MARK: - INV-D02: Runtime References Valid Definitions

    /// RuntimeState should reference Definition by valid id
    func testRuntimeReferencesValidDefinitions() {
        // Given: Content provider with definitions
        let provider = MockContentProvider()

        // And: Runtime state referencing definitions
        let runtime = MockWorldRuntimeState(
            currentRegionId: "forest",
            regionsState: [
                "forest": MockRegionRuntimeState(definitionId: "forest", currentState: "stable", visitCount: 0),
                "village": MockRegionRuntimeState(definitionId: "village", currentState: "stable", visitCount: 2)
            ],
            pressure: 20,
            currentTime: 5
        )

        // When: Validate references
        var brokenReferences: [String] = []
        for (regionId, regionState) in runtime.regionsState {
            if provider.getRegionDefinition(id: regionState.definitionId) == nil {
                brokenReferences.append(regionId)
            }
        }

        // Then: All references valid
        XCTAssertTrue(brokenReferences.isEmpty, "Broken references: \(brokenReferences)")
    }

    func testRuntimeWithInvalidReferenceDetected() {
        // Given: Runtime with invalid reference
        let provider = MockContentProvider()
        let runtime = MockWorldRuntimeState(
            currentRegionId: "nonexistent_region",
            regionsState: [
                "invalid": MockRegionRuntimeState(definitionId: "does_not_exist", currentState: "stable", visitCount: 0)
            ],
            pressure: 20,
            currentTime: 5
        )

        // When: Validate
        var brokenReferences: [String] = []
        for (regionId, regionState) in runtime.regionsState {
            if provider.getRegionDefinition(id: regionState.definitionId) == nil {
                brokenReferences.append(regionId)
            }
        }

        // Then: Invalid reference detected
        XCTAssertFalse(brokenReferences.isEmpty, "Should detect broken reference")
        XCTAssertTrue(brokenReferences.contains("invalid"))
    }

    // MARK: - INV-D03: ContentProvider Validation

    /// ContentProvider should catch broken links
    func testContentProviderValidationCatchesBrokenLinks() {
        // Given: Provider with broken content
        let provider = MockContentProviderWithBrokenLinks()

        // When: Validate
        let errors = provider.validate()

        // Then: Errors detected
        XCTAssertFalse(errors.isEmpty, "Should detect validation errors")
        XCTAssertTrue(errors.contains { $0.type == .brokenNeighborLink })
    }

    func testContentProviderValidationPassesForValidContent() {
        // Given: Provider with valid content
        let provider = MockContentProvider()

        // When: Validate
        let errors = provider.validate()

        // Then: No errors
        XCTAssertTrue(errors.isEmpty, "Valid content should pass validation")
    }

    // MARK: - INV-D04: ID Uniqueness

    func testDefinitionIdsAreUnique() {
        // Given: Content provider
        let provider = MockContentProvider()

        // When: Get all definitions
        let regionDefs = provider.getAllRegionDefinitions()
        let eventDefs = provider.getAllEventDefinitions()

        // Then: IDs unique within each type
        let regionIds = regionDefs.map { $0.id }
        let eventIds = eventDefs.map { $0.id }

        XCTAssertEqual(regionIds.count, Set(regionIds).count, "Region IDs should be unique")
        XCTAssertEqual(eventIds.count, Set(eventIds).count, "Event IDs should be unique")
    }

    // MARK: - INV-D05: Localized Strings Present

    func testDefinitionsHaveLocalizedStrings() {
        // Given: Definitions with LocalizedString
        let regionDef = MockRegionDefinition(
            id: "test",
            title: LocalizedString(en: "Test Region", ru: "Тестовый регион"),
            neighborIds: [],
            anchorId: nil,
            eventPoolIds: [],
            initialState: "stable"
        )

        // Then: Both English and Russian localizations are present
        XCTAssertFalse(regionDef.title.en.isEmpty, "Should have English localization")
        XCTAssertFalse(regionDef.title.ru.isEmpty, "Should have Russian localization")
        XCTAssertNotEqual(regionDef.title.en, regionDef.title.ru, "Localizations should be different")
    }

}

// MARK: - Mock Types

struct MockRegionDefinition {
    let id: String
    let title: LocalizedString
    let neighborIds: [String]
    let anchorId: String?
    let eventPoolIds: [String]
    let initialState: String
}

struct MockEventDefinition {
    let id: String
    let title: LocalizedString
    let body: LocalizedString
    let choiceIds: [String]
    let isOneTime: Bool
    let pressureRange: ClosedRange<Int>
    let regionIds: [String]
}

struct MockRegionRuntimeState {
    let definitionId: String
    var currentState: String
    var visitCount: Int
}

struct MockWorldRuntimeState {
    var currentRegionId: String
    var regionsState: [String: MockRegionRuntimeState]
    var pressure: Int
    var currentTime: Int
}

struct ContentValidationError: Equatable {
    enum ErrorType: Equatable {
        case brokenNeighborLink
        case brokenEventReference
        case duplicateId
        case invalidPressureRange
    }

    let type: ErrorType
    let message: String

    static func == (lhs: ContentValidationError, rhs: ContentValidationError) -> Bool {
        return lhs.type == rhs.type && lhs.message == rhs.message
    }
}

// MARK: - Mock Content Provider

class MockContentProvider {
    private let regions: [MockRegionDefinition] = [
        MockRegionDefinition(
            id: "forest",
            title: LocalizedString(en: "Forest", ru: "Лес"),
            neighborIds: ["village"],
            anchorId: "anchor_forest",
            eventPoolIds: ["pool_forest"],
            initialState: "stable"
        ),
        MockRegionDefinition(
            id: "village",
            title: LocalizedString(en: "Village", ru: "Деревня"),
            neighborIds: ["forest", "mountains"],
            anchorId: nil,
            eventPoolIds: ["pool_village"],
            initialState: "stable"
        ),
        MockRegionDefinition(
            id: "mountains",
            title: LocalizedString(en: "Mountains", ru: "Горы"),
            neighborIds: ["village"],
            anchorId: "anchor_mountains",
            eventPoolIds: ["pool_mountains"],
            initialState: "borderland"
        )
    ]

    private let events: [MockEventDefinition] = [
        MockEventDefinition(
            id: "event_001",
            title: LocalizedString(en: "Event 001", ru: "Событие 001"),
            body: LocalizedString(en: "Event body", ru: "Тело события"),
            choiceIds: ["choice_a", "choice_b"],
            isOneTime: false,
            pressureRange: 0...50,
            regionIds: ["forest"]
        ),
        MockEventDefinition(
            id: "event_002",
            title: LocalizedString(en: "Event 002", ru: "Событие 002"),
            body: LocalizedString(en: "Event body 2", ru: "Тело события 2"),
            choiceIds: ["choice_c"],
            isOneTime: true,
            pressureRange: 30...100,
            regionIds: ["village", "mountains"]
        )
    ]

    func getAllRegionDefinitions() -> [MockRegionDefinition] {
        return regions
    }

    func getRegionDefinition(id: String) -> MockRegionDefinition? {
        return regions.first { $0.id == id }
    }

    func getAllEventDefinitions() -> [MockEventDefinition] {
        return events
    }

    func validate() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []

        // Check neighbor links
        let regionIds = Set(regions.map { $0.id })
        for region in regions {
            for neighborId in region.neighborIds {
                if !regionIds.contains(neighborId) {
                    errors.append(ContentValidationError(
                        type: .brokenNeighborLink,
                        message: "Region \(region.id) references non-existent neighbor \(neighborId)"
                    ))
                }
            }
        }

        return errors
    }
}

class MockContentProviderWithBrokenLinks: MockContentProvider {
    private let brokenRegions: [MockRegionDefinition] = [
        MockRegionDefinition(
            id: "island",
            title: LocalizedString(en: "Island", ru: "Остров"),
            neighborIds: ["nonexistent_region"], // Broken link!
            anchorId: nil,
            eventPoolIds: [],
            initialState: "stable"
        )
    ]

    override func getAllRegionDefinitions() -> [MockRegionDefinition] {
        return brokenRegions
    }

    override func validate() -> [ContentValidationError] {
        var errors: [ContentValidationError] = []
        let regions = getAllRegionDefinitions()
        let regionIds = Set(regions.map { $0.id })

        for region in regions {
            for neighborId in region.neighborIds {
                if !regionIds.contains(neighborId) {
                    errors.append(ContentValidationError(
                        type: .brokenNeighborLink,
                        message: "Region \(region.id) references non-existent neighbor \(neighborId)"
                    ))
                }
            }
        }

        return errors
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/EncounterFateFlowTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Tests that EncounterEngine surfaces FateDrawResult and deck counts
/// after every action that draws a Fate Card.
final class EncounterFateFlowTests: XCTestCase {

    // MARK: - Physical attack sets lastFateDrawResult

    func testPhysicalAttackSetsFateDrawResult() {
        let ctx = EncounterContextFixtures.standard()
        let engine = EncounterEngine(context: ctx)

        XCTAssertNil(engine.lastFateDrawResult, "No fate draw before any action")

        let initialDraw = engine.fateDeckDrawCount
        let result = engine.performAction(.attack(targetId: "test_enemy"))

        XCTAssertTrue(result.success)
        XCTAssertNotNil(engine.lastFateDrawResult, "Fate draw result set after attack")
        XCTAssertEqual(engine.fateDeckDrawCount, initialDraw - 1, "Draw pile shrinks by 1")
        XCTAssertEqual(engine.fateDeckDiscardCount, 1, "Discard pile grows by 1")

        // State change includes fateDraw
        let fateDrawChanges = result.stateChanges.filter {
            if case .fateDraw = $0 { return true }
            return false
        }
        XCTAssertEqual(fateDrawChanges.count, 1, "Exactly one fateDraw state change")
    }

    // MARK: - Spirit attack sets lastFateDrawResult

    func testSpiritAttackSetsFateDrawResult() {
        let ctx = EncounterContextFixtures.standard() // enemy has wp=30
        let engine = EncounterEngine(context: ctx)

        let result = engine.performAction(.spiritAttack(targetId: "test_enemy"))

        XCTAssertTrue(result.success)
        XCTAssertNotNil(engine.lastFateDrawResult, "Fate draw result set after spirit attack")
    }

    // MARK: - Enemy resolution sets lastFateDrawResult (attack intent)

    func testEnemyResolutionSetsFateDrawResult() {
        let ctx = EncounterContextFixtures.standard()
        let engine = EncounterEngine(context: ctx)

        // Generate attack intent
        let intent = engine.generateIntent(for: "test_enemy")
        XCTAssertEqual(intent.type, .attack, "Default intent should be attack")

        // Advance to enemy resolution
        _ = engine.advancePhase() // intent → playerAction
        _ = engine.advancePhase() // playerAction → enemyResolution

        let result = engine.resolveEnemyAction(enemyId: "test_enemy")
        XCTAssertTrue(result.success)
        XCTAssertNotNil(engine.lastFateDrawResult, "Defense fate draw set during enemy resolution")
    }

    // MARK: - Wait does NOT draw a fate card

    func testWaitDoesNotDrawFate() {
        let ctx = EncounterContextFixtures.standard()
        let engine = EncounterEngine(context: ctx)

        let initialDraw = engine.fateDeckDrawCount
        let result = engine.performAction(.wait)

        XCTAssertTrue(result.success)
        XCTAssertNil(engine.lastFateDrawResult, "Wait should not draw fate")
        XCTAssertEqual(engine.fateDeckDrawCount, initialDraw, "Draw pile unchanged")
    }

    // MARK: - Deck counts update after draws

    func testDeckCountsSyncAfterMultipleDraws() {
        let ctx = EncounterContextFixtures.standard()
        let engine = EncounterEngine(context: ctx)

        let total = engine.fateDeckDrawCount + engine.fateDeckDiscardCount

        // Draw 3 times via attacks
        _ = engine.performAction(.attack(targetId: "test_enemy"))
        _ = engine.performAction(.attack(targetId: "test_enemy"))
        _ = engine.performAction(.attack(targetId: "test_enemy"))

        let newTotal = engine.fateDeckDrawCount + engine.fateDeckDiscardCount
        XCTAssertEqual(newTotal, total, "Total cards stay constant (draw + discard)")
        XCTAssertEqual(engine.fateDeckDiscardCount, 3, "3 cards discarded after 3 attacks")
    }

    // MARK: - Consecutive draws update lastFateDrawResult each time

    func testLastFateDrawResultUpdatesEachDraw() {
        let ctx = EncounterContextFixtures.standard()
        let engine = EncounterEngine(context: ctx)

        _ = engine.performAction(.attack(targetId: "test_enemy"))
        let first = engine.lastFateDrawResult
        XCTAssertNotNil(first)

        _ = engine.performAction(.attack(targetId: "test_enemy"))
        let second = engine.lastFateDrawResult
        XCTAssertNotNil(second)

        // They should be different cards (deterministic deck has distinct cards)
        XCTAssertNotEqual(first?.card.id, second?.card.id, "Second draw should be a different card")
    }

    // MARK: - FateDrawResult contains effectiveValue with resonance

    func testFateDrawResultHasEffectiveValue() {
        let ctx = EncounterContextFixtures.standard()
        let engine = EncounterEngine(context: ctx)

        _ = engine.performAction(.attack(targetId: "test_enemy"))
        let result = engine.lastFateDrawResult!

        // effectiveValue should be at least baseValue (resonance may add to it)
        XCTAssertNotNil(result.card, "Card should be present")
        // effectiveValue is baseValue + resonance rule bonus (if matched)
        // With worldResonance=0 (yav zone), rules may or may not match
        XCTAssertTrue(result.effectiveValue >= result.card.baseValue - 5,
                       "Effective value should be reasonable")
    }

    // MARK: - Full round: two fate draws (attack + defense)

    func testFullRoundDrawsTwice() {
        let ctx = EncounterContextFixtures.standard()
        let engine = EncounterEngine(context: ctx)

        let initialDraw = engine.fateDeckDrawCount

        // Intent phase → generate attack intent
        _ = engine.generateIntent(for: "test_enemy")
        _ = engine.advancePhase() // intent → playerAction

        // Player attacks (draw 1)
        _ = engine.performAction(.attack(targetId: "test_enemy"))
        let afterAttack = engine.fateDeckDrawCount
        XCTAssertEqual(afterAttack, initialDraw - 1)

        // Advance to enemy resolution
        _ = engine.advancePhase() // playerAction → enemyResolution

        // Enemy resolves attack intent (draw 2)
        _ = engine.resolveEnemyAction(enemyId: "test_enemy")
        let afterDefense = engine.fateDeckDrawCount
        XCTAssertEqual(afterDefense, initialDraw - 2, "Two draws in one full round")
        XCTAssertEqual(engine.fateDeckDiscardCount, 2)
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/EnemyDefinitionTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Tests for EnemyDefinition JSON decoding
/// Verifies that enemies load correctly from JSON content packs
final class EnemyDefinitionTests: XCTestCase {

    // MARK: - Helper

    /// Creates a decoder configured the same way as PackLoader
    private func makeDecoder() -> JSONDecoder {
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        return decoder
    }

    // MARK: - Basic Decoding Tests

    func testDecodeBasicEnemy() throws {
        // Given: JSON with basic enemy data
        let json = """
        {
            "id": "test_enemy",
            "name": {"en": "Test Enemy", "ru": "Тестовый Враг"},
            "description": {"en": "A test enemy.", "ru": "Тестовый враг."},
            "health": 10,
            "power": 3,
            "defense": 1,
            "difficulty": 2,
            "enemy_type": "beast",
            "rarity": "common",
            "abilities": [],
            "loot_card_ids": [],
            "faith_reward": 5,
            "balance_delta": 0
        }
        """.data(using: .utf8)!

        // When: Decoding
        let enemy = try makeDecoder().decode(EnemyDefinition.self, from: json)

        // Then: Fields should match
        XCTAssertEqual(enemy.id, "test_enemy")
        // Check that both locales are available
        XCTAssertEqual(enemy.name.en, "Test Enemy")
        XCTAssertEqual(enemy.name.ru, "Тестовый Враг")
        XCTAssertEqual(enemy.health, 10)
        XCTAssertEqual(enemy.power, 3)
        XCTAssertEqual(enemy.defense, 1)
        XCTAssertEqual(enemy.difficulty, 2)
        XCTAssertEqual(enemy.enemyType, .beast)
        XCTAssertEqual(enemy.rarity, .common)
        XCTAssertEqual(enemy.faithReward, 5)
        XCTAssertEqual(enemy.balanceDelta, 0)
    }

    func testDecodeEnemyWithSnakeCaseFields() throws {
        // Given: JSON with snake_case fields
        let json = """
        {
            "id": "snake_case_test",
            "name": {"en": "Snake Case", "ru": "Змейка"},
            "description": {"en": "Test", "ru": "Тест"},
            "health": 8,
            "power": 2,
            "defense": 1,
            "difficulty": 1,
            "enemy_type": "spirit",
            "rarity": "uncommon",
            "abilities": [],
            "loot_card_ids": ["card1", "card2"],
            "faith_reward": 3,
            "balance_delta": -5
        }
        """.data(using: .utf8)!

        // When: Decoding
        let enemy = try makeDecoder().decode(EnemyDefinition.self, from: json)

        // Then: Snake case fields should be mapped correctly
        XCTAssertEqual(enemy.enemyType, .spirit)
        XCTAssertEqual(enemy.lootCardIds, ["card1", "card2"])
        XCTAssertEqual(enemy.faithReward, 3)
        XCTAssertEqual(enemy.balanceDelta, -5)
    }

    // MARK: - Enemy Type Tests

    func testAllEnemyTypesDecodable() throws {
        let types = ["beast", "spirit", "undead", "demon", "human", "boss"]
        let expectedTypes: [EnemyType] = [.beast, .spirit, .undead, .demon, .human, .boss]

        for (jsonType, expectedType) in zip(types, expectedTypes) {
            let json = """
            {
                "id": "type_test",
                "name": {"en": "Test", "ru": "Тест"},
                "description": {"en": "Test", "ru": "Тест"},
                "health": 5,
                "power": 1,
                "defense": 0,
                "difficulty": 1,
                "enemy_type": "\(jsonType)",
                "rarity": "common",
                "abilities": [],
                "loot_card_ids": [],
                "faith_reward": 1,
                "balance_delta": 0
            }
            """.data(using: .utf8)!

            let enemy = try makeDecoder().decode(EnemyDefinition.self, from: json)
            XCTAssertEqual(enemy.enemyType, expectedType, "Failed for type: \(jsonType)")
        }
    }

    // MARK: - Enemy Ability Tests

    func testDecodeEnemyWithBonusDamageAbility() throws {
        // Given: JSON with bonus_damage ability
        let json = """
        {
            "id": "ability_test",
            "name": {"en": "Rager", "ru": "Берсерк"},
            "description": {"en": "Test", "ru": "Тест"},
            "health": 10,
            "power": 4,
            "defense": 1,
            "difficulty": 2,
            "enemy_type": "beast",
            "rarity": "uncommon",
            "abilities": [
                {
                    "id": "rage",
                    "name": {"en": "Rage", "ru": "Ярость"},
                    "description": {"en": "Extra damage", "ru": "Доп. урон"},
                    "effect": {"bonus_damage": 3}
                }
            ],
            "loot_card_ids": [],
            "faith_reward": 4,
            "balance_delta": 0
        }
        """.data(using: .utf8)!

        // When: Decoding
        let enemy = try makeDecoder().decode(EnemyDefinition.self, from: json)

        // Then: Ability should be decoded correctly
        XCTAssertEqual(enemy.abilities.count, 1)
        XCTAssertEqual(enemy.abilities[0].id, "rage")

        if case .bonusDamage(let damage) = enemy.abilities[0].effect {
            XCTAssertEqual(damage, 3)
        } else {
            XCTFail("Expected bonusDamage effect")
        }
    }

    func testDecodeEnemyWithRegenerationAbility() throws {
        // Given: JSON with regeneration ability
        let json = """
        {
            "id": "regen_test",
            "name": {"en": "Troll", "ru": "Тролль"},
            "description": {"en": "Test", "ru": "Тест"},
            "health": 15,
            "power": 3,
            "defense": 2,
            "difficulty": 3,
            "enemy_type": "beast",
            "rarity": "rare",
            "abilities": [
                {
                    "id": "regen",
                    "name": {"en": "Regeneration", "ru": "Регенерация"},
                    "description": {"en": "Heals each turn", "ru": "Лечится каждый ход"},
                    "effect": {"regeneration": 2}
                }
            ],
            "loot_card_ids": [],
            "faith_reward": 6,
            "balance_delta": 0
        }
        """.data(using: .utf8)!

        // When: Decoding
        let enemy = try makeDecoder().decode(EnemyDefinition.self, from: json)

        // Then: Regeneration ability should be decoded
        XCTAssertEqual(enemy.abilities.count, 1)
        if case .regeneration(let amount) = enemy.abilities[0].effect {
            XCTAssertEqual(amount, 2)
        } else {
            XCTFail("Expected regeneration effect")
        }
    }

    func testDecodeEnemyWithArmorAbility() throws {
        // Given: JSON with armor ability
        let json = """
        {
            "id": "armor_test",
            "name": {"en": "Guardian", "ru": "Страж"},
            "description": {"en": "Test", "ru": "Тест"},
            "health": 12,
            "power": 2,
            "defense": 4,
            "difficulty": 2,
            "enemy_type": "spirit",
            "rarity": "uncommon",
            "abilities": [
                {
                    "id": "stone_skin",
                    "name": {"en": "Stone Skin", "ru": "Каменная Кожа"},
                    "description": {"en": "Reduces damage", "ru": "Уменьшает урон"},
                    "effect": {"armor": 2}
                }
            ],
            "loot_card_ids": [],
            "faith_reward": 5,
            "balance_delta": 5
        }
        """.data(using: .utf8)!

        // When: Decoding
        let enemy = try makeDecoder().decode(EnemyDefinition.self, from: json)

        // Then: Armor ability should be decoded
        if case .armor(let amount) = enemy.abilities[0].effect {
            XCTAssertEqual(amount, 2)
        } else {
            XCTFail("Expected armor effect")
        }
    }

    func testDecodeEnemyWithApplyCurseAbility() throws {
        // Given: JSON with apply_curse ability
        let json = """
        {
            "id": "curse_test",
            "name": {"en": "Witch", "ru": "Ведьма"},
            "description": {"en": "Test", "ru": "Тест"},
            "health": 8,
            "power": 5,
            "defense": 1,
            "difficulty": 3,
            "enemy_type": "demon",
            "rarity": "rare",
            "abilities": [
                {
                    "id": "curse",
                    "name": {"en": "Curse Touch", "ru": "Проклятие"},
                    "description": {"en": "Curses on hit", "ru": "Проклинает при ударе"},
                    "effect": {"apply_curse": "weakness"}
                }
            ],
            "loot_card_ids": [],
            "faith_reward": 7,
            "balance_delta": -10
        }
        """.data(using: .utf8)!

        // When: Decoding
        let enemy = try makeDecoder().decode(EnemyDefinition.self, from: json)

        // Then: Apply curse ability should be decoded
        if case .applyCurse(let curseId) = enemy.abilities[0].effect {
            XCTAssertEqual(curseId, "weakness")
        } else {
            XCTFail("Expected applyCurse effect")
        }
    }

    // MARK: - Card Conversion Tests

    func testEnemyToCardConversion() throws {
        // Given: Enemy definition
        let json = """
        {
            "id": "card_test",
            "name": {"en": "Wild Beast", "ru": "Дикий Зверь"},
            "description": {"en": "A wild beast.", "ru": "Дикий зверь."},
            "health": 8,
            "power": 3,
            "defense": 1,
            "difficulty": 1,
            "enemy_type": "beast",
            "rarity": "common",
            "abilities": [],
            "loot_card_ids": [],
            "faith_reward": 2,
            "balance_delta": 0
        }
        """.data(using: .utf8)!

        let enemy = try makeDecoder().decode(EnemyDefinition.self, from: json)

        // When: Converting to card
        let card = enemy.toCard()

        // Then: Card should have correct values
        // Card name depends on system locale - just verify it's one of the localized values
        XCTAssertTrue(card.name == "Wild Beast" || card.name == "Дикий Зверь")
        XCTAssertEqual(card.type, .monster)
        XCTAssertEqual(card.health, 8)
        XCTAssertEqual(card.power, 3)
        XCTAssertEqual(card.defense, 1)
        XCTAssertEqual(card.rarity, .common)
    }

    // MARK: - Will & Resonance Behavior Tests

    func testWillFieldIsOptional() throws {
        // Given: JSON without will field (legacy format)
        let json = """
        {
            "id": "no_will",
            "name": {"en": "Beast", "ru": "Зверь"},
            "description": {"en": "Test", "ru": "Тест"},
            "health": 10, "power": 3, "defense": 1, "difficulty": 1,
            "enemy_type": "beast", "rarity": "common",
            "abilities": [], "loot_card_ids": [],
            "faith_reward": 1, "balance_delta": 0
        }
        """.data(using: .utf8)!

        let enemy = try makeDecoder().decode(EnemyDefinition.self, from: json)
        XCTAssertNil(enemy.will)
        XCTAssertNil(enemy.resonanceBehavior)
    }

    func testResonanceBehaviorDecodes() throws {
        // Given: JSON with will and resonance_behavior
        let json = """
        {
            "id": "spirit_enemy",
            "name": {"en": "Spirit", "ru": "Дух"},
            "description": {"en": "Test", "ru": "Тест"},
            "health": 12, "power": 4, "defense": 2, "difficulty": 3,
            "will": 5,
            "enemy_type": "spirit", "rarity": "uncommon",
            "resonance_behavior": {
                "deepNav": {"power_delta": 2, "defense_delta": 1, "health_delta": 5, "will_delta": 3},
                "deepPrav": {"power_delta": -1, "defense_delta": -1, "health_delta": -3, "will_delta": -2}
            },
            "abilities": [], "loot_card_ids": [],
            "faith_reward": 5, "balance_delta": 0
        }
        """.data(using: .utf8)!

        let enemy = try makeDecoder().decode(EnemyDefinition.self, from: json)
        XCTAssertEqual(enemy.will, 5)
        XCTAssertNotNil(enemy.resonanceBehavior)
        XCTAssertEqual(enemy.resonanceBehavior?["deepNav"]?.powerDelta, 2)
        XCTAssertEqual(enemy.resonanceBehavior?["deepNav"]?.healthDelta, 5)
        XCTAssertEqual(enemy.resonanceBehavior?["deepPrav"]?.powerDelta, -1)
    }

    // MARK: - Multiple Abilities Test

    func testDecodeEnemyWithMultipleAbilities() throws {
        // Given: Boss enemy with multiple abilities
        let json = """
        {
            "id": "boss_test",
            "name": {"en": "Leshy Guardian", "ru": "Леший-Хранитель"},
            "description": {"en": "Ancient guardian.", "ru": "Древний страж."},
            "health": 25,
            "power": 7,
            "defense": 4,
            "difficulty": 5,
            "enemy_type": "boss",
            "rarity": "legendary",
            "abilities": [
                {
                    "id": "nature_wrath",
                    "name": {"en": "Nature's Wrath", "ru": "Гнев Природы"},
                    "description": {"en": "Regenerates health", "ru": "Восстанавливает здоровье"},
                    "effect": {"regeneration": 3}
                },
                {
                    "id": "ancient_armor",
                    "name": {"en": "Ancient Armor", "ru": "Древняя Броня"},
                    "description": {"en": "Thick bark", "ru": "Толстая кора"},
                    "effect": {"armor": 2}
                }
            ],
            "loot_card_ids": ["guardian_seal", "ancient_power"],
            "faith_reward": 20,
            "balance_delta": 20
        }
        """.data(using: .utf8)!

        // When: Decoding
        let enemy = try makeDecoder().decode(EnemyDefinition.self, from: json)

        // Then: Should have two abilities
        XCTAssertEqual(enemy.abilities.count, 2)
        XCTAssertEqual(enemy.enemyType, .boss)
        XCTAssertEqual(enemy.rarity, .legendary)
        XCTAssertEqual(enemy.lootCardIds.count, 2)
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/FateAttackTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Tests for Fate-based attack resolution (calculateAttackWithFate)
/// and the updated .combatAttack(effortCards:bonusDamage:) engine action
final class FateAttackTests: XCTestCase {

    // MARK: - calculateAttackWithFate

    func testFateAttackHit() {
        // Setup: strength 5, fate card +2, defense 5
        // totalAttack = 5 + 0(effort) + 2(fate) + 0(bonus) = 7 >= 5 -> hit
        // damage = max(1, 7 - 5 + 2) = 4
        let cards = [FateCard(id: "f1", modifier: 2, name: "Fortune")]
        let deck = FateDeckManager(cards: cards)
        let context = CombatPlayerContext(
            health: 10, maxHealth: 10, faith: 5, balance: 50, strength: 5,
            activeCurses: [], heroBonusDice: 0, heroDamageBonus: 0
        )

        let result = CombatCalculator.calculateAttackWithFate(
            context: context, fateDeck: deck, worldResonance: 0,
            effortCards: 0, monsterDefense: 5, bonusDamage: 0
        )

        XCTAssertTrue(result.isHit)
        XCTAssertEqual(result.baseStrength, 5)
        XCTAssertEqual(result.totalAttack, 7)  // 5 + 2
        XCTAssertEqual(result.damage, 4)       // max(1, 7-5+2)
        XCTAssertNotNil(result.fateDrawResult)
    }

    func testFateAttackMiss() {
        // strength 3, fate -2, defense 5 -> total = 3 + (-2) = 1 < 5 -> miss
        let cards = [FateCard(id: "f1", modifier: -2, name: "Curse")]
        let deck = FateDeckManager(cards: cards)
        let context = CombatPlayerContext(
            health: 10, maxHealth: 10, faith: 5, balance: 50, strength: 3,
            activeCurses: [], heroBonusDice: 0, heroDamageBonus: 0
        )

        let result = CombatCalculator.calculateAttackWithFate(
            context: context, fateDeck: deck, worldResonance: 0,
            effortCards: 0, monsterDefense: 5, bonusDamage: 0
        )

        XCTAssertFalse(result.isHit)
        XCTAssertEqual(result.damage, 0)
    }

    func testFateAttackWithEffort() {
        // strength 3, fate -1, effort 3, defense 5
        // total = 3 + 3 + (-1) + 0 = 5 >= 5 -> hit
        let cards = [FateCard(id: "f1", modifier: -1, name: "Bad")]
        let deck = FateDeckManager(cards: cards)
        let context = CombatPlayerContext(
            health: 10, maxHealth: 10, faith: 5, balance: 50, strength: 3,
            activeCurses: [], heroBonusDice: 0, heroDamageBonus: 0
        )

        let result = CombatCalculator.calculateAttackWithFate(
            context: context, fateDeck: deck, worldResonance: 0,
            effortCards: 3, monsterDefense: 5, bonusDamage: 0
        )

        XCTAssertEqual(result.effortBonus, 3)
        XCTAssertEqual(result.totalAttack, 5)  // 3 + 3 + (-1)
        XCTAssertTrue(result.isHit)
    }

    func testFateAttackResonanceModifiesFate() {
        // Card has resonance rule: in deepNav zone, modifyValue = -3
        // effectiveValue = 1 + (-3) = -2
        let cards = [FateCard(
            id: "nav_card", modifier: 1, name: "Nav Wind",
            resonanceRules: [FateResonanceRule(zone: .deepNav, modifyValue: -3)]
        )]
        let deck = FateDeckManager(cards: cards)
        let context = CombatPlayerContext(
            health: 10, maxHealth: 10, faith: 5, balance: 50, strength: 5,
            activeCurses: [], heroBonusDice: 0, heroDamageBonus: 0
        )

        // deepNav zone requires resonance <= -61
        let result = CombatCalculator.calculateAttackWithFate(
            context: context, fateDeck: deck, worldResonance: -80,
            effortCards: 0, monsterDefense: 5, bonusDamage: 0
        )

        XCTAssertEqual(result.fateDrawResult?.effectiveValue, -2)
        XCTAssertEqual(result.totalAttack, 3)  // 5 + (-2)
    }

    func testFateAttackReturnsSideEffects() {
        let cards = [FateCard(
            id: "f1", modifier: 1, name: "Shifting",
            onDrawEffects: [FateDrawEffect(type: .shiftResonance, value: -5)]
        )]
        let deck = FateDeckManager(cards: cards)
        let context = CombatPlayerContext(
            health: 10, maxHealth: 10, faith: 5, balance: 50, strength: 5,
            activeCurses: [], heroBonusDice: 0, heroDamageBonus: 0
        )

        let result = CombatCalculator.calculateAttackWithFate(
            context: context, fateDeck: deck, worldResonance: 0,
            effortCards: 0, monsterDefense: 5, bonusDamage: 0
        )

        XCTAssertEqual(result.fateDrawEffects.count, 1)
        XCTAssertEqual(result.fateDrawEffects.first?.type, .shiftResonance)
        XCTAssertEqual(result.fateDrawEffects.first?.value, -5)
    }

    func testFateAttackFallbackWithoutDeck() {
        // No fate deck -> uses random fallback in range -1...2
        let context = CombatPlayerContext(
            health: 10, maxHealth: 10, faith: 5, balance: 50, strength: 5,
            activeCurses: [], heroBonusDice: 0, heroDamageBonus: 0
        )

        let result = CombatCalculator.calculateAttackWithFate(
            context: context, fateDeck: nil, worldResonance: 0,
            effortCards: 0, monsterDefense: 5, bonusDamage: 0
        )

        XCTAssertNil(result.fateDrawResult)
        // totalAttack = 5 + random(-1...2), so 4..7
        XCTAssertTrue(result.totalAttack >= 4 && result.totalAttack <= 7,
            "totalAttack should be in range 4...7, got \(result.totalAttack)")
    }

    // MARK: - Engine Integration

    func testCombatAttackActionUsesFateDeck() {
        let engine = TwilightGameEngine()
        engine.initializeNewGame()

        let fateCards = [FateCard(id: "f1", modifier: 2, name: "Fortune")]
        engine.setupFateDeck(cards: fateCards)

        let enemy = Card(
            id: "test_enemy", name: "Beast", type: .monster, description: "Test",
            defense: 10, health: 20
        )
        engine.setupCombatEnemy(enemy)

        let healthBefore = engine.combatEnemyHealth
        let result = engine.performAction(.combatAttack(effortCards: 0, bonusDamage: 0))

        // Default strength is 5, fate +2 -> totalAttack = 7 < defense 10 -> miss
        let hasDamage = result.stateChanges.contains { change in
            if case .enemyDamaged = change { return true }
            return false
        }
        XCTAssertFalse(hasDamage, "Strength 5 + fate 2 = 7 should miss defense 10")
        XCTAssertEqual(engine.combatEnemyHealth, healthBefore)
    }

    func testCombatAttackEffortDiscardsCards() {
        let engine = TwilightGameEngine()

        let startingDeck = [
            Card(id: "s1", name: "Strike", type: .attack, description: "Attack", power: 3),
            Card(id: "s2", name: "Strike", type: .attack, description: "Attack", power: 3),
            Card(id: "d1", name: "Defend", type: .defense, description: "Defense", defense: 2),
            Card(id: "d2", name: "Defend", type: .defense, description: "Defense", defense: 2),
            Card(id: "h1", name: "Heal", type: .spell, description: "Heal")
        ]
        engine.initializeNewGame(playerName: "Test", heroId: nil, startingDeck: startingDeck)

        let fateCards = [FateCard(id: "f1", modifier: 0, name: "Neutral")]
        engine.setupFateDeck(cards: fateCards)

        let enemy = Card(
            id: "test_enemy", name: "Beast", type: .monster, description: "Test",
            defense: 5, health: 20
        )
        engine.setupCombatEnemy(enemy)
        engine.performAction(.combatInitialize)

        let handBefore = engine.playerHand.count

        _ = engine.performAction(.combatAttack(effortCards: 2, bonusDamage: 0))

        // Should have discarded up to 2 cards from hand
        let expectedDiscard = min(2, handBefore)
        XCTAssertEqual(engine.playerHand.count, handBefore - expectedDiscard,
            "Effort cards should be removed from hand")
    }

    func testCombatAttackAppliesFateDrawEffects() {
        let engine = TwilightGameEngine()
        engine.initializeNewGame()

        let fateCards = [FateCard(
            id: "f1", modifier: 1, name: "Resonance Shifter",
            onDrawEffects: [FateDrawEffect(type: .shiftTension, value: 2)]
        )]
        engine.setupFateDeck(cards: fateCards)

        let enemy = Card(
            id: "test_enemy", name: "Beast", type: .monster, description: "Test",
            defense: 1, health: 20
        )
        engine.setupCombatEnemy(enemy)

        let tensionBefore = engine.worldTension
        let result = engine.performAction(.combatAttack(effortCards: 0, bonusDamage: 0))

        let hasTensionChange = result.stateChanges.contains { change in
            if case .tensionChanged = change { return true }
            return false
        }
        XCTAssertTrue(hasTensionChange, "Fate draw effects should be applied through attack pipeline")
        XCTAssertEqual(engine.worldTension, tensionBefore + 2)
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/FateDeckManagerTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Tests for FateDeckManager — fate card draw/discard/reshuffle mechanics
final class FateDeckManagerTests: XCTestCase {

    // MARK: - Helpers

    private func makeTestCards() -> [FateCard] {
        [
            FateCard(id: "fate_plus1", modifier: 1, name: "+1"),
            FateCard(id: "fate_zero", modifier: 0, name: "0"),
            FateCard(id: "fate_minus1", modifier: -1, name: "-1"),
            FateCard(id: "fate_crit", modifier: 2, isCritical: true, name: "Crit"),
        ]
    }

    private func makeRNG(seed: UInt64 = 42) -> WorldRNG {
        WorldRNG(seed: seed)
    }

    // MARK: - Basic Draw

    func testDrawReturnsCard() {
        let rng = makeRNG()
        let deck = FateDeckManager(cards: makeTestCards(), rng: rng)

        let card = deck.draw()
        XCTAssertNotNil(card)
        XCTAssertEqual(deck.drawPile.count, 3)
        XCTAssertEqual(deck.discardPile.count, 1)
    }

    func testDrawAllCards() {
        let rng = makeRNG()
        let cards = makeTestCards()
        let deck = FateDeckManager(cards: cards, rng: rng)

        var drawn: [FateCard] = []
        for _ in 0..<4 {
            if let card = deck.draw() {
                drawn.append(card)
            }
        }
        XCTAssertEqual(drawn.count, 4)
        XCTAssertEqual(deck.drawPile.count, 0)
        XCTAssertEqual(deck.discardPile.count, 4)
    }

    // MARK: - Depletion & Reshuffle

    func testDeckDepletionReshuffles() {
        let rng = makeRNG()
        let deck = FateDeckManager(cards: makeTestCards(), rng: rng)

        // Draw all 4
        for _ in 0..<4 { _ = deck.draw() }
        XCTAssertEqual(deck.drawPile.count, 0)

        // Next draw triggers reshuffle
        let card = deck.draw()
        XCTAssertNotNil(card)
        // After reshuffle + draw: 3 in draw, 1 in discard
        XCTAssertEqual(deck.drawPile.count, 3)
        XCTAssertEqual(deck.discardPile.count, 1)
    }

    func testDrawFromEmptyDeckReturnsNil() {
        let rng = makeRNG()
        let deck = FateDeckManager(cards: [], rng: rng)
        XCTAssertNil(deck.draw())
    }

    // MARK: - Sticky Cards

    func testStickyCardsReturn() {
        let rng = makeRNG()
        let cards = [
            FateCard(id: "curse", modifier: -1, isSticky: true, name: "Curse"),
            FateCard(id: "normal", modifier: 0, name: "Normal"),
        ]
        let deck = FateDeckManager(cards: cards, rng: rng)

        // Draw both
        _ = deck.draw()
        _ = deck.draw()
        XCTAssertEqual(deck.discardPile.count, 2)

        // Reshuffle — sticky cards stay in deck
        deck.reshuffle()
        XCTAssertEqual(deck.drawPile.count, 2)
        XCTAssertTrue(deck.drawPile.contains(where: { $0.id == "curse" }))
    }

    // MARK: - Remove Card

    func testRemoveCard() {
        let rng = makeRNG()
        let deck = FateDeckManager(cards: makeTestCards(), rng: rng)
        let totalBefore = deck.drawPile.count + deck.discardPile.count

        let removed = deck.removeCard(id: "fate_crit")
        XCTAssertTrue(removed)

        let totalAfter = deck.drawPile.count + deck.discardPile.count
        XCTAssertEqual(totalAfter, totalBefore - 1)
    }

    func testRemoveNonexistentCard() {
        let rng = makeRNG()
        let deck = FateDeckManager(cards: makeTestCards(), rng: rng)
        XCTAssertFalse(deck.removeCard(id: "nonexistent"))
    }

    func testRemoveCardFromDiscard() {
        let rng = makeRNG()
        let deck = FateDeckManager(cards: makeTestCards(), rng: rng)

        // Draw a card so it goes to discard
        let drawn = deck.draw()!
        let removed = deck.removeCard(id: drawn.id)
        XCTAssertTrue(removed)
        XCTAssertFalse(deck.discardPile.contains(where: { $0.id == drawn.id }))
    }

    // MARK: - Deterministic Shuffle

    func testDeterministicShuffle() {
        let cards = makeTestCards()

        // Same seed → same order
        let rng1 = makeRNG(seed: 123)
        let deck1 = FateDeckManager(cards: cards, rng: rng1)
        let order1 = deck1.drawPile.map(\.id)

        let rng2 = makeRNG(seed: 123)
        let deck2 = FateDeckManager(cards: cards, rng: rng2)
        let order2 = deck2.drawPile.map(\.id)

        XCTAssertEqual(order1, order2)
    }

    // MARK: - Save/Restore

    func testSaveRestore() {
        let rng = makeRNG()
        let deck = FateDeckManager(cards: makeTestCards(), rng: rng)

        // Draw 2 cards
        _ = deck.draw()
        _ = deck.draw()

        let state = deck.getState()
        XCTAssertEqual(state.drawPile.count, 2)
        XCTAssertEqual(state.discardPile.count, 2)

        // Create new deck and restore
        let rng2 = makeRNG()
        let deck2 = FateDeckManager(cards: [], rng: rng2)
        deck2.restoreState(state)

        XCTAssertEqual(deck2.drawPile.map(\.id), deck.drawPile.map(\.id))
        XCTAssertEqual(deck2.discardPile.map(\.id), deck.discardPile.map(\.id))
    }

    // MARK: - Add Card

    func testAddCard() {
        let rng = makeRNG()
        let deck = FateDeckManager(cards: makeTestCards(), rng: rng)
        let countBefore = deck.drawPile.count

        let blessing = FateCard(id: "blessing", modifier: 2, name: "Blessing")
        deck.addCard(blessing)

        XCTAssertEqual(deck.drawPile.count, countBefore + 1)
        XCTAssertTrue(deck.drawPile.contains(where: { $0.id == "blessing" }))
    }

    // MARK: - Draw and Resolve (Resonance-Aware)

    func testDrawAndResolveBasicValue() {
        let rng = makeRNG()
        let cards = [FateCard(id: "f1", modifier: 2, name: "Fortune", suit: .prav)]
        let deck = FateDeckManager(cards: cards, rng: rng)

        let result = deck.drawAndResolve(worldResonance: 0.0)
        XCTAssertNotNil(result)
        XCTAssertEqual(result!.effectiveValue, 2, "No matching rule → effectiveValue == baseValue")
        XCTAssertNil(result!.appliedRule)
    }

    func testDrawAndResolveAppliesResonanceRule() {
        let rng = makeRNG()
        let rule = FateResonanceRule(zone: .deepPrav, modifyValue: 3)
        let cards = [FateCard(id: "f1", modifier: 1, name: "Fortune", suit: .prav, resonanceRules: [rule])]
        let deck = FateDeckManager(cards: cards, rng: rng)

        // deepPrav zone: resonance 70
        let result = deck.drawAndResolve(worldResonance: 70.0)
        XCTAssertNotNil(result)
        XCTAssertEqual(result!.effectiveValue, 4, "baseValue(1) + rule(3) = 4")
        XCTAssertEqual(result!.appliedRule, rule)
    }

    func testDrawAndResolveNoMatchingRule() {
        let rng = makeRNG()
        let rule = FateResonanceRule(zone: .deepNav, modifyValue: -2)
        let cards = [FateCard(id: "f1", modifier: 1, name: "Fortune", suit: .prav, resonanceRules: [rule])]
        let deck = FateDeckManager(cards: cards, rng: rng)

        // yav zone: resonance 0 — rule doesn't match
        let result = deck.drawAndResolve(worldResonance: 0.0)
        XCTAssertEqual(result!.effectiveValue, 1, "No matching rule → baseValue only")
        XCTAssertNil(result!.appliedRule)
    }

    func testDrawAndResolveReturnsDrawEffects() {
        let rng = makeRNG()
        let effects = [FateDrawEffect(type: .shiftResonance, value: -5), FateDrawEffect(type: .shiftTension, value: 3)]
        let cards = [FateCard(id: "curse", modifier: -2, isSticky: true, name: "Curse", suit: .nav, onDrawEffects: effects)]
        let deck = FateDeckManager(cards: cards, rng: rng)

        let result = deck.drawAndResolve(worldResonance: 0.0)
        XCTAssertEqual(result!.drawEffects.count, 2)
        XCTAssertEqual(result!.drawEffects[0].type, .shiftResonance)
        XCTAssertEqual(result!.drawEffects[0].value, -5)
        XCTAssertEqual(result!.drawEffects[1].type, .shiftTension)
        XCTAssertEqual(result!.drawEffects[1].value, 3)
    }

    func testDrawAndResolveEmptyDeckReturnsNil() {
        let rng = makeRNG()
        let deck = FateDeckManager(cards: [], rng: rng)
        XCTAssertNil(deck.drawAndResolve(worldResonance: 0.0))
    }

    // MARK: - FateCard Suit

    func testFateCardSuit() {
        let navCard = FateCard(id: "n", modifier: -1, name: "Nav", suit: .nav)
        let pravCard = FateCard(id: "p", modifier: 1, name: "Prav", suit: .prav)
        let neutralCard = FateCard(id: "y", modifier: 0, name: "Neutral")

        XCTAssertEqual(navCard.suit, .nav)
        XCTAssertEqual(pravCard.suit, .prav)
        XCTAssertNil(neutralCard.suit)
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/FateSkillCheckTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Tests for Fate Deck integration with SkillCheckResolver (Task 4.1)
final class FateSkillCheckTests: XCTestCase {

    // MARK: - SkillCheckResolver with Fate Deck

    func testSkillCheckUseFateDeckWhenAvailable() {
        let resolver = SkillCheckResolver()
        // Create a deck with only +3 cards (guaranteed success)
        let cards = [FateCard(id: "f1", modifier: 3, isCritical: true, isSticky: false, name: "Crit")]
        resolver.fateDeck = FateDeckManager(cards: cards)

        let challenge = MiniGameChallenge(
            id: "test",
            type: .skillCheck,
            difficulty: 1,
            rewards: MiniGameRewards(flagsToSet: ["test_passed"])
        )
        let context = MiniGameContext(
            playerHealth: 10, playerMaxHealth: 10,
            playerStrength: 5, playerFaith: 3, playerBalance: 50,
            playerResources: [:], worldTension: 0, currentFlags: [:]
        )

        let result = resolver.resolve(challenge: challenge, context: context)
        // strength(5) + fateModifier(3) = 8 >= difficulty*3 = 3
        XCTAssertTrue(result.stateChanges.contains(.flagSet(key: "test_passed", value: true)),
                      "Skill check with strong fate card should succeed")
    }

    func testSkillCheckFailsWithBadFateCard() {
        let resolver = SkillCheckResolver()
        // Create a deck with only -2 cards
        let cards = [FateCard(id: "f1", modifier: -2, isCritical: false, isSticky: true, name: "Curse")]
        resolver.fateDeck = FateDeckManager(cards: cards)

        let challenge = MiniGameChallenge(
            id: "test",
            type: .skillCheck,
            difficulty: 3, // targetNumber = 9
            rewards: MiniGameRewards(flagsToSet: ["test_passed"])
        )
        let context = MiniGameContext(
            playerHealth: 10, playerMaxHealth: 10,
            playerStrength: 5, playerFaith: 3, playerBalance: 50,
            playerResources: [:], worldTension: 0, currentFlags: [:]
        )

        let result = resolver.resolve(challenge: challenge, context: context)
        // strength(5) + fateModifier(-2) = 3 < targetNumber(9)
        XCTAssertFalse(result.stateChanges.contains(.flagSet(key: "test_passed", value: true)),
                       "Skill check with bad fate card should fail")
    }

    func testSkillCheckFallbackWithoutFateDeck() {
        let resolver = SkillCheckResolver()
        // No fateDeck set — should use WorldRNG fallback

        let challenge = MiniGameChallenge(
            id: "test",
            type: .skillCheck,
            difficulty: 1
        )
        let context = MiniGameContext(
            playerHealth: 10, playerMaxHealth: 10,
            playerStrength: 5, playerFaith: 3, playerBalance: 50,
            playerResources: [:], worldTension: 0, currentFlags: [:]
        )

        // Should not crash — falls back to RNG
        let result = resolver.resolve(challenge: challenge, context: context)
        XCTAssertTrue(result.completed, "Skill check should complete even without fate deck")
    }

    func testSkillCheckDrawsFateCard() {
        let resolver = SkillCheckResolver()
        let cards = [
            FateCard(id: "f1", modifier: 0, isCritical: false, isSticky: false, name: "A"),
            FateCard(id: "f2", modifier: 1, isCritical: false, isSticky: false, name: "B"),
        ]
        let deck = FateDeckManager(cards: cards)
        resolver.fateDeck = deck

        let challenge = MiniGameChallenge(id: "test", type: .skillCheck, difficulty: 1)
        let context = MiniGameContext(
            playerHealth: 10, playerMaxHealth: 10,
            playerStrength: 5, playerFaith: 3, playerBalance: 50,
            playerResources: [:], worldTension: 0, currentFlags: [:]
        )

        _ = resolver.resolve(challenge: challenge, context: context)

        // One card should have been drawn (moved to discard)
        XCTAssertEqual(deck.discardPile.count, 1, "Fate deck should have one card in discard after skill check")
    }

    // MARK: - Engine Fate Deck Setup

    func testEngineSetupFateDeck() {
        let engine = TwilightGameEngine()
        XCTAssertNil(engine.fateDeck, "Fate deck should be nil before setup")

        let cards = [FateCard(id: "f1", modifier: 0, isCritical: false, isSticky: false, name: "Test")]
        engine.setupFateDeck(cards: cards)

        XCTAssertNotNil(engine.fateDeck, "Fate deck should be set after setup")
        XCTAssertEqual(engine.fateDeck?.drawPile.count, 1)
    }

    // MARK: - MiniGameDispatcher Fate Deck Wiring

    func testDispatcherPassesFateDeckToResolver() {
        let dispatcher = MiniGameDispatcher()
        let cards = [FateCard(id: "f1", modifier: 3, isCritical: true, isSticky: false, name: "Crit")]
        let deck = FateDeckManager(cards: cards)
        dispatcher.setFateDeck(deck)

        let challenge = MiniGameChallenge(
            id: "test",
            type: .skillCheck,
            difficulty: 1,
            rewards: MiniGameRewards(flagsToSet: ["wired"])
        )
        let context = MiniGameContext(
            playerHealth: 10, playerMaxHealth: 10,
            playerStrength: 5, playerFaith: 3, playerBalance: 50,
            playerResources: [:], worldTension: 0, currentFlags: [:]
        )

        let result = dispatcher.dispatch(challenge: challenge, context: context)
        XCTAssertTrue(result.stateChanges.contains(.flagSet(key: "wired", value: true)),
                      "Dispatcher should route skill check through fate deck")
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/GameplayFlowTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Tests for gameplay flow - regions, travel, events, choices
/// These tests verify the critical user paths work correctly
final class GameplayFlowTests: XCTestCase {

    var engine: TwilightGameEngine!

    override func setUp() {
        super.setUp()
        TestContentLoader.loadContentPacksIfNeeded()
        engine = TwilightGameEngine()
        engine.initializeNewGame(playerName: "Test", heroId: nil)
    }

    override func tearDown() {
        engine = nil
        super.tearDown()
    }

    /// Helper to fail test if regions not loaded
    private func requireRegionsLoaded() -> Bool {
        if engine.regionsArray.isEmpty {
            XCTFail("Skipping: ContentPack not loaded (no regions)")
            return false
        }
        return true
    }

    // MARK: - Region Tests

    func testRegionsArrayNotEmpty() {
        guard requireRegionsLoaded() else { return }
        // Given: Engine initialized
        // When: Accessing regions
        let regions = engine.regionsArray

        // Then: Should have regions
        XCTAssertFalse(regions.isEmpty, "Engine should have at least one region")
    }

    func testCurrentRegionExists() {
        guard requireRegionsLoaded() else { return }
        // Given: Engine initialized
        // When: Checking current region
        let currentRegionId = engine.currentRegionId

        // Then: Should have current region
        XCTAssertNotNil(currentRegionId, "Engine should have current region ID")

        // And current region should be in regionsArray
        let currentRegion = engine.regionsArray.first { $0.id == currentRegionId }
        XCTAssertNotNil(currentRegion, "Current region should exist in regionsArray")
    }

    func testRegionHasRequiredProperties() {
        guard requireRegionsLoaded() else { return }
        // Given: Engine with regions
        guard let region = engine.regionsArray.first else {
            XCTFail("No regions available"); return
        }

        // Then: Region should have required properties
        XCTAssertFalse(region.name.isEmpty, "Region should have name")
        // ID is UUID, always valid
        XCTAssertNotNil(region.id, "Region should have ID")
    }

    // MARK: - Travel Tests

    func testTravelToNeighborRegion() {
        guard requireRegionsLoaded() else { return }
        // Given: Current region with neighbors
        guard let currentRegion = engine.currentRegion else {
            XCTFail("No current region"); return
        }

        guard let neighborId = currentRegion.neighborIds.first else {
            XCTFail("Current region has no neighbors to travel to"); return
        }

        let initialRegionId = engine.currentRegionId

        // When: Traveling to neighbor
        let result = engine.performAction(.travel(toRegionId: neighborId))

        // Then: Travel should succeed
        XCTAssertTrue(result.success, "Travel to neighbor should succeed")

        // And current region should change
        XCTAssertNotEqual(engine.currentRegionId, initialRegionId, "Current region should change after travel")
        XCTAssertEqual(engine.currentRegionId, neighborId, "Current region should be destination")
    }

    func testTravelAdvancesTime() {
        // Given: Current day
        let initialDay = engine.currentDay

        guard let currentRegion = engine.currentRegion,
              let neighborId = currentRegion.neighborIds.first else {
            XCTFail("Cannot test travel time - no neighbors"); return
        }

        // When: Traveling
        let _ = engine.performAction(.travel(toRegionId: neighborId))

        // Then: Day should advance
        XCTAssertGreaterThan(engine.currentDay, initialDay, "Travel should advance time")
    }

    func testCannotTravelToNonNeighbor() {
        guard requireRegionsLoaded() else { return }
        // Given: A region that is not a neighbor
        guard let currentRegion = engine.currentRegion else {
            XCTFail("No current region"); return
        }

        // Find a non-neighbor region
        let nonNeighborRegion = engine.regionsArray.first { region in
            region.id != currentRegion.id && !currentRegion.neighborIds.contains(region.id)
        }

        guard let targetRegion = nonNeighborRegion else {
            XCTFail("All regions are neighbors - cannot test non-neighbor travel"); return
        }

        // When: Trying to travel to non-neighbor
        let _ = engine.performAction(.travel(toRegionId: targetRegion.id))

        // Then: Should fail or be blocked (depending on implementation)
        // Note: Some implementations may allow travel to any region
        // This test documents expected behavior
        if !currentRegion.neighborIds.contains(targetRegion.id) {
            // Either fails or implementation allows any travel
            XCTAssertTrue(true, "Non-neighbor travel behavior documented")
        }
    }

    // MARK: - Event Tests

    func testExploreTriggersEvent() {
        guard requireRegionsLoaded() else { return }
        // Given: Engine in a region
        guard engine.currentRegion != nil else {
            XCTFail("No current region"); return
        }

        // When: Exploring
        let result = engine.performAction(.explore)

        // Then: Should succeed (may or may not trigger event)
        XCTAssertTrue(result.success, "Explore action should succeed")

        // Note: Event may or may not be triggered depending on availability
        // This test verifies the action completes without error
    }

    func testEventHasChoices() {
        // Given: A combat event
        let testEvent = GameEvent(
            id: "test_event_1",
            eventType: .combat,
            title: "Test Combat",
            description: "Test description",
            choices: [
                EventChoice(
                    id: "fight",
                    text: "Fight",
                    consequences: EventConsequences(message: "Fought")
                ),
                EventChoice(
                    id: "flee",
                    text: "Flee",
                    consequences: EventConsequences(healthChange: -1, message: "Fled")
                )
            ]
        )

        // Then: Event should have choices
        XCTAssertGreaterThan(testEvent.choices.count, 0, "Event should have at least one choice")
        XCTAssertEqual(testEvent.choices.count, 2, "Test event should have 2 choices")
    }

    // MARK: - Choice Requirement Tests

    func testChoiceWithNoRequirementsIsAvailable() {
        // Given: A choice with no requirements
        let choice = EventChoice(
            id: "simple_choice",
            text: "Simple choice",
            requirements: nil,
            consequences: EventConsequences(message: "Done")
        )

        // Then: Should be available (requirements are nil)
        XCTAssertNil(choice.requirements, "Choice should have no requirements")
    }

    func testChoiceWithFaithRequirement() {
        // Given: A choice requiring faith
        let choice = EventChoice(
            id: "holy_action",
            text: "Holy action",
            requirements: EventRequirements(minimumFaith: 5),
            consequences: EventConsequences(message: "Blessed")
        )

        // When: Player has enough faith
        let hasFaith = engine.playerFaith >= 5

        // Then: Requirement check depends on faith
        XCTAssertNotNil(choice.requirements?.minimumFaith, "Choice should have faith requirement")
        XCTAssertEqual(choice.requirements?.minimumFaith, 5, "Faith requirement should be 5")

        // Document current state
        print("Player faith: \(engine.playerFaith), Required: 5, Can meet: \(hasFaith)")
    }

    func testChoiceWithHealthRequirement() {
        // Given: A choice requiring health
        let choice = EventChoice(
            id: "dangerous_action",
            text: "Dangerous action",
            requirements: EventRequirements(minimumHealth: 3),
            consequences: EventConsequences(message: "Survived")
        )

        // When: Player has enough health
        let hasHealth = engine.playerHealth >= 3

        // Then: Requirement check depends on health
        XCTAssertNotNil(choice.requirements?.minimumHealth, "Choice should have health requirement")
        XCTAssertEqual(choice.requirements?.minimumHealth, 3, "Health requirement should be 3")
        XCTAssertTrue(hasHealth, "Player should have at least 3 health")
    }

    // MARK: - Choice Application Tests

    func testChoiceConsequencesStructure() {
        // Given: Consequences with various changes
        let consequences = EventConsequences(
            faithChange: -2,
            healthChange: -1,
            message: "Test consequence"
        )

        // Then: Verify consequences structure
        XCTAssertNotNil(consequences.faithChange, "Consequences should have faith change")
        XCTAssertEqual(consequences.faithChange, -2, "Faith change should be -2")
        XCTAssertNotNil(consequences.healthChange, "Consequences should have health change")
        XCTAssertEqual(consequences.healthChange, -1, "Health change should be -1")
        XCTAssertEqual(consequences.message, "Test consequence", "Message should match")
    }

    // MARK: - Combat Event Tests

    func testCombatEventHasMonsterCard() {
        // Given: A combat event definition with challenge
        let challenge = MiniGameChallengeDefinition(
            id: "test_challenge",
            challengeKind: .combat,
            difficulty: 1,
            enemyId: "wild_beast"
        )

        let eventDef = EventDefinition(
            id: "test_combat",
            title: .inline(LocalizedString(en: "Test Combat", ru: "Тест Бой")),
            body: .inline(LocalizedString(en: "A beast attacks!", ru: "Зверь атакует!")),
            eventKind: .miniGame(.combat),
            availability: .always,
            poolIds: ["pool_common"],
            weight: 10,
            isOneTime: false,
            choices: [],
            miniGameChallenge: challenge
        )

        // When: Converting to GameEvent using extension method
        let gameEvent = eventDef.toGameEvent()

        // Then: Should be combat event type
        XCTAssertEqual(gameEvent.eventType, .combat, "Event type should be combat")
        // Note: monsterCard may be nil if enemy is not in registry, but eventType should be correct
    }

    func testNarrativeEventType() {
        // Given: A narrative event definition
        let eventDef = EventDefinition(
            id: "test_narrative",
            title: .inline(LocalizedString(en: "Test Narrative", ru: "Тест Нарратив")),
            body: .inline(LocalizedString(en: "Something happens", ru: "Что-то происходит")),
            eventKind: .inline,
            availability: .always,
            poolIds: ["pool_common"],
            weight: 10,
            isOneTime: false,
            choices: [],
            miniGameChallenge: nil
        )

        // When: Converting to GameEvent using extension method
        let gameEvent = eventDef.toGameEvent()

        // Then: Should NOT have monster card and should be narrative type
        XCTAssertNil(gameEvent.monsterCard, "Non-combat event should not have monster card")
        XCTAssertEqual(gameEvent.eventType, .narrative, "Event type should be narrative")
    }

    // MARK: - Event Definition Parsing Tests

    func testEventKindDecodingInline() throws {
        // Given: JSON with inline event kind
        let json = """
        "inline"
        """.data(using: .utf8)!

        // When: Decoding
        let decoder = JSONDecoder()
        let eventKind = try decoder.decode(EventKind.self, from: json)

        // Then: Should be inline
        XCTAssertEqual(eventKind, .inline, "Should decode 'inline' string to EventKind.inline")
    }

    func testEventKindDecodingMiniGame() throws {
        // Given: JSON with mini_game event kind
        let json = """
        {"mini_game": "combat"}
        """.data(using: .utf8)!

        // When: Decoding
        let decoder = JSONDecoder()
        let eventKind = try decoder.decode(EventKind.self, from: json)

        // Then: Should be miniGame combat
        XCTAssertEqual(eventKind, .miniGame(.combat), "Should decode mini_game object to EventKind.miniGame(.combat)")
    }

    func testMiniGameChallengeDecoding() throws {
        // Given: JSON with simplified mini_game_challenge format
        let json = """
        {
            "enemy_id": "wild_beast",
            "difficulty": 2
        }
        """.data(using: .utf8)!

        // When: Decoding (using same decoder config as PackLoader)
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let challenge = try decoder.decode(MiniGameChallengeDefinition.self, from: json)

        // Then: Should have correct values
        XCTAssertEqual(challenge.enemyId, "wild_beast", "Enemy ID should be decoded")
        XCTAssertEqual(challenge.difficulty, 2, "Difficulty should be decoded")
        XCTAssertEqual(challenge.id, "challenge_wild_beast", "ID should be generated from enemy ID")
    }

    // MARK: - State Persistence Tests

    func testRegionStateAfterTravel() {
        // Given: Initial state
        guard let initialRegion = engine.currentRegion,
              let neighborId = initialRegion.neighborIds.first else {
            XCTFail("Cannot test - no neighbors"); return
        }

        // When: Traveling
        let _ = engine.performAction(.travel(toRegionId: neighborId))

        // Then: New region should be current
        XCTAssertEqual(engine.currentRegionId, neighborId, "Current region ID should update")

        // And previous region should still exist in array
        let previousRegion = engine.regionsArray.first { $0.id == initialRegion.id }
        XCTAssertNotNil(previousRegion, "Previous region should still exist")
    }

    // MARK: - Explore Flow Tests

    func testExploreActionSuccess() {
        guard requireRegionsLoaded() else { return }
        // Given: Engine in a region
        guard engine.currentRegion != nil else {
            XCTFail("No current region"); return
        }

        // When: Exploring
        let result = engine.performAction(.explore)

        // Then: Action should succeed
        XCTAssertTrue(result.success, "Explore action should always succeed")
    }

    func testExploreReturnsEventOrNil() {
        guard requireRegionsLoaded() else { return }
        // Given: Engine in a region
        guard engine.currentRegion != nil else {
            XCTFail("No current region"); return
        }

        // When: Exploring
        let result = engine.performAction(.explore)

        // Then: Either an event is triggered or nil (no events available)
        // Both outcomes are valid
        if let eventId = result.currentEvent {
            // Event was triggered - verify it's a valid UUID
            XCTAssertNotNil(eventId, "Triggered event should have valid ID")
            // Engine should have currentEvent set
            XCTAssertEqual(engine.currentEventId, eventId, "Engine currentEventId should match result")
        } else {
            // No event available - this is expected when region is fully explored
            XCTAssertTrue(result.success, "Explore should succeed even without events")
            XCTAssertNil(engine.currentEventId, "Engine currentEventId should be nil when no event")
        }
    }

    func testExploreDoesNotAdvanceTimeWhenNoEvent() {
        guard requireRegionsLoaded() else { return }
        // Given: Engine with current day
        let initialDay = engine.currentDay

        // When: Exploring
        let result = engine.performAction(.explore)

        // Then: If no event triggered, time should not advance
        if result.currentEvent == nil {
            XCTAssertEqual(engine.currentDay, initialDay, "Day should not advance when no event found")
        }
        // Note: If event was triggered, time advancement depends on event handling
    }

    // MARK: - Combat Mechanics v2.0 Tests (Cards as Modifiers)
    // NOTE: CombatView.CombatStats/CombatOutcome tests moved to app tests (UI types)

    func testCardTypeAttackAddsBonus() {
        // Given: An attack card
        let attackCard = Card(
            id: "test_card_1",
            name: "Test Sword",
            type: .attack,
            description: "A test weapon",
            power: 5
        )

        // Then: Attack cards should have power property
        XCTAssertEqual(attackCard.type, .attack, "Card should be attack type")
        XCTAssertEqual(attackCard.power, 5, "Attack card should have power for bonus damage")
    }

    func testCardTypeDefenseHasDefenseValue() {
        // Given: A defense card
        let defenseCard = Card(
            id: "test_card_2",
            name: "Test Shield",
            type: .defense,
            description: "A test shield",
            defense: 4
        )

        // Then: Defense cards should have defense property
        XCTAssertEqual(defenseCard.type, .defense, "Card should be defense type")
        XCTAssertEqual(defenseCard.defense, 4, "Defense card should have defense for shield value")
    }

    func testCardCostProperty() {
        // Given: Cards with different costs
        let freeCard = Card(
            id: "test_card_3",
            name: "Free Card",
            type: .attack,
            description: "No cost",
            cost: 0
        )
        let costlyCard = Card(
            id: "test_card_4",
            name: "Costly Card",
            type: .spell,
            description: "Costs faith",
            cost: 3
        )

        // Then: Costs should be correct
        XCTAssertEqual(freeCard.cost, 0, "Free card should have 0 cost")
        XCTAssertEqual(costlyCard.cost, 3, "Costly card should have cost of 3")
    }

    func testCardTypeSpellHasAbilities() {
        // Given: A spell card with abilities
        let spellCard = Card(
            id: "test_card_5",
            name: "Fireball",
            type: .spell,
            description: "Deals damage",
            cost: 2,
            abilities: [
                CardAbility(
                    id: "test_ability_1",
                    name: "Fire Damage",
                    description: "Deals fire damage",
                    effect: .damage(amount: 6, type: .fire)
                )
            ]
        )

        // Then: Spell should have abilities
        XCTAssertEqual(spellCard.type, .spell, "Card should be spell type")
        XCTAssertFalse(spellCard.abilities.isEmpty, "Spell should have abilities")

        if case .damage(let amount, let type) = spellCard.abilities.first?.effect {
            XCTAssertEqual(amount, 6, "Damage amount should be 6")
            XCTAssertEqual(type, .fire, "Damage type should be fire")
        } else {
            XCTFail("First ability should be damage effect"); return
        }
    }

    func testCardTypeAffectsCombatBehavior() {
        // Given: Different card types
        let attackTypes: [CardType] = [.attack, .weapon]
        let defenseTypes: [CardType] = [.defense, .armor]
        let spellTypes: [CardType] = [.spell, .ritual]

        // Then: Types should be categorized correctly
        for type in attackTypes {
            XCTAssertTrue(type == .attack || type == .weapon, "Should be attack type")
        }
        for type in defenseTypes {
            XCTAssertTrue(type == .defense || type == .armor, "Should be defense type")
        }
        for type in spellTypes {
            XCTAssertTrue(type == .spell || type == .ritual, "Should be spell type")
        }
    }

    func testCombatResourceFaith() {
        // Given: Engine with player
        let initialFaith = engine.playerFaith

        // Then: Faith should be available for card costs
        XCTAssertGreaterThanOrEqual(initialFaith, 0, "Player should have non-negative faith")
    }

    func testCardAbilityAddDice() {
        // Given: An ability that adds dice
        let ability = CardAbility(
            id: "test_ability_2",
            name: "Blessing",
            description: "Adds bonus dice",
            effect: .addDice(count: 2)
        )

        // Then: Effect should be addDice with correct count
        if case .addDice(let count) = ability.effect {
            XCTAssertEqual(count, 2, "Should add 2 dice")
        } else {
            XCTFail("Effect should be addDice"); return
        }
    }

    func testCardAbilityHeal() {
        // Given: An ability that heals
        let ability = CardAbility(
            id: "test_ability_3",
            name: "Heal",
            description: "Heals player",
            effect: .heal(amount: 5)
        )

        // Then: Effect should be heal with correct amount
        if case .heal(let amount) = ability.effect {
            XCTAssertEqual(amount, 5, "Should heal 5 HP")
        } else {
            XCTFail("Effect should be heal"); return
        }
    }

    func testCardAbilityGainFaith() {
        // Given: An ability that grants faith
        let ability = CardAbility(
            id: "test_ability_4",
            name: "Prayer",
            description: "Grants faith",
            effect: .gainFaith(amount: 3)
        )

        // Then: Effect should be gainFaith with correct amount
        if case .gainFaith(let amount) = ability.effect {
            XCTAssertEqual(amount, 3, "Should grant 3 faith")
        } else {
            XCTFail("Effect should be gainFaith"); return
        }
    }

    // MARK: - Navigation System Tests v2.0

    func testIsNeighborReturnsTrue() {
        // Given: Current region with neighbors
        guard let currentRegion = engine.currentRegion,
              let neighborId = currentRegion.neighborIds.first else {
            XCTFail("No neighbors available"); return
        }

        // When: Checking if neighbor
        let isNeighbor = engine.isNeighbor(regionId: neighborId)

        // Then: Should return true
        XCTAssertTrue(isNeighbor, "Should return true for neighbor region")
    }

    func testIsNeighborReturnsFalseForDistant() {
        // Given: A region that is not a neighbor
        guard let currentRegion = engine.currentRegion else {
            XCTFail("No current region"); return
        }

        let distantRegion = engine.regionsArray.first { region in
            region.id != currentRegion.id && !currentRegion.neighborIds.contains(region.id)
        }

        guard let distant = distantRegion else {
            XCTFail("All regions are neighbors"); return
        }

        // When: Checking if neighbor
        let isNeighbor = engine.isNeighbor(regionId: distant.id)

        // Then: Should return false
        XCTAssertFalse(isNeighbor, "Should return false for distant region")
    }

    func testCalculateTravelCostForNeighbor() {
        // Given: Current region with neighbors
        guard let currentRegion = engine.currentRegion,
              let neighborId = currentRegion.neighborIds.first else {
            XCTFail("No neighbors available"); return
        }

        // When: Calculating travel cost
        let cost = engine.calculateTravelCost(to: neighborId)

        // Then: Should be 1 day for neighbor
        XCTAssertEqual(cost, 1, "Travel cost to neighbor should be 1 day")
    }

    func testCalculateTravelCostForDistant() {
        // Given: A distant region
        guard let currentRegion = engine.currentRegion else {
            XCTFail("No current region"); return
        }

        let distantRegion = engine.regionsArray.first { region in
            region.id != currentRegion.id && !currentRegion.neighborIds.contains(region.id)
        }

        guard let distant = distantRegion else {
            XCTFail("All regions are neighbors"); return
        }

        // When: Calculating travel cost
        let cost = engine.calculateTravelCost(to: distant.id)

        // Then: Should be 2 days for distant
        XCTAssertEqual(cost, 2, "Travel cost to distant region should be 2 days")
    }

    func testCanTravelToNeighbor() {
        // Given: Current region with neighbors
        guard let currentRegion = engine.currentRegion,
              let neighborId = currentRegion.neighborIds.first else {
            XCTFail("No neighbors available"); return
        }

        // When: Checking if can travel
        let canTravel = engine.canTravelTo(regionId: neighborId)

        // Then: Should be able to travel to neighbor
        XCTAssertTrue(canTravel, "Should be able to travel to neighbor")
    }

    func testCannotTravelToDistantRegion() {
        // Given: A distant region
        guard let currentRegion = engine.currentRegion else {
            XCTFail("No current region"); return
        }

        let distantRegion = engine.regionsArray.first { region in
            region.id != currentRegion.id && !currentRegion.neighborIds.contains(region.id)
        }

        guard let distant = distantRegion else {
            XCTFail("All regions are neighbors"); return
        }

        // When: Checking if can travel
        let canTravel = engine.canTravelTo(regionId: distant.id)

        // Then: Should not be able to travel to distant
        XCTAssertFalse(canTravel, "Should not be able to travel to distant region directly")
    }

    func testCannotTravelToCurrentRegion() {
        // Given: Current region
        guard let currentRegionId = engine.currentRegionId else {
            XCTFail("No current region"); return
        }

        // When: Checking if can travel to self
        let canTravel = engine.canTravelTo(regionId: currentRegionId)

        // Then: Should not be able to travel to self
        XCTAssertFalse(canTravel, "Should not be able to travel to current region")
    }

    func testGetRoutingHintForDistantRegion() {
        // Given: A distant region
        guard let currentRegion = engine.currentRegion else {
            XCTFail("No current region"); return
        }

        let distantRegion = engine.regionsArray.first { region in
            region.id != currentRegion.id && !currentRegion.neighborIds.contains(region.id)
        }

        guard let distant = distantRegion else {
            XCTFail("All regions are neighbors"); return
        }

        // When: Getting routing hint
        let hints = engine.getRoutingHint(to: distant.id)

        // Then: Should return array (may be empty if no path via 1 hop)
        // This test verifies the method returns without error and hints are valid region names
        for hint in hints {
            XCTAssertFalse(hint.isEmpty, "Each routing hint should be a non-empty region name")
        }
    }

    func testGetRoutingHintEmptyForNeighbor() {
        // Given: A neighbor region
        guard let currentRegion = engine.currentRegion,
              let neighborId = currentRegion.neighborIds.first else {
            XCTFail("No neighbors available"); return
        }

        // When: Getting routing hint for neighbor
        let hints = engine.getRoutingHint(to: neighborId)

        // Then: Should be empty (no hint needed)
        XCTAssertTrue(hints.isEmpty, "Routing hints should be empty for neighbor")
    }

    // MARK: - UI Stability Tests (Duplicate ID Prevention)

    func testDuplicateCardsHaveUniqueIds() {
        // Given: Two cards with the same name (like "Защитный Посох")
        let card1 = Card(
            id: "test_card_dup_1",
            name: "Защитный Посох",
            type: .attack,
            rarity: .common,
            description: "Простой посох",
            power: 2
        )
        let card2 = Card(
            id: "test_card_dup_2",
            name: "Защитный Посох",
            type: .attack,
            rarity: .common,
            description: "Простой посох",
            power: 2
        )

        // Then: Cards should have unique IDs even with same name
        XCTAssertNotEqual(card1.id, card2.id, "Cards with same name should have unique IDs")
    }

    func testCombatLogCanHaveDuplicateEntries() {
        // Given: A combat log with duplicate entries
        var combatLog: [String] = []
        let entry = "⚔️ Защитный Посох: +2 к урону следующей атаки"

        // When: Adding same entry multiple times
        combatLog.append(entry)
        combatLog.append(entry)
        combatLog.append(entry)

        // Then: Log should contain all entries
        XCTAssertEqual(combatLog.count, 3, "Combat log should allow duplicate entries")

        // And: Enumerated access should work (as used in ForEach)
        let enumerated = Array(combatLog.suffix(5).enumerated())
        XCTAssertEqual(enumerated.count, 3, "Enumerated log should have same count")

        // And: Each entry should have unique offset
        let offsets = enumerated.map { $0.offset }
        let uniqueOffsets = Set(offsets)
        XCTAssertEqual(offsets.count, uniqueOffsets.count, "Each entry should have unique offset for ForEach id")
    }

    // NOTE: SF Symbol tests (testValidSFSymbolsUsed, testInvalidSFSymbolReturnsNil) moved to app tests (UIImage)

    func testDeckCanContainMultipleCopiesOfSameCard() {
        // Given: A deck with multiple copies of the same card name
        let cards = [
            Card(id: "test_deck_1", name: "Защитный Посох", type: .attack, rarity: .common, description: "Test", power: 2),
            Card(id: "test_deck_2", name: "Защитный Посох", type: .attack, rarity: .common, description: "Test", power: 2),
            Card(id: "test_deck_3", name: "Светлый Оберег", type: .defense, rarity: .common, description: "Test", defense: 1),
            Card(id: "test_deck_4", name: "Светлый Оберег", type: .defense, rarity: .common, description: "Test", defense: 1)
        ]

        // When: Getting unique IDs
        let ids = cards.map { $0.id }
        let uniqueIds = Set(ids)

        // Then: All cards should have unique IDs
        XCTAssertEqual(ids.count, uniqueIds.count, "All cards should have unique IDs even with same names")
        XCTAssertEqual(uniqueIds.count, 4, "Should have 4 unique card IDs")
    }

    // MARK: - Content Pack Loading Tests

    func testSemanticVersionDecoding() throws {
        // Given: JSON with version string
        let json = """
        {"version": "1.2.3"}
        """
        struct VersionWrapper: Codable { let version: SemanticVersion }

        // When: Decoding
        let data = json.data(using: .utf8)!
        let decoded = try JSONDecoder().decode(VersionWrapper.self, from: data)

        // Then: Version should be parsed correctly
        XCTAssertEqual(decoded.version.major, 1)
        XCTAssertEqual(decoded.version.minor, 2)
        XCTAssertEqual(decoded.version.patch, 3)
    }

    func testSemanticVersionEncoding() throws {
        // Given: SemanticVersion
        let version = SemanticVersion(major: 2, minor: 0, patch: 1)
        struct VersionWrapper: Codable { let version: SemanticVersion }

        // When: Encoding
        let wrapper = VersionWrapper(version: version)
        let data = try JSONEncoder().encode(wrapper)
        let json = String(data: data, encoding: .utf8)!

        // Then: Should encode to string format
        XCTAssertTrue(json.contains("\"2.0.1\""), "Version should be encoded as string")
    }

    func testInvalidSemanticVersionThrowsError() {
        // Given: JSON with invalid version
        let json = """
        {"version": "invalid"}
        """
        struct VersionWrapper: Codable { let version: SemanticVersion }

        // When/Then: Decoding should throw
        let data = json.data(using: .utf8)!
        XCTAssertThrowsError(try JSONDecoder().decode(VersionWrapper.self, from: data))
    }

    func testContentRegistryExists() {
        // Given: Shared content registry
        let registry = ContentRegistry.shared

        // Then: Should exist
        XCTAssertNotNil(registry, "ContentRegistry.shared should exist")
    }

    // MARK: - Performance Tests

    func testEngineInitializationPerformance() {
        guard requireRegionsLoaded() else { return }
        // Measure time to initialize engine (Engine-First)
        measure {
            let testEngine = TwilightGameEngine()
            testEngine.initializeFromContentRegistry(ContentRegistry.shared)

            // Ensure engine is usable
            XCTAssertNotNil(testEngine.currentRegionId)
        }
    }

    func testRegionAccessPerformance() {
        guard requireRegionsLoaded() else { return }
        // Measure time to access regions multiple times
        measure {
            for _ in 0..<100 {
                let regions = engine.regionsArray
                XCTAssertFalse(regions.isEmpty)
            }
        }
    }

    func testTravelActionPerformance() {
        guard let currentRegion = engine.currentRegion,
              let neighborId = currentRegion.neighborIds.first else {
            XCTFail("No neighbors for performance test"); return
        }

        // Measure travel performance
        measure {
            // Travel to neighbor
            _ = engine.performAction(.travel(toRegionId: neighborId))

            // Travel back
            if let newRegion = engine.currentRegion,
               let returnId = newRegion.neighborIds.first {
                _ = engine.performAction(.travel(toRegionId: returnId))
            }
        }
    }

    func testCardCreationPerformance() {
        // Measure card creation performance
        measure {
            for i in 0..<100 {
                _ = Card(
                    id: "test_perf_\(i)",
                    name: "Test Card \(i)",
                    type: .attack,
                    rarity: .common,
                    description: "Test description",
                    power: 2
                )
            }
        }
    }

    func testCombatLogEnumeratedPerformance() {
        // Test that enumerated log (used in ForEach) is fast
        var log: [String] = []
        for i in 0..<1000 {
            log.append("⚔️ Action \(i)")
        }

        measure {
            // This is what ForEach does
            let enumerated = Array(log.suffix(5).enumerated())
            XCTAssertEqual(enumerated.count, 5)

            // Access each element
            for (index, entry) in enumerated {
                XCTAssertNotNil(index)
                XCTAssertFalse(entry.isEmpty)
            }
        }
    }

    // Legacy sync tests removed - Engine-First architecture manages playerHand directly

    // MARK: - Engine Reset Tests

    /// Test that resetGameState clears isGameOver flag
    func testResetGameStateClearsIsGameOver() {
        // Given: Game is over (simulate by setting tension to max)
        // First check that we can trigger game over
        let initialGameOver = engine.isGameOver
        XCTAssertFalse(initialGameOver, "Game should not be over initially")

        // When: resetGameState is called
        engine.resetGameState()

        // Then: isGameOver should be false
        XCTAssertFalse(engine.isGameOver, "isGameOver should be false after reset")
    }

    /// Test that new game creates fresh world state - Engine-First version
    func testNewGameCreatesFreshWorldState() {
        guard requireRegionsLoaded() else { return }
        // Given: A fresh engine after initialization
        let freshEngine = TwilightGameEngine()
        TestContentLoader.loadContentPacksIfNeeded()
        freshEngine.initializeNewGame(playerName: "Test", heroId: nil)

        // Then: It should have initial world tension
        XCTAssertEqual(freshEngine.worldTension, 30, "Fresh engine should have initial tension")

        // And: It should have initial day count
        XCTAssertEqual(freshEngine.currentDay, 0, "Fresh engine should start at day 0")

        // And: It should have regions (when ContentPack loaded)
        XCTAssertFalse(freshEngine.publishedRegions.isEmpty, "Fresh engine should have regions")
    }

    // MARK: - Travel Validation Tests

    /// Test that travel to non-neighbor region is blocked
    func testTravelToNonNeighborIsBlocked() {
        guard let currentRegion = engine.currentRegion else {
            XCTFail("No current region"); return
        }

        // Find a non-neighbor region
        let nonNeighborRegion = engine.regionsArray.first { region in
            region.id != currentRegion.id && !currentRegion.neighborIds.contains(region.id)
        }

        guard let targetRegion = nonNeighborRegion else {
            XCTFail("No non-neighbor region available for testing"); return
        }

        // When: Try to travel to non-neighbor
        let result = engine.performAction(.travel(toRegionId: targetRegion.id))

        // Then: Action should fail
        XCTAssertFalse(result.success, "Travel to non-neighbor should fail")
        XCTAssertNotNil(result.error, "Should have an error for non-neighbor travel")
    }

    /// Test that travel to neighbor region succeeds
    func testTravelToNeighborSucceeds() {
        guard let currentRegion = engine.currentRegion,
              let neighborId = currentRegion.neighborIds.first else {
            XCTFail("No neighbor available for travel test"); return
        }

        let initialDay = engine.currentDay

        // When: Travel to neighbor
        let result = engine.performAction(.travel(toRegionId: neighborId))

        // Then: Action should succeed
        XCTAssertTrue(result.success, "Travel to neighbor should succeed")
        XCTAssertGreaterThan(engine.currentDay, initialDay, "Day should advance after travel")
        XCTAssertEqual(engine.currentRegionId, neighborId, "Current region should change")
    }

    /// Test that travel cost is calculated correctly
    func testTravelCostCalculation() {
        guard let currentRegion = engine.currentRegion,
              let neighborId = currentRegion.neighborIds.first else {
            XCTFail("No neighbor for cost test"); return
        }

        // When: Calculate travel cost to neighbor
        let neighborCost = engine.calculateTravelCost(to: neighborId)

        // Then: Cost should be 1 for neighbor
        XCTAssertEqual(neighborCost, 1, "Travel to neighbor should cost 1 day")

        // Find non-neighbor
        let nonNeighborRegion = engine.regionsArray.first { region in
            region.id != currentRegion.id && !currentRegion.neighborIds.contains(region.id)
        }

        if let nonNeighbor = nonNeighborRegion {
            // When: Calculate travel cost to non-neighbor
            let nonNeighborCost = engine.calculateTravelCost(to: nonNeighbor.id)

            // Then: Cost should be 2 for non-neighbor
            XCTAssertEqual(nonNeighborCost, 2, "Travel to non-neighbor should cost 2 days")
        }
    }
}

// MARK: - Test Helpers

extension GameplayFlowTests {

    /// Helper to create test engine (Engine-First)
    func createTestEngine() -> TwilightGameEngine {
        let testEngine = TwilightGameEngine()
        testEngine.initializeFromContentRegistry(ContentRegistry.shared)
        return testEngine
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/Phase3ContractTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Phase 3 Contract Tests: GameLoop Integration
/// Verifies that all actions go through Engine and state changes are correct
///
/// АРХИТЕКТУРА ТЕСТИРОВАНИЯ (Audit v1.1 Issue #3):
/// - Этот файл содержит ИНТЕГРАЦИОННЫЕ тесты игрового потока
/// - ВСЕ действия тестируются через TwilightGameEngine.performAction()
/// - Это канонический способ тестирования игровой логики
/// - Для unit-тестов моделей см. WorldStateTests, RegionActionsModelTests
/// - Engine обеспечивает: валидацию, синхронизацию legacy, отслеживание изменений
final class Phase3ContractTests: XCTestCase {

    var engine: TwilightGameEngine!

    override func setUp() {
        super.setUp()
        TestContentLoader.loadContentPacksIfNeeded()
        engine = TwilightGameEngine()
        engine.initializeNewGame(playerName: "Test", heroId: nil)
    }

    override func tearDown() {
        engine = nil
        WorldRNG.shared.setSeed(0)
        super.tearDown()
    }

    /// Helper to fail test if regions not loaded
    private func requireRegionsLoaded() -> Bool {
        if engine.publishedRegions.isEmpty {
            XCTFail("Skipping: ContentPack not loaded (regions empty)")
            return false
        }
        return true
    }

    // MARK: - INV-P3-001: All Actions Through Engine

    func testAllActionsReturnActionResult() {
        // Every action should return an ActionResult
        let actions: [TwilightGameAction] = [
            .rest,
            .explore,
            .skipTurn
        ]

        for action in actions {
            let result = engine.performAction(action)
            XCTAssertNotNil(result, "Action \(action) should return result")
        }
    }

    // MARK: - INV-P3-002: Time Advances Only Via Engine

    func testTimeAdvancesOnlyViaEngine() {
        guard requireRegionsLoaded() else { return }
        let initialDay = engine.currentDay

        // Perform action with time cost
        let result = engine.performAction(.rest)

        XCTAssertTrue(result.success, "Rest action should succeed")
        XCTAssertEqual(engine.currentDay, initialDay + 1, "Day should advance by 1")
    }

    // MARK: - INV-P3-003: State Changes Are Tracked

    func testStateChangesAreTracked() {
        guard requireRegionsLoaded() else { return }
        // Perform action that changes state
        let result = engine.performAction(.rest)

        XCTAssertTrue(result.success)
        XCTAssertFalse(result.stateChanges.isEmpty, "Rest should produce state changes")

        // Check for expected changes
        let hasHealthChange = result.stateChanges.contains { change in
            if case .healthChanged = change { return true }
            return false
        }
        XCTAssertTrue(hasHealthChange, "Rest should change health")

        let hasDayChange = result.stateChanges.contains { change in
            if case .dayAdvanced = change { return true }
            return false
        }
        XCTAssertTrue(hasDayChange, "Rest should advance day")
    }

    // MARK: - INV-P3-004: Validation Before Execution

    func testInvalidActionReturnsError() {
        // Try to travel to non-neighbor region
        let farRegionId = "nonexistent_region_999"  // Non-existent region
        let result = engine.performAction(.travel(toRegionId: farRegionId))

        XCTAssertFalse(result.success, "Invalid travel should fail")
        XCTAssertNotNil(result.error, "Should have error")
    }

    // MARK: - INV-P3-005: Tension Escalation Through Engine

    func testTensionEscalatesOnDay3() {
        guard requireRegionsLoaded() else { return }
        // Advance to day 3
        _ = engine.performAction(.rest)  // Day 1
        _ = engine.performAction(.rest)  // Day 2

        let tensionBeforeDay3 = engine.worldTension

        _ = engine.performAction(.rest)  // Day 3 - should trigger tension

        // Tension should increase on day 3
        XCTAssertGreaterThan(engine.worldTension, tensionBeforeDay3,
            "Tension should increase on day 3")

        // Verify escalation formula: +3 + (daysPassed / 10)
        let expectedIncrease = 3 + (3 / 10)  // = 3
        XCTAssertEqual(engine.worldTension, tensionBeforeDay3 + expectedIncrease,
            "Escalation should follow formula")
    }

    // Legacy sync tests removed - Engine-First architecture

    // MARK: - INV-P3-007: Rest Heals Player

    func testRestHealsPlayer() {
        guard requireRegionsLoaded() else { return }
        // Damage player first by setting engine health directly
        engine.setPlayerHealth(5)

        let initialHealth = engine.playerHealth
        let result = engine.performAction(.rest)

        XCTAssertTrue(result.success)

        // Health should increase (capped at max)
        XCTAssertGreaterThan(engine.playerHealth, initialHealth,
            "Rest should heal player")
    }

    // MARK: - INV-P3-008: Strengthen Anchor Costs Faith

    func testStrengthenAnchorCostsFaith() {
        // Ensure player has enough faith
        engine.setPlayerFaith(20)

        // Move to region with anchor
        guard let regionWithAnchor = engine.publishedRegions.values.first(where: { $0.anchor != nil }) else {
            XCTFail("No region with anchor found"); return
        }
        engine.setCurrentRegion(regionWithAnchor.id)

        let initialFaith = engine.playerFaith
        let result = engine.performAction(.strengthenAnchor)

        if result.success {
            // Faith should decrease
            XCTAssertLessThan(engine.playerFaith, initialFaith,
                "Strengthening anchor should cost faith")
        }
    }

    // MARK: - INV-P3-009: Game Over On Tension 100

    func testGameOverOnMaxTension() {
        // Set tension near max
        engine.setWorldTension(97)

        // Advance time to trigger tension increase
        _ = engine.performAction(.rest)
        _ = engine.performAction(.rest)
        _ = engine.performAction(.rest)  // Day 3

        // If tension reached 100, game should be over
        if engine.worldTension >= 100 {
            XCTAssertTrue(engine.isGameOver, "Game should be over at tension 100")
            XCTAssertNotNil(engine.gameResult, "Should have game result")

            if case .defeat(let reason) = engine.gameResult {
                XCTAssertTrue(reason.contains("Напряжение") || reason.contains("tension"),
                    "Defeat reason should mention tension")
            } else {
                XCTFail("Should be defeat, not victory")
            }
        }
    }

    // MARK: - INV-P3-010: Game Over On Health 0

    func testGameOverOnHealthZero() {
        // Set health to 1
        engine.setPlayerHealth(1)

        // Apply damage through consequences (simulated)
        // For now, manually trigger check
        engine.setPlayerHealth(0)

        // Trigger end condition check
        _ = engine.performAction(.skipTurn)

        XCTAssertTrue(engine.isGameOver || engine.playerHealth <= 0,
            "Game should be over or health should be 0")
    }

    // MARK: - INV-P3-011: Actions Blocked When Game Over

    func testActionsBlockedWhenGameOver() {
        // End the game
        engine.setWorldTension(100)
        _ = engine.performAction(.skipTurn)  // Trigger end check

        // If game is over, actions should fail
        if engine.isGameOver {
            let result = engine.performAction(.rest)
            XCTAssertFalse(result.success, "Actions should fail when game is over")
            XCTAssertEqual(result.error, .gameNotInProgress)
        }
    }

    // MARK: - INV-P3-012: Event Choice Resolution

    func testEventChoiceProducesStateChanges() {
        // This test requires an active event
        // For unit testing, we can test the resolver directly

        let resolver = EventResolver()

        // Create test event with proper EventConsequences structure
        let consequences = EventConsequences(
            faithChange: 3,
            healthChange: -2,
            tensionChange: 1,
            setFlags: ["test_flag": true],
            message: "Test result"
        )

        let choice = EventChoice(
            id: "test_choice",
            text: "Test Choice",
            consequences: consequences
        )

        let event = GameEvent(
            id: "test_event_1",
            eventType: .exploration,
            title: "Test Event",
            description: "Test description",
            choices: [choice],
            weight: 10
        )

        let context = EventResolutionContext(
            currentHealth: 10,
            currentFaith: 5,
            currentBalance: 50,
            currentTension: 30,
            currentFlags: [:]
        )

        let result = resolver.resolve(event: event, choiceIndex: 0, context: context)

        XCTAssertTrue(result.success)
        XCTAssertFalse(result.stateChanges.isEmpty, "Choice should produce changes")

        // Verify expected changes exist
        let hasHealthChange = result.stateChanges.contains { change in
            if case .healthChanged(let delta, _) = change {
                return delta == -2
            }
            return false
        }
        XCTAssertTrue(hasHealthChange, "Should have health change of -2")

        let hasFaithChange = result.stateChanges.contains { change in
            if case .faithChanged(let delta, _) = change {
                return delta == 3
            }
            return false
        }
        XCTAssertTrue(hasFaithChange, "Should have faith change of +3")
    }

    // MARK: - INV-P3-013: Deterministic With Seed

    func testEngineDeterministicWithSeed() {
        // Run same actions with same seed twice
        WorldRNG.shared.setSeed(42)

        let engine1 = TwilightGameEngine()
        engine1.initializeFromContentRegistry(ContentRegistry.shared)

        // Perform actions
        _ = engine1.performAction(.rest)
        _ = engine1.performAction(.rest)
        _ = engine1.performAction(.rest)

        let finalTension1 = engine1.worldTension
        let finalDay1 = engine1.currentDay

        // Reset and run again
        WorldRNG.shared.setSeed(42)

        let engine2 = TwilightGameEngine()
        engine2.initializeFromContentRegistry(ContentRegistry.shared)

        _ = engine2.performAction(.rest)
        _ = engine2.performAction(.rest)
        _ = engine2.performAction(.rest)

        let finalTension2 = engine2.worldTension
        let finalDay2 = engine2.currentDay

        // Results should be identical
        XCTAssertEqual(finalDay1, finalDay2, "Days should match with same seed")
        XCTAssertEqual(finalTension1, finalTension2, "Tension should match with same seed")
    }
}

// MARK: - Test Helpers

/// Helper to describe TwilightGameAction for test output (avoids extension conformance issues)
private func describeAction(_ action: TwilightGameAction) -> String {
    switch action {
    case .travel(let id): return "travel(\(id))"
    case .rest: return "rest"
    case .explore: return "explore"
    case .trade: return "trade"
    case .strengthenAnchor: return "strengthenAnchor"
    case .chooseEventOption(let e, let c): return "choose(\(e), \(c))"
    case .resolveMiniGame(let r): return "miniGame(\(r))"
    case .startCombat(let id): return "combat(\(id))"
    case .combatInitialize: return "combatInitialize"
    // Active Defense actions
    case .combatMulligan(let cardIds): return "combatMulligan(\(cardIds.count) cards)"
    case .combatGenerateIntent: return "combatGenerateIntent"
    case .combatPlayerAttackWithFate(let dmg): return "combatPlayerAttackWithFate(bonus:\(dmg))"
    case .combatSkipAttack: return "combatSkipAttack"
    case .combatEnemyResolveWithFate: return "combatEnemyResolveWithFate"
    // Legacy combat actions
    case .combatAttack(let effort, let dmg): return "combatAttack(effort:\(effort), dmg:\(dmg))"
    case .playCard(let c, let t): return "playCard(\(c), \(String(describing: t)))"
    case .combatApplyEffect(let effect): return "combatApplyEffect(\(effect))"
    case .endCombatTurn: return "endCombatTurn"
    case .combatEnemyAttack(let dmg): return "combatEnemyAttack(\(dmg))"
    case .combatEndTurnPhase: return "combatEndTurnPhase"
    case .combatSpiritAttack: return "combatSpiritAttack"
    case .combatFlee: return "combatFlee"
    case .combatFinish(let victory): return "combatFinish(\(victory))"
    case .dismissCurrentEvent: return "dismissCurrentEvent"
    case .dismissDayEvent: return "dismissDayEvent"
    case .skipTurn: return "skipTurn"
    case .custom(let id, let cost): return "custom(\(id), \(cost))"
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/RegressionPlaythroughTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Regression Playthrough Tests
/// Ensures migration does not change game behavior.
/// These tests use fixed seeds and action sequences to verify determinism.
/// Reference: Docs/MIGRATION_PLAN.md
final class RegressionPlaythroughTests: XCTestCase {

    // MARK: - Test Fixtures

    /// Snapshot of expected game state at checkpoints
    struct GameStateSnapshot: Equatable {
        let pressure: Int
        let time: Int
        let healthRange: ClosedRange<Int>   // Allow small variance
        let faithRange: ClosedRange<Int>
        let visitedRegionsCount: Int
        let flagsSet: Set<String>

        func matches(_ state: ActualGameState, tolerance: Int = 2) -> Bool {
            guard pressure == state.pressure else { return false }
            guard time == state.time else { return false }
            guard healthRange.contains(state.health) else { return false }
            guard faithRange.contains(state.faith) else { return false }
            guard visitedRegionsCount == state.visitedRegionsCount else { return false }
            guard flagsSet.isSubset(of: state.flags) else { return false }
            return true
        }
    }

    struct ActualGameState {
        let pressure: Int
        let time: Int
        let health: Int
        let faith: Int
        let visitedRegionsCount: Int
        let flags: Set<String>
    }

    // MARK: - Determinism Tests

    /// Same seed should produce same event selection
    func testFixedSeedProducesDeterministicEvents() {
        // Given: Fixed seed
        let seed: UInt64 = 42

        // When: Run selection multiple times
        var results: [String] = []
        for _ in 0..<5 {
            let eventId = selectEventWithFixedSeed(seed: seed, poolSize: 10)
            results.append(eventId)
        }

        // Then: All results identical
        let uniqueResults = Set(results)
        XCTAssertEqual(uniqueResults.count, 1, "Same seed should always select same event")
    }

    /// Different actions should produce different outcomes
    func testDifferentActionsProduceDifferentOutcomes() {
        // Given: Two playthroughs with different action sequences
        let actionsA: [TestAction] = [.rest, .rest, .travel("forest")]
        let actionsB: [TestAction] = [.travel("village"), .explore, .rest]

        // When: Simulate both
        let outcomeA = simulatePlaythrough(actions: actionsA, seed: 100)
        let outcomeB = simulatePlaythrough(actions: actionsB, seed: 100)

        // Then: Different final states
        // Note: They might coincidentally match, but likely different
        let areDifferent = outcomeA.time != outcomeB.time ||
                          outcomeA.visitedRegions != outcomeB.visitedRegions
        XCTAssertTrue(areDifferent || actionsA == actionsB,
                      "Different actions should generally produce different outcomes")
    }

    // MARK: - Save/Load Roundtrip

    /// Game state should survive save/load cycle unchanged
    func testSaveLoadRoundtripPreservesState() {
        // Given: Game state
        let originalState = TestGameState(
            pressure: 35,
            time: 12,
            health: 15,
            faith: 8,
            currentRegion: "village",
            visitedRegions: ["forest", "village", "crossroads"],
            flags: ["quest_started": true, "npc_met": true],
            completedEvents: ["event_001", "event_003"]
        )

        // When: Save and load
        let savedData = encodeState(originalState)
        let loadedState = decodeState(savedData)

        // Then: State preserved
        XCTAssertEqual(loadedState.pressure, originalState.pressure)
        XCTAssertEqual(loadedState.time, originalState.time)
        XCTAssertEqual(loadedState.health, originalState.health)
        XCTAssertEqual(loadedState.faith, originalState.faith)
        XCTAssertEqual(loadedState.currentRegion, originalState.currentRegion)
        XCTAssertEqual(loadedState.visitedRegions, originalState.visitedRegions)
        XCTAssertEqual(loadedState.flags, originalState.flags)
        XCTAssertEqual(loadedState.completedEvents, originalState.completedEvents)
    }

    // MARK: - Regression Checkpoints

    /// Standard playthrough should hit expected checkpoints
    /// This test documents expected behavior and catches regressions
    func testStandardPlaythroughReachesCheckpoints() {
        // Given: Standard action sequence (typical early game)
        let standardActions: [TestAction] = [
            .explore,           // Day 1: Explore starting area
            .travel("forest"),  // Day 2: Travel to forest
            .explore,           // Day 3: Explore forest (triggers day threshold)
            .rest,              // Day 4: Rest to recover
            .travel("village"), // Day 5: Travel to village
        ]

        // And: Expected checkpoints (for future snapshot comparison)
        _ = GameStateSnapshot(
            pressure: 0,        // Before first threshold
            time: 2,
            healthRange: 18...20,
            faithRange: 8...12,
            visitedRegionsCount: 1,
            flagsSet: []
        )

        _ = GameStateSnapshot(
            pressure: 5,        // After first threshold (day 3)
            time: 5,
            healthRange: 15...20,
            faithRange: 5...12,
            visitedRegionsCount: 3,
            flagsSet: []
        )

        // When: Run playthrough
        let outcomes = simulateWithCheckpoints(
            actions: standardActions,
            checkpointIndices: [2, 5], // After action 2 and after action 5
            seed: 12345
        )

        // Then: Checkpoints reached (within tolerance)
        // Note: This test may need adjustment as game balance changes
        // The key invariant is: same input → same output
        XCTAssertEqual(outcomes.count, 2, "Should have 2 checkpoints")
    }

    // MARK: - Migration Safety Net

    /// This test captures current behavior for migration comparison
    /// Run before and after migration - results should match
    func testMigrationRegressionHarness() {
        // Given: Canonical test sequence
        let canonicalSeed: UInt64 = 98765
        let canonicalActions: [TestAction] = [
            .explore,
            .travel("forest"),
            .explore,
            .travel("village"),
            .rest,
            .strengthen,
            .travel("crossroads"),
            .explore,
            .rest,
            .travel("forest")
        ]

        // When: Run simulation
        let finalState = simulatePlaythrough(actions: canonicalActions, seed: canonicalSeed)

        // Then: Record/verify known good values
        // These values should be captured once and then verified on each run
        // If migration changes behavior, this test will fail

        // For now, we just verify the simulation completes
        XCTAssertGreaterThan(finalState.time, 0, "Time should advance")
        XCTAssertGreaterThanOrEqual(finalState.visitedRegions.count, 1, "Should have visited regions")

        // TODO: After establishing baseline, add specific assertions:
        // XCTAssertEqual(finalState.pressure, EXPECTED_PRESSURE)
        // XCTAssertEqual(finalState.time, EXPECTED_TIME)
        // XCTAssertEqual(finalState.visitedRegions, EXPECTED_REGIONS)
    }

    // MARK: - Deck State Persistence

    func testDeckStatePersistsAcrossSaveLoad() {
        // Given: Deck state with zones
        let deckState = TestDeckState(
            drawPile: ["card_1", "card_2", "card_3"],
            hand: ["card_4", "card_5"],
            discard: ["card_6"],
            exile: []
        )

        // When: Save and load
        let savedData = encodeDeckState(deckState)
        let loadedDeck = decodeDeckState(savedData)

        // Then: All zones preserved
        XCTAssertEqual(loadedDeck.drawPile, deckState.drawPile)
        XCTAssertEqual(loadedDeck.hand, deckState.hand)
        XCTAssertEqual(loadedDeck.discard, deckState.discard)
        XCTAssertEqual(loadedDeck.exile, deckState.exile)
    }

    // MARK: - Legacy vs Engine Comparison Tests

    /// Compare legacy playthrough to engine playthrough - must produce same results
    /// This is the critical migration safety net
    func testLegacyVsEngineProduceSameOutcome() {
        // Given: Same seed and actions for both
        let seed: UInt64 = 54321
        let actions: [TestAction] = [
            .explore,
            .travel("forest"),
            .rest,
            .explore,
            .travel("village"),
            .strengthen
        ]

        // When: Run both simulations
        let legacyOutcome = runLegacyPlaythrough(seed: seed, actions: actions)
        let engineOutcome = runEnginePlaythrough(seed: seed, actions: actions)

        // Then: Key metrics must match
        XCTAssertEqual(
            legacyOutcome.time,
            engineOutcome.time,
            "Time should match: legacy=\(legacyOutcome.time), engine=\(engineOutcome.time)"
        )
        XCTAssertEqual(
            legacyOutcome.pressure,
            engineOutcome.pressure,
            "Pressure should match: legacy=\(legacyOutcome.pressure), engine=\(engineOutcome.pressure)"
        )
        XCTAssertEqual(
            legacyOutcome.visitedRegions,
            engineOutcome.visitedRegions,
            "Visited regions should match"
        )
    }

    /// Run playthrough using legacy simulation (current Models/*)
    private func runLegacyPlaythrough(seed: UInt64, actions: [TestAction]) -> PlaythroughOutcome {
        // This simulates the current (legacy) game flow
        return simulatePlaythrough(actions: actions, seed: seed)
    }

    /// Run playthrough using new Engine simulation
    private func runEnginePlaythrough(seed: UInt64, actions: [TestAction]) -> PlaythroughOutcome {
        // This simulates the new Engine flow using GameRuntimeState
        var runtime = GameRuntimeState.newGame(
            startingRegionId: "starting_area",
            startingResources: ["health": 20, "faith": 10],
            startingDeck: [],
            seed: seed
        )

        var rng = SeededRNG(seed: seed)

        for action in actions {
            switch action {
            case .rest:
                runtime.world.currentTime += 1
                let currentHealth = runtime.player.getResource("health")
                runtime.player.setResource("health", value: min(20, currentHealth + 3))

            case .explore:
                runtime.world.currentTime += 1
                let eventRoll = Int.random(in: 0..<10, using: &rng)
                if eventRoll < 3 {
                    runtime.player.modifyResource("faith", by: -1)
                }

            case .travel(let destination):
                runtime.world.currentTime += 1
                runtime.world.currentRegionId = destination
                runtime.world.regionsState[destination] = RegionRuntimeState(
                    definitionId: destination,
                    currentState: .stable,
                    visitCount: 1,
                    isDiscovered: true
                )

            case .strengthen:
                runtime.world.currentTime += 1
                runtime.player.modifyResource("faith", by: -2)

            case .choose:
                break
            }

            // Check pressure threshold (same logic as legacy)
            if runtime.world.currentTime > 0 && runtime.world.currentTime % 3 == 0 {
                runtime.world.pressure += 5
            }
        }

        // Build visited regions set
        var visitedRegions = Set<String>(["starting_area"])
        for (regionId, state) in runtime.world.regionsState {
            if state.visitCount > 0 {
                visitedRegions.insert(regionId)
            }
        }

        return PlaythroughOutcome(
            time: runtime.world.currentTime,
            pressure: runtime.world.pressure,
            health: runtime.player.getResource("health"),
            faith: runtime.player.getResource("faith"),
            visitedRegions: visitedRegions,
            completedEvents: runtime.events.completedOneTimeEvents
        )
    }

    /// Test that snapshots can be compared for equality
    func testSnapshotComparison() {
        // Given: Two game states with same values
        let state1 = GameRuntimeState.newGame(
            startingRegionId: "forest",
            startingResources: ["health": 20, "faith": 10],
            startingDeck: ["c1", "c2"],
            seed: 100
        )

        let state2 = GameRuntimeState.newGame(
            startingRegionId: "forest",
            startingResources: ["health": 20, "faith": 10],
            startingDeck: ["c1", "c2"],
            seed: 100
        )

        // When: Take snapshots
        let snapshot1 = state1.snapshot()
        let snapshot2 = state2.snapshot()

        // Then: Snapshots equal
        XCTAssertEqual(snapshot1, snapshot2)
    }

    /// Test that different states produce different snapshots
    func testSnapshotDetectsDifferences() {
        // Given: Two different game states
        var state1 = GameRuntimeState.newGame(
            startingRegionId: "forest",
            startingResources: ["health": 20, "faith": 10],
            startingDeck: [],
            seed: 100
        )
        state1.world.pressure = 50

        var state2 = GameRuntimeState.newGame(
            startingRegionId: "forest",
            startingResources: ["health": 20, "faith": 10],
            startingDeck: [],
            seed: 100
        )
        state2.world.pressure = 0

        // When: Take snapshots
        let snapshot1 = state1.snapshot()
        let snapshot2 = state2.snapshot()

        // Then: Snapshots different
        XCTAssertNotEqual(snapshot1, snapshot2)
        XCTAssertNotEqual(snapshot1.pressure, snapshot2.pressure)
    }
}

// MARK: - Test Types

enum TestAction: Equatable {
    case rest
    case explore
    case travel(String)
    case strengthen
    case choose(eventId: String, choiceId: String)
}

struct TestGameState: Codable, Equatable {
    var pressure: Int
    var time: Int
    var health: Int
    var faith: Int
    var currentRegion: String
    var visitedRegions: Set<String>
    var flags: [String: Bool]
    var completedEvents: Set<String>
}

struct TestDeckState: Codable, Equatable {
    var drawPile: [String]
    var hand: [String]
    var discard: [String]
    var exile: [String]
}

struct PlaythroughOutcome {
    let time: Int
    let pressure: Int
    let health: Int
    let faith: Int
    let visitedRegions: Set<String>
    let completedEvents: Set<String>
}

// MARK: - Simulation Helpers

func selectEventWithFixedSeed(seed: UInt64, poolSize: Int) -> String {
    var rng = SeededRNG(seed: seed)
    let index = Int.random(in: 0..<poolSize, using: &rng)
    return "event_\(index)"
}

func simulatePlaythrough(actions: [TestAction], seed: UInt64) -> PlaythroughOutcome {
    var state = TestGameState(
        pressure: 0,
        time: 0,
        health: 20,
        faith: 10,
        currentRegion: "starting_area",
        visitedRegions: ["starting_area"],
        flags: [:],
        completedEvents: []
    )

    var rng = SeededRNG(seed: seed)

    for action in actions {
        switch action {
        case .rest:
            state.time += 1
            state.health = min(20, state.health + 3)

        case .explore:
            state.time += 1
            // Random event might affect resources
            let eventRoll = Int.random(in: 0..<10, using: &rng)
            if eventRoll < 3 {
                state.faith -= 1
            }

        case .travel(let destination):
            state.time += 1
            state.currentRegion = destination
            state.visitedRegions.insert(destination)

        case .strengthen:
            state.time += 1
            state.faith -= 2

        case .choose:
            // Choice resolution would go here
            break
        }

        // Check pressure threshold
        if state.time > 0 && state.time % 3 == 0 {
            state.pressure += 5
        }
    }

    return PlaythroughOutcome(
        time: state.time,
        pressure: state.pressure,
        health: state.health,
        faith: state.faith,
        visitedRegions: state.visitedRegions,
        completedEvents: state.completedEvents
    )
}

func simulateWithCheckpoints(
    actions: [TestAction],
    checkpointIndices: [Int],
    seed: UInt64
) -> [PlaythroughOutcome] {
    var results: [PlaythroughOutcome] = []
    var currentActions: [TestAction] = []

    for (index, action) in actions.enumerated() {
        currentActions.append(action)

        if checkpointIndices.contains(index + 1) {
            let outcome = simulatePlaythrough(actions: currentActions, seed: seed)
            results.append(outcome)
        }
    }

    return results
}

func encodeState(_ state: TestGameState) -> Data {
    return try! JSONEncoder().encode(state)
}

func decodeState(_ data: Data) -> TestGameState {
    return try! JSONDecoder().decode(TestGameState.self, from: data)
}

func encodeDeckState(_ state: TestDeckState) -> Data {
    return try! JSONEncoder().encode(state)
}

func decodeDeckState(_ data: Data) -> TestDeckState {
    return try! JSONDecoder().decode(TestDeckState.self, from: data)
}

struct SeededRNG: RandomNumberGenerator {
    var state: UInt64

    init(seed: UInt64) {
        self.state = seed
    }

    mutating func next() -> UInt64 {
        state = state &* 6364136223846793005 &+ 1442695040888963407
        return state
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/ResonanceEngineTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Tests for ResonanceEngine — world resonance state management
final class ResonanceEngineTests: XCTestCase {

    // MARK: - Initial State

    func testInitialValueIsZero() {
        let engine = ResonanceEngine()
        XCTAssertEqual(engine.value, 0.0)
        XCTAssertEqual(engine.getActiveZone(), .yav)
    }

    func testInitWithCustomValue() {
        let engine = ResonanceEngine(value: 42.0)
        XCTAssertEqual(engine.value, 42.0)
        XCTAssertEqual(engine.getActiveZone(), .prav)
    }

    // MARK: - Clamping

    func testResonanceClamping() {
        let engine = ResonanceEngine()

        // Shift far positive — should clamp at 100
        engine.shift(amount: 200, source: "test")
        XCTAssertEqual(engine.value, 100.0)

        // Shift far negative — should clamp at -100
        engine.shift(amount: -300, source: "test")
        XCTAssertEqual(engine.value, -100.0)
    }

    func testInitClamps() {
        let high = ResonanceEngine(value: 999)
        XCTAssertEqual(high.value, 100.0)

        let low = ResonanceEngine(value: -999)
        XCTAssertEqual(low.value, -100.0)
    }

    // MARK: - Zone Detection

    func testZoneDetection() {
        // deepNav: -100..-61
        XCTAssertEqual(ResonanceEngine.zone(for: -100), .deepNav)
        XCTAssertEqual(ResonanceEngine.zone(for: -61), .deepNav)

        // nav: -60..-21
        XCTAssertEqual(ResonanceEngine.zone(for: -60), .nav)
        XCTAssertEqual(ResonanceEngine.zone(for: -21), .nav)

        // yav: -20..20
        XCTAssertEqual(ResonanceEngine.zone(for: -20), .yav)
        XCTAssertEqual(ResonanceEngine.zone(for: 0), .yav)
        XCTAssertEqual(ResonanceEngine.zone(for: 20), .yav)

        // prav: 21..60
        XCTAssertEqual(ResonanceEngine.zone(for: 21), .prav)
        XCTAssertEqual(ResonanceEngine.zone(for: 60), .prav)

        // deepPrav: 61..100
        XCTAssertEqual(ResonanceEngine.zone(for: 61), .deepPrav)
        XCTAssertEqual(ResonanceEngine.zone(for: 100), .deepPrav)
    }

    // MARK: - Shift

    func testShiftReturnsRecord() {
        let engine = ResonanceEngine()

        let shift = engine.shift(amount: 15, source: "battle_won")

        XCTAssertEqual(shift.amount, 15)
        XCTAssertEqual(shift.source, "battle_won")
        XCTAssertEqual(shift.resultingValue, 15.0)
        XCTAssertEqual(engine.value, 15.0)
    }

    func testMultipleShifts() {
        let engine = ResonanceEngine()

        engine.shift(amount: 30, source: "a")
        let s2 = engine.shift(amount: -10, source: "b")

        XCTAssertEqual(s2.resultingValue, 20.0)
        XCTAssertEqual(engine.value, 20.0)
    }

    // MARK: - Save/Load

    func testSetValue() {
        let engine = ResonanceEngine()
        engine.setValue(75.0)
        XCTAssertEqual(engine.value, 75.0)

        // Clamps
        engine.setValue(200.0)
        XCTAssertEqual(engine.value, 100.0)
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/TimeSystemTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Time System Invariant Tests
/// Ensures the time system follows critical rules:
/// - Each day must be processed individually (no skipping)
/// - Time cannot be rolled back
/// - Escalation happens at correct intervals
final class TimeSystemTests: XCTestCase {

    var engine: TwilightGameEngine!

    override func setUp() {
        super.setUp()
        engine = TwilightGameEngine()
        // Initialize with minimal setup
        TestContentLoader.loadContentPacksIfNeeded()
        engine.initializeNewGame(playerName: "Test", heroId: nil)
    }

    override func tearDown() {
        engine = nil
        super.tearDown()
    }

    // MARK: - Day Processing Invariants

    /// INVARIANT: Each day must be processed individually, not skipped
    /// When advancing multiple days, tension should increase for EACH eligible day
    func testEachDayProcessedIndividually() {
        // Given: Engine at day 0 with initial tension
        let initialDay = engine.currentDay
        let initialTension = engine.worldTension

        // When: Advance by 9 days (should trigger 3 tension ticks at days 3, 6, 9)
        // Using performAction to simulate real gameplay
        for _ in 0..<9 {
            // Rest action costs 1 day
            _ = engine.performAction(.rest)
        }

        // Then: Should be at day 9
        XCTAssertEqual(engine.currentDay, initialDay + 9, "Should have advanced 9 days")

        // And: Tension should have increased 3 times (at days 3, 6, 9)
        // Each tick increases tension by at least 3 (base amount)
        XCTAssertGreaterThanOrEqual(
            engine.worldTension,
            initialTension + 9, // 3 ticks * 3 base minimum
            "Tension should increase at each interval"
        )
    }

    /// INVARIANT: Time cannot be rolled back
    /// currentDay should only increase, never decrease
    func testTimeCannotBeRolledBack() {
        // Given: Engine at some day
        let dayBeforeAction = engine.currentDay

        // When: Perform any action
        _ = engine.performAction(.rest)

        // Then: Day should not have decreased
        XCTAssertGreaterThanOrEqual(
            engine.currentDay,
            dayBeforeAction,
            "Time should never go backwards"
        )
    }

    /// INVARIANT: No day can be skipped when advancing time
    /// If we go from day 1 to day 10, days 2-9 must all be processed
    func testNoDaySkipping() {
        // This test verifies the implementation correctness
        // by checking that tension ticks happen at the expected intervals

        // Given: Engine at day 0
        XCTAssertEqual(engine.currentDay, 0, "Should start at day 0")

        // Record tension before starting
        let tensionAtDay0 = engine.worldTension

        // Advance to day 3 (first tension tick)
        for _ in 0..<3 {
            _ = engine.performAction(.rest)
        }
        let tensionAtDay3 = engine.worldTension
        XCTAssertGreaterThan(tensionAtDay3, tensionAtDay0, "Tension should increase at day 3")

        // Advance to day 6 (second tension tick)
        for _ in 0..<3 {
            _ = engine.performAction(.rest)
        }
        let tensionAtDay6 = engine.worldTension
        XCTAssertGreaterThan(tensionAtDay6, tensionAtDay3, "Tension should increase at day 6")

        // Advance to day 9 (third tension tick)
        for _ in 0..<3 {
            _ = engine.performAction(.rest)
        }
        let tensionAtDay9 = engine.worldTension
        XCTAssertGreaterThan(tensionAtDay9, tensionAtDay6, "Tension should increase at day 9")
    }

    // MARK: - Escalation Invariants

    /// INVARIANT: Escalation must increase with time
    /// The tension increase per tick should grow as days progress
    func testEscalationIncreasesWithTime() {
        // The formula is: base + (daysPassed / 10)
        // Day 1-9: +3
        // Day 10-19: +4
        // Day 20-29: +5

        let earlyIncrease = TwilightPressureRules.calculateTensionIncrease(daysPassed: 5)
        let midIncrease = TwilightPressureRules.calculateTensionIncrease(daysPassed: 15)
        let lateIncrease = TwilightPressureRules.calculateTensionIncrease(daysPassed: 25)

        XCTAssertEqual(earlyIncrease, 3, "Early game (day 5): base tension increase")
        XCTAssertEqual(midIncrease, 4, "Mid game (day 15): +1 escalation")
        XCTAssertEqual(lateIncrease, 5, "Late game (day 25): +2 escalation")

        XCTAssertLessThan(earlyIncrease, midIncrease, "Tension increase should grow over time")
        XCTAssertLessThan(midIncrease, lateIncrease, "Tension increase should continue growing")
    }

    /// INVARIANT: Tension tick interval is respected
    /// Tension should only increase every N days (default 3)
    func testTensionTickIntervalRespected() {
        // Record initial tension
        let initialTension = engine.worldTension

        // Day 1: No tick
        _ = engine.performAction(.rest)
        XCTAssertEqual(engine.worldTension, initialTension, "No tension increase on day 1")

        // Day 2: No tick
        _ = engine.performAction(.rest)
        XCTAssertEqual(engine.worldTension, initialTension, "No tension increase on day 2")

        // Day 3: Tick!
        _ = engine.performAction(.rest)
        XCTAssertGreaterThan(engine.worldTension, initialTension, "Tension should increase on day 3")
    }

    // MARK: - Free Action Invariants

    /// INVARIANT: Most actions cost time (no free actions except instant ones)
    func testMostActionsCostTime() {
        let dayBefore = engine.currentDay

        // Rest should cost time
        _ = engine.performAction(.rest)
        XCTAssertGreaterThan(engine.currentDay, dayBefore, "Rest should advance time")
    }

    // MARK: - State Consistency

    /// INVARIANT: Engine state remains consistent after time advancement
    func testStateConsistencyAfterTimeAdvancement() {
        // Advance several days
        for _ in 0..<10 {
            _ = engine.performAction(.rest)
        }

        // State should be consistent
        XCTAssertGreaterThanOrEqual(engine.playerHealth, 0, "Health should not be negative")
        XCTAssertGreaterThanOrEqual(engine.playerFaith, 0, "Faith should not be negative")
        XCTAssertGreaterThanOrEqual(engine.worldTension, 0, "Tension should not be negative")
        XCTAssertLessThanOrEqual(engine.worldTension, 100, "Tension should not exceed 100")
    }

    // MARK: - Regression Tests

    /// Regression test: Ensure advancing by N days doesn't skip day processing
    /// This guards against the bug: `daysPassed += N` instead of proper iteration
    func testAdvanceMultipleDaysProcessesEach() {
        // Setup: Start at day 0, tension tick every 3 days
        let initialTension = engine.worldTension

        // If we advance by 6 days, we should see exactly 2 tension ticks
        // (at day 3 and day 6)

        // Simulate advancing 6 days
        for _ in 0..<6 {
            _ = engine.performAction(.rest)
        }

        // We should be at day 6
        XCTAssertEqual(engine.currentDay, 6)

        // Tension should have increased twice
        // Minimum increase: 2 * 3 (base) = 6
        XCTAssertGreaterThanOrEqual(
            engine.worldTension - initialTension,
            6,
            "Two tension ticks should have occurred"
        )
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/IntegrationTests/EncounterIntegrationTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Encounter integration tests — full encounter lifecycle
/// Reference: ENCOUNTER_TEST_MODEL.md §4.1
/// Uses real EncounterEngine, no mocks
final class EncounterIntegrationTests: XCTestCase {

    // #22: Full kill path — physical attacks until HP=0
    func testFullKillPath() {
        let ctx = EncounterContext(
            hero: EncounterHero(id: "warrior", hp: 100, maxHp: 100, strength: 10, armor: 5),
            enemies: [EncounterEnemy(id: "beast", name: "Weak Beast", hp: 10, maxHp: 10, wp: 5, maxWp: 5, power: 3, defense: 1)],
            fateDeckSnapshot: FateDeckFixtures.deterministicState(),
            modifiers: [],
            rules: EncounterRules(),
            rngSeed: 42
        )
        let engine = EncounterEngine(context: ctx)

        // Combat loop
        var rounds = 0
        while engine.enemies[0].isAlive && rounds < 10 {
            _ = engine.generateIntent(for: "beast")
            _ = engine.performAction(.attack(targetId: "beast"))
            if engine.enemies[0].isAlive {
                _ = engine.resolveEnemyAction(enemyId: "beast")
                _ = engine.advancePhase() // roundEnd
            }
            rounds += 1
        }

        let result = engine.finishEncounter()
        XCTAssertEqual(result.outcome, .victory(.killed))
        XCTAssertEqual(result.perEntityOutcomes["beast"], .killed)
        XCTAssertGreaterThan(engine.enemies[0].wp ?? 1, 0, "WP should remain in kill path")
    }

    // #23: Full pacify path — spirit attacks until WP=0
    func testFullPacifyPath() {
        let ctx = EncounterContext(
            hero: EncounterHero(id: "diplomat", hp: 100, maxHp: 100, strength: 3, armor: 2, wisdom: 10),
            enemies: [EncounterEnemy(id: "spirit", name: "Spirit", hp: 100, maxHp: 100, wp: 5, maxWp: 5, power: 3)],
            fateDeckSnapshot: FateDeckFixtures.deterministicState(),
            modifiers: [],
            rules: EncounterRules(),
            rngSeed: 42
        )
        let engine = EncounterEngine(context: ctx)

        var rounds = 0
        while !(engine.enemies[0].isPacified) && rounds < 10 {
            _ = engine.generateIntent(for: "spirit")
            _ = engine.performAction(.spiritAttack(targetId: "spirit"))
            if !(engine.enemies[0].isPacified) {
                _ = engine.resolveEnemyAction(enemyId: "spirit")
                _ = engine.advancePhase()
            }
            rounds += 1
        }

        let result = engine.finishEncounter()
        XCTAssertEqual(result.outcome, .victory(.pacified))
        XCTAssertGreaterThan(engine.enemies[0].hp, 0, "HP should remain in pacify path")
    }

    // #24: Escalation full cycle — spirit→body with resonance penalty
    func testEscalationFullCycle() {
        let ctx = EncounterContext(
            hero: EncounterHero(id: "hero", hp: 100, maxHp: 100, strength: 5, armor: 2, wisdom: 5),
            enemies: [EncounterEnemy(id: "guard", name: "Guard", hp: 100, maxHp: 100, wp: 100, maxWp: 100, power: 5, defense: 2)],
            fateDeckSnapshot: FateDeckFixtures.deterministicState(),
            modifiers: [],
            rules: EncounterRules(),
            rngSeed: 42,
            worldResonance: 0
        )
        let engine = EncounterEngine(context: ctx)

        // Spirit attack (diplomacy)
        _ = engine.performAction(.spiritAttack(targetId: "guard"))

        // Physical attack (escalation)
        let result = engine.performAction(.attack(targetId: "guard"))

        // Verify resonance shifted
        let resonanceShift = result.stateChanges.compactMap { change -> Float? in
            if case .resonanceShifted(let delta, _) = change { return delta }
            return nil
        }.first

        XCTAssertNotNil(resonanceShift, "Escalation must produce resonance shift")
        XCTAssertLessThan(resonanceShift ?? 0, 0, "Escalation shifts resonance toward Nav (negative)")
    }

    // #19: Multi-enemy — per-entity outcomes
    func testMultiEnemy1vN() {
        let ctx = EncounterContextFixtures.multiEnemy()
        let engine = EncounterEngine(context: ctx)

        // Kill first enemy
        _ = engine.performAction(.attack(targetId: "enemy_1"))

        // Pacify second
        _ = engine.performAction(.spiritAttack(targetId: "enemy_2"))

        let result = engine.finishEncounter()

        // Per-entity outcomes should exist
        XCTAssertNotNil(result.perEntityOutcomes["enemy_1"])
        XCTAssertNotNil(result.perEntityOutcomes["enemy_2"])
        XCTAssertNotNil(result.perEntityOutcomes["enemy_3"])
    }

    // #20: All pacified → nonviolent encounter
    func testMultiEnemyAllPacified() {
        let ctx = EncounterContextFixtures.multiEnemy()
        let engine = EncounterEngine(context: ctx)

        // Spirit attack all enemies
        _ = engine.performAction(.spiritAttack(targetId: "enemy_1"))
        _ = engine.performAction(.spiritAttack(targetId: "enemy_2"))
        _ = engine.performAction(.spiritAttack(targetId: "enemy_3"))

        let result = engine.finishEncounter()

        // All should be pacified → nonviolent flag
        for (_, outcome) in result.perEntityOutcomes {
            XCTAssertEqual(outcome, .pacified)
        }
        XCTAssertEqual(result.transaction.worldFlags["nonviolent"], true, "All pacified = nonviolent")
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/LayerTests/BehaviorRuntimeTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Behavior Runtime component tests
/// Reference: ENCOUNTER_TEST_MODEL.md §3.4
final class BehaviorRuntimeTests: XCTestCase {

    // #21: Intent updates when conditions change
    func testDynamicIntentUpdate() {
        let ctx = EncounterContextFixtures.standard()
        let engine = EncounterEngine(context: ctx)

        // Round 1: full HP enemy → likely attack intent
        let intent1 = engine.generateIntent(for: "test_enemy")

        // Damage enemy significantly
        _ = engine.performAction(.attack(targetId: "test_enemy"))

        // Round 2: low HP enemy → intent may change (heal/flee)
        let intent2 = engine.generateIntent(for: "test_enemy")

        // Intent should potentially change based on HP condition
        // (exact behavior depends on behavior definition)
        XCTAssertNotNil(intent1)
        XCTAssertNotNil(intent2)
        // Dynamic: the test verifies the system CAN produce different intents
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/LayerTests/EncounterEngineTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Encounter Engine component tests
/// Reference: ENCOUNTER_TEST_MODEL.md §3.1
final class EncounterEngineTests: XCTestCase {

    // #1: Enemy has both HP and WP tracks initialized
    func testDualTrackInitialization() {
        let ctx = EncounterContextFixtures.dualTrack(enemyHP: 50, enemyWP: 30)
        let engine = EncounterEngine(context: ctx)

        XCTAssertEqual(engine.enemies[0].hp, 50)
        XCTAssertEqual(engine.enemies[0].wp, 30)
        XCTAssertEqual(engine.enemies[0].maxWp, 30)
        XCTAssertTrue(engine.enemies[0].hasSpiritTrack)
    }

    // #4: Active defense uses fate card to reduce damage
    func testActiveDefenseFateCard() {
        let ctx = EncounterContextFixtures.standard()
        let engine = EncounterEngine(context: ctx)

        // Generate enemy intent (attack)
        _ = engine.generateIntent(for: "test_enemy")
        XCTAssertNotNil(engine.currentIntent)

        let hpBefore = engine.heroHP

        // Resolve enemy attack with fate-based defense
        _ = engine.resolveEnemyAction(enemyId: "test_enemy")

        // Player should take reduced damage (defense + fate card)
        let damage = hpBefore - engine.heroHP
        XCTAssertGreaterThanOrEqual(damage, 0, "Damage should be non-negative")
    }

    // #5: Critical defense blocks all damage
    func testCriticalDefenseBlocksAll() {
        // Use critical-only fate deck
        let ctx = EncounterContext(
            hero: EncounterHero(id: "hero", hp: 100, maxHp: 100, strength: 5, armor: 2),
            enemies: [EncounterEnemy(id: "e1", name: "Attacker", hp: 50, maxHp: 50, power: 100, defense: 0)],
            fateDeckSnapshot: FateDeckManager(cards: FateDeckFixtures.criticalOnly()).getState(),
            modifiers: [],
            rules: EncounterRules(),
            rngSeed: 42
        )
        let engine = EncounterEngine(context: ctx)

        _ = engine.generateIntent(for: "e1")
        let hpBefore = engine.heroHP
        _ = engine.resolveEnemyAction(enemyId: "e1")

        // Critical defense → 0 damage
        XCTAssertEqual(engine.heroHP, hpBefore, "Critical defense should block all damage")
    }

    // #6: Intent generated in intent phase
    func testIntentGeneratedInIntentPhase() {
        let ctx = EncounterContextFixtures.standard()
        let engine = EncounterEngine(context: ctx)

        XCTAssertEqual(engine.currentPhase, .intent)
        XCTAssertNil(engine.currentIntent)

        let intent = engine.generateIntent(for: "test_enemy")

        XCTAssertNotNil(engine.currentIntent)
        XCTAssertGreaterThan(intent.value, 0, "Intent should have a value")
    }

    // #7: Intent visible before player action
    func testIntentVisibility() {
        let ctx = EncounterContextFixtures.standard()
        let engine = EncounterEngine(context: ctx)

        let intent = engine.generateIntent(for: "test_enemy")

        XCTAssertFalse(intent.description.isEmpty, "Intent must have description for UI")
        XCTAssertNotNil(intent.type, "Intent must have type")
    }

    // #8: Escalation (Spirit→Body) shifts resonance
    func testEscalationResonanceShift() {
        let ctx = EncounterContextFixtures.dualTrack(enemyHP: 100, enemyWP: 100)
        let engine = EncounterEngine(context: ctx)

        // Spirit attack first
        _ = engine.performAction(.spiritAttack(targetId: "test_enemy"))

        // Physical attack (escalation)
        let result = engine.performAction(.attack(targetId: "test_enemy"))

        // Should emit resonance shift
        let hasShift = result.stateChanges.contains { change in
            if case .resonanceShifted = change { return true }
            return false
        }
        XCTAssertTrue(hasShift, "Escalation must shift resonance toward Nav")
    }

    // #9: Escalation surprise damage bonus
    func testEscalationSurpriseDamage() {
        let ctx = EncounterContextFixtures.dualTrack(enemyHP: 100, enemyWP: 100)
        let engine = EncounterEngine(context: ctx)

        // Spirit attack first (establish diplomacy)
        _ = engine.performAction(.spiritAttack(targetId: "test_enemy"))
        let hpBefore = engine.enemies[0].hp

        // Physical attack (escalation → surprise bonus)
        _ = engine.performAction(.attack(targetId: "test_enemy"))

        let damage = hpBefore - engine.enemies[0].hp
        XCTAssertGreaterThan(damage, 0, "Escalation attack must deal boosted damage")
    }

    // #10: De-escalation applies rage shield
    func testDeEscalationRageShield() {
        let ctx = EncounterContextFixtures.dualTrack(enemyHP: 100, enemyWP: 100)
        let engine = EncounterEngine(context: ctx)

        // Physical attack first
        _ = engine.performAction(.attack(targetId: "test_enemy"))

        // Spirit attack (de-escalation)
        let result = engine.performAction(.spiritAttack(targetId: "test_enemy"))

        let hasShield = result.stateChanges.contains { change in
            if case .rageShieldApplied = change { return true }
            return false
        }
        XCTAssertTrue(hasShield, "De-escalation must apply rage shield")
        XCTAssertGreaterThan(engine.enemies[0].rageShield, 0, "Rage shield value must be > 0")
    }

    // #12: WP=0 + HP>0 → pacified
    func testPacifyOutcome() {
        let ctx = EncounterContext(
            hero: EncounterHero(id: "hero", hp: 100, maxHp: 100, strength: 5, armor: 2, wisdom: 10),
            enemies: [EncounterEnemy(id: "e1", name: "Spirit", hp: 100, maxHp: 100, wp: 1, maxWp: 1, power: 3)],
            fateDeckSnapshot: FateDeckFixtures.deterministicState(),
            modifiers: [],
            rules: EncounterRules(),
            rngSeed: 42
        )
        let engine = EncounterEngine(context: ctx)

        let result = engine.performAction(.spiritAttack(targetId: "e1"))

        let hasPacified = result.stateChanges.contains { change in
            if case .enemyPacified = change { return true }
            return false
        }
        XCTAssertTrue(hasPacified, "WP=0 + HP>0 must result in pacified")
    }

    // #16: Mulligan replaces selected cards
    func testMulliganReplace() {
        let ctx = EncounterContextFixtures.standard()
        let engine = EncounterEngine(context: ctx)

        let result = engine.performAction(.mulligan(cardIds: ["card_1", "card_2"]))

        XCTAssertTrue(result.success, "Mulligan should succeed on first attempt")
        XCTAssertTrue(engine.mulliganDone, "Mulligan flag should be set")
    }

    // #17: Mulligan only once
    func testMulliganOnceOnly() {
        let ctx = EncounterContextFixtures.standard()
        let engine = EncounterEngine(context: ctx)

        // First mulligan
        _ = engine.performAction(.mulligan(cardIds: []))
        XCTAssertTrue(engine.mulliganDone)

        // Second mulligan should fail
        let result = engine.performAction(.mulligan(cardIds: []))
        XCTAssertEqual(result.error, .mulliganAlreadyDone, "Second mulligan must return error")
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/LayerTests/FateDeckEngineTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Fate Deck Engine component tests
/// Reference: ENCOUNTER_TEST_MODEL.md §3.3
final class FateDeckEngineTests: XCTestCase {

    // #14: Wait action does not draw fate card
    func testWaitNoFateDraw() {
        let ctx = EncounterContextFixtures.standard()
        let engine = EncounterEngine(context: ctx)

        // Wait should not draw
        let result = engine.performAction(.wait)

        // No fate draw in state changes
        let hasDraw = result.stateChanges.contains { change in
            if case .fateDraw = change { return true }
            return false
        }
        XCTAssertFalse(hasDraw, "Wait action must not draw a fate card")
    }

    // #39: Fate card resolution order: DRAW → MATCH → VALUE → KEYWORD → RESONANCE
    func testResolutionOrder() {
        // Resolution pipeline is tracked through state changes emitted by resolveEnemyAction
        // When an enemy attacks, the engine: draws a fate card → checks value → applies to damage
        let ctx = EncounterContextFixtures.standard()
        let engine = EncounterEngine(context: ctx)

        // Generate and resolve enemy attack
        let intent = engine.generateIntent(for: "test_enemy")
        XCTAssertEqual(intent.type, .attack, "Default intent should be attack")

        let result = engine.resolveEnemyAction(enemyId: "test_enemy")
        XCTAssertTrue(result.success, "Enemy resolution should succeed")

        // State changes should contain fateDraw before playerHPChanged
        // This validates the resolution order: draw happens before damage calc
        var sawDraw = false
        var sawHP = false
        var orderCorrect = true

        for change in result.stateChanges {
            switch change {
            case .fateDraw:
                sawDraw = true
                if sawHP { orderCorrect = false } // draw must come before HP change
            case .playerHPChanged:
                sawHP = true
            default:
                break
            }
        }

        // If a fate card was drawn, it must appear before HP change
        if sawDraw && sawHP {
            XCTAssertTrue(orderCorrect, "Fate draw must precede HP change in resolution order")
        }
        // At minimum, HP change should occur (enemy attacked)
        XCTAssertTrue(sawHP, "Enemy attack should produce playerHPChanged")
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/LayerTests/KeywordInterpreterTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Keyword Interpreter component tests
/// Reference: ENCOUNTER_TEST_MODEL.md §3.2
/// Tests context × keyword interpretation matrix
final class KeywordInterpreterTests: XCTestCase {

    // #34: Same keyword gives different effects in different contexts
    func testSurgeInCombatPhysical() {
        let combatEffect = KeywordInterpreter.resolve(keyword: .surge, context: .combatPhysical)
        let exploreEffect = KeywordInterpreter.resolve(keyword: .surge, context: .exploration)

        XCTAssertGreaterThan(combatEffect.bonusDamage, 0,
            "Surge in combat should give bonus damage")
        XCTAssertNotNil(exploreEffect.special,
            "Surge in exploration should have special effect")
        XCTAssertNotEqual(combatEffect, exploreEffect,
            "Same keyword must give different effects in different contexts")
    }

    // #35: Match bonus when suit matches action type
    func testMatchBonusEnhanced() {
        let base = KeywordInterpreter.resolve(keyword: .surge, context: .combatPhysical, isMatch: false)
        let matched = KeywordInterpreter.resolve(keyword: .surge, context: .combatPhysical, isMatch: true)

        XCTAssertEqual(matched.bonusDamage, base.bonusDamage * 2,
            "Match bonus should double the keyword effect")
    }

    // #36: Mismatch gives only value, no keyword effect
    func testMismatchSuppressed() {
        let effect = KeywordInterpreter.resolveWithAlignment(
            keyword: .surge,
            context: .combatPhysical,
            isMismatch: true
        )

        XCTAssertEqual(effect.bonusDamage, 0, "Mismatch should suppress damage bonus")
        XCTAssertEqual(effect.bonusValue, 0, "Mismatch should suppress value bonus")
        XCTAssertNil(effect.special, "Mismatch should suppress special effect")
    }

    // #37: All keywords × all contexts = 25 combinations, none nil
    func testAllKeywordsAllContexts() {
        for keyword in FateKeyword.allCases {
            for context in ActionContext.allCases {
                let effect = KeywordInterpreter.resolve(keyword: keyword, context: context)
                // Effect should have at least one non-zero field
                let hasEffect = effect.bonusDamage > 0 || effect.bonusValue > 0 || effect.special != nil
                XCTAssertTrue(hasEffect,
                    "\(keyword)×\(context) must have a defined effect")
            }
        }
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/LayerTests/ModifierSystemTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Modifier System component tests
/// Reference: ENCOUNTER_TEST_MODEL.md §3.5
final class ModifierSystemTests: XCTestCase {

    // #13: Resonance zone affects fate card value via resonance rules
    func testResonanceCostModifier() {
        // A Nav card in deep Prav zone should have its value modified
        let navCard = FateCard(
            id: "test_nav",
            modifier: -1,
            name: "Nav Test",
            suit: .nav,
            resonanceRules: [
                FateResonanceRule(zone: .deepPrav, modifyValue: 1),  // neutralized in Prav
                FateResonanceRule(zone: .deepNav, modifyValue: -1)   // strengthened in Nav
            ]
        )

        // In deep Prav zone, the Nav card should be penalized (modifyValue = +1, i.e. less negative)
        let deepPravRule = navCard.resonanceRules.first { $0.zone == .deepPrav }
        XCTAssertNotNil(deepPravRule, "Nav card must have a deepPrav resonance rule")
        XCTAssertGreaterThan(deepPravRule!.modifyValue, 0,
            "Nav card in deep Prav zone should be weakened (positive modifier)")

        // In deep Nav zone, the Nav card should be strengthened
        let deepNavRule = navCard.resonanceRules.first { $0.zone == .deepNav }
        XCTAssertNotNil(deepNavRule, "Nav card must have a deepNav resonance rule")
        XCTAssertLessThan(deepNavRule!.modifyValue, 0,
            "Nav card in deep Nav zone should be strengthened (negative modifier)")
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/GateTests/INV_BHV_GateTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Behavior Runtime Invariants — Gate Tests
/// Reference: ENCOUNTER_TEST_MODEL.md §2.3
/// Rule: < 2 seconds, deterministic, no system RNG
final class INV_BHV_GateTests: XCTestCase {

    // Sample behavior for testing
    private func sampleBehavior() -> BehaviorDefinition {
        BehaviorDefinition(id: "aggressive_melee", rules: [
            BehaviorRule(
                conditions: [
                    BehaviorCondition(type: "hp_percent", op: ">=", value: 0.5),
                    BehaviorCondition(type: "round_number", op: ">=", value: 1.0)
                ],
                intentType: "attack",
                valueFormula: "power * heavyAttackMultiplier"
            ),
            BehaviorRule(
                conditions: [
                    BehaviorCondition(type: "hp_percent", op: "<", value: 0.3)
                ],
                intentType: "heal",
                valueFormula: "power"
            )
        ])
    }

    // INV-BHV-002: Unknown condition type → hard fail at validation
    func test_INV_BHV_002_ConditionsParsable() {
        let behavior = sampleBehavior()
        let errors = ConditionParser.validateAll(behavior)

        XCTAssertTrue(errors.isEmpty,
            "All conditions must be parsable. Errors: \(errors.joined(separator: "; "))")
    }

    // INV-BHV-004: value_formula must use whitelist (no hardcoded numbers)
    func test_INV_BHV_004_FormulaWhitelist() {
        let behavior = sampleBehavior()
        let knownMultipliers = CombatBalanceConfig.default.knownMultiplierKeys

        var formulaErrors: [String] = []
        for rule in behavior.rules {
            let unknowns = FormulaValidator.validate(
                formula: rule.valueFormula,
                knownMultipliers: knownMultipliers
            )
            if !unknowns.isEmpty {
                formulaErrors.append("\(rule.intentType): unknown tokens \(unknowns)")
            }
        }

        XCTAssertTrue(formulaErrors.isEmpty,
            "Formulas use non-whitelisted tokens: \(formulaErrors.joined(separator: "; "))")
    }

    // INV-BHV-004 (split): Escalation uses Balance Pack value (not hardcoded)
    func test_INV_BHV_004_EscalationUsesBalancePack() {
        let customConfig = CombatBalanceConfig(
            baseDamage: 3, powerModifier: 1.0, defenseReduction: 0.5,
            diceMax: 6, actionsPerTurn: 3, cardsDrawnPerTurn: 5, maxHandSize: 7,
            escalationResonanceShift: -10.0,
            escalationSurpriseBonus: 7,
            deEscalationRageShield: 5,
            matchMultiplier: 2.0
        )
        let ctx = EncounterContext(
            hero: EncounterHero(id: "h1", hp: 100, maxHp: 100, strength: 10, armor: 2, wisdom: 10),
            enemies: [EncounterEnemy(id: "e1", name: "E", hp: 50, maxHp: 50, wp: 20, maxWp: 20, power: 5, defense: 2)],
            fateDeckSnapshot: FateDeckFixtures.deterministicState(),
            modifiers: [],
            rules: EncounterRules(),
            rngSeed: 42,
            worldResonance: 0,
            balanceConfig: customConfig
        )
        let engine = EncounterEngine(context: ctx)

        // First attack spiritual, then physical to trigger escalation
        _ = engine.performAction(.spiritAttack(targetId: "e1"))
        let result = engine.performAction(.attack(targetId: "e1"))

        // Should use custom surprise bonus (7) from balance config
        let hpChange = result.stateChanges.first { change in
            if case .enemyHPChanged = change { return true }
            return false
        }
        XCTAssertNotNil(hpChange, "Physical attack after spirit should deal damage with escalation bonus")

        // Verify resonance shift uses custom value (-10.0)
        let resShift = result.stateChanges.first { change in
            if case .resonanceShifted = change { return true }
            return false
        }
        XCTAssertNotNil(resShift, "Escalation should shift resonance")
        if case .resonanceShifted(let delta, _) = resShift {
            XCTAssertEqual(delta, -10.0, "Resonance shift must come from balance config")
        }
    }

    // INV-BHV-004 (split): Match bonus multiplier from Balance Pack
    func test_INV_BHV_004_MatchMultiplierFromBalancePack() {
        let config = CombatBalanceConfig.default
        XCTAssertNotNil(config.matchMultiplier, "Match multiplier must be defined in balance config")
        XCTAssertEqual(config.matchMultiplier, 1.5, "Default match multiplier should be 1.5")
    }

    // INV-BHV-005: Intent type must be valid IntentType enum value
    func test_INV_BHV_005_IntentTypesValid() {
        let behavior = sampleBehavior()

        var invalidTypes: [String] = []
        for rule in behavior.rules {
            if !rule.hasValidIntentType {
                invalidTypes.append(rule.intentType)
            }
        }

        XCTAssertTrue(invalidTypes.isEmpty,
            "Invalid intent types: \(invalidTypes.joined(separator: ", "))")
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/GateTests/INV_CNT_GateTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Content Validation Invariants — Gate Tests
/// Reference: ENCOUNTER_TEST_MODEL.md §2.4
/// Rule: < 2 seconds, deterministic, no system RNG
final class INV_CNT_GateTests: XCTestCase {

    // INV-CNT-001: All behavior_id refs in enemies must exist
    func test_INV_CNT_001_BehaviorRefsExist() {
        // EncounterEnemy has behaviorId; EnemyDefinition does not yet.
        // Validate that any EncounterEnemy with a behaviorId references a non-empty string.
        // When BehaviorRegistry is loaded, this will validate against actual definitions.
        let testEnemies = [
            EncounterEnemy(id: "e1", name: "Wolf", hp: 10, maxHp: 10, behaviorId: "aggressive_melee"),
            EncounterEnemy(id: "e2", name: "Ghost", hp: 8, maxHp: 8, behaviorId: nil)
        ]

        var missing: [String] = []
        for enemy in testEnemies {
            if let bid = enemy.behaviorId, bid.isEmpty {
                missing.append("\(enemy.id): empty behaviorId")
            }
        }

        XCTAssertTrue(missing.isEmpty,
            "Missing behavior refs: \(missing.joined(separator: ", "))")
    }

    // INV-CNT-002: All fate card IDs must be globally unique
    func test_INV_CNT_002_FateCardIdsUnique() {
        TestContentLoader.loadContentPacksIfNeeded()
        let fateCards = ContentRegistry.shared.getAllFateCards()
        var seen = Set<String>()
        var dupes: [String] = []

        for card in fateCards {
            if seen.contains(card.id) { dupes.append(card.id) }
            seen.insert(card.id)
        }

        XCTAssertTrue(dupes.isEmpty, "Duplicate fate card IDs: \(dupes.joined(separator: ", "))")
    }

    // INV-CNT-003: MULTIPLIER_ID in value_formula must exist in Balance Pack
    func test_INV_CNT_003_MultiplierRefsExist() {
        let behavior = BehaviorDefinition(id: "test_behavior", rules: [
            BehaviorRule(
                conditions: [BehaviorCondition(type: "hp_percent", op: ">=", value: 0.5)],
                intentType: "attack",
                valueFormula: "power * heavyAttackMultiplier"
            )
        ])

        let knownMultipliers = CombatBalanceConfig.default.knownMultiplierKeys

        var unknownRefs: [String] = []
        for rule in behavior.rules {
            let unknowns = FormulaValidator.validate(
                formula: rule.valueFormula,
                knownMultipliers: knownMultipliers
            )
            unknownRefs.append(contentsOf: unknowns)
        }

        XCTAssertTrue(unknownRefs.isEmpty,
            "Unknown multiplier refs: \(unknownRefs.joined(separator: ", "))")
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/GateTests/INV_ENC_GateTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Encounter Engine Invariants — Gate Tests
/// Reference: ENCOUNTER_TEST_MODEL.md §2.1
/// Rule: < 2 seconds, deterministic, no system RNG
final class INV_ENC_GateTests: XCTestCase {

    // INV-ENC-002: Physical attack affects only HP, not WP
    func test_INV_ENC_002_PhysicalAttackHPOnly() {
        // Arrange
        let ctx = EncounterContextFixtures.dualTrack(enemyHP: 50, enemyWP: 30)
        let engine = EncounterEngine(context: ctx)

        let initialHP = engine.enemies[0].hp
        let initialWP = engine.enemies[0].wp

        // Act: physical attack
        _ = engine.performAction(.attack(targetId: "test_enemy"))

        // Assert: HP changed, WP unchanged
        XCTAssertLessThan(engine.enemies[0].hp, initialHP, "HP must decrease after physical attack")
        XCTAssertEqual(engine.enemies[0].wp, initialWP, "WP must NOT change on physical attack")
    }

    // INV-ENC-002 (split): Spiritual attack affects only WP, not HP
    func test_INV_ENC_002_SpiritualAttackWPOnly() {
        // Arrange
        let ctx = EncounterContextFixtures.dualTrack(enemyHP: 50, enemyWP: 30)
        let engine = EncounterEngine(context: ctx)

        let initialHP = engine.enemies[0].hp
        let initialWP = engine.enemies[0].wp!

        // Act: spirit attack
        _ = engine.performAction(.spiritAttack(targetId: "test_enemy"))

        // Assert: WP changed, HP unchanged
        XCTAssertLessThan(engine.enemies[0].wp!, initialWP, "WP must decrease after spiritual attack")
        XCTAssertEqual(engine.enemies[0].hp, initialHP, "HP must NOT change on spiritual attack")
    }

    // INV-ENC-003: HP=0 → killed, regardless of WP state
    func test_INV_ENC_003_KillPriorityWhenBothZero() {
        // Arrange: weak enemy (1 HP, 1 WP)
        let ctx = EncounterContextFixtures.weakEnemy()
        let engine = EncounterEngine(context: ctx)

        // Act: spirit attack to reduce WP to 0
        _ = engine.performAction(.spiritAttack(targetId: "weak_enemy"))

        // Act: physical attack to reduce HP to 0
        let result = engine.performAction(.attack(targetId: "weak_enemy"))

        // Assert: outcome is killed (not pacified)
        let hasKilled = result.stateChanges.contains { change in
            if case .enemyKilled = change { return true }
            return false
        }
        XCTAssertTrue(hasKilled, "When HP=0, outcome must be .killed regardless of WP")
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/GateTests/INV_FATE_GateTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Fate Deck Invariants — Gate Tests
/// Reference: ENCOUNTER_TEST_MODEL.md §2.2
/// Rule: < 2 seconds, deterministic, no system RNG
final class INV_FATE_GateTests: XCTestCase {

    // INV-FATE-001: FateDeck is global across contexts (conservation)
    func test_INV_FATE_001_DeckConservation() {
        let ctx = EncounterContextFixtures.standard()
        let initialSnapshot = ctx.fateDeckSnapshot
        let engine = EncounterEngine(context: ctx)

        // Perform attack to trigger fate draw in enemy resolution
        _ = engine.generateIntent(for: "test_enemy")
        _ = engine.resolveEnemyAction(enemyId: "test_enemy")

        let result = engine.finishEncounter()

        // The updated fate deck state must differ from initial (cards were drawn)
        XCTAssertNotEqual(initialSnapshot, result.updatedFateDeck,
            "Fate deck state must change after cards are drawn")
    }

    // INV-FATE-002: Wait action has no side effects on Fate deck
    func test_INV_FATE_002_WaitNoFateDeckSideEffect() {
        let ctx = EncounterContextFixtures.standard()
        let engine = EncounterEngine(context: ctx)

        let result = engine.performAction(.wait)

        let hasDraw = result.stateChanges.contains { change in
            if case .fateDraw = change { return true }
            return false
        }
        XCTAssertFalse(hasDraw, "Wait action must not draw a fate card")
    }

    // INV-FATE-006: All fate card suits must be valid
    func test_INV_FATE_006_SuitValidity() {
        TestContentLoader.loadContentPacksIfNeeded()
        let fateCards = ContentRegistry.shared.getAllFateCards()

        let validSuits: Set<String> = ["nav", "prav", "yav"]
        var invalid: [String] = []

        for card in fateCards {
            if let suit = card.suit?.rawValue, !validSuits.contains(suit) {
                invalid.append("\(card.id): \(suit)")
            }
        }

        XCTAssertTrue(invalid.isEmpty, "Invalid suits: \(invalid.joined(separator: ", "))")
    }

    // INV-FATE-007: Choice cards must have both options
    func test_INV_FATE_007_ChoiceCardCompleteness() {
        TestContentLoader.loadContentPacksIfNeeded()
        let fateCards = ContentRegistry.shared.getAllFateCards()

        let choiceCards = fateCards.filter { $0.cardType == .choice }
        var incomplete: [String] = []

        for card in choiceCards {
            guard let options = card.choiceOptions, options.count >= 2 else {
                incomplete.append(card.id)
                continue
            }
        }

        XCTAssertTrue(incomplete.isEmpty,
            "Choice cards missing 2+ options: \(incomplete.joined(separator: ", "))")
    }

    // INV-FATE-008: All fate card keywords must be valid FateKeyword enum values
    func test_INV_FATE_008_KeywordValidity() {
        // Validate that:
        // 1. FateKeyword enum exists and has all expected cases
        // 2. Any card with a keyword has a valid value (guaranteed by Codable decode)
        // 3. Programmatic FateCard init accepts keywords correctly

        let allKeywords = FateKeyword.allCases
        XCTAssertEqual(allKeywords.count, 5, "FateKeyword must have exactly 5 cases")

        let expectedRawValues: Set<String> = ["surge", "focus", "echo", "shadow", "ward"]
        let actualRawValues = Set(allKeywords.map { $0.rawValue })
        XCTAssertEqual(actualRawValues, expectedRawValues,
            "FateKeyword cases must match spec")

        // Verify keyword round-trips through Codable
        for keyword in allKeywords {
            let card = FateCard(id: "test_\(keyword.rawValue)", modifier: 0, name: "Test", keyword: keyword)
            let data = try! JSONEncoder().encode(card)
            let decoded = try! JSONDecoder().decode(FateCard.self, from: data)
            XCTAssertEqual(decoded.keyword, keyword,
                "Keyword \(keyword.rawValue) must survive encode/decode")
        }
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/Helpers/EncounterContextFixtures.swift
// ==========================================

import Foundation
@testable import TwilightEngine

/// Deterministic fixtures for Encounter tests
/// Rule: No UUID(), no Int.random(), no system RNG. All data hardcoded or seeded.
enum EncounterContextFixtures {

    /// Minimal valid context: 1 hero vs 1 enemy with dual tracks
    static func standard(seed: UInt64 = 42) -> EncounterContext {
        EncounterContext(
            hero: EncounterHero(
                id: "test_hero",
                hp: 100, maxHp: 100,
                strength: 5, armor: 2, wisdom: 3, willDefense: 1
            ),
            enemies: [
                EncounterEnemy(
                    id: "test_enemy",
                    name: "Test Enemy",
                    hp: 50, maxHp: 50,
                    wp: 30, maxWp: 30,
                    power: 5, defense: 2
                )
            ],
            fateDeckSnapshot: FateDeckFixtures.deterministicState(),
            modifiers: [],
            rules: EncounterRules(),
            rngSeed: seed
        )
    }

    /// Context with dual-track enemy (custom HP/WP)
    static func dualTrack(enemyHP: Int = 50, enemyWP: Int = 30, seed: UInt64 = 42) -> EncounterContext {
        EncounterContext(
            hero: EncounterHero(
                id: "test_hero",
                hp: 100, maxHp: 100,
                strength: 5, armor: 2
            ),
            enemies: [
                EncounterEnemy(
                    id: "test_enemy",
                    name: "Test Enemy",
                    hp: enemyHP, maxHp: enemyHP,
                    wp: enemyWP, maxWp: enemyWP,
                    power: 5, defense: 2
                )
            ],
            fateDeckSnapshot: FateDeckFixtures.deterministicState(),
            modifiers: [],
            rules: EncounterRules(),
            rngSeed: seed
        )
    }

    /// Multi-enemy context (1 vs 3)
    static func multiEnemy(seed: UInt64 = 42) -> EncounterContext {
        EncounterContext(
            hero: EncounterHero(
                id: "test_hero",
                hp: 100, maxHp: 100,
                strength: 5, armor: 2, wisdom: 10
            ),
            enemies: [
                EncounterEnemy(id: "enemy_1", name: "Bandit A", hp: 10, maxHp: 10, wp: 5, maxWp: 5, power: 3, defense: 1),
                EncounterEnemy(id: "enemy_2", name: "Bandit B", hp: 15, maxHp: 15, wp: 8, maxWp: 8, power: 4, defense: 1),
                EncounterEnemy(id: "enemy_3", name: "Bandit C", hp: 20, maxHp: 20, wp: 10, maxWp: 10, power: 5, defense: 2)
            ],
            fateDeckSnapshot: FateDeckFixtures.deterministicState(),
            modifiers: [],
            rules: EncounterRules(),
            rngSeed: seed
        )
    }

    /// Weak enemy (1 HP, 1 WP) for kill/pacify priority tests
    static func weakEnemy(seed: UInt64 = 42) -> EncounterContext {
        EncounterContext(
            hero: EncounterHero(
                id: "test_hero",
                hp: 100, maxHp: 100,
                strength: 10, armor: 2
            ),
            enemies: [
                EncounterEnemy(
                    id: "weak_enemy",
                    name: "Weak Enemy",
                    hp: 1, maxHp: 1,
                    wp: 1, maxWp: 1,
                    power: 1, defense: 0
                )
            ],
            fateDeckSnapshot: FateDeckFixtures.deterministicState(),
            modifiers: [],
            rules: EncounterRules(),
            rngSeed: seed
        )
    }
}

/// Deterministic Fate deck fixtures
enum FateDeckFixtures {

    /// 5 known cards
    static func deterministic() -> [FateCard] {
        [
            FateCard(id: "fate_1", modifier: 1, name: "Fortune +1"),
            FateCard(id: "fate_2", modifier: 2, name: "Fortune +2"),
            FateCard(id: "fate_3", modifier: -1, name: "Misfortune -1"),
            FateCard(id: "fate_4", modifier: 3, isCritical: true, name: "Critical"),
            FateCard(id: "fate_5", modifier: 0, name: "Neutral")
        ]
    }

    /// FateDeckState from deterministic cards (for EncounterContext)
    static func deterministicState() -> FateDeckState {
        let manager = FateDeckManager(cards: deterministic())
        return manager.getState()
    }

    /// Single critical card
    static func criticalOnly() -> [FateCard] {
        [FateCard(id: "crit_1", modifier: 3, isCritical: true, name: "Critical Block")]
    }
}


// ==========================================
// FILE: Packages/TwilightEngine/Tests/TwilightEngineTests/Helpers/TestContentLoader.swift
// ==========================================

import Foundation
@testable import TwilightEngine

/// Helper для загрузки ContentPacks в тестовом окружении пакета TwilightEngine
/// Загружает паки из директории проекта (CoreHeroes + TwilightMarchesActI)
enum TestContentLoader {

    /// Флаг, показывающий загружены ли паки
    private(set) static var isLoaded = false

    /// Загрузить ContentPacks из исходной директории
    /// Безопасно вызывать многократно - загрузка произойдёт только один раз
    static func loadContentPacksIfNeeded() {
        let registry = ContentRegistry.shared

        // Always check actual registry state, not just isLoaded flag.
        // Other test classes may call resetForTesting() which clears the registry.
        guard registry.loadedPackIds.isEmpty else {
            isLoaded = true
            return
        }

        let packURLs = findContentPacksURLs()

        guard !packURLs.isEmpty else {
            print("⚠️ TestContentLoader: ContentPacks not found")
            return
        }

        do {
            try registry.loadPacks(from: packURLs)
            print("✅ TestContentLoader: Loaded \(packURLs.count) packs")
            isLoaded = true
        } catch {
            print("❌ TestContentLoader: Failed to load packs: \(error)")
        }
    }

    /// Найти пути к ContentPacks
    private static func findContentPacksURLs() -> [URL] {
        // Путь от файла теста к корню проекта:
        // TwilightEngineTests/Helpers/TestContentLoader.swift
        //   → TwilightEngineTests
        //   → Tests
        //   → TwilightEngine
        //   → Packages
        //   → ProjectRoot
        let testFilePath = URL(fileURLWithPath: #filePath)
        let projectRoot = testFilePath
            .deletingLastPathComponent()  // Helpers
            .deletingLastPathComponent()  // TwilightEngineTests
            .deletingLastPathComponent()  // Tests
            .deletingLastPathComponent()  // TwilightEngine
            .deletingLastPathComponent()  // Packages
            .deletingLastPathComponent()  // Project root

        var urls: [URL] = []

        // Character pack (CoreHeroes) — must point to .pack file, not directory
        let coreHeroesPath = projectRoot
            .appendingPathComponent("Packages")
            .appendingPathComponent("CharacterPacks")
            .appendingPathComponent("CoreHeroes")
            .appendingPathComponent("Sources")
            .appendingPathComponent("CoreHeroesContent")
            .appendingPathComponent("Resources")
            .appendingPathComponent("CoreHeroes.pack")

        if FileManager.default.fileExists(atPath: coreHeroesPath.path) {
            urls.append(coreHeroesPath)
        }

        // Story pack (TwilightMarchesActI) — must point to .pack file, not directory
        let storyPackPath = projectRoot
            .appendingPathComponent("Packages")
            .appendingPathComponent("StoryPacks")
            .appendingPathComponent("Season1")
            .appendingPathComponent("TwilightMarchesActI")
            .appendingPathComponent("Sources")
            .appendingPathComponent("TwilightMarchesActIContent")
            .appendingPathComponent("Resources")
            .appendingPathComponent("TwilightMarchesActI.pack")

        if FileManager.default.fileExists(atPath: storyPackPath.path) {
            urls.append(storyPackPath)
        }

        if urls.isEmpty {
            print("❌ TestContentLoader: ContentPacks not found")
        }

        return urls
    }

    /// Сбросить состояние (для изолированных тестов)
    static func reset() {
        ContentRegistry.shared.unloadAllPacks()
        CardRegistry.shared.clear()
        AbilityRegistry.shared.clear()
        isLoaded = false
    }
}


// ==========================================
// FILE: CardSampleGameTests/Unit/HeroRegistryTests.swift
// ==========================================

import XCTest
import TwilightEngine
import CoreHeroesContent
import TwilightMarchesActIContent

@testable import CardSampleGame

/// Тесты для загрузки героев из Content Pack через ContentRegistry
final class HeroRegistryTests: XCTestCase {

    override func setUp() {
        super.setUp()
        TestContentLoader.loadContentPacksIfNeeded()
    }

    // MARK: - Базовые тесты

    func testRegistryHasHeroes() {
        let heroes = ContentRegistry.shared.getAllHeroes()
        XCTAssertGreaterThan(heroes.count, 0, "Реестр должен содержать героев из контент пака")
    }

    func testHeroHasValidStats() {
        let heroes = ContentRegistry.shared.getAllHeroes()

        for hero in heroes {
            XCTAssertGreaterThan(hero.baseStats.maxHealth, 0, "Герой \(hero.id) должен иметь maxHealth > 0")
            XCTAssertGreaterThan(hero.baseStats.maxFaith, 0, "Герой \(hero.id) должен иметь maxFaith > 0")
        }
    }

    func testHeroHasSpecialAbility() {
        let heroes = ContentRegistry.shared.getAllHeroes()

        for hero in heroes {
            XCTAssertFalse(hero.specialAbility.id.isEmpty, "Герой \(hero.id) должен иметь способность")
        }
    }

    // MARK: - Тесты поиска по ID

    func testHeroLookupById() {
        let heroes = ContentRegistry.shared.getAllHeroes()

        guard let firstHero = heroes.first else {
            XCTFail("Нет героев в реестре")
            return
        }

        let foundHero = ContentRegistry.shared.getHero(id: firstHero.id)
        XCTAssertNotNil(foundHero)
        XCTAssertEqual(foundHero?.id, firstHero.id)
    }

    func testNonExistentHeroReturnsNil() {
        let hero = ContentRegistry.shared.getHero(id: "nonexistent_hero_12345")
        XCTAssertNil(hero)
    }

    // MARK: - Тесты доступности

    func testAvailableHeroes() {
        let heroes = ContentRegistry.shared.getAllHeroes()
        let available = heroes.filter { hero in
            if case .alwaysAvailable = hero.availability {
                return true
            }
            return false
        }

        XCTAssertGreaterThan(available.count, 0, "Должны быть доступные герои")
    }

    // MARK: - Тесты стартовых колод

    func testHeroesHaveStartingDecks() {
        let heroes = ContentRegistry.shared.getAllHeroes()

        for hero in heroes {
            XCTAssertFalse(hero.startingDeckCardIDs.isEmpty,
                          "Герой \(hero.id) должен иметь стартовую колоду")
        }
    }

    // MARK: - Тесты первого героя

    func testFirstHeroExists() {
        let heroes = ContentRegistry.shared.getAllHeroes()
        XCTAssertFalse(heroes.isEmpty, "Должен быть хотя бы один герой")
    }
}


// ==========================================
// FILE: CardSampleGameTests/Unit/SaveLoadTests.swift
// ==========================================

import XCTest
import TwilightEngine

@testable import CardSampleGame

/// Engine-First Save/Load Tests
/// Tests the EngineSave-based save system (no legacy GameSave)
final class SaveLoadTests: XCTestCase {

    var engine: TwilightGameEngine!
    var saveManager: SaveManager!

    override func setUp() {
        super.setUp()
        TestContentLoader.loadContentPacksIfNeeded()
        engine = TwilightGameEngine()
        engine.initializeNewGame(playerName: "Test Hero", heroId: nil)
        saveManager = SaveManager()

        // Clear test slots
        for slot in 100...105 {
            saveManager.deleteSave(from: slot)
        }
    }

    override func tearDown() {
        // Clear after tests
        for slot in 100...105 {
            saveManager.deleteSave(from: slot)
        }
        engine = nil
        saveManager = nil
        WorldRNG.shared.setSeed(0)
        super.tearDown()
    }

    // MARK: - Basic Save/Load

    func testSaveGameCreatesSlot() {
        saveManager.saveGame(to: 100, engine: engine)
        XCTAssertTrue(saveManager.hasSave(in: 100), "Slot should have a save")
    }

    func testSaveGamePreservesPlayerName() {
        saveManager.saveGame(to: 100, engine: engine)
        let save = saveManager.getSave(from: 100)

        XCTAssertEqual(save?.playerName, "Test Hero")
    }

    func testSaveGamePreservesHealth() {
        let initialHealth = engine.playerHealth
        let initialMaxHealth = engine.playerMaxHealth

        saveManager.saveGame(to: 100, engine: engine)
        let save = saveManager.getSave(from: 100)

        XCTAssertEqual(save?.playerHealth, initialHealth)
        XCTAssertEqual(save?.playerMaxHealth, initialMaxHealth)
    }

    func testSaveGamePreservesFaith() {
        let initialFaith = engine.playerFaith
        let initialMaxFaith = engine.playerMaxFaith

        saveManager.saveGame(to: 100, engine: engine)
        let save = saveManager.getSave(from: 100)

        XCTAssertEqual(save?.playerFaith, initialFaith)
        XCTAssertEqual(save?.playerMaxFaith, initialMaxFaith)
    }

    func testSaveGamePreservesBalance() {
        let initialBalance = engine.playerBalance

        saveManager.saveGame(to: 100, engine: engine)
        let save = saveManager.getSave(from: 100)

        XCTAssertEqual(save?.playerBalance, initialBalance)
    }

    func testSaveGamePreservesCurrentDay() {
        // Advance some days
        _ = engine.performAction(.skipTurn)
        _ = engine.performAction(.skipTurn)
        let currentDay = engine.currentDay

        saveManager.saveGame(to: 100, engine: engine)
        let save = saveManager.getSave(from: 100)

        XCTAssertEqual(save?.currentDay, currentDay)
    }

    // MARK: - Deck Preservation (CRITICAL)

    func testSaveGamePreservesDeck() {
        let deckCount = engine.playerDeck.count

        saveManager.saveGame(to: 100, engine: engine)
        let save = saveManager.getSave(from: 100)

        XCTAssertEqual(save?.deckCardIds.count, deckCount, "Deck preserved")
    }

    func testSaveGamePreservesHand() {
        let handCount = engine.playerHand.count

        saveManager.saveGame(to: 100, engine: engine)
        let save = saveManager.getSave(from: 100)

        XCTAssertEqual(save?.handCardIds.count, handCount, "Hand preserved")
    }

    // MARK: - World State Preservation (CRITICAL)

    func testSaveGamePreservesWorldTension() {
        // Advance time to increase tension
        for _ in 0..<6 {
            _ = engine.performAction(.skipTurn)
        }
        let tension = engine.worldTension

        saveManager.saveGame(to: 100, engine: engine)
        let save = saveManager.getSave(from: 100)

        XCTAssertEqual(save?.worldTension, tension)
    }

    func testSaveGamePreservesMainQuestStage() {
        let stage = engine.mainQuestStage

        saveManager.saveGame(to: 100, engine: engine)
        let save = saveManager.getSave(from: 100)

        XCTAssertEqual(save?.mainQuestStage, stage)
    }

    func testSaveGamePreservesWorldFlags() {
        engine.setWorldFlags(["test_flag": true, "another_flag": false])

        saveManager.saveGame(to: 100, engine: engine)
        let save = saveManager.getSave(from: 100)

        XCTAssertEqual(save?.worldFlags["test_flag"], true)
        XCTAssertEqual(save?.worldFlags["another_flag"], false)
    }

    // MARK: - Load Game

    func testLoadGameRestoresHealth() {
        saveManager.saveGame(to: 100, engine: engine)
        let savedHealth = engine.playerHealth

        let newEngine = TwilightGameEngine()
        TestContentLoader.loadContentPacksIfNeeded()
        XCTAssertTrue(saveManager.loadGame(from: 100, engine: newEngine))

        XCTAssertEqual(newEngine.playerHealth, savedHealth)
    }

    func testLoadGameRestoresFaith() {
        saveManager.saveGame(to: 100, engine: engine)
        let savedFaith = engine.playerFaith

        let newEngine = TwilightGameEngine()
        TestContentLoader.loadContentPacksIfNeeded()
        XCTAssertTrue(saveManager.loadGame(from: 100, engine: newEngine))

        XCTAssertEqual(newEngine.playerFaith, savedFaith)
    }

    func testLoadGameRestoresBalance() {
        saveManager.saveGame(to: 100, engine: engine)
        let savedBalance = engine.playerBalance

        let newEngine = TwilightGameEngine()
        TestContentLoader.loadContentPacksIfNeeded()
        XCTAssertTrue(saveManager.loadGame(from: 100, engine: newEngine))

        XCTAssertEqual(newEngine.playerBalance, savedBalance)
    }

    func testLoadGameRestoresCurrentDay() {
        _ = engine.performAction(.skipTurn)
        _ = engine.performAction(.skipTurn)
        saveManager.saveGame(to: 100, engine: engine)
        let savedDay = engine.currentDay

        let newEngine = TwilightGameEngine()
        TestContentLoader.loadContentPacksIfNeeded()
        XCTAssertTrue(saveManager.loadGame(from: 100, engine: newEngine))

        XCTAssertEqual(newEngine.currentDay, savedDay)
    }

    func testLoadGameRestoresWorldTension() {
        for _ in 0..<6 {
            _ = engine.performAction(.skipTurn)
        }
        saveManager.saveGame(to: 100, engine: engine)
        let savedTension = engine.worldTension

        let newEngine = TwilightGameEngine()
        TestContentLoader.loadContentPacksIfNeeded()
        XCTAssertTrue(saveManager.loadGame(from: 100, engine: newEngine))

        XCTAssertEqual(newEngine.worldTension, savedTension)
    }

    // MARK: - Delete Save

    func testDeleteSave() {
        saveManager.saveGame(to: 100, engine: engine)
        XCTAssertTrue(saveManager.hasSave(in: 100))

        saveManager.deleteSave(from: 100)

        XCTAssertFalse(saveManager.hasSave(in: 100))
    }

    // MARK: - Multiple Slots

    func testMultipleSaveSlots() {
        engine.initializeNewGame(playerName: "Hero 1", heroId: nil)
        saveManager.saveGame(to: 101, engine: engine)

        engine.initializeNewGame(playerName: "Hero 2", heroId: nil)
        saveManager.saveGame(to: 102, engine: engine)

        let save1 = saveManager.getSave(from: 101)
        let save2 = saveManager.getSave(from: 102)

        XCTAssertEqual(save1?.playerName, "Hero 1")
        XCTAssertEqual(save2?.playerName, "Hero 2")
    }

    func testOverwriteSave() {
        // Ensure slot is clean
        saveManager.deleteSave(from: 100)

        let firstDay = engine.currentDay
        saveManager.saveGame(to: 100, engine: engine)

        // Advance time (use skipTurn - doesn't require region validation)
        _ = engine.performAction(.skipTurn)
        _ = engine.performAction(.skipTurn)

        let secondDay = engine.currentDay
        XCTAssertGreaterThan(secondDay, firstDay, "Day should advance after skipTurn")

        // Overwrite save
        saveManager.saveGame(to: 100, engine: engine)

        let save = saveManager.getSave(from: 100)
        XCTAssertEqual(save?.currentDay, secondDay, "Save should have updated day")
    }

    // MARK: - Data Integrity

    func testSaveDataIntegrity() {
        // Advance the game a bit
        for _ in 0..<5 {
            _ = engine.performAction(.skipTurn)
        }

        saveManager.saveGame(to: 100, engine: engine)

        let newEngine = TwilightGameEngine()
        TestContentLoader.loadContentPacksIfNeeded()
        XCTAssertTrue(saveManager.loadGame(from: 100, engine: newEngine))

        // Verify all fields match
        XCTAssertEqual(newEngine.playerName, engine.playerName)
        XCTAssertEqual(newEngine.playerHealth, engine.playerHealth)
        XCTAssertEqual(newEngine.playerMaxHealth, engine.playerMaxHealth)
        XCTAssertEqual(newEngine.playerFaith, engine.playerFaith)
        XCTAssertEqual(newEngine.playerMaxFaith, engine.playerMaxFaith)
        XCTAssertEqual(newEngine.playerBalance, engine.playerBalance)
        XCTAssertEqual(newEngine.currentDay, engine.currentDay)
        XCTAssertEqual(newEngine.worldTension, engine.worldTension)
        XCTAssertEqual(newEngine.mainQuestStage, engine.mainQuestStage)
    }

    // MARK: - EngineSave Encoding/Decoding

    func testEngineSaveEncodeDecode() {
        saveManager.saveGame(to: 100, engine: engine)

        guard let save = saveManager.getSave(from: 100) else {
            XCTFail("Failed to get save")
            return
        }

        do {
            let encoded = try JSONEncoder().encode(save)
            let decoded = try JSONDecoder().decode(EngineSave.self, from: encoded)

            XCTAssertEqual(decoded.playerName, save.playerName)
            XCTAssertEqual(decoded.playerHealth, save.playerHealth)
            XCTAssertEqual(decoded.currentDay, save.currentDay)
        } catch {
            XCTFail("Encoding error: \(error)")
        }
    }

    // MARK: - Pack Compatibility (Epic 7)

    func testSaveStoresPackSetAndRefusesIncompatibleLoad() {
        // 1. Save the game - should capture current pack set
        saveManager.saveGame(to: 100, engine: engine)

        guard let save = saveManager.getSave(from: 100) else {
            XCTFail("Failed to get save")
            return
        }

        // 2. Verify save stores pack compatibility info
        XCTAssertFalse(save.coreVersion.isEmpty, "Save should store coreVersion")
        XCTAssertGreaterThan(save.formatVersion, 0, "Save should store formatVersion")
        // activePackSet may be empty if no packs loaded - that's OK for test

        // 3. Verify compatibility check works for current save
        let compatibility = save.validateCompatibility(with: ContentRegistry.shared)
        XCTAssertTrue(compatibility.isLoadable, "Save with current packs should be loadable")

        // 4. Test incompatible save (format version too new)
        let incompatibleSave = EngineSave(
            version: save.version,
            savedAt: save.savedAt,
            gameDuration: save.gameDuration,
            coreVersion: save.coreVersion,
            activePackSet: save.activePackSet,
            formatVersion: EngineSave.currentFormatVersion + 10, // Future format
            primaryCampaignPackId: "nonexistent_campaign_pack", // Missing pack
            playerName: save.playerName,
            heroId: save.heroId,
            playerHealth: save.playerHealth,
            playerMaxHealth: save.playerMaxHealth,
            playerFaith: save.playerFaith,
            playerMaxFaith: save.playerMaxFaith,
            playerBalance: save.playerBalance,
            deckCardIds: save.deckCardIds,
            handCardIds: save.handCardIds,
            discardCardIds: save.discardCardIds,
            currentDay: save.currentDay,
            worldTension: save.worldTension,
            lightDarkBalance: save.lightDarkBalance,
            currentRegionId: save.currentRegionId,
            regions: save.regions,
            mainQuestStage: save.mainQuestStage,
            activeQuestIds: save.activeQuestIds,
            completedQuestIds: save.completedQuestIds,
            questStages: save.questStages,
            completedEventIds: save.completedEventIds,
            eventLog: save.eventLog,
            worldFlags: save.worldFlags,
            rngSeed: save.rngSeed,
            rngState: save.rngState
        )

        // 5. Verify incompatible save is rejected
        let incompatibleResult = incompatibleSave.validateCompatibility(with: ContentRegistry.shared)
        XCTAssertFalse(incompatibleResult.isLoadable, "Save with future format should not be loadable")
        XCTAssertFalse(incompatibleResult.errorMessages.isEmpty, "Should have error messages")

        // 6. Test SaveManager returns detailed result
        let loadResult = saveManager.loadGameWithResult(from: 100, engine: engine)
        XCTAssertTrue(loadResult.success, "Loading current save should succeed")
        XCTAssertNil(loadResult.error, "No error for successful load")
    }

    func testSaveStoresPrimaryCampaignPackId() {
        // Save should capture the primary campaign pack
        saveManager.saveGame(to: 100, engine: engine)

        guard let save = saveManager.getSave(from: 100) else {
            XCTFail("Failed to get save")
            return
        }

        // If packs are loaded, primaryCampaignPackId should be set
        // If no packs loaded (test environment), it can be nil - that's OK
        if !ContentRegistry.shared.loadedPacks.isEmpty {
            // At least one pack loaded - check if it's a campaign/full pack
            let hasCampaignPack = ContentRegistry.shared.loadedPacks.values
                .contains { $0.manifest.packType == .campaign || $0.manifest.packType == .full }

            if hasCampaignPack {
                XCTAssertNotNil(save.primaryCampaignPackId, "Should store primary campaign pack ID")
            }
        }

        // Either way, the save should be valid
        let compatibility = save.validateCompatibility(with: ContentRegistry.shared)
        XCTAssertTrue(compatibility.isLoadable, "Save should be loadable")
    }

    func testLoadGameWithResultReturnsSaveNotFoundError() {
        // Try to load from empty slot
        let result = saveManager.loadGameWithResult(from: 999, engine: engine)

        XCTAssertFalse(result.success, "Loading from empty slot should fail")
        XCTAssertNotNil(result.error, "Should have error")

        if case .saveNotFound(let slot) = result.error {
            XCTAssertEqual(slot, 999, "Error should contain correct slot")
        } else {
            XCTFail("Expected saveNotFound error")
        }
    }
}


// ==========================================
// FILE: CardSampleGameTests/Unit/ContentPackTests/ContentManagerTests.swift
// ==========================================

import XCTest
import TwilightEngine
import CoreHeroesContent
import TwilightMarchesActIContent

@testable import CardSampleGame

/// Tests for ContentManager functionality
final class ContentManagerTests: XCTestCase {

    // MARK: - Properties

    private var characterPackURL: URL?
    private var storyPackURL: URL?

    // MARK: - Setup

    override func setUp() {
        super.setUp()
        // Reset managers before each test
        ContentRegistry.shared.resetForTesting()
        ContentManager.shared.reset()

        // Use TestContentLoader for robust URL discovery
        characterPackURL = TestContentLoader.characterPackURL
        storyPackURL = TestContentLoader.storyPackURL
    }

    override func tearDown() {
        ContentRegistry.shared.resetForTesting()
        ContentManager.shared.reset()
        characterPackURL = nil
        storyPackURL = nil
        super.tearDown()
    }

    // MARK: - Pack Discovery Tests

    func testDiscoverPacksFindsProvidedURLs() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // When - Discover packs with bundled URLs
        let discovered = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!, storyPackURL!])

        // Then - Both packs should be discovered
        XCTAssertEqual(discovered.count, 2)

        let packIds = discovered.map { $0.id }
        XCTAssertTrue(packIds.contains("core-heroes"))
        XCTAssertTrue(packIds.contains("twilight-marches-act1"))
    }

    func testDiscoveredPacksHaveCorrectSource() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // When
        let discovered = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // Then - Should be marked as bundled source
        XCTAssertEqual(discovered.count, 1)
        if case .bundled = discovered[0].source {
            // OK - correct source type
        } else {
            XCTFail("Pack should have bundled source")
        }
    }

    func testDiscoveredPacksHaveManifest() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // When
        let discovered = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // Then - Should have manifest loaded
        XCTAssertEqual(discovered.count, 1)
        XCTAssertNotNil(discovered[0].manifest)
        XCTAssertEqual(discovered[0].manifest?.packId, "core-heroes")
    }

    func testDiscoveredPacksStartInDiscoveredState() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // When
        let discovered = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // Then - Should start in discovered state (not loaded yet)
        XCTAssertEqual(discovered.count, 1)
        XCTAssertEqual(discovered[0].state, .discovered)
    }

    // MARK: - Pack Validation Tests

    func testValidatePackReturnsValidSummary() async throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given - Discover pack first
        _ = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // When - Validate pack
        let summary = await ContentManager.shared.validatePack("core-heroes")

        // Then - Should be valid
        XCTAssertEqual(summary.packId, "core-heroes")
        XCTAssertEqual(summary.errorCount, 0, "Pack should have no errors")
        XCTAssertTrue(summary.isValid)
    }

    func testValidatePackFileDirectly() async throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // When - Validate pack file directly
        let summary = await ContentManager.shared.validatePackFile(at: characterPackURL!)

        // Then
        XCTAssertEqual(summary.errorCount, 0)
        XCTAssertTrue(summary.isValid)
        XCTAssertGreaterThan(summary.duration, 0)
    }

    func testValidateNonExistentPackReturnsError() async {
        // When - Validate non-existent pack
        let summary = await ContentManager.shared.validatePack("non-existent-pack")

        // Then - Should return error
        XCTAssertEqual(summary.errorCount, 1)
        XCTAssertFalse(summary.isValid)
        XCTAssertTrue(summary.errors.contains { $0.contains("not found") })
    }

    // MARK: - Pack Loading Tests

    func testLoadPackSucceeds() async throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given - Discover pack
        _ = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // When - Load pack
        let loadedPack = try await ContentManager.shared.loadPack("core-heroes")

        // Then
        XCTAssertEqual(loadedPack.manifest.packId, "core-heroes")
        XCTAssertTrue(ContentRegistry.shared.loadedPackIds.contains("core-heroes"))
    }

    func testLoadPackUpdatesState() async throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given
        _ = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // When
        _ = try await ContentManager.shared.loadPack("core-heroes")

        // Then - Get pack state
        let pack = ContentManager.shared.getPack("core-heroes")
        XCTAssertEqual(pack?.state, .loaded)
        XCTAssertNotNil(pack?.loadedAt)
    }

    func testLoadNonExistentPackThrows() async {
        // When/Then - Loading non-existent pack should throw
        do {
            _ = try await ContentManager.shared.loadPack("non-existent")
            XCTFail("Should have thrown error")
        } catch {
            // Expected
            XCTAssertTrue(error is ContentReloadError)
        }
    }

    // MARK: - State Query Tests

    func testGetAllPacksReturnsDiscoveredPacks() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given
        _ = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // When
        let allPacks = ContentManager.shared.getAllPacks()

        // Then
        XCTAssertEqual(allPacks.count, 1)
        XCTAssertEqual(allPacks[0].id, "core-heroes")
    }

    func testGetPackReturnsSpecificPack() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given
        _ = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // When
        let pack = ContentManager.shared.getPack("core-heroes")

        // Then
        XCTAssertNotNil(pack)
        XCTAssertEqual(pack?.id, "core-heroes")
    }

    func testGetPackReturnsNilForUnknownPack() {
        // When
        let pack = ContentManager.shared.getPack("unknown-pack")

        // Then
        XCTAssertNil(pack)
    }

    func testGetBundledPacksFiltersCorrectly() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given - Discover bundled pack
        _ = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // When
        let bundled = ContentManager.shared.getBundledPacks()

        // Then
        XCTAssertEqual(bundled.count, 1)
        if case .bundled = bundled[0].source {
            // OK
        } else {
            XCTFail("Should be bundled source")
        }
    }

    // MARK: - Reload Capability Tests

    func testBundledPacksCannotReload() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given
        _ = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // When
        let canReload = ContentManager.shared.canReload("core-heroes")

        // Then - Bundled packs cannot be hot-reloaded
        XCTAssertFalse(canReload)
    }

    func testSafeReloadFailsForBundledPacks() async throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given - Discover and load pack
        _ = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])
        _ = try await ContentManager.shared.loadPack("core-heroes")

        // When - Try to reload bundled pack
        let result = await ContentManager.shared.safeReloadPack("core-heroes")

        // Then - Should fail with notReloadable error
        switch result {
        case .success:
            XCTFail("Should not succeed for bundled pack")
        case .failure(let error):
            if case .notReloadable = error {
                // Expected
            } else {
                XCTFail("Should be notReloadable error, got: \(error)")
            }
        }
    }

    // MARK: - ManagedPack Property Tests

    func testManagedPackCanValidateWhenDiscovered() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given
        let discovered = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // Then
        XCTAssertTrue(discovered[0].canValidate)
    }

    func testManagedPackHasFileSize() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given
        let discovered = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // Then
        XCTAssertGreaterThan(discovered[0].fileSize, 0)
    }

    func testManagedPackHasModificationDate() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        // Given
        let discovered = ContentManager.shared.discoverPacks(bundledURLs: [characterPackURL!])

        // Then - Should have recent modification date (within last year)
        let oneYearAgo = Date().addingTimeInterval(-365 * 24 * 60 * 60)
        XCTAssertGreaterThan(discovered[0].modifiedAt, oneYearAgo)
    }

    // MARK: - ValidationSummary Tests

    func testValidationSummaryEquality() {
        let summary1 = ValidationSummary(
            packId: "test",
            errorCount: 0,
            warningCount: 1,
            infoCount: 2,
            duration: 0.5
        )
        let summary2 = ValidationSummary(
            packId: "test",
            errorCount: 0,
            warningCount: 1,
            infoCount: 2,
            duration: 0.5
        )

        // ValidationSummary equality is based on packId
        XCTAssertEqual(summary1.packId, summary2.packId)
    }

    func testValidationSummaryIsValidWhenNoErrors() {
        let summary = ValidationSummary(
            packId: "test",
            errorCount: 0,
            warningCount: 5,
            infoCount: 10,
            duration: 1.0
        )

        XCTAssertTrue(summary.isValid)
    }

    func testValidationSummaryIsInvalidWhenHasErrors() {
        let summary = ValidationSummary(
            packId: "test",
            errorCount: 1,
            warningCount: 0,
            infoCount: 0,
            duration: 1.0
        )

        XCTAssertFalse(summary.isValid)
    }

    // MARK: - PackLoadState Tests

    func testPackLoadStateEquality() {
        XCTAssertEqual(PackLoadState.discovered, PackLoadState.discovered)
        XCTAssertEqual(PackLoadState.validating, PackLoadState.validating)
        XCTAssertEqual(PackLoadState.loading, PackLoadState.loading)
        XCTAssertEqual(PackLoadState.loaded, PackLoadState.loaded)
        XCTAssertEqual(PackLoadState.failed("error"), PackLoadState.failed("error"))
        XCTAssertNotEqual(PackLoadState.failed("error1"), PackLoadState.failed("error2"))
    }

    func testPackLoadStateStatusIcon() {
        XCTAssertEqual(PackLoadState.discovered.statusIcon, "circle")
        XCTAssertEqual(PackLoadState.loaded.statusIcon, "checkmark.circle.fill")
        XCTAssertEqual(PackLoadState.failed("").statusIcon, "xmark.circle.fill")
    }

    // MARK: - PackSource Tests

    func testPackSourceIsReloadable() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        let bundled = PackSource.bundled(url: characterPackURL!)
        let external = PackSource.external(url: characterPackURL!)

        XCTAssertFalse(bundled.isReloadable)
        XCTAssertTrue(external.isReloadable)
    }

    func testPackSourceDisplayName() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        let bundled = PackSource.bundled(url: characterPackURL!)
        let external = PackSource.external(url: characterPackURL!)

        XCTAssertEqual(bundled.displayName, "Bundled")
        XCTAssertEqual(external.displayName, "External")
    }

    func testPackSourceURL() throws {
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available"); return }

        let bundled = PackSource.bundled(url: characterPackURL!)

        XCTAssertEqual(bundled.url, characterPackURL!)
    }
}


// ==========================================
// FILE: CardSampleGameTests/Unit/ContentPackTests/ContentRegistryTests.swift
// ==========================================

import XCTest
import TwilightEngine
import CoreHeroesContent
import TwilightMarchesActIContent

@testable import CardSampleGame

/// Tests for ContentRegistry functionality
final class ContentRegistryTests: XCTestCase {

    // MARK: - Properties

    private var characterPackURL: URL?
    private var storyPackURL: URL?

    // MARK: - Setup

    override func setUp() {
        super.setUp()
        // Reset registry before each test
        ContentRegistry.shared.resetForTesting()

        // Use TestContentLoader for robust URL discovery (with file path fallback)
        characterPackURL = TestContentLoader.characterPackURL
        storyPackURL = TestContentLoader.storyPackURL
    }

    override func tearDown() {
        ContentRegistry.shared.resetForTesting()
        characterPackURL = nil
        storyPackURL = nil
        super.tearDown()
    }

    // MARK: - Pack Loading Tests

    func testLoadMultiplePacks() throws {
        // Skip if packs not available (Bundle.module resolution issue in tests)
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // When - Load both packs using multi-pack loader
        let packs = try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // Then
        XCTAssertEqual(packs.count, 2)
        XCTAssertTrue(ContentRegistry.shared.loadedPackIds.contains("core-heroes"))
        XCTAssertTrue(ContentRegistry.shared.loadedPackIds.contains("twilight-marches-act1"))
    }

    func testLoadPackRegistersContent() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // When
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // Then
        XCTAssertGreaterThan(ContentRegistry.shared.getAllCards().count, 0)
        XCTAssertGreaterThan(ContentRegistry.shared.getAllHeroes().count, 0)
        XCTAssertGreaterThan(ContentRegistry.shared.getAllRegions().count, 0)
    }

    func testLoadPackUpdatesBalanceConfig() throws {
        // Given - No balance config before loading
        XCTAssertNil(ContentRegistry.shared.getBalanceConfig())

        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // When
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // Then
        XCTAssertNotNil(ContentRegistry.shared.getBalanceConfig())
    }

    func testCannotLoadSamePackTwice() throws {
        // Skip if character pack not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }

        // Given
        try ContentRegistry.shared.loadPack(from: characterPackURL!)

        // Then - Should throw when trying to load again
        XCTAssertThrowsError(try ContentRegistry.shared.loadPack(from: characterPackURL!)) { error in
            if case PackLoadError.packAlreadyLoaded(let packId) = error {
                XCTAssertEqual(packId, "core-heroes")
            } else {
                XCTFail("Expected packAlreadyLoaded error")
            }
        }
    }

    // MARK: - Content Access Tests

    func testGetCardById() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When - Try to get a known card
        let allCards = ContentRegistry.shared.getAllCards()
        guard let firstCard = allCards.first else {
            XCTFail("No cards loaded")
            return
        }

        // Then
        let fetchedCard = ContentRegistry.shared.getCard(id: firstCard.id)
        XCTAssertNotNil(fetchedCard)
        XCTAssertEqual(fetchedCard?.id, firstCard.id)
    }

    func testGetHeroById() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When
        let allHeroes = ContentRegistry.shared.getAllHeroes()
        guard let firstHero = allHeroes.first else {
            XCTFail("No heroes loaded")
            return
        }

        // Then
        let fetchedHero = ContentRegistry.shared.getHero(id: firstHero.id)
        XCTAssertNotNil(fetchedHero)
        XCTAssertEqual(fetchedHero?.id, firstHero.id)
    }

    func testGetNonExistentContent() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // Then
        XCTAssertNil(ContentRegistry.shared.getCard(id: "nonexistent_card"))
        XCTAssertNil(ContentRegistry.shared.getHero(id: "nonexistent_hero"))
        XCTAssertNil(ContentRegistry.shared.getRegion(id: "nonexistent_region"))
    }

    // MARK: - Starting Deck Tests

    func testGetStartingDeckForHero() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])
        let allHeroes = ContentRegistry.shared.getAllHeroes()
        guard let hero = allHeroes.first else {
            XCTFail("No heroes loaded")
            return
        }

        // When
        let startingDeck = ContentRegistry.shared.getStartingDeck(forHero: hero.id)

        // Then
        XCTAssertFalse(startingDeck.isEmpty, "Hero should have starting deck")
        XCTAssertEqual(startingDeck.count, hero.startingDeckCardIDs.count)
    }

    // MARK: - Unload Tests

    func testUnloadPack() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When - Unload character pack
        ContentRegistry.shared.unloadPack("core-heroes")

        // Then - Only character pack content should be gone
        XCTAssertFalse(ContentRegistry.shared.loadedPackIds.contains("core-heroes"))
        XCTAssertTrue(ContentRegistry.shared.loadedPackIds.contains("twilight-marches-act1"))
    }

    func testUnloadAllPacks() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])
        XCTAssertGreaterThan(ContentRegistry.shared.getAllCards().count, 0)

        // When
        ContentRegistry.shared.unloadAllPacks()

        // Then
        XCTAssertEqual(ContentRegistry.shared.getAllCards().count, 0)
        XCTAssertEqual(ContentRegistry.shared.getAllHeroes().count, 0)
        XCTAssertTrue(ContentRegistry.shared.loadedPackIds.isEmpty)
    }

    // MARK: - Validation Tests

    func testValidateLoadedContent() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When
        let errors = ContentRegistry.shared.validateAllContent()

        // Then - Should have no critical errors (warnings are OK)
        let criticalErrors = errors.filter { $0.type == .brokenReference }
        XCTAssertTrue(criticalErrors.isEmpty, "Should have no broken references: \(criticalErrors)")
    }

    // MARK: - Inventory Tests

    func testTotalInventory() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When
        let inventory = ContentRegistry.shared.totalInventory

        // Then
        XCTAssertGreaterThan(inventory.cardCount, 0)
        XCTAssertGreaterThan(inventory.heroCount, 0)
        XCTAssertTrue(inventory.hasBalanceConfig)
    }

    // MARK: - ContentProvider Protocol Tests

    func testContentProviderProtocolConformance() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])
        let provider: ContentProvider = ContentRegistry.shared

        // When/Then - Should work as ContentProvider
        XCTAssertFalse(provider.getAllRegionDefinitions().isEmpty, "Should have regions")
        XCTAssertFalse(provider.getAllEventDefinitions().isEmpty, "Should have events")
        XCTAssertFalse(provider.getAllQuestDefinitions().isEmpty, "Should have quests")
    }

    // MARK: - Pack Type Query Tests

    func testGetCharacterPacks() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When
        let characterPacks = ContentRegistry.shared.getCharacterPacks()

        // Then
        XCTAssertEqual(characterPacks.count, 1)
        XCTAssertEqual(characterPacks.first?.manifest.packId, "core-heroes")
    }

    func testGetStoryPacks() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When
        let storyPacks = ContentRegistry.shared.getStoryPacks()

        // Then
        XCTAssertEqual(storyPacks.count, 1)
        XCTAssertEqual(storyPacks.first?.manifest.packId, "twilight-marches-act1")
    }

    func testIsReadyForGameplay() throws {
        // Given - No packs loaded
        XCTAssertFalse(ContentRegistry.shared.isReadyForGameplay)

        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // When - Load only character pack
        try ContentRegistry.shared.loadPack(from: characterPackURL!)
        XCTAssertFalse(ContentRegistry.shared.isReadyForGameplay)

        // When - Load story pack
        try ContentRegistry.shared.loadPack(from: storyPackURL!)
        XCTAssertTrue(ContentRegistry.shared.isReadyForGameplay)
    }

    // MARK: - Season/Campaign Query Tests

    func testGetPacksBySeason() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When
        let season1Packs = ContentRegistry.shared.getPacksBySeason("season1")

        // Then - TwilightMarchesActI should be in season1
        XCTAssertEqual(season1Packs.count, 1)
        XCTAssertEqual(season1Packs.first?.manifest.packId, "twilight-marches-act1")
    }

    func testGetPacksByCampaign() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When
        let campaignPacks = ContentRegistry.shared.getPacksByCampaign("twilight-marches")

        // Then
        XCTAssertEqual(campaignPacks.count, 1)
        XCTAssertEqual(campaignPacks.first?.manifest.packId, "twilight-marches-act1")
        XCTAssertEqual(campaignPacks.first?.manifest.campaignOrder, 1)
    }

    func testGetAvailableSeasons() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When
        let seasons = ContentRegistry.shared.getAvailableSeasons()

        // Then - Should include season1 from TwilightMarchesActI
        XCTAssertTrue(seasons.contains("season1"))
    }

    func testGetCampaignsInSeason() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When
        let campaigns = ContentRegistry.shared.getCampaignsInSeason("season1")

        // Then
        XCTAssertTrue(campaigns.contains("twilight-marches"))
    }

    func testIsCampaignCompleteWithSingleAct() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When - With only Act I loaded, campaign is "complete" (sequential from 1)
        let isComplete = ContentRegistry.shared.isCampaignComplete("twilight-marches")

        // Then - Act I starts at order 1, so it's complete for what's loaded
        XCTAssertTrue(isComplete)
    }

    func testGetNextPackInCampaignReturnsNilForLastAct() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When - Try to get next pack after Act I (Act II not loaded)
        let nextPack = ContentRegistry.shared.getNextPackInCampaign(after: "twilight-marches-act1")

        // Then - Should be nil since Act II isn't loaded
        XCTAssertNil(nextPack)
    }

    func testHasAllRequiredPacksForFirstAct() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When - Check if Act I has all required packs (it shouldn't require any)
        let hasRequired = ContentRegistry.shared.hasAllRequiredPacks(for: "twilight-marches-act1")

        // Then - Act I is the first act, so no required packs
        XCTAssertTrue(hasRequired)
    }

    func testCharacterPackHasNoSeason() throws {
        // Skip if packs not available
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }
        if storyPackURL == nil { XCTFail("TwilightMarchesActI pack not available"); return }

        // Given
        try ContentRegistry.shared.loadPacks(from: [characterPackURL!, storyPackURL!])

        // When - Get packs for non-existent season
        let noSeasonPacks = ContentRegistry.shared.getPacksBySeason("nonexistent")

        // Then - Should be empty
        XCTAssertTrue(noSeasonPacks.isEmpty)

        // And - CoreHeroes should not appear in season1 (it has no season)
        let characterPacks = ContentRegistry.shared.getCharacterPacks()
        XCTAssertNil(characterPacks.first?.manifest.season)
    }

    // MARK: - Mock Content Tests

    func testRegisterMockContent() {
        // Given
        let mockRegion = RegionDefinition(
            id: "test_region",
            title: .inline(LocalizedString(en: "Test", ru: "Тест")),
            description: .inline(LocalizedString(en: "Test region", ru: "Тестовый регион")),
            regionType: "test",
            neighborIds: []
        )

        // When
        ContentRegistry.shared.registerMockContent(
            regions: ["test_region": mockRegion]
        )

        // Then
        XCTAssertNotNil(ContentRegistry.shared.getRegion(id: "test_region"))
        XCTAssertEqual(ContentRegistry.shared.getAllRegions().count, 1)
    }
}


// ==========================================
// FILE: CardSampleGameTests/Unit/ContentPackTests/PackLoaderTests.swift
// ==========================================

import XCTest
import TwilightEngine
import PackAuthoring
import CoreHeroesContent
import TwilightMarchesActIContent

@testable import CardSampleGame

/// Tests for PackLoader functionality
/// Note: PackLoader is used at compile-time to load JSON content packs.
/// These tests use the JSON source directories, not the binary .pack files.
final class PackLoaderTests: XCTestCase {

    // MARK: - Properties

    /// URL to JSON source directory (not .pack file)
    private var characterPackURL: URL?
    private var storyPackURL: URL?

    // MARK: - Setup

    override func setUp() {
        super.setUp()
        // Use TestContentLoader JSON URLs for PackLoader tests
        characterPackURL = TestContentLoader.characterPackJSONURL
        storyPackURL = TestContentLoader.storyPackJSONURL
    }

    override func tearDown() {
        characterPackURL = nil
        storyPackURL = nil
        super.tearDown()
    }

    // MARK: - Character Pack Manifest Tests

    func testLoadCharacterPackManifest() throws {
        // Fail if character pack not available (Bundle.module resolution issue in tests)
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }

        // Given
        let url = characterPackURL!

        // When
        let manifest = try PackManifest.load(from: url)

        // Then
        XCTAssertEqual(manifest.packId, "core-heroes")
        XCTAssertEqual(manifest.packType, .character)
        XCTAssertFalse(manifest.displayName.en.isEmpty)
        XCTAssertFalse(manifest.displayName.ru.isEmpty)
    }

    // MARK: - Story Pack Manifest Tests

    func testLoadStoryPackManifest() throws {
        // Given
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI pack not available")

        // When
        let manifest = try PackManifest.load(from: url)

        // Then
        XCTAssertEqual(manifest.packId, "twilight-marches-act1")
        XCTAssertEqual(manifest.packType, .campaign)
        XCTAssertFalse(manifest.displayName.en.isEmpty)
        XCTAssertFalse(manifest.displayName.ru.isEmpty)
    }

    func testManifestVersionParsing() throws {
        // Given
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI pack not available")

        // When
        let manifest = try PackManifest.load(from: url)

        // Then
        XCTAssertGreaterThanOrEqual(manifest.version.major, 1)
    }

    func testManifestCoreCompatibility() throws {
        // Given
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI pack not available")

        // When
        let manifest = try PackManifest.load(from: url)

        // Then
        XCTAssertTrue(manifest.isCompatibleWithCore(), "Pack should be compatible with current Core version")
    }

    func testManifestPackType() throws {
        // Given
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI pack not available")

        // When
        let manifest = try PackManifest.load(from: url)

        // Then - TwilightMarchesActI is a campaign pack
        XCTAssertEqual(manifest.packType, .campaign)
    }

    func testManifestEntryRegion() throws {
        // Given
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI pack not available")

        // When
        let manifest = try PackManifest.load(from: url)

        // Then - Campaign packs should have an entry region
        XCTAssertNotNil(manifest.entryRegionId)
    }

    func testManifestLocales() throws {
        // Given
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI pack not available")

        // When
        let manifest = try PackManifest.load(from: url)

        // Then
        XCTAssertTrue(manifest.supportedLocales.contains("en"))
        XCTAssertTrue(manifest.supportedLocales.contains("ru"))
    }

    // MARK: - Content Loading Tests

    func testLoadCharacterPackContent() throws {
        // Fail if character pack not available (Bundle.module resolution issue in tests)
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }

        // Given
        let url = characterPackURL!
        let manifest = try PackManifest.load(from: url)

        // When
        let pack = try PackLoader.load(manifest: manifest, from: url)

        // Then - Should load heroes and cards
        XCTAssertGreaterThan(pack.cards.count, 0, "Should load cards")
        XCTAssertGreaterThan(pack.heroes.count, 0, "Should load heroes")
    }

    func testLoadStoryPackContent() throws {
        // Given
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI pack not available")
        let manifest = try PackManifest.load(from: url)

        // When
        let pack = try PackLoader.load(manifest: manifest, from: url)

        // Then - Should load story content
        XCTAssertGreaterThan(pack.regions.count, 0, "Should load regions")
        XCTAssertGreaterThan(pack.events.count, 0, "Should load events")
    }

    func testLoadBalanceConfiguration() throws {
        // Given
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI pack not available")
        let manifest = try PackManifest.load(from: url)

        // When
        let pack = try PackLoader.load(manifest: manifest, from: url)

        // Then
        XCTAssertNotNil(pack.balanceConfig, "Should load balance configuration")
    }

    func testBalanceConfigurationValues() throws {
        // Given
        let url = try XCTUnwrap(storyPackURL, "TwilightMarchesActI pack not available")
        let manifest = try PackManifest.load(from: url)
        let pack = try PackLoader.load(manifest: manifest, from: url)

        // When
        let balance = try XCTUnwrap(pack.balanceConfig)

        // Then - Validate sensible values
        XCTAssertGreaterThan(balance.resources.maxHealth, 0)
        XCTAssertGreaterThan(balance.resources.maxFaith, 0)
        XCTAssertGreaterThanOrEqual(balance.resources.startingHealth, 1)
        XCTAssertGreaterThanOrEqual(balance.pressure.maxPressure, 1)
        XCTAssertGreaterThan(balance.anchor.maxIntegrity, 0)
    }

    // MARK: - Cards Loading Tests

    func testLoadCards() throws {
        // Fail if character pack not available (Bundle.module resolution issue in tests)
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }

        // Given
        let url = characterPackURL!
        let manifest = try PackManifest.load(from: url)

        // When
        let pack = try PackLoader.load(manifest: manifest, from: url)

        // Then
        XCTAssertFalse(pack.cards.isEmpty, "Should load cards")

        // Verify card structure
        if let firstCard = pack.cards.values.first {
            XCTAssertFalse(firstCard.id.isEmpty)
            XCTAssertFalse(firstCard.name.isEmpty)
        }
    }

    func testCardsHaveValidFaithCost() throws {
        // Fail if character pack not available (Bundle.module resolution issue in tests)
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }

        // Given
        let url = characterPackURL!
        let manifest = try PackManifest.load(from: url)
        let pack = try PackLoader.load(manifest: manifest, from: url)

        // Then - All cards should have non-negative faith cost
        for (id, card) in pack.cards {
            XCTAssertGreaterThanOrEqual(card.faithCost, 0, "Card '\(id)' has negative faith cost")
        }
    }

    // MARK: - Heroes Loading Tests

    func testLoadHeroes() throws {
        // Fail if character pack not available (Bundle.module resolution issue in tests)
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }

        // Given
        let url = characterPackURL!
        let manifest = try PackManifest.load(from: url)

        // When
        let pack = try PackLoader.load(manifest: manifest, from: url)

        // Then
        XCTAssertFalse(pack.heroes.isEmpty, "Should load heroes")

        // Verify hero structure
        if let firstHero = pack.heroes.values.first {
            XCTAssertFalse(firstHero.id.isEmpty)
            XCTAssertFalse(firstHero.name.isEmpty)
        }
    }

    func testHeroesHaveStartingDecks() throws {
        // Fail if character pack not available (Bundle.module resolution issue in tests)
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }

        // Given
        let url = characterPackURL!
        let manifest = try PackManifest.load(from: url)
        let pack = try PackLoader.load(manifest: manifest, from: url)

        // Then - Heroes should have starting decks
        for (id, hero) in pack.heroes {
            XCTAssertFalse(hero.startingDeckCardIDs.isEmpty, "Hero '\(id)' has no starting deck")
        }
    }

    func testHeroesHaveValidBaseStats() throws {
        // Fail if character pack not available (Bundle.module resolution issue in tests)
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }

        // Given
        let url = characterPackURL!
        let manifest = try PackManifest.load(from: url)
        let pack = try PackLoader.load(manifest: manifest, from: url)

        // Then - Heroes should have valid base stats
        for (id, hero) in pack.heroes {
            XCTAssertGreaterThan(hero.baseStats.maxHealth, 0, "Hero '\(id)' has invalid maxHealth")
            XCTAssertGreaterThan(hero.baseStats.maxFaith, 0, "Hero '\(id)' has invalid maxFaith")
        }
    }

    func testHeroesHaveSpecialAbility() throws {
        // Fail if character pack not available (Bundle.module resolution issue in tests)
        if characterPackURL == nil { XCTFail("CoreHeroes pack not available - Bundle.module resolution issue"); return }

        // Given
        let url = characterPackURL!
        let manifest = try PackManifest.load(from: url)
        let pack = try PackLoader.load(manifest: manifest, from: url)

        // Then - Heroes should have special ability from their class
        for (id, hero) in pack.heroes {
            XCTAssertFalse(hero.specialAbility.id.isEmpty, "Hero '\(id)' has no special ability")
        }
    }

    // MARK: - Error Handling Tests

    func testLoadManifestFromInvalidPath() {
        // Given
        let invalidURL = URL(fileURLWithPath: "/nonexistent/path")

        // Then
        XCTAssertThrowsError(try PackManifest.load(from: invalidURL)) { error in
            // Should throw a file not found or similar error
            XCTAssertTrue(error is PackLoadError || error is DecodingError)
        }
    }

    func testLoadPackWithCorruptedJSONThrows() throws {
        // Given: a temp directory with broken regions file
        let tempDir = FileManager.default.temporaryDirectory
            .appendingPathComponent("PackLoaderTests_\(UUID().uuidString)")
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        defer { try? FileManager.default.removeItem(at: tempDir) }

        // Write corrupted regions JSON
        try "{ not valid json [[[".data(using: .utf8)!.write(to: tempDir.appendingPathComponent("regions.json"))

        // Create manifest programmatically pointing to the corrupted file
        let manifest = PackManifest(
            packId: "broken-test",
            displayName: LocalizedString(en: "Broken", ru: "Сломанный"),
            description: LocalizedString(en: "Test", ru: "Тест"),
            version: SemanticVersion(major: 1, minor: 0, patch: 0),
            packType: .campaign,
            coreVersionMin: SemanticVersion(major: 1, minor: 0, patch: 0),
            author: "test",
            regionsPath: "regions.json"
        )

        // Then
        XCTAssertThrowsError(try PackLoader.load(manifest: manifest, from: tempDir))
    }

    // MARK: - SHA256 Tests

    func testComputeSHA256ProducesConsistentHash() throws {
        // Given: a temp file with known content
        let tempFile = FileManager.default.temporaryDirectory
            .appendingPathComponent("sha256test_\(UUID().uuidString).txt")
        try "hello world".data(using: .utf8)!.write(to: tempFile)
        defer { try? FileManager.default.removeItem(at: tempFile) }

        // When
        let hash1 = try PackLoader.computeSHA256(of: tempFile)
        let hash2 = try PackLoader.computeSHA256(of: tempFile)

        // Then
        XCTAssertEqual(hash1, hash2, "Same file should produce same hash")
        XCTAssertEqual(hash1.count, 64, "SHA256 hex string should be 64 characters")
    }

    func testComputeSHA256DiffersForDifferentContent() throws {
        let tempFile1 = FileManager.default.temporaryDirectory
            .appendingPathComponent("sha256test_a_\(UUID().uuidString).txt")
        let tempFile2 = FileManager.default.temporaryDirectory
            .appendingPathComponent("sha256test_b_\(UUID().uuidString).txt")
        try "content A".data(using: .utf8)!.write(to: tempFile1)
        try "content B".data(using: .utf8)!.write(to: tempFile2)
        defer {
            try? FileManager.default.removeItem(at: tempFile1)
            try? FileManager.default.removeItem(at: tempFile2)
        }

        // When
        let hash1 = try PackLoader.computeSHA256(of: tempFile1)
        let hash2 = try PackLoader.computeSHA256(of: tempFile2)

        // Then
        XCTAssertNotEqual(hash1, hash2, "Different content should produce different hashes")
    }

    func testComputeSHA256ThrowsForMissingFile() {
        let missingFile = URL(fileURLWithPath: "/nonexistent/file.txt")
        XCTAssertThrowsError(try PackLoader.computeSHA256(of: missingFile))
    }

    // MARK: - Semantic Version Tests

    func testSemanticVersionComparison() {
        // Given
        let v100 = SemanticVersion(major: 1, minor: 0, patch: 0)
        let v110 = SemanticVersion(major: 1, minor: 1, patch: 0)
        let v111 = SemanticVersion(major: 1, minor: 1, patch: 1)
        let v200 = SemanticVersion(major: 2, minor: 0, patch: 0)

        // Then
        XCTAssertLessThan(v100, v110)
        XCTAssertLessThan(v110, v111)
        XCTAssertLessThan(v111, v200)
        XCTAssertEqual(v100, SemanticVersion(major: 1, minor: 0, patch: 0))
    }

    func testSemanticVersionFromString() {
        // Given
        let version = SemanticVersion(string: "1.2.3")

        // Then
        XCTAssertEqual(version?.major, 1)
        XCTAssertEqual(version?.minor, 2)
        XCTAssertEqual(version?.patch, 3)
    }

    func testSemanticVersionDescription() {
        // Given
        let version = SemanticVersion(major: 1, minor: 2, patch: 3)

        // Then
        XCTAssertEqual(version.description, "1.2.3")
    }
}


// ==========================================
// FILE: CardSampleGameTests/TestHelpers/SourcePathResolver.swift
// ==========================================

import Foundation

/// Centralizes source file path resolution for gate tests.
/// Requirement: AUDIT_FIXLIST C1 - no hardcoded paths scattered in tests.
///
/// All engine source paths should use this resolver to ensure:
/// 1. Paths are consistent across all gate tests
/// 2. Path changes only need to be made in one place
/// 3. Tests fail clearly if paths are wrong
struct SourcePathResolver {

    // MARK: - Base Paths

    /// Project root directory (where CardSampleGame.xcodeproj is located)
    static var projectRoot: URL {
        // Navigate from test file to project root
        var url = URL(fileURLWithPath: #file)
        // Go up: SourcePathResolver.swift -> TestHelpers -> CardSampleGameTests -> Project Root
        for _ in 0..<3 {
            url = url.deletingLastPathComponent()
        }
        return url
    }

    /// TwilightEngine package base path
    static var engineBase: String {
        "Packages/TwilightEngine/Sources/TwilightEngine"
    }

    /// Full URL to TwilightEngine sources
    static var engineBaseURL: URL {
        projectRoot.appendingPathComponent(engineBase)
    }

    // MARK: - Engine Core Paths

    /// Path to TwilightGameEngine.swift
    static var twilightGameEngine: URL {
        engineBaseURL.appendingPathComponent("Core/TwilightGameEngine.swift")
    }

    /// Path to EngineSave.swift
    static var engineSave: URL {
        engineBaseURL.appendingPathComponent("Core/EngineSave.swift")
    }

    /// Path to EngineProtocols.swift
    static var engineProtocols: URL {
        engineBaseURL.appendingPathComponent("Core/EngineProtocols.swift")
    }

    // MARK: - Engine Module Paths

    /// Path to ExplorationModels.swift
    static var explorationModels: URL {
        engineBaseURL.appendingPathComponent("Models/ExplorationModels.swift")
    }

    /// Path to BalanceConfiguration.swift
    static var balanceConfiguration: URL {
        engineBaseURL.appendingPathComponent("ContentPacks/BalanceConfiguration.swift")
    }

    /// Path to ContentRegistry.swift
    static var contentRegistry: URL {
        engineBaseURL.appendingPathComponent("ContentPacks/ContentRegistry.swift")
    }

    // MARK: - Core Directories

    /// All core engine directories to scan for architectural compliance
    static var coreDirectories: [String] {
        [
            "\(engineBase)/Core",
            "\(engineBase)/ContentPacks",
            "\(engineBase)/Events",
            "\(engineBase)/Combat",
            "\(engineBase)/Quest",
            "\(engineBase)/Cards",
            "\(engineBase)/Heroes",
            "\(engineBase)/Modules",
            "\(engineBase)/Config",
            "\(engineBase)/Runtime",
            "\(engineBase)/Story",
            "\(engineBase)/Localization"
        ]
    }

    /// All production code directories (Engine + App)
    static var productionDirectories: [String] {
        [engineBase, "App", "Views", "Models", "Utilities"]
    }

    // MARK: - Validation

    /// Check if a critical path exists, fail the test if not
    static func requireExists(_ url: URL, file: StaticString = #file, line: UInt = #line) -> Bool {
        if FileManager.default.fileExists(atPath: url.path) {
            return true
        }
        return false
    }

    /// Get full path for a relative path within the project
    static func resolve(_ relativePath: String) -> URL {
        projectRoot.appendingPathComponent(relativePath)
    }

    /// Check if the project root is correctly resolved
    static func validateProjectRoot() -> Bool {
        // Check that Views folder exists at project root
        let viewsPath = projectRoot.appendingPathComponent("Views")
        return FileManager.default.fileExists(atPath: viewsPath.path)
    }
}


// ==========================================
// FILE: CardSampleGameTests/TestHelpers/TestContentLoader.swift
// ==========================================

import Foundation
import TwilightEngine
import PackAuthoring
import CoreHeroesContent
import TwilightMarchesActIContent

@testable import CardSampleGame

/// Helper для загрузки ContentPacks в тестовом окружении
/// Использует CoreHeroes и TwilightMarchesActI пакеты для получения контента
enum TestContentLoader {

    /// Флаг, показывающий загружены ли паки
    private(set) static var isLoaded = false

    // MARK: - JSON Directory URLs (for PackLoader tests)

    /// URL to CoreHeroes JSON source directory (for testing PackLoader)
    /// Returns the directory containing manifest.json and content files
    static var characterPackJSONURL: URL? {
        // Get .pack URL and derive JSON directory (sibling directory with same name)
        if let packURL = characterPackURL {
            let jsonDirURL = packURL.deletingPathExtension()
            if FileManager.default.fileExists(atPath: jsonDirURL.appendingPathComponent("manifest.json").path) {
                return jsonDirURL
            }
        }
        // Fallback: search directly
        return findJSONDirectory(bundleName: "CoreHeroes_CoreHeroesContent", resourceName: "CoreHeroes")
    }

    /// URL to TwilightMarchesActI JSON source directory (for testing PackLoader)
    /// Returns the directory containing manifest.json and content files
    static var storyPackJSONURL: URL? {
        // Get .pack URL and derive JSON directory (sibling directory with same name)
        if let packURL = storyPackURL {
            let jsonDirURL = packURL.deletingPathExtension()
            if FileManager.default.fileExists(atPath: jsonDirURL.appendingPathComponent("manifest.json").path) {
                return jsonDirURL
            }
        }
        // Fallback: search directly
        return findJSONDirectory(bundleName: "TwilightMarchesActI_TwilightMarchesActIContent", resourceName: "TwilightMarchesActI")
    }

    // MARK: - Binary Pack URLs

    /// URL to CoreHeroes pack (via Bundle.module or bundle search fallback)
    /// Returns nil if the pack cannot be verified to exist with a valid manifest
    static var characterPackURL: URL? {
        #if DEBUG
        print("🔍 TestContentLoader: Looking for CoreHeroes pack")
        print("🔍 CoreHeroesContent.packURL = \(String(describing: CoreHeroesContent.packURL))")
        #endif

        // Try Bundle.module first - expects .pack file
        if let url = CoreHeroesContent.packURL {
            if verifyPackFile(at: url) {
                return url
            }
            #if DEBUG
            print("⚠️ CoreHeroesContent.packURL exists but not a valid .pack file")
            #endif
        }

        // Fallback: search for the .pack file in the test bundle
        let fallback = findPackFile(bundleName: "CoreHeroes_CoreHeroesContent", resourceName: "CoreHeroes")
        #if DEBUG
        print("🔍 Fallback result = \(String(describing: fallback))")
        #endif

        // Verify fallback is valid .pack file
        if let url = fallback, verifyPackFile(at: url) {
            return url
        }

        #if DEBUG
        print("❌ TestContentLoader: No valid CoreHeroes pack found")
        #endif
        return nil
    }

    /// URL to TwilightMarchesActI pack (via Bundle.module or bundle search fallback)
    /// Returns nil if the pack cannot be verified to exist with a valid manifest
    static var storyPackURL: URL? {
        #if DEBUG
        print("🔍 TestContentLoader: Looking for TwilightMarchesActI pack")
        print("🔍 TwilightMarchesActIContent.packURL = \(String(describing: TwilightMarchesActIContent.packURL))")
        #endif

        // Try Bundle.module first - expects .pack file
        if let url = TwilightMarchesActIContent.packURL {
            if verifyPackFile(at: url) {
                return url
            }
            #if DEBUG
            print("⚠️ TwilightMarchesActIContent.packURL exists but not a valid .pack file")
            #endif
        }

        // Fallback: search for the .pack file in the test bundle
        let fallback = findPackFile(bundleName: "TwilightMarchesActI_TwilightMarchesActIContent", resourceName: "TwilightMarchesActI")
        #if DEBUG
        print("🔍 Fallback result = \(String(describing: fallback))")
        #endif

        // Verify fallback is valid .pack file
        if let url = fallback, verifyPackFile(at: url) {
            return url
        }

        #if DEBUG
        print("❌ TestContentLoader: No valid TwilightMarchesActI pack found")
        #endif
        return nil
    }

    /// Загрузить ContentPacks из пакетов
    /// Безопасно вызывать многократно - загрузка произойдёт только один раз
    static func loadContentPacksIfNeeded() {
        // Also reload if registry was reset externally
        guard !isLoaded || ContentRegistry.shared.loadedPackIds.isEmpty else { return }

        do {
            // Загружаем паки через ContentRegistry
            let registry = ContentRegistry.shared

            // Проверяем, не загружен ли уже
            if registry.loadedPackIds.isEmpty {
                var urls: [URL] = []

                // Load character pack first (priority order)
                if let heroesURL = characterPackURL {
                    urls.append(heroesURL)
                }

                // Load story pack
                if let storyURL = storyPackURL {
                    urls.append(storyURL)
                }

                guard !urls.isEmpty else {
                    print("⚠️ TestContentLoader: ContentPacks not found in packages")
                    return
                }

                try registry.loadPacks(from: urls)
                print("✅ TestContentLoader: Loaded \(urls.count) packs")
            }

            isLoaded = true
        } catch {
            print("❌ TestContentLoader: Failed to load packs: \(error)")
        }
    }

    /// Find .pack file by searching in test bundle and all related locations
    private static func findPackFile(bundleName: String, resourceName: String) -> URL? {
        let testBundle = Bundle(for: BundleToken.self)
        let packFileName = "\(resourceName).pack"

        #if DEBUG
        print("🔍 findPackFile: Looking for \(bundleName).bundle/\(packFileName)")
        print("🔍 Test bundle path: \(testBundle.bundlePath)")
        #endif

        // Method 1: Direct URL lookup in test bundle
        if let url = testBundle.url(forResource: bundleName, withExtension: "bundle") {
            let packPath = url.appendingPathComponent(packFileName)
            #if DEBUG
            print("🔍 Method 1: Found bundle at \(url)")
            print("🔍 Method 1: Checking \(packPath.path)")
            #endif
            if FileManager.default.fileExists(atPath: packPath.path) {
                #if DEBUG
                print("✅ Method 1: Found .pack file!")
                #endif
                return packPath
            }
        }

        // Method 2: Direct path construction in test bundle
        if let testBundlePath = testBundle.bundlePath as NSString? {
            let bundlePath = testBundlePath.appendingPathComponent("\(bundleName).bundle")
            let packPath = (bundlePath as NSString).appendingPathComponent(packFileName)
            #if DEBUG
            print("🔍 Method 2: Checking \(packPath)")
            #endif
            if FileManager.default.fileExists(atPath: packPath) {
                #if DEBUG
                print("✅ Method 2: Found .pack file!")
                #endif
                return URL(fileURLWithPath: packPath)
            }
        }

        // Method 3: Search in Frameworks folder
        if let testBundlePath = testBundle.bundlePath as NSString? {
            let frameworksPath = testBundlePath.appendingPathComponent("Frameworks")
            #if DEBUG
            print("🔍 Method 3: Checking frameworks at \(frameworksPath)")
            #endif
            if let contents = try? FileManager.default.contentsOfDirectory(atPath: frameworksPath) {
                #if DEBUG
                print("🔍 Method 3: Found frameworks: \(contents)")
                #endif
                for item in contents where item.hasSuffix(".framework") {
                    let frameworkPath = (frameworksPath as NSString).appendingPathComponent(item)
                    let innerBundlePath = (frameworkPath as NSString).appendingPathComponent("\(bundleName).bundle")
                    let packPath = (innerBundlePath as NSString).appendingPathComponent(packFileName)
                    if FileManager.default.fileExists(atPath: packPath) {
                        #if DEBUG
                        print("✅ Method 3: Found .pack file at \(packPath)!")
                        #endif
                        return URL(fileURLWithPath: packPath)
                    }
                }
            }
        }

        // Method 4: Check main app bundle
        if let mainBundlePath = Bundle.main.bundlePath as NSString? {
            let bundlePath = mainBundlePath.appendingPathComponent("\(bundleName).bundle")
            let packPath = (bundlePath as NSString).appendingPathComponent(packFileName)
            #if DEBUG
            print("🔍 Method 4: Checking main bundle \(packPath)")
            #endif
            if FileManager.default.fileExists(atPath: packPath) {
                #if DEBUG
                print("✅ Method 4: Found .pack file!")
                #endif
                return URL(fileURLWithPath: packPath)
            }
        }

        #if DEBUG
        print("❌ findPackFile: Pack file not found for \(bundleName).bundle/\(packFileName)")
        #endif
        return nil
    }

    /// Verify that a URL points to a valid .pack file
    private static func verifyPackFile(at url: URL) -> Bool {
        #if DEBUG
        print("🔍 verifyPackFile: checking \(url.path)")
        #endif

        // Check file exists
        guard FileManager.default.fileExists(atPath: url.path) else {
            #if DEBUG
            print("❌ verifyPackFile: file does not exist")
            #endif
            return false
        }

        // Verify it's a valid .pack file using BinaryPackReader
        let isValid = BinaryPackReader.isValidPackFile(url)
        #if DEBUG
        print(isValid ? "✅ verifyPackFile: valid .pack file" : "❌ verifyPackFile: not a valid .pack file")
        #endif
        return isValid
    }

    /// Find JSON source directory (for PackLoader tests)
    private static func findJSONDirectory(bundleName: String, resourceName: String) -> URL? {
        let testBundle = Bundle(for: BundleToken.self)

        // Method 1: Direct URL lookup in test bundle
        if let url = testBundle.url(forResource: bundleName, withExtension: "bundle") {
            let jsonDirPath = url.appendingPathComponent(resourceName)
            let manifestPath = jsonDirPath.appendingPathComponent("manifest.json")
            if FileManager.default.fileExists(atPath: manifestPath.path) {
                return jsonDirPath
            }
        }

        // Method 2: Direct path construction
        if let testBundlePath = testBundle.bundlePath as NSString? {
            let bundlePath = testBundlePath.appendingPathComponent("\(bundleName).bundle")
            let jsonDirPath = (bundlePath as NSString).appendingPathComponent(resourceName)
            let manifestPath = (jsonDirPath as NSString).appendingPathComponent("manifest.json")
            if FileManager.default.fileExists(atPath: manifestPath) {
                return URL(fileURLWithPath: jsonDirPath)
            }
        }

        // Method 3: Search in Frameworks folder
        if let testBundlePath = testBundle.bundlePath as NSString? {
            let frameworksPath = testBundlePath.appendingPathComponent("Frameworks")
            if let contents = try? FileManager.default.contentsOfDirectory(atPath: frameworksPath) {
                for item in contents where item.hasSuffix(".framework") {
                    let frameworkPath = (frameworksPath as NSString).appendingPathComponent(item)
                    let innerBundlePath = (frameworkPath as NSString).appendingPathComponent("\(bundleName).bundle")
                    let jsonDirPath = (innerBundlePath as NSString).appendingPathComponent(resourceName)
                    let manifestPath = (jsonDirPath as NSString).appendingPathComponent("manifest.json")
                    if FileManager.default.fileExists(atPath: manifestPath) {
                        return URL(fileURLWithPath: jsonDirPath)
                    }
                }
            }
        }

        return nil
    }

    /// Сбросить состояние (для изолированных тестов)
    static func reset() {
        ContentRegistry.shared.unloadAllPacks()
        CardRegistry.shared.clear()
        AbilityRegistry.shared.clear()
        isLoaded = false
    }
}

// Helper class to get the test bundle
private class BundleToken {}


// ==========================================
// FILE: CardSampleGameTests/Views/HeroPanelTests.swift
// ==========================================

import XCTest
import TwilightEngine

@testable import CardSampleGame

/// Tests for the HeroPanel component
/// Verifies that the unified hero panel displays correctly across all screens
final class HeroPanelTests: XCTestCase {

    // MARK: - Test Engine Setup

    var engine: TwilightGameEngine!

    override func setUp() {
        super.setUp()
        engine = TwilightGameEngine()
    }

    override func tearDown() {
        engine = nil
        super.tearDown()
    }

    // MARK: - Hero Display Tests

    func testHeroDisplaysCorrectly() {
        // Given: Get first available hero from registry
        let registry = HeroRegistry.shared
        guard let hero = registry.firstHero else {
            XCTFail("No heroes in registry"); return
        }

        // Set hero via Engine-First
        engine.setHeroId(hero.id)

        // Then: Hero ID should be set
        XCTAssertEqual(engine.heroId, hero.id)
    }

    func testAllHeroesHaveValidData() {
        // Verify all heroes have valid data for display
        let registry = HeroRegistry.shared

        for hero in registry.allHeroes {
            XCTAssertFalse(hero.id.isEmpty, "Hero should have ID")
            XCTAssertFalse(hero.name.isEmpty, "Hero \(hero.id) should have a name")
            XCTAssertFalse(hero.icon.isEmpty, "Hero \(hero.id) should have an icon")
            XCTAssertFalse(hero.description.isEmpty, "Hero \(hero.id) should have a description")
        }
    }

    // MARK: - Player Stats Tests

    func testPlayerStatsAvailableFromEngine() {
        // Given: Engine with specific stats
        // Note: setMaxHealth before setHealth, as health is capped to maxHealth
        engine.setPlayerMaxHealth(20)
        engine.setPlayerHealth(15)
        engine.setPlayerFaith(8)
        engine.setPlayerBalance(65)
        engine.setPlayerName("Тестовый Герой")

        // Then: Stats should be readable from engine
        XCTAssertEqual(engine.playerName, "Тестовый Герой")
        XCTAssertEqual(engine.playerHealth, 15)
        XCTAssertEqual(engine.playerMaxHealth, 20)
        XCTAssertEqual(engine.playerFaith, 8)
        XCTAssertEqual(engine.playerBalance, 65)
    }

    // MARK: - Balance Display Tests

    func testBalanceDescriptionForLightPath() {
        // Given: Player with high balance (Light path)
        engine.setPlayerBalance(80)

        // Then: Balance should indicate Light path
        XCTAssertGreaterThanOrEqual(engine.playerBalance, 70)
    }

    func testBalanceDescriptionForDarkPath() {
        // Given: Player with low balance (Dark path)
        engine.setPlayerBalance(20)

        // Then: Balance should indicate Dark path
        XCTAssertLessThanOrEqual(engine.playerBalance, 30)
    }

    func testBalanceDescriptionForNeutral() {
        // Given: Player with neutral balance
        engine.setPlayerBalance(50)

        // Then: Balance should be in neutral range
        let balance = engine.playerBalance
        XCTAssertGreaterThan(balance, 30)
        XCTAssertLessThan(balance, 70)
    }

    // MARK: - Health Color Tests

    func testHealthColorLogic() {
        // Test health percentage thresholds
        // > 60% = green, 30-60% = orange, < 30% = red

        // High health (> 60%)
        let highPercentage = Double(18) / Double(20) // 90%
        XCTAssertGreaterThan(highPercentage, 0.6)

        // Medium health (30-60%)
        let medPercentage = Double(10) / Double(20) // 50%
        XCTAssertGreaterThan(medPercentage, 0.3)
        XCTAssertLessThan(medPercentage, 0.6)

        // Low health (< 30%)
        let lowPercentage = Double(4) / Double(20) // 20%
        XCTAssertLessThan(lowPercentage, 0.3)
    }
}


// ==========================================
// FILE: CardSampleGameTests/GateTests/AuditGateTests.swift
// ==========================================

import XCTest
import TwilightEngine
import PackAuthoring

@testable import CardSampleGame

/// Audit Gate Tests - Required for "фундамент для будущих игр" approval
/// These tests verify architectural requirements from Audit 2.0
///
/// Reference: Результат аудита 2.0.rtf
final class AuditGateTests: XCTestCase {

    override func setUp() {
        super.setUp()
        WorldRNG.shared.setSeed(0)
        // Загружаем ContentPacks для тестов
        TestContentLoader.loadContentPacksIfNeeded()
    }

    override func tearDown() {
        WorldRNG.shared.setSeed(0)
        super.tearDown()
    }

    // MARK: - EPIC 0: Release Safety & Build Hygiene

    /// Gate test: Missing asset returns placeholder, never nil/crash
    /// Requirement: "UI никогда не показывает пустую иконку из-за отсутствующего ассета"
    func testMissingAssetHandling_returnsPlaceholder() {
        // Test with definitely non-existent asset names
        let missingAssets = [
            "nonexistent_icon_12345",
            "missing_region_xyz",
            "invalid_asset_name",
            "",
            "   "
        ]

        let defaultFallback = "questionmark.circle"

        for assetName in missingAssets {
            let result = AssetValidator.safeIconName(assetName, fallback: defaultFallback)

            // Must return fallback, not the missing asset name
            XCTAssertEqual(
                result,
                defaultFallback,
                "Missing asset '\(assetName)' should return fallback '\(defaultFallback)'"
            )
        }

        // Test nil input
        let nilResult = AssetValidator.safeIconName(nil, fallback: defaultFallback)
        XCTAssertEqual(
            nilResult,
            defaultFallback,
            "Nil asset name should return fallback"
        )

        // Test custom fallback
        let customFallback = "exclamationmark.triangle"
        let customResult = AssetValidator.safeIconName("missing_icon", fallback: customFallback)
        XCTAssertEqual(
            customResult,
            customFallback,
            "Should use custom fallback when provided"
        )
    }

    /// Gate test: AssetValidator.assetExists returns false for missing assets
    func testAssetValidator_detectsMissingAssets() {
        // Non-existent asset should return false
        XCTAssertFalse(
            AssetValidator.assetExists("definitely_not_a_real_asset_xyz"),
            "assetExists should return false for missing assets"
        )

        // Validate pack icons returns list of missing
        let testIcons = ["missing1", "missing2", "missing3"]
        let missing = AssetValidator.validatePackIcons(icons: testIcons)
        XCTAssertEqual(
            missing.count,
            testIcons.count,
            "All test icons should be reported as missing"
        )
    }

    /// Gate test: AssetRegistry returns SF Symbol fallback for missing assets
    /// Requirement: Epic 0.1 - "UI никогда не показывает пустую иконку"
    func testAssetRegistry_returnsFallbackForMissingAssets() {
        // AssetRegistry should always return a valid Image, never crash
        // For missing assets, it falls back to SF Symbols

        // Test region fallback
        _ = AssetRegistry.regionIcon("nonexistent_region_12345")

        // Test hero fallback
        _ = AssetRegistry.heroPortrait("nonexistent_hero_xyz")

        // Test card fallback
        _ = AssetRegistry.cardArt("nonexistent_card_abc")

        // Test hasAsset returns false for missing
        XCTAssertFalse(
            AssetRegistry.hasAsset(named: "definitely_missing_asset_99999"),
            "hasAsset should return false for missing assets"
        )

        // Test placeholder validation
        let missingPlaceholders = AssetRegistry.validatePlaceholders()
        // Note: In a real app with Assets.xcassets, this would be empty
        // For now we verify the API works
        XCTAssertNotNil(missingPlaceholders, "validatePlaceholders should return array")
    }

    // MARK: - EPIC 1: Engine Core Scrubbing

    /// Gate test: Engine/Core should not contain game-specific IDs
    /// Requirement: "Engine не содержит ни одного ID, специфичного для игры"
    func testEngineContainsNoGameSpecificIds() {
        // Verify that regions come from ContentRegistry, not hardcoded in Engine
        let registry = ContentRegistry.shared
        let regionsFromRegistry = registry.getAllRegions()

        // If packs are loaded, verify engine uses ContentRegistry data
        if !regionsFromRegistry.isEmpty {
            // All region IDs should come from loaded packs
            let regionIds = regionsFromRegistry.map { $0.id }
            XCTAssertFalse(regionIds.isEmpty, "Регионы должны загружаться из ContentRegistry")

            // Verify each region has data-driven properties
            for region in regionsFromRegistry {
                XCTAssertFalse(region.id.isEmpty, "Region ID не должен быть пустым")
                XCTAssertFalse(region.title.localized.isEmpty, "Region должен иметь локализованное имя")
                XCTAssertFalse(region.regionType.isEmpty, "Region должен иметь тип из данных")
            }
        }

        // Verify Engine initializes and works with data-driven content
        let engine = TwilightGameEngine()
        XCTAssertNotNil(engine, "Engine должен инициализироваться без хардкода контента")

        // Engine should expose regions from ContentRegistry, not internal hardcoded list
        let engineRegions = engine.regionsArray
        XCTAssertNotNil(engineRegions, "Engine должен предоставлять регионы из ContentRegistry")
    }

    /// Gate test: Manifest is single source of entry region
    /// Requirement: "no fallback 'village'"
    func testManifestIsSingleSourceOfEntryRegion() {
        // Verify that ContentRegistry uses manifest.entryRegionId
        let registry = ContentRegistry.shared

        // Campaign packs should have entryRegionId, character packs don't need it
        let campaignPacks = registry.loadedPacks.values.filter {
            $0.manifest.packType == .campaign
        }

        for pack in campaignPacks {
            // Campaign packs must specify entryRegionId
            XCTAssertNotNil(
                pack.manifest.entryRegionId,
                "Campaign pack '\(pack.manifest.packId)' must specify entryRegionId"
            )
        }

        // The code change removed `?? "village"` fallback
        // This test documents the requirement
    }

    // MARK: - EPIC 1.1: One Truth Runtime (Engine-First Architecture)

    /// Gate test: Views should primarily use TwilightGameEngine, not legacy WorldState
    /// Requirement: "UI читает Engine, а не legacy WorldState напрямую"
    func testViewsUseEngineFirstArchitecture() {
        // This test documents the Engine-First architecture requirement
        // Views should observe TwilightGameEngine for state, not WorldState directly
        //
        // Allowed patterns:
        // - @ObservedObject var engine: TwilightGameEngine (primary source)
        // - WorldState usage only for legacy compatibility adapters (marked as such)
        //
        // Disallowed patterns:
        // - Direct WorldState mutation from Views
        // - Views creating new WorldState instances for game logic

        // Verify Engine provides all necessary data for Views
        let engine = TwilightGameEngine()

        // Engine should expose player state
        XCTAssertGreaterThan(engine.playerHealth, 0, "Engine должен предоставлять здоровье игрока")
        XCTAssertGreaterThan(engine.playerFaith, 0, "Engine должен предоставлять веру игрока")

        // Engine should expose world state
        XCTAssertFalse(engine.playerName.isEmpty, "Engine должен предоставлять имя игрока")

        // Engine should handle actions
        let result = engine.performAction(.rest)
        XCTAssertNotNil(result, "Engine должен обрабатывать действия")

        // Note: Full verification requires static code analysis
        // This test documents the requirement and verifies API availability
    }

    /// Gate test: Contract tests run against production engine
    /// Requirement: "контрактные тесты идут против production engine, не test stub"
    func testContractsRunAgainstProductionEngine() {
        // Verify that TwilightGameEngine (production) is testable
        let engine = TwilightGameEngine()

        // Basic contracts: state changes are observable
        let initialHealth = engine.playerHealth
        XCTAssertGreaterThan(initialHealth, 0, "Initial health должен быть положительным")

        // Perform action that should change state
        _ = engine.performAction(.rest)

        // State should be accessible (may or may not change depending on game rules)
        XCTAssertGreaterThanOrEqual(engine.playerHealth, 0, "Health должен быть доступен после действия")

        // The test verifies we're using production engine, not a mock
        // Production engine has full game logic
    }

    // MARK: - EPIC 2.1: Code Registry Isolation

    /// Gate test: CardFactory is the primary interface, not direct registry access
    /// Requirement: "runtime не обращается напрямую к CodeRegistry"
    func testCardFactoryIsThePrimaryInterface() throws {
        // CardFactory should be the single entry point for card creation at runtime
        // It abstracts over both ContentRegistry (JSON packs) and CardRegistry (built-in)

        let factory = CardFactory.shared

        // Factory should provide starting decks
        let deck = factory.createStartingDeck(forHero: "veleslava")
        // Deck may be empty if no packs loaded, but method should work
        XCTAssertNotNil(deck, "CardFactory должен предоставлять стартовые колоды")

        // Factory should provide guardians
        let guardians = factory.createGuardians()
        // Skip if ContentPacks not loaded in test environment
        // GATE TEST: Must not skip - if packs not loaded, this is a test environment issue
        if guardians.isEmpty {
            XCTFail("GATE TEST FAILURE: ContentPacks not loaded - test environment configuration issue")
            return
        }

        // Factory should provide encounter deck
        let encounters = factory.createEncounterDeck()
        XCTAssertNotNil(encounters, "CardFactory должен предоставлять колоду столкновений")

        // This test documents that CardFactory is the correct abstraction layer
        // Direct CardRegistry/HeroRegistry access should only be in CardFactory implementation
    }

    /// Gate test: ContentRegistry is the source of truth for pack content
    /// Requirement: "ContentRegistry как единственный источник данных из pack'ов"
    func testContentRegistryIsSingleSourceOfPackData() {
        // ContentRegistry should be used for all pack content access
        let registry = ContentRegistry.shared

        // Registry should expose loaded packs
        XCTAssertNotNil(registry.loadedPacks, "ContentRegistry должен хранить загруженные pack'и")

        // Registry should provide access to pack content via factory methods
        // Direct access to registry methods is appropriate for reading definitions
        let regions = registry.getAllRegions()
        XCTAssertNotNil(regions, "ContentRegistry должен предоставлять регионы")

        let events = registry.getAllEvents()
        XCTAssertNotNil(events, "ContentRegistry должен предоставлять события")

        // This documents that ContentRegistry is the correct source for pack data
    }

    // MARK: - EPIC 2: Determinism

    /// Gate test: Full playthrough is identical with same seed
    /// Requirement: "полный playthrough одинаков при seed (на production engine)"
    func testWorldDeterminismWithSeed() {
        let testSeed: UInt64 = 12345

        // First playthrough
        WorldRNG.shared.setSeed(testSeed)
        let results1 = simulateDeterministicActions()

        // Second playthrough with same seed
        WorldRNG.shared.setSeed(testSeed)
        let results2 = simulateDeterministicActions()

        // Results must be identical
        XCTAssertEqual(
            results1.randomValues,
            results2.randomValues,
            "Random values must be identical with same seed"
        )
        XCTAssertEqual(
            results1.selectedIndices,
            results2.selectedIndices,
            "Selection results must be identical with same seed"
        )
    }

    /// Gate test: No system random in Engine/Core and core paths
    /// Requirement: "статический scan по randomElement/shuffled/Double.random"
    func testNoSystemRandomInEngineCore() throws {
        // Get project root directory from compile-time path
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // Engine
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        // Scan entire engine source tree recursively (no hardcoded subdirectory list)
        let engineBase = SourcePathResolver.engineBase

        // Forbidden patterns (system random APIs)
        let forbiddenPatterns = [
            ".randomElement()",      // Array.randomElement()
            ".shuffled()",           // Array.shuffled()
            "Int.random(",           // Int.random(in:)
            "Double.random(",        // Double.random(in:)
            "UInt64.random(",        // UInt64.random(in:)
            "Bool.random(",          // Bool.random()
            "arc4random",            // C random
            "drand48"                // C random
        ]

        // Allowed contexts (where system random is OK)
        let allowedContexts = [
            "WorldRNG",              // Our deterministic RNG
            "// ",                   // Single-line comments
            "/// ",                  // Doc comments
            "/* ",                   // Block comments
            "* "                     // Block comment continuation
        ]

        // No exceptions: all system RNG removed from engine
        let allowedExceptions: [String: [String]] = [:]

        var violations: [String] = []

        let engineDir = projectRoot.appendingPathComponent(engineBase)
        let swiftFiles = findSwiftFiles(in: engineDir)

        for fileURL in swiftFiles {
            let fileName = fileURL.lastPathComponent
            let content = try String(contentsOf: fileURL, encoding: .utf8)
            let lines = content.components(separatedBy: .newlines)

            for (index, line) in lines.enumerated() {
                let trimmedLine = line.trimmingCharacters(in: .whitespaces)
                let lineNumber = index + 1

                // Check each forbidden pattern
                for pattern in forbiddenPatterns {
                    if line.contains(pattern) {
                        // Check if it's in an allowed context
                        let isAllowedContext = allowedContexts.contains { context in
                            trimmedLine.hasPrefix(context) || line.contains(context)
                        }

                        // Check if it's an allowed exception for this file
                        let isAllowedException = allowedExceptions[fileName]?.contains { exception in
                            pattern.contains(exception) || exception.contains(pattern)
                        } ?? false

                        if !isAllowedContext && !isAllowedException {
                            violations.append("  \(fileName):\(lineNumber): \(trimmedLine) [pattern: \(pattern)]")
                        }
                    }
                }
            }
        }

        if !violations.isEmpty {
            let message = """
            Found \(violations.count) system random API usages in core engine paths:
            \(violations.joined(separator: "\n"))

            All randomness in Engine/Core must use WorldRNG for determinism.
            Replace:
            - .randomElement() → WorldRNG.shared.randomElement(from:)
            - .shuffled() → WorldRNG.shared.shuffle(&array)
            - Int.random(in:) → WorldRNG.shared.nextInt(in:)
            - Double.random(in:) → WorldRNG.shared.nextDouble()
            """
            XCTFail(message)
        }

        // Also verify WorldRNG determinism
        WorldRNG.shared.setSeed(42)
        let val1 = WorldRNG.shared.nextDouble()
        WorldRNG.shared.setSeed(42)
        let val2 = WorldRNG.shared.nextDouble()
        XCTAssertEqual(val1, val2, "WorldRNG must be deterministic with same seed")
    }

    // MARK: - EPIC 3: Pack Compatibility

    /// Gate test: Can load multiple packs (campaign + character)
    /// Note: "Character Pack" replaces "Investigator Pack" for Twilight Marches theme
    func testLoadTwoPacks_CampaignPlusCharacter() throws {
        // This test would require having multiple pack files
        // For now, verify the API supports this
        let registry = ContentRegistry.shared

        // Verify registry can hold multiple packs
        XCTAssertNotNil(registry.loadedPacks, "Registry should support multiple packs")

        // Note: Full test requires campaign + character pack files
    }

    /// Gate test: Save stores pack versions and validates on load
    func testSaveLoadValidatesPackVersions() {
        // Get currently loaded packs to create a valid activePackSet
        let registry = ContentRegistry.shared
        var activePackSet: [String: String] = [:]
        for (packId, pack) in registry.loadedPacks {
            activePackSet[packId] = pack.manifest.version.description
        }

        // Create a test save with pack version info
        let testSave = EngineSave(
            version: EngineSave.currentVersion,
            savedAt: Date(),
            gameDuration: 100,
            coreVersion: EngineSave.currentCoreVersion,
            activePackSet: activePackSet,
            formatVersion: EngineSave.currentFormatVersion,
            primaryCampaignPackId: nil,
            playerName: "Test",
            heroId: nil,
            playerHealth: 10,
            playerMaxHealth: 10,
            playerFaith: 5,
            playerMaxFaith: 5,
            playerBalance: 50,
            deckCardIds: [],
            handCardIds: [],
            discardCardIds: [],
            currentDay: 1,
            worldTension: 0,
            lightDarkBalance: 50,
            currentRegionId: nil,
            regions: [],
            mainQuestStage: 0,
            activeQuestIds: [],
            completedQuestIds: [],
            questStages: [:],
            completedEventIds: [],
            eventLog: [],
            worldFlags: [:],
            rngSeed: 0,
            rngState: 0
        )

        // Verify save contains required version fields
        XCTAssertFalse(testSave.coreVersion.isEmpty, "Save must store coreVersion")
        XCTAssertNotNil(testSave.activePackSet, "Save must store activePackSet")
        XCTAssertGreaterThan(testSave.formatVersion, 0, "Save must have formatVersion > 0")

        // Verify validation works - save with matching pack versions should be loadable
        let compatibility = testSave.validateCompatibility(with: registry)
        XCTAssertTrue(compatibility.isLoadable, "Save with matching pack versions should be loadable")

        // Test that mismatched pack triggers warning/error
        let mismatchedSave = EngineSave(
            version: EngineSave.currentVersion,
            savedAt: Date(),
            gameDuration: 100,
            coreVersion: EngineSave.currentCoreVersion,
            activePackSet: ["nonexistent_pack": "1.0.0"],
            formatVersion: EngineSave.currentFormatVersion,
            primaryCampaignPackId: nil,
            playerName: "Test",
            heroId: nil,
            playerHealth: 10,
            playerMaxHealth: 10,
            playerFaith: 5,
            playerMaxFaith: 5,
            playerBalance: 50,
            deckCardIds: [],
            handCardIds: [],
            discardCardIds: [],
            currentDay: 1,
            worldTension: 0,
            lightDarkBalance: 50,
            currentRegionId: nil,
            regions: [],
            mainQuestStage: 0,
            activeQuestIds: [],
            completedQuestIds: [],
            questStages: [:],
            completedEventIds: [],
            eventLog: [],
            worldFlags: [:],
            rngSeed: 0,
            rngState: 0
        )

        let mismatchedCompatibility = mismatchedSave.validateCompatibility(with: registry)
        // Missing packs result in warnings, not errors - save is still loadable
        // This allows users to continue playing even if some content is unavailable
        XCTAssertTrue(mismatchedCompatibility.isLoadable, "Save with missing pack should still be loadable (with warnings)")

        // But it should have warnings
        if case .compatible(let warnings) = mismatchedCompatibility {
            XCTAssertFalse(warnings.isEmpty, "Missing pack should generate warnings")
        } else if case .fullyCompatible = mismatchedCompatibility {
            XCTFail("Missing pack should generate at least a warning")
        }
    }

    // MARK: - EPIC 5: Localization Support

    /// Gate test: Pack content supports localization
    /// Requirement: "Packs используют stringKey/nameRu/descriptionRu для локализации"
    func testPackContentSupportsLocalization() {
        // Verify that content definitions have localization support
        // Current implementation uses nameRu/descriptionRu fields (PoC approach)
        // Future: stringKey approach for app-side localization

        // Verify HeroRegistry uses localized names
        let heroes = HeroRegistry.shared.allHeroes
        for hero in heroes {
            // Hero should have a name (either localized or default)
            XCTAssertFalse(hero.name.isEmpty, "Hero должен иметь имя")
            XCTAssertFalse(hero.description.isEmpty, "Hero должен иметь описание")
        }

        // Verify ContentRegistry provides localized content
        let registry = ContentRegistry.shared
        let regions = registry.getAllRegions()
        for region in regions {
            XCTAssertFalse(region.title.localized.isEmpty, "Region должен иметь имя")
        }

        // This documents that localization is supported via nameRu/descriptionRu pattern
        // The pack loader handles locale detection and returns appropriate strings
    }

    // MARK: - EPIC 6: Pack Composition

    /// Gate test: Multiple packs can be loaded together
    /// Requirement: "Campaign Pack + Character Pack работают вместе"
    func testCampaignPlusCharacterPackComposition() {
        // Verify ContentRegistry supports multiple pack loading
        let registry = ContentRegistry.shared

        // Registry should be able to hold multiple packs
        XCTAssertNotNil(registry.loadedPacks, "Registry должен поддерживать множественные pack'и")

        // Verify pack loading API exists
        // Note: Full test requires actual pack files

        // Document the composition requirement:
        // - Campaign pack provides: regions, events, quests, enemies
        // - Character pack provides: heroes, hero-specific cards, hero abilities
        // - Packs can have dependencies (character pack depends on campaign pack)
    }

    // MARK: - EPIC 7: Save Pack Set Tracking

    /// Gate test: Save stores pack set for compatibility
    /// Requirement: "Save хранит activePackSet и проверяет при загрузке"
    func testSaveStoresPackSetAndValidates() {
        // Verify EngineSave has pack compatibility fields
        let engine = TwilightGameEngine()

        // EngineSave should include:
        // - coreVersion: String
        // - activePackSet: [String: String] (packId -> version)
        // - formatVersion: Int

        // Verify engine is valid and can be used for save
        XCTAssertNotNil(engine, "Engine должен быть создан для сохранения")

        // Create a minimal save to verify structure
        // Note: This is documented in EngineSave.swift
        XCTAssertEqual(EngineSave.currentVersion, 1, "EngineSave должен иметь версию")
        XCTAssertEqual(EngineSave.currentFormatVersion, 1, "EngineSave должен иметь версию формата")
        XCTAssertFalse(EngineSave.currentCoreVersion.isEmpty, "EngineSave должен иметь версию core")
    }

    // MARK: - Determinism Helpers

    private struct DeterministicResults {
        var randomValues: [Double] = []
        var selectedIndices: [Int] = []
    }

    private func simulateDeterministicActions() -> DeterministicResults {
        var results = DeterministicResults()

        // Generate random values
        for _ in 0..<10 {
            results.randomValues.append(WorldRNG.shared.nextDouble())
        }

        // Simulate selection from arrays
        let testArray = ["a", "b", "c", "d", "e"]
        for _ in 0..<5 {
            if let selected = WorldRNG.shared.randomElement(from: testArray),
               let index = testArray.firstIndex(of: selected) {
                results.selectedIndices.append(index)
            }
        }

        return results
    }

    // MARK: - EPIC 1.2: One Engine = One Truth

    /// Gate test: Contract tests run against production engine, not test stub
    /// Also verifies that TwilightGameEngine is the ONLY runtime engine
    func testContractsAgainstProductionEngine() {
        // Verify that TwilightGameEngine (production) can be tested
        let engine = TwilightGameEngine()

        // Basic contract: performAction returns result
        let result = engine.performAction(.rest)
        XCTAssertNotNil(result, "Production engine should return action result")

        // Contract: state changes are observable
        // (This is verified by the Engine-First architecture)
    }

    /// Gate test: No alternative runtime engines exist in TwilightEngine package
    /// Requirement: "Production runtime engine должен быть единственным исполняемым движком"
    func testNoAlternativeEnginesExist() throws {
        // Get project root directory from compile-time path
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // Engine
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        let coreDir = projectRoot.appendingPathComponent(SourcePathResolver.engineBase + "/Core")

        // Scan for files with "Engine" in the name
        let engineFiles = try FileManager.default.contentsOfDirectory(at: coreDir, includingPropertiesForKeys: nil)
            .filter { $0.pathExtension == "swift" }
            .filter { $0.lastPathComponent.contains("Engine") }
            .map { $0.lastPathComponent }

        // Only TwilightGameEngine should exist as the runtime engine
        // Other "Engine" files (TimeEngine, PressureEngine) are subsystems, not full runtime engines
        let alternativeEngines = engineFiles.filter { file in
            // TwilightGameEngine is the production engine
            if file == "TwilightGameEngine.swift" { return false }
            // TimeEngine and PressureEngine are subsystems, not runtime engines
            if file == "TimeEngine.swift" || file == "PressureEngine.swift" { return false }
            // EngineProtocols.swift contains protocols, not a runtime engine
            if file == "EngineProtocols.swift" { return false }
            // EngineSave.swift is a data model, not a runtime engine
            if file == "EngineSave.swift" { return false }
            // ResonanceEngine.swift is a subsystem (zone detection + resonance state), not a runtime engine
            if file == "ResonanceEngine.swift" { return false }
            // Any other "Engine" file is a potential violation
            return true
        }

        XCTAssertTrue(
            alternativeEngines.isEmpty,
            "Found alternative runtime engines that should be removed: \(alternativeEngines). " +
            "TwilightGameEngine должен быть единственным runtime движком."
        )
    }

    // MARK: - EPIC 2.1: Single Source of Content (Packs only)

    /// Gate test: Runtime does not access code registries directly
    /// Requirement: "Вся загрузка карт/героев/квестов/ивентов осуществляется через ContentRegistry"
    func testRuntimeDoesNotAccessCodeRegistries() throws {
        // Get project root directory from compile-time path
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // Engine
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        // Directories to check (production code only, excluding tests)
        // Engine code is now in TwilightEngine package
        let productionDirs = [SourcePathResolver.engineBase, "App", "Views", "Models", "Utilities"]

        // Patterns that indicate direct code registry access (should use ContentRegistry/CardFactory)
        let forbiddenPatterns = [
            "CardRegistry.shared",           // Direct CardRegistry access
            "TwilightMarchesCards",          // Hardcoded card definitions
            "registerBuiltInCards",          // Built-in card registration
            "HeroRegistry.shared.register"   // Direct hero registration (reading is OK)
        ]

        // Allowed patterns (these files ARE the registries, they can access themselves)
        let allowedFiles = [
            "CardRegistry.swift",
            "CardFactory.swift",  // CardFactory internally manages registries
            "ContentRegistry.swift",
            "HeroRegistry.swift"
        ]

        var violations: [String] = []
        var dirsFound = 0

        for dir in productionDirs {
            let dirURL = projectRoot.appendingPathComponent(dir)
            guard FileManager.default.fileExists(atPath: dirURL.path) else { continue }
            dirsFound += 1

            let swiftFiles = findSwiftFiles(in: dirURL)
            for fileURL in swiftFiles {
                let fileName = fileURL.lastPathComponent

                // Skip allowed files (registries themselves)
                if allowedFiles.contains(fileName) { continue }

                let fileViolations = try checkForbiddenPatternsInFile(fileURL, patterns: forbiddenPatterns)
                violations.append(contentsOf: fileViolations)
            }
        }

        XCTAssertGreaterThan(dirsFound, 0, "No production directories found — repo structure may have changed")

        if !violations.isEmpty {
            let message = """
            Found \(violations.count) direct code registry accesses in production code:
            \(violations.joined(separator: "\n"))

            Runtime должен использовать ContentRegistry/CardFactory для загрузки контента.
            Прямой доступ к CardRegistry.shared или TwilightMarchesCards запрещён.
            """
            XCTFail(message)
        }
    }

    /// Gate test: Runtime rejects raw JSON files, only accepts binary .pack
    /// Requirement: "Runtime загружает только .pack файлы, JSON только для compile-time"
    func testRuntimeRejectsRawJSON() throws {
        // Create a temporary JSON directory (simulating raw JSON pack)
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        defer { try? FileManager.default.removeItem(at: tempDir) }

        // Create a minimal manifest.json file
        let manifestJSON = """
        {
            "packId": "test-json-pack",
            "displayName": { "en": "Test JSON Pack", "ru": "Тестовый JSON пак" },
            "version": "1.0.0",
            "packType": "character",
            "coreVersionMin": "1.0.0"
        }
        """
        let manifestURL = tempDir.appendingPathComponent("manifest.json")
        try manifestJSON.write(to: manifestURL, atomically: true, encoding: .utf8)

        // Attempt to load raw JSON directory should fail
        let registry = ContentRegistry.shared
        registry.resetForTesting()

        // Try to load the JSON directory (not a .pack file)
        do {
            _ = try registry.loadPack(from: tempDir)
            XCTFail("GATE TEST FAILURE: Runtime должен отвергать raw JSON директории")
        } catch let error as PackLoadError {
            // Expected: should fail with invalidManifest error
            if case .invalidManifest(let reason) = error {
                XCTAssertTrue(
                    reason.contains(".pack") || reason.contains("pack"),
                    "Error message should mention .pack files: \(reason)"
                )
            } else {
                // Any PackLoadError is acceptable - runtime rejected the JSON
            }
        } catch {
            // Any error is fine - runtime rejected the raw JSON
        }

        // Also verify that a file with wrong extension is rejected
        let wrongExtFile = tempDir.appendingPathComponent("test.json")
        try "{}".write(to: wrongExtFile, atomically: true, encoding: .utf8)

        do {
            _ = try registry.loadPack(from: wrongExtFile)
            XCTFail("GATE TEST FAILURE: Runtime должен отвергать файлы без расширения .pack")
        } catch {
            // Expected: any error means runtime correctly rejected the file
        }
    }

    /// Check a Swift file for forbidden patterns not in comments
    private func checkForbiddenPatternsInFile(_ fileURL: URL, patterns: [String]) throws -> [String] {
        let content = try String(contentsOf: fileURL, encoding: .utf8)
        let lines = content.components(separatedBy: .newlines)
        var violations: [String] = []

        for (index, line) in lines.enumerated() {
            let trimmedLine = line.trimmingCharacters(in: .whitespaces)
            let lineNumber = index + 1

            // Skip comments
            if trimmedLine.hasPrefix("//") || trimmedLine.hasPrefix("/*") || trimmedLine.hasPrefix("*") {
                continue
            }

            // Remove inline comments for pattern matching
            var lineToCheck = trimmedLine
            if let commentRange = lineToCheck.range(of: "//") {
                lineToCheck = String(lineToCheck[..<commentRange.lowerBound])
            }

            // Check for forbidden patterns
            for pattern in patterns {
                if lineToCheck.contains(pattern) {
                    let fileName = fileURL.lastPathComponent
                    violations.append("  \(fileName):\(lineNumber): \(trimmedLine) [pattern: \(pattern)]")
                }
            }
        }

        return violations
    }
}

// MARK: - Static Analysis Test (Supplementary)

extension AuditGateTests {

    /// Supplementary: Verify no hardcoded region IDs in key files
    /// See ArchitectureComplianceTests for full static analysis
    func testDocumentHardcodedIdRemoval() throws {
        // Document the changes made to remove hardcoded IDs:
        //
        // 1. TwilightGameEngine.swift:
        //    - mapRegionType(fromString:) now takes regionType string, not ID
        //    - entryRegionId comes from manifest, no "village" fallback
        //    - tensionTickInterval and restHealAmount now from BalanceConfiguration
        //
        // 2. JSONContentProvider.swift:
        //    - Events loaded from events.json, not hardcoded pool_* files
        //    - RegionDefinition includes regionType field
        //
        // 3. ContentView.swift, WorldMapView.swift, WorldState.swift:
        //    - All TwilightMarchesCards usage replaced with CardFactory
        //
        // 4. PlayerRuntimeState.swift:
        //    - shuffle() replaced with WorldRNG.shared.shuffle()
        //
        // 5. BalanceConfiguration:
        //    - Added restHealAmount and tensionTickInterval

        // Verify architectural principles are enforced
        // Full static analysis in ArchitectureComplianceTests
        let factory = CardFactory.shared
        XCTAssertNotNil(factory, "CardFactory must be the single source of cards")

        let guardians = factory.createGuardians()
        // Skip if ContentPacks not loaded in test environment
        // GATE TEST: Must not skip - if packs not loaded, this is a test environment issue
        if guardians.isEmpty {
            XCTFail("GATE TEST FAILURE: ContentPacks not loaded - test environment configuration issue")
            return
        }
    }

    // MARK: - EPIC 0.3: Content Hash Verification

    /// Gate test: Checksum mismatch throws error during pack loading
    /// Requirement: "hash verification при загрузке pack'ов"
    func testContentHashMismatchThrowsError() throws {
        // Create a temporary pack with incorrect checksum
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }

        // Create a simple test file
        let testContent = "test content"
        let testFileURL = tempDir.appendingPathComponent("test.json")
        try testContent.data(using: .utf8)!.write(to: testFileURL)

        // Compute correct hash
        let correctHash = try PackLoader.computeSHA256(of: testFileURL)
        XCTAssertFalse(correctHash.isEmpty, "Hash should not be empty")

        // Verify that an intentionally wrong hash would be detected
        let wrongHash = "0000000000000000000000000000000000000000000000000000000000000000"
        XCTAssertNotEqual(correctHash, wrongHash, "Correct hash should differ from test wrong hash")

        // Create manifest with wrong checksum
        let manifest = PackManifest(
            packId: "test-pack",
            displayName: LocalizedString("Test Pack"),
            description: LocalizedString("Test pack for checksum verification"),
            version: SemanticVersion(major: 1, minor: 0, patch: 0),
            packType: .campaign,
            coreVersionMin: SemanticVersion(major: 1, minor: 0, patch: 0),
            author: "Test",
            checksums: ["test.json": wrongHash]
        )

        // Attempt to load should fail with checksum mismatch
        do {
            _ = try PackLoader.load(manifest: manifest, from: tempDir)
            XCTFail("Loading pack with wrong checksum should throw error")
        } catch let error as PackLoadError {
            if case .checksumMismatch(let file, let expected, let actual) = error {
                XCTAssertEqual(file, "test.json")
                XCTAssertEqual(expected, wrongHash)
                XCTAssertEqual(actual, correctHash)
            } else {
                // File not found is acceptable since we only have test.json
                // and no real content files
                if case .fileNotFound = error {
                    // This is OK - the checksum check happens first
                } else {
                    throw error
                }
            }
        }
    }

    /// Gate test: Correct checksum passes verification
    func testCorrectChecksumPassesVerification() throws {
        // Create a temporary pack with correct checksum
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }

        // Create a simple test file
        let testContent = "test content"
        let testFileURL = tempDir.appendingPathComponent("test.json")
        try testContent.data(using: .utf8)!.write(to: testFileURL)

        // Compute correct hash
        let correctHash = try PackLoader.computeSHA256(of: testFileURL)

        // Create manifest with correct checksum
        let manifest = PackManifest(
            packId: "test-pack",
            displayName: LocalizedString("Test Pack"),
            description: LocalizedString("Test pack for checksum verification"),
            version: SemanticVersion(major: 1, minor: 0, patch: 0),
            packType: .campaign,
            coreVersionMin: SemanticVersion(major: 1, minor: 0, patch: 0),
            author: "Test",
            checksums: ["test.json": correctHash]
        )

        // Attempt to load should pass checksum verification
        // (may fail later due to missing content files, but that's OK)
        do {
            _ = try PackLoader.load(manifest: manifest, from: tempDir)
        } catch let error as PackLoadError {
            // Checksum should pass, other errors are acceptable
            if case .checksumMismatch = error {
                XCTFail("Pack with correct checksum should not fail checksum verification")
            }
            // Other errors (contentLoadFailed, etc.) are acceptable since we have minimal test files
        }
    }

    // MARK: - EPIC 11.2: Negative Tests for ContentLoader

    /// Negative test: Broken JSON fails to load
    func testBrokenJSONFailsToLoad() throws {
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }

        // Create invalid JSON
        let brokenJSON = "{ invalid json content"
        let jsonFileURL = tempDir.appendingPathComponent("regions.json")
        try brokenJSON.data(using: .utf8)!.write(to: jsonFileURL)

        // Create manifest pointing to broken JSON
        let manifest = PackManifest(
            packId: "broken-pack",
            displayName: LocalizedString("Broken Pack"),
            description: LocalizedString("Test pack with broken JSON"),
            version: SemanticVersion(major: 1, minor: 0, patch: 0),
            packType: .campaign,
            coreVersionMin: SemanticVersion(major: 1, minor: 0, patch: 0),
            author: "Test",
            regionsPath: "regions.json"
        )

        // Attempt to load should fail
        do {
            _ = try PackLoader.load(manifest: manifest, from: tempDir)
            XCTFail("Loading broken JSON should throw error")
        } catch let error as PackLoadError {
            // Should fail with contentLoadFailed
            if case .contentLoadFailed(let file, _) = error {
                XCTAssertEqual(file, "regions.json", "Ошибка должна указывать на сломанный файл")
            } else {
                // Any PackLoadError is acceptable for broken JSON
            }
        }
    }

    /// Negative test: Missing required fields fails validation
    func testMissingRequiredFieldsFailsValidation() throws {
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }

        // Create JSON with missing required fields (id is required for regions)
        let incompleteJSON = """
        [
            {
                "name": "Test Region"
            }
        ]
        """
        let jsonFileURL = tempDir.appendingPathComponent("regions.json")
        try incompleteJSON.data(using: .utf8)!.write(to: jsonFileURL)

        // Create manifest
        let manifest = PackManifest(
            packId: "incomplete-pack",
            displayName: LocalizedString("Incomplete Pack"),
            description: LocalizedString("Test pack with incomplete JSON"),
            version: SemanticVersion(major: 1, minor: 0, patch: 0),
            packType: .campaign,
            coreVersionMin: SemanticVersion(major: 1, minor: 0, patch: 0),
            author: "Test",
            regionsPath: "regions.json"
        )

        // Attempt to load - should fail due to missing fields
        do {
            _ = try PackLoader.load(manifest: manifest, from: tempDir)
            // If it loads, the JSON decoder should have failed
            XCTFail("Loading JSON with missing required fields should fail")
        } catch {
            // Expected to fail - any error is acceptable
        }
    }

    // MARK: - EPIC 11.3: State Round-Trip Serialization

    /// Gate test: EngineSave round-trip preserves all data
    func testStateRoundTripSerialization() throws {
        // Create EngineSave with test data
        let originalSave = EngineSave(
            version: EngineSave.currentVersion,
            savedAt: Date(),
            gameDuration: 3600.0,
            coreVersion: EngineSave.currentCoreVersion,
            activePackSet: ["test_campaign": "1.0.0"],
            formatVersion: EngineSave.currentFormatVersion,
            primaryCampaignPackId: nil,
            playerName: "Test Hero",
            heroId: "test_hero",
            playerHealth: 10,
            playerMaxHealth: 12,
            playerFaith: 5,
            playerMaxFaith: 8,
            playerBalance: 50,
            deckCardIds: ["card_1", "card_2", "card_3"],
            handCardIds: ["card_4"],
            discardCardIds: ["card_5"],
            currentDay: 3,
            worldTension: 25,
            lightDarkBalance: 50,
            currentRegionId: "test_region",
            regions: [],
            mainQuestStage: 2,
            activeQuestIds: ["quest_1"],
            completedQuestIds: ["quest_0"],
            questStages: ["quest_1": 1],
            completedEventIds: ["event_1", "event_2"],
            eventLog: [],
            worldFlags: ["flag_1": true, "flag_2": false],
            rngSeed: 12345,
            rngState: 12345
        )

        // Encode to JSON
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        let jsonData = try encoder.encode(originalSave)

        // Decode back
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        let loadedSave = try decoder.decode(EngineSave.self, from: jsonData)

        // Verify all fields match
        XCTAssertEqual(loadedSave.version, originalSave.version)
        XCTAssertEqual(loadedSave.coreVersion, originalSave.coreVersion)
        XCTAssertEqual(loadedSave.formatVersion, originalSave.formatVersion)
        XCTAssertEqual(loadedSave.playerName, originalSave.playerName)
        XCTAssertEqual(loadedSave.playerHealth, originalSave.playerHealth)
        XCTAssertEqual(loadedSave.playerMaxHealth, originalSave.playerMaxHealth)
        XCTAssertEqual(loadedSave.playerFaith, originalSave.playerFaith)
        XCTAssertEqual(loadedSave.playerMaxFaith, originalSave.playerMaxFaith)
        XCTAssertEqual(loadedSave.playerBalance, originalSave.playerBalance)
        XCTAssertEqual(loadedSave.deckCardIds, originalSave.deckCardIds)
        XCTAssertEqual(loadedSave.handCardIds, originalSave.handCardIds)
        XCTAssertEqual(loadedSave.discardCardIds, originalSave.discardCardIds)
        XCTAssertEqual(loadedSave.currentDay, originalSave.currentDay)
        XCTAssertEqual(loadedSave.worldTension, originalSave.worldTension)
        XCTAssertEqual(loadedSave.lightDarkBalance, originalSave.lightDarkBalance)
        XCTAssertEqual(loadedSave.currentRegionId, originalSave.currentRegionId)
        XCTAssertEqual(loadedSave.mainQuestStage, originalSave.mainQuestStage)
        XCTAssertEqual(loadedSave.activeQuestIds, originalSave.activeQuestIds)
        XCTAssertEqual(loadedSave.completedQuestIds, originalSave.completedQuestIds)
        XCTAssertEqual(loadedSave.questStages, originalSave.questStages)
        XCTAssertEqual(loadedSave.completedEventIds, originalSave.completedEventIds)
        XCTAssertEqual(loadedSave.worldFlags, originalSave.worldFlags)
        XCTAssertEqual(loadedSave.rngSeed, originalSave.rngSeed)
        XCTAssertEqual(loadedSave.activePackSet, originalSave.activePackSet)
    }

    // MARK: - EPIC 12: Critical Game Conditions

    /// Gate test: Player health reaching 0 triggers defeat
    /// Requirement: "здоровье игрока = 0 вызывает поражение"
    func testPlayerDeathTriggersDefeat() {
        let engine = TwilightGameEngine()
        engine.initializeNewGame(playerName: "Test", heroId: nil, startingDeck: [])

        // Verify player starts alive
        XCTAssertGreaterThan(engine.playerHealth, 0, "Player should start with health > 0")

        // Deal fatal damage
        let fatalDamage = engine.playerHealth + 10
        engine.performAction(.combatApplyEffect(effect: .takeDamage(amount: fatalDamage)))

        // Verify player health is 0 (not negative)
        XCTAssertEqual(engine.playerHealth, 0, "Player health should be exactly 0, not negative")
    }

    /// Gate test: Player health cannot go below 0
    /// Requirement: "здоровье не может быть отрицательным"
    func testPlayerHealthCannotBeNegative() {
        let engine = TwilightGameEngine()
        engine.initializeNewGame(playerName: "Test", heroId: nil, startingDeck: [])

        // Deal massive damage
        engine.performAction(.combatApplyEffect(effect: .takeDamage(amount: 9999)))

        // Health should be 0, not negative
        XCTAssertGreaterThanOrEqual(engine.playerHealth, 0, "Health cannot be negative")
    }

    /// Gate test: Healing cannot exceed max health
    /// Requirement: "лечение не превышает максимальное здоровье"
    func testHealingCannotExceedMaxHealth() {
        let engine = TwilightGameEngine()
        engine.initializeNewGame(playerName: "Test", heroId: nil, startingDeck: [])

        let maxHealth = engine.playerMaxHealth

        // Heal beyond max
        engine.performAction(.combatApplyEffect(effect: .heal(amount: 9999)))

        // Health should not exceed max
        XCTAssertLessThanOrEqual(engine.playerHealth, maxHealth, "Health cannot exceed max")
        XCTAssertEqual(engine.playerHealth, maxHealth, "Healing should cap at max health")
    }

    /// Gate test: Faith cannot go below 0 or exceed max
    /// Requirement: "вера в пределах 0..max"
    func testFaithBoundsAreRespected() {
        let engine = TwilightGameEngine()
        engine.initializeNewGame(playerName: "Test", heroId: nil, startingDeck: [])

        let maxFaith = engine.playerMaxFaith

        // Try to spend more faith than available
        engine.performAction(.combatApplyEffect(effect: .spendFaith(amount: 9999)))
        XCTAssertGreaterThanOrEqual(engine.playerFaith, 0, "Faith cannot be negative")

        // Try to gain more faith than max
        engine.performAction(.combatApplyEffect(effect: .gainFaith(amount: 9999)))
        XCTAssertLessThanOrEqual(engine.playerFaith, maxFaith, "Faith cannot exceed max")
    }

    /// Gate test: Enemy health cannot go below 0
    /// Requirement: "здоровье врага не отрицательное"
    func testEnemyHealthCannotBeNegative() {
        let engine = TwilightGameEngine()
        engine.initializeNewGame(playerName: "Test", heroId: nil, startingDeck: [])

        let enemy = Card(id: "test_enemy", name: "Test Enemy", type: .monster, description: "Test", health: 10)
        engine.setupCombatEnemy(enemy)

        // Deal massive damage
        engine.performAction(.combatApplyEffect(effect: .damageEnemy(amount: 9999)))

        // Enemy health should be 0, not negative
        XCTAssertEqual(engine.combatEnemyHealth, 0, "Enemy health should be 0, not negative")
    }

    // MARK: - EPIC 0.2: Release Configuration (Debug Prints)

    /// Gate test: All print() statements must be wrapped in #if DEBUG
    /// Requirement: "В Release сборке нет debug print'ов"
    func testAllPrintStatementsAreDebugOnly() throws {
        // Get project root directory from compile-time path
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // Engine
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        // Skip if project source not accessible (e.g., running on CI without source)
        guard FileManager.default.fileExists(atPath: projectRoot.path) else {
            XCTFail("GATE TEST FAILURE: Project source not accessible at \(projectRoot.path)")
            return
        }

        // Directories to check (production code only)
        let productionDirs = [
            "Engine",
            "App",
            "Views",
            "Models",
            "Utilities"
        ]

        var violations: [String] = []
        var dirsFound = 0

        for dir in productionDirs {
            let dirURL = projectRoot.appendingPathComponent(dir)

            // Skip if directory doesn't exist
            guard FileManager.default.fileExists(atPath: dirURL.path) else {
                continue
            }
            dirsFound += 1

            let swiftFiles = findSwiftFiles(in: dirURL)

            for fileURL in swiftFiles {
                let fileViolations = try checkPrintStatementsInFile(fileURL)
                violations.append(contentsOf: fileViolations)
            }
        }

        XCTAssertGreaterThan(dirsFound, 0, "No production directories found — repo structure may have changed")

        // Report all violations
        if !violations.isEmpty {
            let message = "Found \(violations.count) print() statements not wrapped in #if DEBUG:\n" +
                violations.joined(separator: "\n")
            XCTFail(message)
        }
    }

    /// Find all Swift files recursively in a directory
    private func findSwiftFiles(in directory: URL) -> [URL] {
        var result: [URL] = []
        let fileManager = FileManager.default

        guard let enumerator = fileManager.enumerator(
            at: directory,
            includingPropertiesForKeys: [.isRegularFileKey],
            options: [.skipsHiddenFiles]
        ) else {
            return result
        }

        for case let fileURL as URL in enumerator {
            if fileURL.pathExtension == "swift" {
                result.append(fileURL)
            }
        }

        return result
    }

    /// Check a Swift file for print() statements not in #if DEBUG blocks
    /// Returns array of violation descriptions
    private func checkPrintStatementsInFile(_ fileURL: URL) throws -> [String] {
        let content = try String(contentsOf: fileURL, encoding: .utf8)
        let lines = content.components(separatedBy: .newlines)
        var violations: [String] = []

        // Track preprocessor directive stack
        // Each entry is true if we're in a DEBUG-related block
        var conditionalStack: [Bool] = []
        var inPreviewBlock = false
        var previewBraceDepth = 0

        for (index, line) in lines.enumerated() {
            let trimmedLine = line.trimmingCharacters(in: .whitespaces)
            let lineNumber = index + 1

            // Track #if / #elseif / #else / #endif blocks
            if trimmedLine.hasPrefix("#if DEBUG") || trimmedLine.hasPrefix("#if compiler") {
                // Start of DEBUG or compiler-specific block (compiler is also debug-only)
                conditionalStack.append(true)
            } else if trimmedLine.hasPrefix("#if ") || trimmedLine.hasPrefix("#if(") {
                // Start of non-DEBUG conditional
                conditionalStack.append(false)
            } else if trimmedLine.hasPrefix("#elseif DEBUG") {
                // Switching to DEBUG branch
                if !conditionalStack.isEmpty {
                    conditionalStack[conditionalStack.count - 1] = true
                }
            } else if trimmedLine.hasPrefix("#elseif") || trimmedLine.hasPrefix("#else") {
                // Switching to non-DEBUG branch (inverse of previous)
                if !conditionalStack.isEmpty {
                    conditionalStack[conditionalStack.count - 1] = false
                }
            } else if trimmedLine.hasPrefix("#endif") {
                // End of conditional block
                if !conditionalStack.isEmpty {
                    conditionalStack.removeLast()
                }
            }

            // Track #Preview blocks (SwiftUI previews are debug-only)
            if trimmedLine.hasPrefix("#Preview") {
                inPreviewBlock = true
                previewBraceDepth = 0
            }

            // Track braces in preview block
            if inPreviewBlock {
                previewBraceDepth += trimmedLine.filter { $0 == "{" }.count
                previewBraceDepth -= trimmedLine.filter { $0 == "}" }.count
                if previewBraceDepth <= 0 && trimmedLine.contains("}") {
                    inPreviewBlock = false
                }
            }

            // Check if we're inside any DEBUG block
            let isInsideDebugBlock = conditionalStack.contains(true)

            // Skip if inside DEBUG or Preview block
            if isInsideDebugBlock || inPreviewBlock {
                continue
            }

            // Skip comments
            if trimmedLine.hasPrefix("//") || trimmedLine.hasPrefix("/*") || trimmedLine.hasPrefix("*") {
                continue
            }

            // Skip markdown files embedded in code (documentation)
            if fileURL.lastPathComponent.hasSuffix(".md") {
                continue
            }

            // Check for print() call
            if trimmedLine.contains("print(") {
                // Skip if it's in a comment on the same line
                if let printIndex = trimmedLine.range(of: "print("),
                   let commentIndex = trimmedLine.range(of: "//"),
                   commentIndex.lowerBound < printIndex.lowerBound {
                    continue
                }

                let fileName = fileURL.lastPathComponent
                violations.append("  \(fileName):\(lineNumber): \(trimmedLine)")
            }
        }

        return violations
    }

    // MARK: - EPIC 1.1: One Truth Runtime (No Legacy Models in Views)

    /// Gate test: Views should not use legacy WorldState, GameState, or direct state mutations
    /// Requirement: "Views/ не импортируют и не используют legacy модели"
    func testNoLegacyWorldStateUsageInViews() throws {
        // Get project root directory from compile-time path
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // Engine
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        let viewsDir = projectRoot.appendingPathComponent("Views")

        // Skip if Views directory doesn't exist
        guard FileManager.default.fileExists(atPath: viewsDir.path) else {
            XCTFail("GATE TEST FAILURE: Views directory not found at \(viewsDir.path)")
            return
        }

        // Legacy patterns that should NOT appear in Views (outside of comments/previews)
        let legacyPatterns = [
            "WorldState",           // Legacy world state model
            "GameState",            // Legacy game state model
            "legacyPlayer",         // Legacy player reference
            "legacyWorldState",     // Legacy world state reference
            "connectToLegacy"       // Legacy connection method
        ]

        var violations: [String] = []
        let swiftFiles = findSwiftFiles(in: viewsDir)

        for fileURL in swiftFiles {
            let fileViolations = try checkLegacyPatternsInFile(fileURL, patterns: legacyPatterns)
            violations.append(contentsOf: fileViolations)
        }

        // Report all violations
        if !violations.isEmpty {
            let message = """
            Found \(violations.count) legacy model usages in Views/:
            \(violations.joined(separator: "\n"))

            Views should only use TwilightGameEngine as the single source of truth.
            Remove legacy WorldState/GameState references and use engine properties instead.
            """
            XCTFail(message)
        }
    }

    /// Check a Swift file for legacy patterns not in comments or preview blocks
    private func checkLegacyPatternsInFile(_ fileURL: URL, patterns: [String]) throws -> [String] {
        let content = try String(contentsOf: fileURL, encoding: .utf8)
        let lines = content.components(separatedBy: .newlines)
        var violations: [String] = []

        // Track if we're inside a preview block or multiline comment
        var inPreviewBlock = false
        var previewBraceDepth = 0
        var inMultilineComment = false

        for (index, line) in lines.enumerated() {
            let trimmedLine = line.trimmingCharacters(in: .whitespaces)
            let lineNumber = index + 1

            // Track multiline comments
            if trimmedLine.contains("/*") {
                inMultilineComment = true
            }
            if trimmedLine.contains("*/") {
                inMultilineComment = false
                continue
            }
            if inMultilineComment {
                continue
            }

            // Track #Preview blocks
            if trimmedLine.hasPrefix("#Preview") || trimmedLine.contains("PreviewProvider") {
                inPreviewBlock = true
                previewBraceDepth = 0
            }

            // Track braces in preview block
            if inPreviewBlock {
                previewBraceDepth += trimmedLine.filter { $0 == "{" }.count
                previewBraceDepth -= trimmedLine.filter { $0 == "}" }.count
                if previewBraceDepth <= 0 && trimmedLine.contains("}") {
                    inPreviewBlock = false
                }
                continue  // Skip preview content
            }

            // Skip single-line comments
            if trimmedLine.hasPrefix("//") {
                continue
            }

            // Remove inline comments for pattern matching
            var lineToCheck = trimmedLine
            if let commentRange = lineToCheck.range(of: "//") {
                lineToCheck = String(lineToCheck[..<commentRange.lowerBound])
            }

            // Check for legacy patterns
            for pattern in patterns {
                if lineToCheck.contains(pattern) {
                    let fileName = fileURL.lastPathComponent
                    violations.append("  \(fileName):\(lineNumber): \(trimmedLine) [pattern: \(pattern)]")
                }
            }
        }

        return violations
    }

    // MARK: - EPIC 3.1: Stable IDs Everywhere

    /// Gate test: Save/Load uses stable definition IDs, not UUIDs
    /// Requirement: "Запрет UUID для контентных сущностей в Save/Load"
    func testSaveLoadUsesStableDefinitionIdsOnly() throws {
        // Get project root directory from compile-time path
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // Engine
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        let engineFile = projectRoot
            .appendingPathComponent(SourcePathResolver.engineBase + "/Core/TwilightGameEngine.swift")

        guard FileManager.default.fileExists(atPath: engineFile.path) else {
            XCTFail("GATE TEST FAILURE: TwilightGameEngine.swift not found at \(engineFile.path)")
            return
        }

        let content = try String(contentsOf: engineFile, encoding: .utf8)

        // Patterns that indicate UUID usage for content entity IDs (should use String definition IDs)
        let forbiddenPatterns = [
            "completedEventIds: Set<UUID>",      // Should be Set<String>
            "completedEventIds.map { $0.uuidString }",  // Should not need conversion
            "compactMap { UUID(uuidString:",    // Should not convert strings to UUIDs
            "eventDefinitionIdToUUID"           // Helper should be removed
        ]

        var violations: [String] = []
        let lines = content.components(separatedBy: .newlines)

        for (index, line) in lines.enumerated() {
            let trimmedLine = line.trimmingCharacters(in: .whitespaces)
            let lineNumber = index + 1

            // Skip comments
            if trimmedLine.hasPrefix("//") || trimmedLine.hasPrefix("/*") || trimmedLine.hasPrefix("*") {
                continue
            }

            for pattern in forbiddenPatterns {
                if line.contains(pattern) {
                    violations.append("  TwilightGameEngine.swift:\(lineNumber): \(trimmedLine) [pattern: \(pattern)]")
                }
            }
        }

        if !violations.isEmpty {
            let message = """
            Found \(violations.count) UUID usages for content entity IDs:
            \(violations.joined(separator: "\n"))

            Content entity IDs (events, quests, cards, heroes) should use stable String definition IDs,
            not generated UUIDs. This ensures save compatibility across sessions.
            """
            XCTFail(message)
        }

        // Additional verification: completedEventIds should be declared as Set<String>
        XCTAssertTrue(
            content.contains("completedEventIds: Set<String>"),
            "completedEventIds should be declared as Set<String>, not Set<UUID>"
        )

        // Verify EngineSave uses String IDs
        let saveFile = projectRoot.appendingPathComponent(SourcePathResolver.engineBase + "/Core/EngineSave.swift")
        if FileManager.default.fileExists(atPath: saveFile.path) {
            let saveContent = try String(contentsOf: saveFile, encoding: .utf8)
            XCTAssertTrue(
                saveContent.contains("completedEventIds: [String]"),
                "EngineSave.completedEventIds should be [String], not [UUID]"
            )
        }
    }

    // MARK: - A1: definitionId Non-Optional Gate Tests

    /// Gate test: definitionId must be non-optional in pack-driven entities (Audit A1)
    /// Requirement: "definitionId должен быть обязательным для всех pack-driven сущностей"
    func testDefinitionIdIsNonOptional() throws {
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // Engine
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        // Check EngineRegionState
        let engineFile = projectRoot.appendingPathComponent(SourcePathResolver.engineBase + "/Core/TwilightGameEngine.swift")
        guard FileManager.default.fileExists(atPath: engineFile.path) else {
            XCTFail("GATE TEST FAILURE: TwilightGameEngine.swift not found")
            return
        }

        let engineContent = try String(contentsOf: engineFile, encoding: .utf8)

        // EngineRegionState.id must be String (id IS the definitionId after UUID->String migration)
        XCTAssertTrue(
            engineContent.contains("public let id: String"),
            "EngineRegionState.id must be non-optional String (id IS definitionId)"
        )

        // Check Quest
        let modelsFile = projectRoot.appendingPathComponent(SourcePathResolver.engineBase + "/Models/ExplorationModels.swift")
        guard FileManager.default.fileExists(atPath: modelsFile.path) else {
            XCTFail("GATE TEST FAILURE: ExplorationModels.swift not found")
            return
        }

        let modelsContent = try String(contentsOf: modelsFile, encoding: .utf8)

        // Quest.id must be String (id IS the definitionId after UUID->String migration)
        XCTAssertTrue(
            modelsContent.contains("public let id: String"),
            "Quest.id must be non-optional String (id IS definitionId)"
        )
    }

    /// Gate test: All pack-driven entities have non-empty definitionId at runtime (Audit 1.4)
    func testDefinitionIdNeverNilForPackEntities() throws {
        let registry = ContentRegistry.shared
        XCTAssertFalse(registry.loadedPacks.isEmpty, "Content packs must be loaded")

        // Regions
        for (id, region) in registry.loadedPacks.values.flatMap({ $0.regions }) {
            XCTAssertFalse(id.isEmpty, "Region definitionId must not be empty")
            XCTAssertEqual(id, region.id, "Region key must match id")
        }

        // Events
        for (id, event) in registry.loadedPacks.values.flatMap({ $0.events }) {
            XCTAssertFalse(id.isEmpty, "Event definitionId must not be empty")
            XCTAssertEqual(id, event.id, "Event key must match id")
            for choice in event.choices {
                XCTAssertFalse(choice.id.isEmpty, "EventChoice.id must not be empty (event: \(id))")
            }
        }

        // Quests
        for (id, quest) in registry.loadedPacks.values.flatMap({ $0.quests }) {
            XCTAssertFalse(id.isEmpty, "Quest definitionId must not be empty")
            XCTAssertEqual(id, quest.id, "Quest key must match id")
        }

        // Heroes
        for (id, hero) in registry.loadedPacks.values.flatMap({ $0.heroes }) {
            XCTAssertFalse(id.isEmpty, "Hero definitionId must not be empty")
            XCTAssertEqual(id, hero.id, "Hero key must match id")
        }

        // Enemies
        for (id, enemy) in registry.loadedPacks.values.flatMap({ $0.enemies }) {
            XCTAssertFalse(id.isEmpty, "Enemy definitionId must not be empty")
            XCTAssertEqual(id, enemy.id, "Enemy key must match id")
        }

        // Cards
        for card in registry.getAllCards() {
            XCTAssertFalse(card.id.isEmpty, "Card definitionId must not be empty")
        }
    }

    /// Gate test: No UUID fallback in save serialization (Audit A1)
    /// Requirement: "Полностью удалить fallback uuidString из сейвов"
    func testNoUuidFallbackInSave() throws {
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()
            .deletingLastPathComponent()
            .deletingLastPathComponent()

        let saveFile = projectRoot.appendingPathComponent(SourcePathResolver.engineBase + "/Core/EngineSave.swift")
        guard FileManager.default.fileExists(atPath: saveFile.path) else {
            XCTFail("GATE TEST FAILURE: EngineSave.swift not found")
            return
        }

        let content = try String(contentsOf: saveFile, encoding: .utf8)

        // No UUID fallback patterns allowed
        let forbiddenPatterns = [
            "?? region.id.uuidString",
            "?? anchor.id.uuidString",
            "?? quest.id.uuidString",
            ".uuidString // fallback"
        ]

        var violations: [String] = []
        let lines = content.components(separatedBy: .newlines)

        for (index, line) in lines.enumerated() {
            for pattern in forbiddenPatterns {
                if line.contains(pattern) {
                    violations.append("Line \(index + 1): \(line.trimmingCharacters(in: .whitespaces))")
                }
            }
        }

        if !violations.isEmpty {
            XCTFail("""
                Found UUID fallback patterns in EngineSave.swift (Audit A1 violation):
                \(violations.joined(separator: "\n"))

                definitionId must be required, no UUID fallback allowed.
                """)
        }
    }

    // MARK: - A2: RNG State Persistence Gate Tests

    /// Gate test: RNG state is saved and restored (Audit A2)
    /// Requirement: "Сейв обязан хранить RNG state для детерминизма после загрузки"
    func testSaveLoadRestoresRngState() throws {
        // Set a known RNG state
        let testSeed: UInt64 = 12345
        WorldRNG.shared.setSeed(testSeed)

        // Advance RNG a few times
        _ = WorldRNG.shared.next()
        _ = WorldRNG.shared.next()
        _ = WorldRNG.shared.next()

        let stateBeforeSave = WorldRNG.shared.currentState()

        // Generate some random values to verify
        let value1 = WorldRNG.shared.next()
        let value2 = WorldRNG.shared.next()

        // Restore state to before we generated values
        WorldRNG.shared.restoreState(stateBeforeSave)

        // Verify same values are generated
        let restored1 = WorldRNG.shared.next()
        let restored2 = WorldRNG.shared.next()

        XCTAssertEqual(value1, restored1, "RNG should produce same value after state restore")
        XCTAssertEqual(value2, restored2, "RNG should produce same sequence after state restore")
    }

    /// Gate test: EngineSave includes rngState field (Audit A2)
    func testEngineSaveHasRngStateField() throws {
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()
            .deletingLastPathComponent()
            .deletingLastPathComponent()

        let saveFile = projectRoot.appendingPathComponent(SourcePathResolver.engineBase + "/Core/EngineSave.swift")
        guard FileManager.default.fileExists(atPath: saveFile.path) else {
            XCTFail("GATE TEST FAILURE: EngineSave.swift not found")
            return
        }

        let content = try String(contentsOf: saveFile, encoding: .utf8)

        // EngineSave must have rngState field
        XCTAssertTrue(
            content.contains("public let rngState: UInt64"),
            "EngineSave must have rngState field for deterministic save/load (Audit 1.5)"
        )
    }

    /// Gate test: createSave saves RNG state (Audit A2)
    func testCreateSaveSavesRngState() throws {
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()
            .deletingLastPathComponent()
            .deletingLastPathComponent()

        let engineFile = projectRoot.appendingPathComponent(SourcePathResolver.engineBase + "/Core/TwilightGameEngine.swift")
        guard FileManager.default.fileExists(atPath: engineFile.path) else {
            XCTFail("GATE TEST FAILURE: TwilightGameEngine.swift not found")
            return
        }

        let content = try String(contentsOf: engineFile, encoding: .utf8)

        // createSave must include RNG state
        XCTAssertTrue(
            content.contains("rngState: WorldRNG.shared.currentState()"),
            "createSave must save WorldRNG.shared.currentState() (Audit A2)"
        )

        // Must not have "rngSeed: nil" pattern anymore
        XCTAssertFalse(
            content.contains("rngSeed: nil"),
            "createSave must not set rngSeed to nil (Audit A2)"
        )
    }

    // MARK: - Audit 4.2: Pack Compiler Round-Trip

    /// Gate test: .pack load → re-write → re-load round-trip (Audit 4.2)
    func testPackCompilerRoundTrip() throws {
        // Load the compiled .pack via registry (already loaded)
        let registry = ContentRegistry.shared
        XCTAssertFalse(registry.loadedPacks.isEmpty, "Packs must be loaded")

        guard let pack = registry.loadedPacks.values.first else {
            XCTFail("GATE TEST FAILURE: No loaded packs available")
            return
        }

        let originalRegionCount = pack.regions.count
        let originalEventCount = pack.events.count
        let packId = pack.manifest.packId

        // Write to temp .pack file
        let tempDir = FileManager.default.temporaryDirectory
            .appendingPathComponent("pack_roundtrip_\(ProcessInfo.processInfo.globallyUniqueString)")
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        defer { try? FileManager.default.removeItem(at: tempDir) }

        let packFile = tempDir.appendingPathComponent("roundtrip.pack")
        try BinaryPackWriter.compile(pack, to: packFile)

        // Verify .pack file exists and is non-empty
        let attrs = try FileManager.default.attributesOfItem(atPath: packFile.path)
        let fileSize = attrs[.size] as? Int64 ?? 0
        XCTAssertGreaterThan(fileSize, 0, ".pack file must not be empty")

        // Re-load .pack
        let reloaded = try BinaryPackReader.loadContent(from: packFile)

        // Validate round-trip: content is intact
        XCTAssertEqual(reloaded.manifest.packId, packId, "Pack ID must survive round-trip")
        XCTAssertEqual(reloaded.regions.count, originalRegionCount, "Region count must survive round-trip")
        XCTAssertEqual(reloaded.events.count, originalEventCount, "Event count must survive round-trip")
    }

    // MARK: - F1: No Legacy Initialization in Views

    /// Gate test: Views must not contain legacy initialization patterns (Audit F1)
    /// Requirement: "В WorldMapView отсутствуют legacy init/ветки/комментарии"
    ///
    /// Legacy patterns to detect:
    /// - "legacy init" / "legacy initialization" comments
    /// - "shared between legacy" comments
    /// - Legacy adapter references
    ///
    /// Positive patterns to allow:
    /// - "no legacy sync needed" (indicates legacy was removed)
    func testNoLegacyInitializationInViews() throws {
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // Engine
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        let viewsDir = projectRoot.appendingPathComponent("Views")

        guard FileManager.default.fileExists(atPath: viewsDir.path) else {
            XCTFail("GATE TEST FAILURE: Views directory not found")
            return
        }

        // Legacy patterns that indicate old architecture (should be removed)
        let forbiddenPatterns = [
            "legacy init",
            "legacy initialization",
            "shared between legacy",
            "LegacyAdapter",
            "legacyInit",
            "connectToLegacy"
        ]

        // Positive patterns that are allowed (indicate legacy was removed)
        let allowedPatterns = [
            "no legacy sync needed",
            "no legacy needed",
            "legacy removed"
        ]

        var violations: [(file: String, line: Int, content: String, pattern: String)] = []
        let swiftFiles = findSwiftFiles(in: viewsDir)

        for fileURL in swiftFiles {
            let content = try String(contentsOf: fileURL, encoding: .utf8)
            let lines = content.components(separatedBy: .newlines)
            let fileName = fileURL.lastPathComponent

            for (index, line) in lines.enumerated() {
                let lowerLine = line.lowercased()
                let lineNumber = index + 1

                // Check each forbidden pattern
                for pattern in forbiddenPatterns {
                    if lowerLine.contains(pattern.lowercased()) {
                        // Check if this line also contains an allowed pattern
                        let hasAllowedPattern = allowedPatterns.contains { allowed in
                            lowerLine.contains(allowed.lowercased())
                        }

                        if !hasAllowedPattern {
                            violations.append((
                                file: fileName,
                                line: lineNumber,
                                content: line.trimmingCharacters(in: .whitespaces),
                                pattern: pattern
                            ))
                        }
                    }
                }
            }
        }

        if !violations.isEmpty {
            let message = violations.map { "\($0.file):\($0.line): \($0.content) [pattern: \($0.pattern)]" }
                .joined(separator: "\n")
            XCTFail("""
                GATE TEST FAILURE: Legacy initialization patterns found in Views/ (Audit F1)

                Views should use Engine-First architecture only.
                Remove legacy initialization, adapters, and related comments.

                Violations:
                \(message)
                """)
        }
    }

    /// Audit 2.1 alias: exact name from acceptance criteria
    func testNoLegacyInitializationCommentsInWorldMapView() throws {
        try testNoLegacyInitializationInViews()
    }

    // MARK: - F2: AssetRegistry Safety (No Direct UIImage)

    /// Gate test: Views and ViewModels must not use UIImage(named:) directly (Audit F2)
    /// Requirement: "Запрещены прямые UIImage(named:) в UI и VM — только через AssetRegistry"
    ///
    /// Direct UIImage(named:) bypasses the fallback system and can show:
    /// - Pink squares (missing image)
    /// - Empty images
    /// - Nil crashes
    ///
    /// All image loading must go through AssetRegistry which provides SF Symbol fallback.
    /// Audit 2.2 alias: exact name from acceptance criteria
    func testNoDirectImageNamedInViews() throws {
        try testNoDirectUIImageNamedInViewsAndViewModels()
    }

    func testNoDirectUIImageNamedInViewsAndViewModels() throws {
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // Engine
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        // Directories to scan
        let dirsToScan = ["Views", "ViewModels"]

        // Forbidden patterns (direct UIImage/NSImage/SwiftUI Image loading)
        let forbiddenPatterns = [
            "UIImage(named:",
            "NSImage(named:",
            "Image(uiImage: UIImage(named:",
            "Image(nsImage: NSImage(named:"
        ]

        // Forbidden SwiftUI pattern: Image("...") but NOT Image(systemName:
        let swiftUIImagePattern = "Image(\""

        // Allowed files (AssetRegistry itself needs to use UIImage)
        let allowedFiles = [
            "AssetRegistry.swift",
            "AssetValidator.swift"
        ]

        var violations: [(file: String, line: Int, content: String)] = []
        var dirsFound = 0

        for dirName in dirsToScan {
            let dirURL = projectRoot.appendingPathComponent(dirName)

            guard FileManager.default.fileExists(atPath: dirURL.path) else {
                continue
            }
            dirsFound += 1

            let swiftFiles = findSwiftFiles(in: dirURL)

            for fileURL in swiftFiles {
                let fileName = fileURL.lastPathComponent

                // Skip allowed files
                if allowedFiles.contains(fileName) {
                    continue
                }

                let content = try String(contentsOf: fileURL, encoding: .utf8)
                let lines = content.components(separatedBy: .newlines)

                for (index, line) in lines.enumerated() {
                    let trimmedLine = line.trimmingCharacters(in: .whitespaces)
                    let lineNumber = index + 1

                    // Skip comments
                    if trimmedLine.hasPrefix("//") || trimmedLine.hasPrefix("/*") || trimmedLine.hasPrefix("*") {
                        continue
                    }

                    // Check for forbidden patterns
                    for pattern in forbiddenPatterns {
                        if line.contains(pattern) {
                            violations.append((
                                file: fileName,
                                line: lineNumber,
                                content: trimmedLine
                            ))
                        }
                    }

                    // Check for SwiftUI Image("...") — but not Image(systemName:
                    if line.contains(swiftUIImagePattern) && !line.contains("Image(systemName:") {
                        violations.append((
                            file: fileName,
                            line: lineNumber,
                            content: trimmedLine
                        ))
                    }
                }
            }
        }

        XCTAssertGreaterThan(dirsFound, 0, "No view directories found — repo structure may have changed")

        if !violations.isEmpty {
            let message = violations.map { "\($0.file):\($0.line): \($0.content)" }
                .joined(separator: "\n")
            XCTFail("""
                GATE TEST FAILURE: Direct Image(named:)/UIImage(named:) found in Views/ViewModels (Audit 2.2)

                Use AssetRegistry instead for automatic fallback support:
                - AssetRegistry.image(for: .region("forest"))
                - AssetRegistry.heroPortrait("warrior")
                - AssetRegistry.cardArt("fireball")

                Violations:
                \(message)
                """)
        }
    }

    // MARK: - B1.2: Static Scan — No Game-Specific IDs in Engine Source

    /// Gate test: Engine source must not contain hardcoded game-specific region/entity IDs (Audit 1.2)
    /// Requirement: "Engine не должен содержать game-specific IDs/словари конкретной игры"
    func testEngineSourceContainsNoGameSpecificIds() throws {
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // GateTests
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        let engineBase = projectRoot.appendingPathComponent(SourcePathResolver.engineBase)

        // Build forbidden literals dynamically from loaded content packs.
        // Any content-defined ID (region, event, quest, hero, enemy) should NOT
        // appear as a string literal in Engine source code.
        TestContentLoader.loadContentPacksIfNeeded()
        var contentIds: Set<String> = []
        for pack in ContentRegistry.shared.loadedPacks.values {
            contentIds.formUnion(pack.regions.keys)
            contentIds.formUnion(pack.events.keys)
            contentIds.formUnion(pack.quests.keys)
            contentIds.formUnion(pack.heroes.keys)
            contentIds.formUnion(pack.enemies.keys)
        }

        // Exclude engine-level enum rawValues that coincide with content IDs
        // (e.g., "breach" is both a region ID and a RegionState enum value)
        var engineTerms: Set<String> = []
        // RegionState rawValues
        for state in RegionState.allCases { engineTerms.insert(state.rawValue) }
        // RegionStateType rawValues
        for state in RegionStateType.allCases { engineTerms.insert(state.rawValue) }
        // Generic terms used by engine code (defaults, error messages)
        engineTerms.insert("unknown")
        engineTerms.insert("test")
        engineTerms.insert("rest")
        contentIds.subtract(engineTerms)

        // Format as quoted string literals for source scanning
        let forbiddenLiterals = contentIds.map { "\"\($0)\"" }

        // Allowed contexts: files that define type enums with rawValue strings
        let allowedFiles = [
            "ExplorationModels.swift"  // RegionType enum rawValues
        ]

        var violations: [String] = []

        // Scan all Swift files recursively under engine source (no hardcoded subdirectory list)
        let swiftFiles = findSwiftFiles(in: engineBase)

        for fileURL in swiftFiles {
            let fileName = fileURL.lastPathComponent
            if allowedFiles.contains(fileName) { continue }

            let content = try String(contentsOf: fileURL, encoding: .utf8)
            let lines = content.components(separatedBy: .newlines)

            for (index, line) in lines.enumerated() {
                let trimmed = line.trimmingCharacters(in: .whitespaces)

                // Skip comments
                if trimmed.hasPrefix("//") || trimmed.hasPrefix("/*") || trimmed.hasPrefix("*") {
                    continue
                }

                for literal in forbiddenLiterals {
                    if line.contains(literal) {
                        violations.append("  \(fileName):\(index + 1): \(trimmed) [literal: \(literal)]")
                    }
                }
            }
        }

        if !violations.isEmpty {
            XCTFail("""
                GATE TEST FAILURE: Game-specific IDs found in Engine source (Audit 1.2)

                Engine must not contain hardcoded game-specific strings.
                All IDs must come from pack manifests/definitions.

                Violations:
                \(violations.joined(separator: "\n"))
                """)
        }
    }

    // MARK: - Runtime must not use PackLoader (JSON is authoring-only)

    /// Gate test: ContentRegistry and ContentManager must NOT reference PackLoader.
    /// Runtime loads only binary .pack files via BinaryPackReader.
    func testRuntimeDoesNotUsePackLoader() throws {
        let projectRoot = SourcePathResolver.projectRoot
        let runtimeFiles = [
            "ContentPacks/ContentRegistry.swift",
            "ContentPacks/ContentManager.swift"
        ]

        var filesFound = 0
        for file in runtimeFiles {
            let filePath = projectRoot.appendingPathComponent(SourcePathResolver.engineBase + "/" + file)
            guard FileManager.default.fileExists(atPath: filePath.path) else { continue }
            filesFound += 1
            let content = try String(contentsOf: filePath, encoding: .utf8)
            XCTAssertFalse(
                content.contains("PackLoader"),
                "\(file) must not use PackLoader — runtime uses BinaryPackReader only"
            )
        }
        XCTAssertGreaterThan(filesFound, 0, "No runtime files found — repo structure may have changed")
    }

    // MARK: - C1: No XCTSkip in ANY Tests

    /// Gate test: ALL tests must not use XCTSkip (Audit C1 / v2.1)
    /// Requirement: "Gate tests должны падать, а не скипаться"
    /// Scope expanded to ALL test directories (v2.1 audit requirement)
    ///
    /// If a test can't verify something, it must XCTFail, not XCTSkip.
    /// XCTSkip creates "false green" - CI passes but nothing was verified.
    func testNoXCTSkipInAnyTests() throws {
        let testFile = URL(fileURLWithPath: #filePath)
        let projectRoot = testFile
            .deletingLastPathComponent()  // GateTests
            .deletingLastPathComponent()  // CardSampleGameTests
            .deletingLastPathComponent()  // Project root

        // Scan ALL test directories (v2.1: expanded from GateTests only)
        let testDirs = [
            projectRoot.appendingPathComponent("CardSampleGameTests"),
            projectRoot.appendingPathComponent("Packages/TwilightEngine/Tests/TwilightEngineTests") // Test dir, not engine source
        ]

        var violations: [(file: String, line: Int, content: String)] = []
        var dirsFound = 0

        for testDir in testDirs {
            guard FileManager.default.fileExists(atPath: testDir.path) else { continue }
            dirsFound += 1

            let fileManager = FileManager.default
            guard let enumerator = fileManager.enumerator(
                at: testDir,
                includingPropertiesForKeys: [.isRegularFileKey],
                options: [.skipsHiddenFiles]
            ) else { continue }

            for case let fileURL as URL in enumerator {
                guard fileURL.pathExtension == "swift" else { continue }

                let content = try String(contentsOf: fileURL, encoding: .utf8)
                let lines = content.components(separatedBy: .newlines)

                for (index, line) in lines.enumerated() {
                    let trimmed = line.trimmingCharacters(in: .whitespaces)

                    // Skip comments
                    if trimmed.hasPrefix("//") || trimmed.hasPrefix("/*") || trimmed.hasPrefix("*") {
                        continue
                    }

                    // Skip string literals containing "XCTSkip" (e.g. in this very test's detection logic)
                    if trimmed.contains("\"XCTSkip") || trimmed.contains("XCTSkip\"") {
                        continue
                    }

                    // Match actual XCTSkip/XCTSkipIf calls
                    if line.contains("XCTSkip(") || line.contains("XCTSkipIf(") || line.contains("XCTSkipUnless(") {
                        let fileName = fileURL.lastPathComponent
                        violations.append((file: fileName, line: index + 1, content: trimmed))
                    }
                }
            }
        }

        XCTAssertGreaterThan(dirsFound, 0, "No test directories found — repo structure may have changed")

        if !violations.isEmpty {
            let message = violations.map { "\($0.file):\($0.line): \($0.content)" }.joined(separator: "\n")
            XCTFail("""
                GATE TEST FAILURE: XCTSkip found in tests (Audit C1 v2.1)

                ALL tests must use XCTFail, not XCTSkip. XCTSkip creates "false green" CI results.

                Violations:
                \(message)

                Fix: Replace XCTSkip/XCTSkipIf with XCTFail and return.
                """)
        }
    }
}


// ==========================================
// FILE: CardSampleGameTests/GateTests/CodeHygieneTests.swift
// ==========================================

import XCTest
@testable import CardSampleGame

/// Audit tests to ensure Code Hygiene compliance (Epic 10)
/// These tests fail if:
/// - Public API methods lack `///` doc comments (10.1)
/// - Files contain too many types or exceed line limits (10.2)
final class CodeHygieneTests: XCTestCase {

    // MARK: - Configuration

    /// Maximum lines per file before warning (for NEW files)
    /// Legacy files are grandfathered at their current size
    private let maxLinesPerFile = 600

    /// Maximum public types per file (for NEW files)
    /// Related small types (enums, helper structs) can stay together
    private let maxTypesPerFile = 5

    /// Files that are exempt from limits (legacy, grandfathered)
    /// These files existed before Epic 10 enforcement
    /// New files MUST follow the limits
    private let legacyFiles: Set<String> = [
        // Large files (>600 lines)
        "ExplorationModels.swift",      // 872 lines - exploration domain models
        "TwilightGameEngine.swift",     // 2247 lines - main engine
        "ContentRegistry.swift",        // 844 lines - registry
        "JSONContentProvider.swift",    // 969 lines - JSON loading
        // PackValidator.swift moved to PackAuthoring module
        // Files with many related types (>5 types)
        "EngineProtocols.swift",        // 30+ protocols - all engine contracts
        "CodeContentProvider.swift",    // JSON loading types
        "EventDefinition.swift",        // Event system types
        "HeroAbility.swift",            // Ability system types
        "PackTypes.swift",              // Pack-related types
        "BalanceConfiguration.swift",   // Balance config types (intentionally grouped)
        "CardDefinition.swift",         // Card system types
        "CardType.swift",               // Card enums
        "ContentManager.swift",         // Content management types (cohesive hot-reload API)
        "GameDefinition.swift",         // Game definition types
        "QuestDefinition.swift",        // Quest system types
        "AbilityRegistry.swift",        // Ability loading types
        "HeroRegistry.swift",           // Hero loading types
        "HeroDefinition.swift",         // Hero system types
        "CardRegistry.swift",           // Card loading types
        "EngineSave.swift",             // Save system types
        "TimeEngine.swift",             // Time system types
        "TwilightGameAction.swift",     // Action types
        "PressureEngine.swift",         // Pressure system types
        "ContentProvider.swift",        // Provider types
        "MiniGameChallengeDefinition.swift", // MiniGame types
        "EnemyDefinition.swift",        // Enemy types
        "EngineTypes.swift",            // Runtime types
    ]

    /// Directories to audit in TwilightEngine
    private let engineDirectories = [
        "Cards",
        "ContentPacks",
        "Heroes",
        "Core",
        "Data",
        "Models",
        "Runtime"
    ]

    /// Critical public API files that MUST have doc comments on public methods
    /// These are the main entry points for engine consumers
    private let criticalAPIFiles = [
        "CardRegistry.swift",
        "HeroRegistry.swift",
        "ContentRegistry.swift",
        "PackManifest.swift"
    ]

    /// Methods in critical API files that are allowed without docs (internal helpers)
    private let exemptMethods: Set<String> = [
        "loadHeroes()",     // Protocol implementation in data sources
        "loadCards()",      // Protocol implementation in data sources
        "toStandard()",     // Conversion helper
        "toHeroStats()",    // Conversion helper
    ]

    // MARK: - Path Resolution

    private var engineRoot: URL? {
        guard let root = projectRoot else { return nil }
        return root
            .appendingPathComponent("Packages")
            .appendingPathComponent("TwilightEngine")
            .appendingPathComponent("Sources")
            .appendingPathComponent("TwilightEngine")
    }

    private var projectRoot: URL? {
        // Try SRCROOT from scheme environment
        if let srcRoot = ProcessInfo.processInfo.environment["SRCROOT"] {
            return URL(fileURLWithPath: srcRoot)
        }

        // Fallback: Navigate up from test file location
        let thisFile = #file
        var url = URL(fileURLWithPath: thisFile)
        // Go up: Engine -> CardSampleGameTests -> Project Root
        for _ in 0..<3 {
            url = url.deletingLastPathComponent()
        }

        // Verify we found the right directory
        let packagesPath = url.appendingPathComponent("Packages")
        if FileManager.default.fileExists(atPath: packagesPath.path) {
            return url
        }

        return nil
    }

    // MARK: - 10.1 Documentation Tests

    func testPublicMethodsHaveDocComments() throws {
        guard let engine = engineRoot else {
            XCTFail("GATE TEST FAILURE: Could not determine engine root path"); return
        }

        var violations: [(file: String, method: String)] = []

        for apiFile in criticalAPIFiles {
            let filePath = findFile(named: apiFile, in: engine)
            guard let path = filePath else {
                XCTFail("Critical API file not found: \(apiFile)")
                continue
            }

            let content = try String(contentsOfFile: path, encoding: .utf8)
            let undocumentedMethods = findUndocumentedPublicMethods(in: content)

            for method in undocumentedMethods {
                // Skip exempt methods (internal helpers, protocol implementations)
                if exemptMethods.contains(method) {
                    continue
                }
                violations.append((apiFile, method))
            }
        }

        if !violations.isEmpty {
            let message = violations.map { "  \($0.file): \($0.method)" }.joined(separator: "\n")
            XCTFail("""
                Found \(violations.count) public methods without /// doc comments:
                \(message)

                Add documentation like:
                /// Brief description of what method does.
                /// - Parameter name: Description of parameter.
                /// - Returns: Description of return value.
                """)
        }
    }

    func testPublicPropertiesHaveDocComments() throws {
        guard let engine = engineRoot else {
            XCTFail("GATE TEST FAILURE: Could not determine engine root path"); return
        }

        var violations: [(file: String, property: String)] = []

        // Only check CardRegistry and HeroRegistry for now
        // ContentRegistry/PackLoader/PackManifest have many internal properties
        let strictPropertyFiles = ["CardRegistry.swift", "HeroRegistry.swift"]

        for apiFile in strictPropertyFiles {
            let filePath = findFile(named: apiFile, in: engine)
            guard let path = filePath else { continue }

            let content = try String(contentsOfFile: path, encoding: .utf8)
            let undocumentedProps = findUndocumentedPublicProperties(in: content)

            for prop in undocumentedProps {
                // Skip common property names that are self-documenting
                if ["id", "name", "shared", "fileURL"].contains(prop) {
                    continue
                }
                violations.append((apiFile, prop))
            }
        }

        if !violations.isEmpty {
            let message = violations.map { "  \($0.file): \($0.property)" }.joined(separator: "\n")
            XCTFail("""
                Found \(violations.count) public properties without /// doc comments:
                \(message)

                Add documentation like:
                /// Brief description of property.
                public let/var propertyName: Type
                """)
        }
    }

    // MARK: - 10.2 File Organization Tests

    func testFilesDoNotExceedLineLimit() throws {
        guard let engine = engineRoot else {
            XCTFail("GATE TEST FAILURE: Could not determine engine root path"); return
        }

        var violations: [(file: String, lines: Int)] = []

        for dir in engineDirectories {
            let dirPath = engine.appendingPathComponent(dir)
            let files = findSwiftFiles(in: dirPath)

            for filePath in files {
                let fileName = URL(fileURLWithPath: filePath).lastPathComponent

                // Skip legacy files (grandfathered)
                if legacyFiles.contains(fileName) {
                    continue
                }

                let content = try String(contentsOfFile: filePath, encoding: .utf8)
                let lineCount = content.components(separatedBy: .newlines).count

                if lineCount > maxLinesPerFile {
                    violations.append((fileName, lineCount))
                }
            }
        }

        if !violations.isEmpty {
            let message = violations.map { "  \($0.file): \($0.lines) lines (max \(maxLinesPerFile))" }.joined(separator: "\n")
            XCTFail("""
                Found \(violations.count) NEW files exceeding line limit:
                \(message)

                Consider splitting into smaller files:
                - Extract related types into separate files
                - Move extensions to Type+Extension.swift files
                - Group by functionality, not just proximity

                If this is intentional, add the file to legacyFiles in CodeHygieneTests.swift
                """)
        }
    }

    func testFilesDoNotHaveTooManyTypes() throws {
        guard let engine = engineRoot else {
            XCTFail("GATE TEST FAILURE: Could not determine engine root path"); return
        }

        var violations: [(file: String, types: [String])] = []

        for dir in engineDirectories {
            let dirPath = engine.appendingPathComponent(dir)
            let files = findSwiftFiles(in: dirPath)

            for filePath in files {
                let fileName = URL(fileURLWithPath: filePath).lastPathComponent

                // Skip legacy files (grandfathered)
                if legacyFiles.contains(fileName) {
                    continue
                }

                let content = try String(contentsOfFile: filePath, encoding: .utf8)
                let publicTypes = findPublicTypeDeclarations(in: content)

                if publicTypes.count > maxTypesPerFile {
                    violations.append((fileName, publicTypes))
                }
            }
        }

        if !violations.isEmpty {
            let message = violations.map { file, types in
                "  \(file): \(types.count) types [\(types.prefix(5).joined(separator: ", "))\(types.count > 5 ? "..." : "")]"
            }.joined(separator: "\n")
            XCTFail("""
                Found \(violations.count) NEW files with too many public types (max \(maxTypesPerFile)):
                \(message)

                Follow "1 file = 1 main type" principle:
                - Primary type: MyType.swift
                - Extensions: MyType+Feature.swift
                - Related small types can stay together if cohesive

                If this is intentional, add the file to legacyFiles in CodeHygieneTests.swift
                """)
        }
    }

    // MARK: - Helpers

    private func findFile(named name: String, in directory: URL) -> String? {
        guard let enumerator = FileManager.default.enumerator(
            at: directory,
            includingPropertiesForKeys: [.isRegularFileKey],
            options: [.skipsHiddenFiles]
        ) else { return nil }

        for case let fileURL as URL in enumerator {
            if fileURL.lastPathComponent == name {
                return fileURL.path
            }
        }
        return nil
    }

    private func findSwiftFiles(in directory: URL) -> [String] {
        var files: [String] = []

        guard let enumerator = FileManager.default.enumerator(
            at: directory,
            includingPropertiesForKeys: [.isRegularFileKey],
            options: [.skipsHiddenFiles]
        ) else { return files }

        for case let fileURL as URL in enumerator {
            if fileURL.pathExtension == "swift" {
                files.append(fileURL.path)
            }
        }

        return files
    }

    /// Find public methods without preceding /// doc comment
    private func findUndocumentedPublicMethods(in content: String) -> [String] {
        var undocumented: [String] = []
        let lines = content.components(separatedBy: .newlines)

        // Pattern for public func/method declarations
        let methodPattern = #"^\s*public\s+(static\s+)?func\s+(\w+)"#
        let methodRegex = try? NSRegularExpression(pattern: methodPattern)

        // Attributes that can appear between doc comment and declaration
        let attributePattern = #"^\s*@\w+"#

        for (index, line) in lines.enumerated() {
            guard let regex = methodRegex,
                  let match = regex.firstMatch(in: line, range: NSRange(line.startIndex..., in: line)) else {
                continue
            }

            // Extract method name
            if let nameRange = Range(match.range(at: 2), in: line) {
                let methodName = String(line[nameRange])

                // Check if previous non-empty, non-attribute line is a doc comment
                var prevIndex = index - 1
                var foundDocComment = false

                while prevIndex >= 0 {
                    let prevLine = lines[prevIndex].trimmingCharacters(in: .whitespaces)
                    if prevLine.isEmpty {
                        prevIndex -= 1
                        continue
                    }
                    // Skip Swift attributes (@discardableResult, @MainActor, etc.)
                    if prevLine.range(of: attributePattern, options: .regularExpression) != nil {
                        prevIndex -= 1
                        continue
                    }
                    // Check for doc comment
                    if prevLine.hasPrefix("///") || prevLine.hasPrefix("*/") {
                        foundDocComment = true
                    }
                    break
                }

                if !foundDocComment {
                    undocumented.append(methodName + "()")
                }
            }
        }

        return undocumented
    }

    /// Find public properties without preceding /// doc comment
    private func findUndocumentedPublicProperties(in content: String) -> [String] {
        var undocumented: [String] = []
        let lines = content.components(separatedBy: .newlines)

        // Pattern for public let/var declarations (not in function bodies)
        let propPattern = #"^\s*public\s+(static\s+)?(let|var)\s+(\w+)"#
        let propRegex = try? NSRegularExpression(pattern: propPattern)

        // Attributes that can appear between doc comment and declaration
        let attributePattern = #"^\s*@\w+"#

        for (index, line) in lines.enumerated() {
            guard let regex = propRegex,
                  let match = regex.firstMatch(in: line, range: NSRange(line.startIndex..., in: line)) else {
                continue
            }

            // Skip computed properties (they have doc comments on the var line usually)
            if line.contains("{") && line.contains("return") {
                continue
            }

            // Extract property name
            if let nameRange = Range(match.range(at: 3), in: line) {
                let propName = String(line[nameRange])

                // Check if previous non-empty, non-attribute line is a doc comment
                var prevIndex = index - 1
                var foundDocComment = false

                while prevIndex >= 0 {
                    let prevLine = lines[prevIndex].trimmingCharacters(in: .whitespaces)
                    if prevLine.isEmpty {
                        prevIndex -= 1
                        continue
                    }
                    // Skip Swift attributes
                    if prevLine.range(of: attributePattern, options: .regularExpression) != nil {
                        prevIndex -= 1
                        continue
                    }
                    // Check for doc comment
                    if prevLine.hasPrefix("///") || prevLine.hasPrefix("*/") {
                        foundDocComment = true
                    }
                    break
                }

                if !foundDocComment {
                    undocumented.append(propName)
                }
            }
        }

        return undocumented
    }

    /// Find public type declarations (class, struct, enum, protocol)
    private func findPublicTypeDeclarations(in content: String) -> [String] {
        var types: [String] = []
        let lines = content.components(separatedBy: .newlines)

        // Pattern for public type declarations
        let typePattern = #"^\s*public\s+(final\s+)?(class|struct|enum|protocol|actor)\s+(\w+)"#
        let typeRegex = try? NSRegularExpression(pattern: typePattern)

        for line in lines {
            guard let regex = typeRegex,
                  let match = regex.firstMatch(in: line, range: NSRange(line.startIndex..., in: line)) else {
                continue
            }

            if let nameRange = Range(match.range(at: 3), in: line) {
                types.append(String(line[nameRange]))
            }
        }

        return types
    }
}


// ==========================================
// FILE: CardSampleGameTests/GateTests/ConditionValidatorTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Tests for condition validation (Audit G1 requirement).
/// Ensures all conditions in packs use known, valid types.
///
/// Architecture note: This engine uses typed enums for conditions,
/// not string expressions. This provides compile-time safety against typos
/// like "WorldResonanse" - they simply won't compile or parse.
final class ConditionValidatorTests: XCTestCase {

    // MARK: - Whitelist Tests

    func testValidAbilityConditionTypesExist() throws {
        // Verify the whitelist is not empty
        let types = ConditionValidator.allValidConditionTypes()
        XCTAssertFalse(types.isEmpty, "Should have valid condition types")

        // Verify known conditions are in the list
        XCTAssertTrue(types.contains("hpBelowPercent"), "hpBelowPercent should be valid")
        XCTAssertTrue(types.contains("targetFullHP"), "targetFullHP should be valid")
        XCTAssertTrue(types.contains("firstAttack"), "firstAttack should be valid")
    }

    func testValidAbilityTriggersExist() throws {
        let triggers = ConditionValidator.allValidTriggers()
        XCTAssertFalse(triggers.isEmpty, "Should have valid triggers")

        // Verify known triggers
        XCTAssertTrue(triggers.contains("onAttack"), "onAttack should be valid")
        XCTAssertTrue(triggers.contains("turnStart"), "turnStart should be valid")
        XCTAssertTrue(triggers.contains("manual"), "manual should be valid")
    }

    func testValidAbilityEffectTypesExist() throws {
        let effects = ConditionValidator.allValidEffectTypes()
        XCTAssertFalse(effects.isEmpty, "Should have valid effect types")

        // Verify known effects
        XCTAssertTrue(effects.contains("bonusDamage"), "bonusDamage should be valid")
        XCTAssertTrue(effects.contains("heal"), "heal should be valid")
        XCTAssertTrue(effects.contains("drawCard"), "drawCard should be valid")
    }

    // MARK: - Rejection Tests

    func testRejectsUnknownConditionType() throws {
        // Typos like "WorldResonanse" should be rejected
        XCTAssertFalse(
            ConditionValidator.validateAbilityCondition("WorldResonanse"),
            "Unknown condition 'WorldResonanse' should be rejected"
        )
        XCTAssertFalse(
            ConditionValidator.validateAbilityCondition("hp_below_percent"),
            "Snake_case version should be rejected (we use camelCase)"
        )
        XCTAssertFalse(
            ConditionValidator.validateAbilityCondition(""),
            "Empty string should be rejected"
        )
    }

    func testRejectsUnknownTrigger() throws {
        XCTAssertFalse(
            ConditionValidator.validateAbilityTrigger("onDamageRecieved"), // typo
            "Typo 'onDamageRecieved' should be rejected"
        )
        XCTAssertFalse(
            ConditionValidator.validateAbilityTrigger("on_attack"),
            "Snake_case should be rejected"
        )
    }

    func testRejectsUnknownEffectType() throws {
        XCTAssertFalse(
            ConditionValidator.validateAbilityEffectType("bonusDammage"), // typo
            "Typo 'bonusDammage' should be rejected"
        )
        XCTAssertFalse(
            ConditionValidator.validateAbilityEffectType("bonus_damage"),
            "Snake_case should be rejected"
        )
    }

    // MARK: - Integration Test: All Pack Conditions Valid

    func testAllPackConditionsAreValid() throws {
        // Use shared registry (packs are loaded globally in tests)
        let registry = ContentRegistry.shared

        // Ensure packs are loaded
        guard !registry.loadedPackIds.isEmpty else {
            // Load packs if not already loaded
            guard let storyPackURL = TestContentLoader.storyPackURL,
                  let charPackURL = TestContentLoader.characterPackURL else {
                XCTFail("GATE TEST FAILURE: Could not locate content packs for validation")
                return
            }

            do {
                try registry.loadPack(from: storyPackURL)
                try registry.loadPack(from: charPackURL)
            } catch {
                XCTFail("GATE TEST FAILURE: Failed to load packs: \(error)")
                return
            }
            return try testAllPackConditionsAreValid()
        }

        // Validate all loaded packs
        for (packId, pack) in registry.loadedPacks {
            let result = ConditionValidator.validate(pack: pack)
            if !result.isValid {
                XCTFail("Pack '\(packId)' has invalid conditions:\n\(result.errors.joined(separator: "\n"))")
            }
        }
    }

    // MARK: - Type Safety Tests

    func testConditionsUseTypedEnumsNotStrings() throws {
        // This test documents that our architecture prevents string-based typos
        // by using typed enums that are validated at parse time

        // AbilityConditionType is an enum with CaseIterable
        let allConditionTypes = AbilityConditionType.allCases
        XCTAssertFalse(allConditionTypes.isEmpty, "AbilityConditionType should have cases")

        // Attempting to decode an unknown type would fail JSON parsing
        let invalidJSON = """
        {"type": "WorldResonanse", "value": 50}
        """.data(using: .utf8)!

        // This should fail to decode because "WorldResonanse" is not a valid enum case
        XCTAssertThrowsError(try JSONDecoder().decode(AbilityCondition.self, from: invalidJSON)) { error in
            // Verify it's a decoding error for unknown enum value
            XCTAssertTrue(error is DecodingError, "Should throw DecodingError for unknown enum value")
        }
    }

    func testValidConditionDecodesSuccessfully() throws {
        // Valid condition should decode
        let validJSON = """
        {"type": "hpBelowPercent", "value": 50}
        """.data(using: .utf8)!

        let condition = try JSONDecoder().decode(AbilityCondition.self, from: validJSON)
        XCTAssertEqual(condition.type, .hpBelowPercent)
        XCTAssertEqual(condition.value, 50)
    }

    func testSnakeCaseEnumValueIsRejected() throws {
        // Enum values must use camelCase, not snake_case
        // keyDecodingStrategy only converts dictionary keys, not enum string values
        let snakeCaseJSON = """
        {"type": "hp_below_percent", "value": 50}
        """.data(using: .utf8)!

        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase

        // This should FAIL because "hp_below_percent" is not a valid enum value
        // Our enums use camelCase: "hpBelowPercent"
        XCTAssertThrowsError(try decoder.decode(AbilityCondition.self, from: snakeCaseJSON)) { error in
            XCTAssertTrue(error is DecodingError, "Snake_case enum values should be rejected")
        }
    }
}


// ==========================================
// FILE: CardSampleGameTests/GateTests/ContentValidationTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Content Validation Tests - validates cross-references in JSON content
/// Prevents "silent failures" where typos cause conditions to never match
///
/// **Risk Mitigation:**
/// - Typo in flag name → condition never triggers
/// - Typo in region ID → event never appears in that region
/// - Typo in quest ID → quest progress never registers
/// - Typo in resource ID → requirement check fails silently
final class ContentValidationTests: XCTestCase {

    // MARK: - Test Data

    private var loadedPack: LoadedPack?
    private var allRegionIds: Set<String> = []
    private var allEventIds: Set<String> = []
    private var allQuestIds: Set<String> = []
    private var allCardIds: Set<String> = []
    private var allHeroIds: Set<String> = []
    private var allEnemyIds: Set<String> = []
    private var allAnchorIds: Set<String> = []

    // System flags and known resources are collected dynamically from loaded packs
    // to avoid hardcoding game-specific content in engine-level tests.
    private var systemFlags: Set<String> = []
    private var knownResources: Set<String> = []

    // Known valid region states (engine-level enum values, not game-specific)
    private let knownRegionStates: Set<String> = [
        "stable",
        "borderland",
        "breach",
        "corrupted",
        "lost"
    ]

    // MARK: - Setup

    override func setUpWithError() throws {
        try super.setUpWithError()

        // Load content pack using TestContentLoader
        TestContentLoader.loadContentPacksIfNeeded()

        // Get loaded pack from registry
        guard let packId = ContentRegistry.shared.loadedPackIds.first(where: { $0.contains("twilight") || $0.contains("act") }),
              let pack = ContentRegistry.shared.loadedPacks[packId] else {
            XCTFail("CONTENT VALIDATION FAILURE: TwilightMarchesActI pack not loaded - check TestContentLoader"); return
        }

        self.loadedPack = pack
        collectKnownIds()
    }

    private func collectKnownIds() {
        guard let pack = loadedPack else { return }

        // Regions (dictionary keys are IDs)
        allRegionIds = Set(pack.regions.keys)

        // Events
        allEventIds = Set(pack.events.keys)

        // Quests
        allQuestIds = Set(pack.quests.keys)

        // Cards
        allCardIds = Set(pack.cards.keys)

        // Heroes
        allHeroIds = Set(pack.heroes.keys)

        // Enemies
        allEnemyIds = Set(pack.enemies.keys)

        // Anchors
        allAnchorIds = Set(pack.anchors.keys)

        // Collect all flags that are SET by consequences (these are valid to reference)
        collectKnownFlags(from: pack)

        // Collect known resources from balance config
        collectKnownResources()
    }

    /// Collect all flags that are set/cleared by event choices and quest outcomes.
    /// These flags are valid to reference in conditions — no hardcoded list needed.
    private func collectKnownFlags(from pack: LoadedPack) {
        var flags: Set<String> = []

        for (_, event) in pack.events {
            for choice in event.choices {
                flags.formUnion(choice.consequences.setFlags)
                flags.formUnion(choice.consequences.clearFlags)
            }
        }

        for (_, quest) in pack.quests {
            flags.formUnion(quest.completionRewards.setFlags)
            flags.formUnion(quest.failurePenalties.setFlags)
        }

        systemFlags = flags
    }

    /// Collect known resource keys from balance config and engine conventions.
    private func collectKnownResources() {
        // Engine-level resource keys (used by ResourceBalanceConfig and consequences)
        knownResources = ["health", "faith", "supplies", "gold", "balance"]
        // Extend from balance config if available
        if let config = ContentRegistry.shared.getBalanceConfig() {
            // Balance config confirms these resources exist; no game-specific names needed
            _ = config
        }
    }

    // MARK: - Flag Validation

    func testAllReferencedFlagsAreKnown() throws {
        guard let pack = loadedPack else {
            XCTFail("CONTENT VALIDATION FAILURE: Pack not loaded"); return
        }

        var referencedFlags: Set<String> = []
        var setFlags: Set<String> = []

        // Collect flags from events
        for (_, event) in pack.events {
            // Availability flags
            referencedFlags.formUnion(event.availability.requiredFlags)
            referencedFlags.formUnion(event.availability.forbiddenFlags)

            // Choice flags
            for choice in event.choices {
                if let req = choice.requirements {
                    referencedFlags.formUnion(req.requiredFlags)
                    referencedFlags.formUnion(req.forbiddenFlags)
                }
                setFlags.formUnion(choice.consequences.setFlags)
                setFlags.formUnion(choice.consequences.clearFlags)
            }
        }

        // Collect flags from quests
        for (_, quest) in pack.quests {
            referencedFlags.formUnion(quest.availability.requiredFlags)
            referencedFlags.formUnion(quest.availability.forbiddenFlags)

            setFlags.formUnion(quest.completionRewards.setFlags)
            setFlags.formUnion(quest.failurePenalties.setFlags)

            // Flags in objective completion conditions are set by engine logic
            for objective in quest.objectives {
                if case .flagSet(let flag) = objective.completionCondition {
                    setFlags.insert(flag)
                }
            }
        }

        // All set flags become valid referenced flags
        let allKnownFlags = systemFlags.union(setFlags)

        // Find unknown flags
        let unknownFlags = referencedFlags.subtracting(allKnownFlags)

        if !unknownFlags.isEmpty {
            XCTFail("""
                Found \(unknownFlags.count) unknown flags referenced in conditions:
                \(unknownFlags.sorted().map { "  - \($0)" }.joined(separator: "\n"))

                These flags are checked but never set. Possible causes:
                1. Typo in flag name
                2. Flag is set elsewhere (add to systemFlags in test)
                3. Missing set_flags in consequences
                """)
        }
    }

    // MARK: - Region ID Validation

    func testAllReferencedRegionIdsExist() throws {
        guard let pack = loadedPack else {
            XCTFail("CONTENT VALIDATION FAILURE: Pack not loaded"); return
        }

        var referencedRegionIds: Set<String> = []

        // From event availability
        for (_, event) in pack.events {
            if let regionIds = event.availability.regionIds {
                referencedRegionIds.formUnion(regionIds)
            }
        }

        // From quest availability
        for (_, quest) in pack.quests {
            if let regionIds = quest.availability.regionIds {
                referencedRegionIds.formUnion(regionIds)
            }
        }

        // From region connections (neighborIds)
        for (_, region) in pack.regions {
            referencedRegionIds.formUnion(region.neighborIds)
        }

        // Find unknown regions
        let unknownRegions = referencedRegionIds.subtracting(allRegionIds)

        if !unknownRegions.isEmpty {
            XCTFail("""
                Found \(unknownRegions.count) unknown region IDs:
                \(unknownRegions.sorted().map { "  - \($0)" }.joined(separator: "\n"))

                Known regions: \(allRegionIds.sorted().joined(separator: ", "))
                """)
        }
    }

    // MARK: - Quest ID Validation

    func testAllReferencedQuestIdsExist() throws {
        guard let pack = loadedPack else {
            XCTFail("CONTENT VALIDATION FAILURE: Pack not loaded"); return
        }

        var referencedQuestIds: Set<String> = []

        // From event consequences
        for (_, event) in pack.events {
            for choice in event.choices {
                if let questProgress = choice.consequences.questProgress {
                    referencedQuestIds.insert(questProgress.questId)
                }
            }
        }

        // Find unknown quests
        let unknownQuests = referencedQuestIds.subtracting(allQuestIds)

        if !unknownQuests.isEmpty {
            XCTFail("""
                Found \(unknownQuests.count) unknown quest IDs in event consequences:
                \(unknownQuests.sorted().map { "  - \($0)" }.joined(separator: "\n"))

                Known quests: \(allQuestIds.sorted().joined(separator: ", "))
                """)
        }
    }

    // MARK: - Event ID Validation

    func testAllReferencedEventIdsExist() throws {
        guard let pack = loadedPack else {
            XCTFail("CONTENT VALIDATION FAILURE: Pack not loaded"); return
        }

        var referencedEventIds: Set<String> = []

        // From choice consequences (trigger_event_id)
        for (_, event) in pack.events {
            for choice in event.choices {
                if let triggerId = choice.consequences.triggerEventId {
                    referencedEventIds.insert(triggerId)
                }
            }
        }

        // Find unknown events
        let unknownEvents = referencedEventIds.subtracting(allEventIds)

        if !unknownEvents.isEmpty {
            XCTFail("""
                Found \(unknownEvents.count) unknown event IDs in trigger_event_id:
                \(unknownEvents.sorted().map { "  - \($0)" }.joined(separator: "\n"))

                Known events: \(allEventIds.sorted().joined(separator: ", "))
                """)
        }
    }

    // MARK: - Resource ID Validation

    func testAllReferencedResourceIdsAreKnown() throws {
        guard let pack = loadedPack else {
            XCTFail("CONTENT VALIDATION FAILURE: Pack not loaded"); return
        }

        var referencedResources: Set<String> = []

        // From event choice requirements and consequences
        for (_, event) in pack.events {
            for choice in event.choices {
                if let req = choice.requirements {
                    referencedResources.formUnion(req.minResources.keys)
                }
                referencedResources.formUnion(choice.consequences.resourceChanges.keys)
            }
        }

        // From quest rewards/penalties
        for (_, quest) in pack.quests {
            referencedResources.formUnion(quest.completionRewards.resourceChanges.keys)
            referencedResources.formUnion(quest.failurePenalties.resourceChanges.keys)
        }

        // Find unknown resources
        let unknownResources = referencedResources.subtracting(knownResources)

        if !unknownResources.isEmpty {
            XCTFail("""
                Found \(unknownResources.count) unknown resource IDs:
                \(unknownResources.sorted().map { "  - \($0)" }.joined(separator: "\n"))

                Known resources: \(knownResources.sorted().joined(separator: ", "))
                """)
        }
    }

    // MARK: - Region State Validation

    func testAllReferencedRegionStatesAreKnown() throws {
        guard let pack = loadedPack else {
            XCTFail("CONTENT VALIDATION FAILURE: Pack not loaded"); return
        }

        var referencedStates: Set<String> = []

        // From event availability
        for (_, event) in pack.events {
            if let states = event.availability.regionStates {
                referencedStates.formUnion(states)
            }
        }

        // From quest availability
        for (_, quest) in pack.quests {
            if let states = quest.availability.regionStates {
                referencedStates.formUnion(states)
            }
        }

        // Find unknown states
        let unknownStates = referencedStates.subtracting(knownRegionStates)

        if !unknownStates.isEmpty {
            XCTFail("""
                Found \(unknownStates.count) unknown region states:
                \(unknownStates.sorted().map { "  - \($0)" }.joined(separator: "\n"))

                Known states: \(knownRegionStates.sorted().joined(separator: ", "))
                """)
        }
    }

    // MARK: - Card ID Validation

    func testAllReferencedCardIdsExist() throws {
        guard let pack = loadedPack else {
            XCTFail("CONTENT VALIDATION FAILURE: Pack not loaded"); return
        }

        var referencedCardIds: Set<String> = []

        // From quest rewards
        for (_, quest) in pack.quests {
            referencedCardIds.formUnion(quest.completionRewards.cardIds)
        }

        // From hero starting decks (if heroes are loaded)
        for (_, hero) in pack.heroes {
            referencedCardIds.formUnion(hero.startingDeckCardIDs)
        }

        // Find unknown cards - need to check global CardRegistry too
        let allKnownCards = allCardIds.union(Set(CardRegistry.shared.allCards.map { $0.id }))
        let unknownCards = referencedCardIds.subtracting(allKnownCards)

        if !unknownCards.isEmpty {
            XCTFail("""
                Found \(unknownCards.count) unknown card IDs:
                \(unknownCards.sorted().map { "  - \($0)" }.joined(separator: "\n"))

                Known cards in pack: \(allCardIds.sorted().joined(separator: ", "))
                """)
        }
    }

    // MARK: - Comprehensive Summary

    func testContentIntegrityReport() throws {
        guard let pack = loadedPack else {
            XCTFail("CONTENT VALIDATION FAILURE: Pack not loaded"); return
        }

        print("""

            === Content Integrity Report ===

            Pack: \(pack.manifest.packId) v\(pack.manifest.version)

            Content Counts:
            - Regions: \(pack.regions.count)
            - Events: \(pack.events.count)
            - Quests: \(pack.quests.count)
            - Cards: \(pack.cards.count)
            - Heroes: \(pack.heroes.count)
            - Enemies: \(pack.enemies.count)
            - Anchors: \(pack.anchors.count)

            Region IDs: \(allRegionIds.sorted().joined(separator: ", "))
            Quest IDs: \(allQuestIds.sorted().joined(separator: ", "))

            ================================

            """)

        // This test always passes - it's for diagnostics
        XCTAssertTrue(true)
    }
}


// ==========================================
// FILE: CardSampleGameTests/GateTests/DesignSystemComplianceTests.swift
// ==========================================

import XCTest
@testable import CardSampleGame

/// Audit tests to ensure Design System compliance
/// These tests fail if magic numbers or hardcoded colors are found in View files
/// Reference: AUDIT_ENGINE_FIRST_v1_1.md, Epic 9.1
///
/// All View files are now fully compliant. These tests enforce:
/// - No magic numbers (use Spacing.*, Sizes.*, CornerRadius.*)
/// - No hardcoded colors (use AppColors.*)
/// - No hardcoded opacity (use Opacity.*)
final class DesignSystemComplianceTests: XCTestCase {

    /// Strict compliance mode - fails on any violation
    private let allowLegacyViolations = false

    /// No legacy files - all Views are now compliant
    private let legacyFiles: [String] = []

    // MARK: - View Files to Audit

    /// All View files that must use DesignSystem constants
    private var viewFiles: [String] {
        guard let root = projectRoot else { return [] }
        let viewsDir = root.appendingPathComponent("Views")
        return findSwiftFiles(in: viewsDir)
    }

    private var projectRoot: URL? {
        // Try to find project root via SRCROOT (set in scheme environment)
        if let srcRoot = ProcessInfo.processInfo.environment["SRCROOT"] {
            return URL(fileURLWithPath: srcRoot)
        }

        // Fallback: Navigate up from test file location
        // This file is at CardSampleGameTests/GateTests/DesignSystemComplianceTests.swift
        let thisFile = #file
        var url = URL(fileURLWithPath: thisFile)
        // Go up 3 levels: GateTests -> CardSampleGameTests -> Project Root
        for _ in 0..<3 {
            url = url.deletingLastPathComponent()
        }

        // Verify we found the right directory by checking for Views folder
        let viewsPath = url.appendingPathComponent("Views")
        if FileManager.default.fileExists(atPath: viewsPath.path) {
            return url
        }

        return nil
    }

    // MARK: - Magic Number Patterns

    /// Patterns that indicate hardcoded spacing/padding values
    private let magicNumberPatterns: [(pattern: String, description: String)] = [
        // Padding with raw numbers (but allow Spacing.* references)
        (#"\.padding\(\s*\d+\s*\)"#, "padding with magic number"),
        (#"\.padding\(\.\w+,\s*\d+\s*\)"#, "directional padding with magic number"),
        (#"\.padding\(\.horizontal,\s*\d+\s*\)"#, "horizontal padding with magic number"),
        (#"\.padding\(\.vertical,\s*\d+\s*\)"#, "vertical padding with magic number"),

        // Spacing with raw numbers in stacks (0 is allowed - means no spacing)
        (#"VStack\(spacing:\s*[1-9]\d*\s*\)"#, "VStack spacing with magic number"),
        (#"HStack\(spacing:\s*[1-9]\d*\s*\)"#, "HStack spacing with magic number"),
        (#"LazyVStack\(spacing:\s*[1-9]\d*\s*\)"#, "LazyVStack spacing with magic number"),
        (#"LazyHStack\(spacing:\s*[1-9]\d*\s*\)"#, "LazyHStack spacing with magic number"),

        // Corner radius with raw numbers
        (#"\.cornerRadius\(\s*\d+\s*\)"#, "cornerRadius with magic number"),

        // Frame with raw numbers (except 0 and .infinity)
        (#"\.frame\(width:\s*[1-9]\d*\s*\)"#, "frame width with magic number"),
        (#"\.frame\(height:\s*[1-9]\d*\s*\)"#, "frame height with magic number"),
    ]

    /// Patterns that are allowed (exceptions)
    private let allowedPatterns: [String] = [
        "Spacing\\.", // Spacing.sm, Spacing.md, etc.
        "Sizes\\.",   // Sizes.iconSmall, etc.
        "CornerRadius\\.", // CornerRadius.md, etc.
        "lineWidth:", // lineWidth is ok for strokes
        "size:\\s*\\d+", // font size modifiers (allowed for now)
        "#Preview", // Preview code is exempt
        "PreviewProvider", // Preview code is exempt
    ]

    // MARK: - Hardcoded Color Patterns

    /// Patterns that indicate hardcoded colors instead of AppColors
    private let hardcodedColorPatterns: [(pattern: String, description: String)] = [
        (#"Color\.red(?!\w)"#, "hardcoded Color.red"),
        (#"Color\.blue(?!\w)"#, "hardcoded Color.blue"),
        (#"Color\.green(?!\w)"#, "hardcoded Color.green"),
        (#"Color\.orange(?!\w)"#, "hardcoded Color.orange"),
        (#"Color\.yellow(?!\w)"#, "hardcoded Color.yellow"),
        (#"Color\.purple(?!\w)"#, "hardcoded Color.purple"),
        (#"Color\.gray(?!\w)"#, "hardcoded Color.gray"),
        (#"Color\.pink(?!\w)"#, "hardcoded Color.pink"),
        (#"\.foregroundColor\(\.red\)"#, "foregroundColor(.red)"),
        (#"\.foregroundColor\(\.blue\)"#, "foregroundColor(.blue)"),
        (#"\.foregroundColor\(\.green\)"#, "foregroundColor(.green)"),
        (#"\.foregroundColor\(\.orange\)"#, "foregroundColor(.orange)"),
        (#"\.foregroundColor\(\.yellow\)"#, "foregroundColor(.yellow)"),
        (#"\.foregroundColor\(\.purple\)"#, "foregroundColor(.purple)"),
        (#"\.foregroundColor\(\.gray\)"#, "foregroundColor(.gray)"),
        (#"\.foregroundColor\(\.secondary\)"#, "foregroundColor(.secondary) - use AppColors.muted"),
    ]

    /// Color patterns that are allowed
    private let allowedColorPatterns: [String] = [
        "AppColors\\.",   // AppColors.primary, etc.
        "Color\\.white",  // white is ok (neutral)
        "Color\\.black",  // black is ok (neutral)
        "Color\\.clear",  // clear is ok
        "Color\\.primary", // system primary is ok
        "Color\\.accentColor", // accent is ok
        "Color\\(UIColor\\.", // UIColor wrappers are ok
        "Color\\.indigo", // indigo is ok (no AppColors equivalent yet)
        "Color\\.brown",  // brown is ok (no AppColors equivalent yet)
        "Color\\.teal",   // teal is ok (no AppColors equivalent yet)
        "Color\\.cyan",   // cyan is ok (no AppColors equivalent yet)
        "Color\\.pink",   // pink is ok (no AppColors equivalent yet)
        "#Preview",       // Preview code is exempt
        "PreviewProvider", // Preview code is exempt
        "// DesignSystem-exempt", // Explicit exemption comment
    ]

    // MARK: - Hardcoded Opacity Patterns

    /// Patterns that indicate hardcoded opacity values
    private let hardcodedOpacityPatterns: [(pattern: String, description: String)] = [
        (#"\.opacity\(0\.\d+\)"#, "hardcoded opacity value"),
    ]

    /// Opacity patterns that are allowed
    private let allowedOpacityPatterns: [String] = [
        "Opacity\\.",     // Opacity.medium, etc.
        "#Preview",       // Preview code is exempt
        "PreviewProvider", // Preview code is exempt
        "\\.opacity\\(0\\.15\\)", // 0.15 is acceptable for card backgrounds (close to Opacity.faint)
        "\\.opacity\\(0\\.1\\)",  // 0.1 is acceptable for subtle backgrounds
    ]

    // MARK: - Tests

    func testNoMagicNumbersInViews() throws {
        guard projectRoot != nil else {
            XCTFail("GATE TEST FAILURE: Could not determine project root path"); return
        }
        var violations: [(file: String, line: Int, issue: String)] = []

        for filePath in viewFiles {
            let content = try String(contentsOfFile: filePath, encoding: .utf8)
            let lines = content.components(separatedBy: .newlines)

            for (lineIndex, line) in lines.enumerated() {
                // Skip if line contains allowed pattern
                if allowedPatterns.contains(where: { line.range(of: $0, options: .regularExpression) != nil }) {
                    continue
                }

                // Check for magic number violations
                for (pattern, description) in magicNumberPatterns {
                    if line.range(of: pattern, options: .regularExpression) != nil {
                        let fileName = URL(fileURLWithPath: filePath).lastPathComponent
                        violations.append((fileName, lineIndex + 1, description))
                    }
                }
            }
        }

        // Separate legacy vs new violations
        let newViolations = violations.filter { !legacyFiles.contains($0.file) }
        let legacyViolations = violations.filter { legacyFiles.contains($0.file) }

        // Always fail on new violations
        if !newViolations.isEmpty {
            let message = newViolations.map { "  \($0.file):\($0.line) - \($0.issue)" }.joined(separator: "\n")
            XCTFail("Found \(newViolations.count) magic number violations in migrated files:\n\(message)\n\nUse Spacing.*, Sizes.*, or CornerRadius.* instead.")
        }

        // Warn about legacy violations (or fail if strict mode)
        if !legacyViolations.isEmpty && !allowLegacyViolations {
            let message = legacyViolations.map { "  \($0.file):\($0.line) - \($0.issue)" }.joined(separator: "\n")
            XCTFail("Found \(legacyViolations.count) magic number violations in legacy files:\n\(message)")
        }
    }

    func testNoHardcodedColorsInViews() throws {
        guard projectRoot != nil else {
            XCTFail("GATE TEST FAILURE: Could not determine project root path"); return
        }
        var violations: [(file: String, line: Int, issue: String)] = []

        for filePath in viewFiles {
            let content = try String(contentsOfFile: filePath, encoding: .utf8)
            let lines = content.components(separatedBy: .newlines)

            for (lineIndex, line) in lines.enumerated() {
                // Skip if line contains allowed pattern
                if allowedColorPatterns.contains(where: { line.range(of: $0, options: .regularExpression) != nil }) {
                    continue
                }

                // Check for hardcoded color violations
                for (pattern, description) in hardcodedColorPatterns {
                    if line.range(of: pattern, options: .regularExpression) != nil {
                        let fileName = URL(fileURLWithPath: filePath).lastPathComponent
                        violations.append((fileName, lineIndex + 1, description))
                    }
                }
            }
        }

        // Separate legacy vs new violations
        let newViolations = violations.filter { !legacyFiles.contains($0.file) }
        let legacyViolations = violations.filter { legacyFiles.contains($0.file) }

        // Always fail on new violations
        if !newViolations.isEmpty {
            let message = newViolations.map { "  \($0.file):\($0.line) - \($0.issue)" }.joined(separator: "\n")
            XCTFail("Found \(newViolations.count) hardcoded color violations in migrated files:\n\(message)\n\nUse AppColors.* instead.")
        }

        // Warn about legacy violations (or fail if strict mode)
        if !legacyViolations.isEmpty && !allowLegacyViolations {
            let message = legacyViolations.map { "  \($0.file):\($0.line) - \($0.issue)" }.joined(separator: "\n")
            XCTFail("Found \(legacyViolations.count) hardcoded color violations in legacy files:\n\(message)")
        }
    }

    func testNoHardcodedOpacityInViews() throws {
        guard projectRoot != nil else {
            XCTFail("GATE TEST FAILURE: Could not determine project root path"); return
        }
        var violations: [(file: String, line: Int, issue: String)] = []

        for filePath in viewFiles {
            let content = try String(contentsOfFile: filePath, encoding: .utf8)
            let lines = content.components(separatedBy: .newlines)

            for (lineIndex, line) in lines.enumerated() {
                // Skip if line contains allowed pattern
                if allowedOpacityPatterns.contains(where: { line.range(of: $0, options: .regularExpression) != nil }) {
                    continue
                }

                // Check for hardcoded opacity violations
                for (pattern, description) in hardcodedOpacityPatterns {
                    if line.range(of: pattern, options: .regularExpression) != nil {
                        let fileName = URL(fileURLWithPath: filePath).lastPathComponent
                        violations.append((fileName, lineIndex + 1, description))
                    }
                }
            }
        }

        // Separate legacy vs new violations
        let newViolations = violations.filter { !legacyFiles.contains($0.file) }
        let legacyViolations = violations.filter { legacyFiles.contains($0.file) }

        // Always fail on new violations
        if !newViolations.isEmpty {
            let message = newViolations.map { "  \($0.file):\($0.line) - \($0.issue)" }.joined(separator: "\n")
            XCTFail("Found \(newViolations.count) hardcoded opacity violations in migrated files:\n\(message)\n\nUse Opacity.* instead.")
        }

        // Warn about legacy violations (or fail if strict mode)
        if !legacyViolations.isEmpty && !allowLegacyViolations {
            let message = legacyViolations.map { "  \($0.file):\($0.line) - \($0.issue)" }.joined(separator: "\n")
            XCTFail("Found \(legacyViolations.count) hardcoded opacity violations in legacy files:\n\(message)")
        }
    }

    func testDesignSystemFilesExist() throws {
        guard let root = projectRoot else {
            XCTFail("GATE TEST FAILURE: Could not determine project root path"); return
        }
        let designSystemPath = root.appendingPathComponent("Utilities/DesignSystem.swift")
        XCTAssertTrue(
            FileManager.default.fileExists(atPath: designSystemPath.path),
            "DesignSystem.swift must exist at Utilities/DesignSystem.swift"
        )
    }

    func testDesignSystemHasRequiredTokens() throws {
        guard let root = projectRoot else {
            XCTFail("GATE TEST FAILURE: Could not determine project root path"); return
        }
        let designSystemPath = root.appendingPathComponent("Utilities/DesignSystem.swift")
        let content = try String(contentsOf: designSystemPath, encoding: .utf8)

        // Check for required enums
        XCTAssertTrue(content.contains("enum Spacing"), "DesignSystem must define Spacing enum")
        XCTAssertTrue(content.contains("enum Sizes"), "DesignSystem must define Sizes enum")
        XCTAssertTrue(content.contains("enum CornerRadius"), "DesignSystem must define CornerRadius enum")
        XCTAssertTrue(content.contains("enum AppColors"), "DesignSystem must define AppColors enum")
        XCTAssertTrue(content.contains("enum Opacity"), "DesignSystem must define Opacity enum")

        // Check for key tokens
        XCTAssertTrue(content.contains("static let sm"), "Spacing must have sm token")
        XCTAssertTrue(content.contains("static let md"), "Spacing must have md token")
        XCTAssertTrue(content.contains("static let lg"), "Spacing must have lg token")
        XCTAssertTrue(content.contains("static let primary"), "AppColors must have primary token")
        XCTAssertTrue(content.contains("static let danger"), "AppColors must have danger token")
        XCTAssertTrue(content.contains("static let success"), "AppColors must have success token")
    }

    // MARK: - Helpers

    private func findSwiftFiles(in directory: URL) -> [String] {
        var files: [String] = []

        guard let enumerator = FileManager.default.enumerator(
            at: directory,
            includingPropertiesForKeys: [.isRegularFileKey],
            options: [.skipsHiddenFiles]
        ) else {
            return files
        }

        for case let fileURL as URL in enumerator {
            if fileURL.pathExtension == "swift" {
                files.append(fileURL.path)
            }
        }

        return files
    }
}


// ==========================================
// FILE: CardSampleGameTests/GateTests/ExpressionParserTests.swift
// ==========================================

import XCTest
import TwilightEngine

/// Expression Parser Tests — Audit v2.1, Section 3.1
/// Validates that the ExpressionParser correctly rejects unknown variables,
/// unknown functions, and invalid syntax in pack condition strings.
final class ExpressionParserTests: XCTestCase {

    // MARK: - Rejects Unknown Variables

    func testRejectsUnknownVariables() {
        // "WorldResonanse" is a typo for "WorldResonance"
        let result = ExpressionParser.validate("WorldResonanse < -50")
        XCTAssertNotNil(result, "Should reject unknown variable")

        if case .unknownVariable(let name) = result {
            XCTAssertEqual(name, "WorldResonanse", "Should identify the typo variable")
        } else {
            XCTFail("Expected unknownVariable error, got: \(String(describing: result))")
        }

        // Another typo
        let result2 = ExpressionParser.validate("playerHelth > 5")
        XCTAssertNotNil(result2, "Should reject 'playerHelth' typo")
    }

    func testAcceptsKnownVariables() {
        // These should all pass validation
        let validExpressions = [
            "WorldTension > 50",
            "playerHealth < 10",
            "lightDarkBalance >= 30",
            "currentDay == 5",
            "PlayerFaith <= 3"
        ]

        for expr in validExpressions {
            let result = ExpressionParser.validate(expr)
            XCTAssertNil(result, "Should accept valid expression: '\(expr)', got: \(String(describing: result))")
        }
    }

    // MARK: - Rejects Unknown Functions

    func testRejectsUnknownFunctions() {
        let result = ExpressionParser.validate("unknownFunc(\"test\")")
        XCTAssertNotNil(result, "Should reject unknown function")

        if case .unknownFunction(let name) = result {
            XCTAssertEqual(name, "unknownFunc", "Should identify the unknown function")
        } else {
            XCTFail("Expected unknownFunction error, got: \(String(describing: result))")
        }
    }

    func testAcceptsKnownFunctions() {
        let validExpressions = [
            "hasFlag(\"quest_started\")",
            "notFlag(\"boss_defeated\")",
            "visitedRegion(\"market\")",
            "hasQuest(\"main_quest\")"
        ]

        for expr in validExpressions {
            let result = ExpressionParser.validate(expr)
            XCTAssertNil(result, "Should accept valid expression: '\(expr)', got: \(String(describing: result))")
        }
    }

    // MARK: - Rejects Invalid Syntax

    func testRejectsInvalidSyntax() {
        // Empty expression
        let emptyResult = ExpressionParser.validate("")
        XCTAssertNotNil(emptyResult, "Should reject empty expression")
        if case .emptyExpression = emptyResult {
            // Expected
        } else {
            XCTFail("Expected emptyExpression error")
        }

        // Whitespace only
        let whitespaceResult = ExpressionParser.validate("   ")
        XCTAssertNotNil(whitespaceResult, "Should reject whitespace-only expression")
    }

    func testRejectsUnterminatedString() {
        let result = ExpressionParser.validate("hasFlag(\"unterminated)")
        // Should detect either invalid syntax or reach end of expression improperly
        // The tokenizer handles unterminated strings as invalid
        XCTAssertNotNil(result, "Should reject unterminated string literal")
    }

    // MARK: - Batch Validation

    func testValidateAllReturnsAllErrors() {
        let expressions = [
            "WorldTension > 50",       // Valid
            "WorldResonanse < -50",    // Invalid: typo
            "playerHealth >= 0",       // Valid
            "unknownFunc(\"x\")",      // Invalid: unknown function
        ]

        let errors = ExpressionParser.validateAll(expressions)
        XCTAssertEqual(errors.count, 2, "Should find exactly 2 invalid expressions")
        XCTAssertEqual(errors[0].0, "WorldResonanse < -50")
        XCTAssertEqual(errors[1].0, "unknownFunc(\"x\")")
    }

    // MARK: - Complex Expressions

    func testComplexValidExpression() {
        let result = ExpressionParser.validate("WorldTension > 50 && playerHealth < 10")
        XCTAssertNil(result, "Should accept complex valid expression with &&")
    }

    func testComparisonOperators() {
        let ops = ["<", ">", "<=", ">=", "==", "!="]
        for op in ops {
            let result = ExpressionParser.validate("WorldTension \(op) 50")
            XCTAssertNil(result, "Should accept operator: \(op)")
        }
    }

    // MARK: - Boolean Literals

    func testAcceptsBooleanLiterals() {
        let result = ExpressionParser.validate("hasFlag(\"test\") == true")
        XCTAssertNil(result, "Should accept boolean literal 'true'")
    }

    // MARK: - All Pack Conditions Are Valid (Integration)

    func testAllPackConditionsAreValid() {
        // Load all packs and validate that any string-based conditions parse correctly
        // Currently the engine uses typed Availability structs, not string expressions.
        // This test ensures the ExpressionParser infrastructure is ready for string conditions.

        let registry = ContentRegistry.shared

        // Verify the parser accepts all known variable names
        for variable in ExpressionParser.knownVariables {
            let result = ExpressionParser.validate("\(variable) > 0")
            XCTAssertNil(result, "Known variable '\(variable)' should be accepted")
        }

        // Verify the parser accepts all known function names
        for function in ExpressionParser.knownFunctions {
            let result = ExpressionParser.validate("\(function)(\"test\")")
            XCTAssertNil(result, "Known function '\(function)' should be accepted")
        }

        // Verify registry is accessible
        XCTAssertNotNil(registry, "ContentRegistry should be accessible")
    }
}


// ==========================================
// FILE: CardSampleGameTests/GateTests/LocalizationValidatorTests.swift
// ==========================================

import XCTest
@testable import TwilightEngine

/// Gate tests for localization schema consistency (Audit B1 requirement).
/// Ensures all packs use the canonical localization approach without mixing schemes.
///
/// Canonical approach: Inline LocalizedString { "en": "...", "ru": "..." }
/// Forbidden: Mixing inline strings with StringKey references within the same pack.
final class LocalizationValidatorTests: XCTestCase {

    // MARK: - Canon Tests

    func testCanonicalSchemeIsInlineOnly() throws {
        // Document the canonical scheme
        XCTAssertEqual(
            LocalizationValidator.canonicalScheme,
            .inlineOnly,
            "Canonical localization scheme should be inline-only"
        )
    }

    func testInlineTextIsCanonical() throws {
        let text = LocalizableText.localized(en: "Strike", ru: "Удар")
        XCTAssertTrue(
            LocalizationValidator.isCanonical(text),
            "Inline LocalizedString should be canonical"
        )
    }

    func testStringKeyIsNotCanonical() throws {
        let text = LocalizableText.key("card.strike.name")
        XCTAssertFalse(
            LocalizationValidator.isCanonical(text),
            "StringKey should NOT be canonical (we use inline scheme)"
        )
    }

    // MARK: - Gate Test: No Mixed Localization Schema

    func testNoMixedLocalizationSchema() throws {
        // Load real packs
        let registry = ContentRegistry.shared

        // Ensure packs are loaded
        if registry.loadedPackIds.isEmpty {
            guard let storyPackURL = TestContentLoader.storyPackURL,
                  let charPackURL = TestContentLoader.characterPackURL else {
                XCTFail("GATE TEST FAILURE: Could not locate content packs")
                return
            }
            do {
                try registry.loadPack(from: storyPackURL)
                try registry.loadPack(from: charPackURL)
            } catch {
                XCTFail("GATE TEST FAILURE: Failed to load packs: \(error)")
                return
            }
        }

        // Validate all loaded packs
        for (packId, pack) in registry.loadedPacks {
            let result = LocalizationValidator.validate(pack: pack)

            // Check scheme is canonical
            if result.scheme != LocalizationValidator.canonicalScheme {
                let reason = LocalizationValidator.failureReason(result: result)
                XCTFail("Pack '\(packId)' uses non-canonical localization scheme:\n\(reason)")
            }

            // Check no mixed entities
            if !result.mixedEntities.isEmpty {
                let entities = result.mixedEntities.prefix(5).joined(separator: ", ")
                XCTFail("Pack '\(packId)' has entities mixing localization schemes: \(entities)")
            }
        }
    }

    // MARK: - Fallback Determinism Test

    func testLocalizationFallbackIsDeterministic() throws {
        // Test that fallback to English is deterministic when Russian is missing

        // Create inline text with both translations
        let fullText = LocalizableText.localized(en: "Attack", ru: "Атака")

        // Resolve for English (should return English)
        let enResult = fullText.resolved(for: "en")
        XCTAssertEqual(enResult, "Attack", "English resolution should return English text")

        // Resolve for Russian (should return Russian)
        let ruResult = fullText.resolved(for: "ru")
        XCTAssertEqual(ruResult, "Атака", "Russian resolution should return Russian text")

        // Resolve for unknown locale (should fallback to English)
        let unknownResult = fullText.resolved(for: "de")
        XCTAssertEqual(unknownResult, "Attack", "Unknown locale should fallback to English")

        // Multiple resolutions should be deterministic
        XCTAssertEqual(fullText.resolved(for: "de"), unknownResult, "Fallback should be deterministic")
        XCTAssertEqual(fullText.resolved(for: "de"), unknownResult, "Fallback should be deterministic")
    }

    func testEmptyRussianReturnsEnglishWhenEmpty() throws {
        // Create text with empty Russian
        let text = LocalizableText.inline(LocalizedString(en: "Test", ru: ""))

        // Current behavior: returns empty string (no automatic fallback)
        // This is documented behavior - content authors must provide all translations
        let ruResult = text.resolved(for: "ru")

        // Document the current behavior
        // Note: This could be changed to fallback to English if desired
        XCTAssertTrue(ruResult.isEmpty || ruResult == "Test",
            "Russian should either return empty or fallback to English")
    }

    // MARK: - Validation Result Tests

    func testValidationResultForInlineOnlyPack() throws {
        // Create a mock validation result for inline-only pack
        let result = LocalizationValidator.ValidationResult(
            isValid: true,
            scheme: .inlineOnly,
            inlineCount: 100,
            keyCount: 0,
            mixedEntities: []
        )

        XCTAssertTrue(result.isValid)
        XCTAssertEqual(result.scheme, .inlineOnly)
        XCTAssertTrue(result.mixedEntities.isEmpty)
    }

    func testValidationResultForMixedPack() throws {
        // Create a mock validation result for mixed pack
        let result = LocalizationValidator.ValidationResult(
            isValid: false,
            scheme: .mixed,
            inlineCount: 50,
            keyCount: 50,
            mixedEntities: ["event:test_event", "hero:test_hero"]
        )

        XCTAssertFalse(result.isValid)
        XCTAssertEqual(result.scheme, .mixed)
        XCTAssertFalse(result.mixedEntities.isEmpty)
    }
}

